
bin/app.elf:     file format elf32-littlearm


Disassembly of section .text:

c0d00000 <main>:
  .color_dashboard = COLOR_APP_LIGHT,
  .header_text = CHAINID_UPCASE,
#endif // TARGET_BLUE
};

__attribute__((section(".boot"))) int main(int arg0) {
c0d00000:	b570      	push	{r4, r5, r6, lr}
c0d00002:	b08c      	sub	sp, #48	; 0x30
c0d00004:	4604      	mov	r4, r0
        }
    }
    END_TRY;
#else
    // exit critical section
    __asm volatile("cpsie i");
c0d00006:	b662      	cpsie	i

    if (arg0) {
c0d00008:	2c00      	cmp	r4, #0
c0d0000a:	d009      	beq.n	c0d00020 <main+0x20>
        if (((unsigned int *)arg0)[0] != 0x100) {
c0d0000c:	2001      	movs	r0, #1
c0d0000e:	0200      	lsls	r0, r0, #8
c0d00010:	6821      	ldr	r1, [r4, #0]
c0d00012:	4281      	cmp	r1, r0
c0d00014:	d002      	beq.n	c0d0001c <main+0x1c>
            os_lib_throw(INVALID_PARAMETER);
c0d00016:	2002      	movs	r0, #2
c0d00018:	f004 f818 	bl	c0d0404c <os_lib_throw>
        }
        chainConfig = (chain_config_t *)((unsigned int *)arg0)[1];
c0d0001c:	6860      	ldr	r0, [r4, #4]
c0d0001e:	e003      	b.n	c0d00028 <main+0x28>
    }
    else {
        chainConfig = (chain_config_t *)PIC(&C_chain_config);
c0d00020:	482e      	ldr	r0, [pc, #184]	; (c0d000dc <_nvram_data_size+0x9c>)
c0d00022:	4478      	add	r0, pc
c0d00024:	f003 fe5e 	bl	c0d03ce4 <pic>
c0d00028:	4927      	ldr	r1, [pc, #156]	; (c0d000c8 <_nvram_data_size+0x88>)
c0d0002a:	6008      	str	r0, [r1, #0]
    }

    os_memset(&txContext, 0, sizeof(txContext));
c0d0002c:	4827      	ldr	r0, [pc, #156]	; (c0d000cc <_nvram_data_size+0x8c>)
c0d0002e:	2100      	movs	r1, #0
c0d00030:	223c      	movs	r2, #60	; 0x3c
c0d00032:	f002 fcf5 	bl	c0d02a20 <os_memset>

    // ensure exception will work as planned
    os_boot();
c0d00036:	f002 fc45 	bl	c0d028c4 <os_boot>
c0d0003a:	4d25      	ldr	r5, [pc, #148]	; (c0d000d0 <_nvram_data_size+0x90>)
c0d0003c:	2400      	movs	r4, #0

    for (;;) {
        UX_INIT();
c0d0003e:	22b0      	movs	r2, #176	; 0xb0

c0d00040 <_nvram_data_size>:
c0d00040:	4628      	mov	r0, r5
c0d00042:	4621      	mov	r1, r4
c0d00044:	f002 fcec 	bl	c0d02a20 <os_memset>
c0d00048:	ae01      	add	r6, sp, #4

        BEGIN_TRY {
            TRY {
c0d0004a:	4630      	mov	r0, r6
c0d0004c:	f006 ffb6 	bl	c0d06fbc <setjmp>
c0d00050:	8530      	strh	r0, [r6, #40]	; 0x28
c0d00052:	b280      	uxth	r0, r0
c0d00054:	2800      	cmp	r0, #0
c0d00056:	d006      	beq.n	c0d00066 <_nvram_data_size+0x26>
c0d00058:	2810      	cmp	r0, #16
c0d0005a:	d0ef      	beq.n	c0d0003c <main+0x3c>
            FINALLY {
            }
        }
        END_TRY;
    }
	  app_exit();
c0d0005c:	f002 fc0e 	bl	c0d0287c <app_exit>
#endif
    return 0;
c0d00060:	2000      	movs	r0, #0
c0d00062:	b00c      	add	sp, #48	; 0x30
c0d00064:	bd70      	pop	{r4, r5, r6, pc}
c0d00066:	a801      	add	r0, sp, #4

    for (;;) {
        UX_INIT();

        BEGIN_TRY {
            TRY {
c0d00068:	f002 fc2f 	bl	c0d028ca <try_context_set>
                io_seproxyhal_init();
c0d0006c:	f002 fed2 	bl	c0d02e14 <io_seproxyhal_init>
#ifdef TARGET_NANOX
                // grab the current plane mode setting
                G_io_app.plane_mode = os_setting_get(OS_SETTING_PLANEMODE, NULL, 0);
#endif // TARGET_NANOX

                if (N_storage.initialized != 0x01) {
c0d00070:	481b      	ldr	r0, [pc, #108]	; (c0d000e0 <_nvram_data_size+0xa0>)
c0d00072:	4478      	add	r0, pc
c0d00074:	f003 fe36 	bl	c0d03ce4 <pic>
c0d00078:	7880      	ldrb	r0, [r0, #2]
c0d0007a:	2801      	cmp	r0, #1
c0d0007c:	d00c      	beq.n	c0d00098 <_nvram_data_size+0x58>
c0d0007e:	466d      	mov	r5, sp
                  internalStorage_t storage;
                  storage.dataAllowed = 0x00;
c0d00080:	702c      	strb	r4, [r5, #0]
                  storage.contractDetails = 0x00;
c0d00082:	706c      	strb	r4, [r5, #1]
c0d00084:	2001      	movs	r0, #1
                  storage.initialized = 0x01;
c0d00086:	70a8      	strb	r0, [r5, #2]
                  nvm_write(&N_storage, (void*)&storage, sizeof(internalStorage_t));
c0d00088:	4816      	ldr	r0, [pc, #88]	; (c0d000e4 <_nvram_data_size+0xa4>)
c0d0008a:	4478      	add	r0, pc
c0d0008c:	f003 fe2a 	bl	c0d03ce4 <pic>
c0d00090:	2203      	movs	r2, #3
c0d00092:	4629      	mov	r1, r5
c0d00094:	f003 fe68 	bl	c0d03d68 <nvm_write>
                }
                dataAllowed = N_storage.dataAllowed;
c0d00098:	4c13      	ldr	r4, [pc, #76]	; (c0d000e8 <_nvram_data_size+0xa8>)
c0d0009a:	447c      	add	r4, pc
c0d0009c:	4620      	mov	r0, r4
c0d0009e:	f003 fe21 	bl	c0d03ce4 <pic>
c0d000a2:	7800      	ldrb	r0, [r0, #0]
c0d000a4:	490b      	ldr	r1, [pc, #44]	; (c0d000d4 <_nvram_data_size+0x94>)
c0d000a6:	7008      	strb	r0, [r1, #0]
                contractDetails = N_storage.contractDetails;
c0d000a8:	4620      	mov	r0, r4
c0d000aa:	f003 fe1b 	bl	c0d03ce4 <pic>
c0d000ae:	7840      	ldrb	r0, [r0, #1]
c0d000b0:	4909      	ldr	r1, [pc, #36]	; (c0d000d8 <_nvram_data_size+0x98>)
c0d000b2:	7008      	strb	r0, [r1, #0]
c0d000b4:	2000      	movs	r0, #0

                USB_power(0);
c0d000b6:	f006 fd27 	bl	c0d06b08 <USB_power>
c0d000ba:	2001      	movs	r0, #1
                USB_power(1);
c0d000bc:	f006 fd24 	bl	c0d06b08 <USB_power>

                ui_idle();
c0d000c0:	f000 fdf0 	bl	c0d00ca4 <ui_idle>
    #if defined(TARGET_BLUE)
                // setup the status bar colors (remembered after wards, even more if another app does not resetup after app switch)
                UX_SET_STATUS_BAR_COLOR(0xFFFFFF, chainConfig->color_header);
    #endif // #if defined(TARGET_BLUE)

                sample_main();
c0d000c4:	f002 f88c 	bl	c0d021e0 <sample_main>
c0d000c8:	20001aa0 	.word	0x20001aa0
c0d000cc:	20001a64 	.word	0x20001a64
c0d000d0:	20001898 	.word	0x20001898
c0d000d4:	20001800 	.word	0x20001800
c0d000d8:	20001801 	.word	0x20001801
c0d000dc:	00007cfa 	.word	0x00007cfa
c0d000e0:	0001084a 	.word	0x0001084a
c0d000e4:	00010832 	.word	0x00010832
c0d000e8:	00010822 	.word	0x00010822

c0d000ec <cx_hash_X>:
}

int cx_hash_X(cx_hash_t *hash ,
              int mode,
              unsigned char WIDE *in , unsigned int len,
              unsigned char *out) {
c0d000ec:	b570      	push	{r4, r5, r6, lr}
c0d000ee:	b082      	sub	sp, #8
c0d000f0:	7805      	ldrb	r5, [r0, #0]
c0d000f2:	2414      	movs	r4, #20
   unsigned int hsz = 0;

    switch (hash->algo) {
c0d000f4:	2d05      	cmp	r5, #5
c0d000f6:	dc09      	bgt.n	c0d0010c <cx_hash_X+0x20>
c0d000f8:	2d02      	cmp	r5, #2
c0d000fa:	dd17      	ble.n	c0d0012c <cx_hash_X+0x40>
c0d000fc:	2d03      	cmp	r5, #3
c0d000fe:	d01b      	beq.n	c0d00138 <cx_hash_X+0x4c>
c0d00100:	2d04      	cmp	r5, #4
c0d00102:	d01b      	beq.n	c0d0013c <cx_hash_X+0x50>
c0d00104:	2d05      	cmp	r5, #5
c0d00106:	d11b      	bne.n	c0d00140 <cx_hash_X+0x54>
c0d00108:	2440      	movs	r4, #64	; 0x40
c0d0010a:	e007      	b.n	c0d0011c <cx_hash_X+0x30>
c0d0010c:	1fac      	subs	r4, r5, #6
c0d0010e:	2c03      	cmp	r4, #3
c0d00110:	d303      	bcc.n	c0d0011a <cx_hash_X+0x2e>
c0d00112:	2d09      	cmp	r5, #9
c0d00114:	d001      	beq.n	c0d0011a <cx_hash_X+0x2e>
c0d00116:	2d0a      	cmp	r5, #10
c0d00118:	d112      	bne.n	c0d00140 <cx_hash_X+0x54>
c0d0011a:	6884      	ldr	r4, [r0, #8]
c0d0011c:	9d06      	ldr	r5, [sp, #24]
    default:
        THROW(INVALID_PARAMETER);
        return 0;
    }

    return cx_hash(hash, mode, in, len, out, hsz);
c0d0011e:	466e      	mov	r6, sp
c0d00120:	6035      	str	r5, [r6, #0]
c0d00122:	6074      	str	r4, [r6, #4]
c0d00124:	f003 fe4e 	bl	c0d03dc4 <cx_hash>
c0d00128:	b002      	add	sp, #8
c0d0012a:	bd70      	pop	{r4, r5, r6, pc}
c0d0012c:	2d01      	cmp	r5, #1
c0d0012e:	d0f5      	beq.n	c0d0011c <cx_hash_X+0x30>
c0d00130:	2d02      	cmp	r5, #2
c0d00132:	d105      	bne.n	c0d00140 <cx_hash_X+0x54>
c0d00134:	241c      	movs	r4, #28
c0d00136:	e7f1      	b.n	c0d0011c <cx_hash_X+0x30>
c0d00138:	2420      	movs	r4, #32
c0d0013a:	e7ef      	b.n	c0d0011c <cx_hash_X+0x30>
c0d0013c:	2430      	movs	r4, #48	; 0x30
c0d0013e:	e7ed      	b.n	c0d0011c <cx_hash_X+0x30>
        break;  
    case CX_BLAKE2B:
        hsz =   ((cx_blake2b_t*)hash)->output_size;
        break;
    default:
        THROW(INVALID_PARAMETER);
c0d00140:	2002      	movs	r0, #2
c0d00142:	f002 fd2a 	bl	c0d02b9a <os_longjmp>

c0d00146 <cx_hash_sha256_X>:

    return cx_hash(hash, mode, in, len, out, hsz);

}

int cx_hash_sha256_X(unsigned char WIDE *in, unsigned int len, unsigned char *out){
c0d00146:	b580      	push	{r7, lr}
    return cx_hash_sha256(in, len, out, 32);
c0d00148:	2320      	movs	r3, #32
c0d0014a:	f003 fe6d 	bl	c0d03e28 <cx_hash_sha256>
c0d0014e:	bd80      	pop	{r7, pc}

c0d00150 <cx_ecfp_get_domain_length>:
    exponent[3] = pub_exponent>>0;

    return cx_rsa_generate_pair(modulus_len, public_key, private_key, exponent, 4, externalPQ);
}

static unsigned int cx_ecfp_get_domain_length(cx_curve_t curve) {
c0d00150:	b580      	push	{r7, lr}
c0d00152:	4601      	mov	r1, r0
c0d00154:	2020      	movs	r0, #32
    switch(curve) {
c0d00156:	2928      	cmp	r1, #40	; 0x28
c0d00158:	dd0b      	ble.n	c0d00172 <cx_ecfp_get_domain_length+0x22>
c0d0015a:	292c      	cmp	r1, #44	; 0x2c
c0d0015c:	dd15      	ble.n	c0d0018a <cx_ecfp_get_domain_length+0x3a>
c0d0015e:	2941      	cmp	r1, #65	; 0x41
c0d00160:	dd24      	ble.n	c0d001ac <cx_ecfp_get_domain_length+0x5c>
c0d00162:	2942      	cmp	r1, #66	; 0x42
c0d00164:	d02d      	beq.n	c0d001c2 <cx_ecfp_get_domain_length+0x72>
c0d00166:	2961      	cmp	r1, #97	; 0x61
c0d00168:	d02c      	beq.n	c0d001c4 <cx_ecfp_get_domain_length+0x74>
c0d0016a:	2962      	cmp	r1, #98	; 0x62
c0d0016c:	d12b      	bne.n	c0d001c6 <cx_ecfp_get_domain_length+0x76>
c0d0016e:	2038      	movs	r0, #56	; 0x38
    default:
        break;
    }
    THROW(INVALID_PARAMETER);
    return 0;
}
c0d00170:	bd80      	pop	{r7, pc}
c0d00172:	460a      	mov	r2, r1
c0d00174:	2924      	cmp	r1, #36	; 0x24
c0d00176:	dc10      	bgt.n	c0d0019a <cx_ecfp_get_domain_length+0x4a>
c0d00178:	3a21      	subs	r2, #33	; 0x21
c0d0017a:	2a02      	cmp	r2, #2
c0d0017c:	d322      	bcc.n	c0d001c4 <cx_ecfp_get_domain_length+0x74>
c0d0017e:	2923      	cmp	r1, #35	; 0x23
c0d00180:	d009      	beq.n	c0d00196 <cx_ecfp_get_domain_length+0x46>
c0d00182:	2924      	cmp	r1, #36	; 0x24
c0d00184:	d11f      	bne.n	c0d001c6 <cx_ecfp_get_domain_length+0x76>
c0d00186:	2042      	movs	r0, #66	; 0x42
c0d00188:	bd80      	pop	{r7, pc}
c0d0018a:	292a      	cmp	r1, #42	; 0x2a
c0d0018c:	dc13      	bgt.n	c0d001b6 <cx_ecfp_get_domain_length+0x66>
c0d0018e:	2929      	cmp	r1, #41	; 0x29
c0d00190:	d001      	beq.n	c0d00196 <cx_ecfp_get_domain_length+0x46>
c0d00192:	292a      	cmp	r1, #42	; 0x2a
c0d00194:	d117      	bne.n	c0d001c6 <cx_ecfp_get_domain_length+0x76>
c0d00196:	2030      	movs	r0, #48	; 0x30
c0d00198:	bd80      	pop	{r7, pc}
c0d0019a:	3a25      	subs	r2, #37	; 0x25
c0d0019c:	2a02      	cmp	r2, #2
c0d0019e:	d311      	bcc.n	c0d001c4 <cx_ecfp_get_domain_length+0x74>
c0d001a0:	2927      	cmp	r1, #39	; 0x27
c0d001a2:	d001      	beq.n	c0d001a8 <cx_ecfp_get_domain_length+0x58>
c0d001a4:	2928      	cmp	r1, #40	; 0x28
c0d001a6:	d10e      	bne.n	c0d001c6 <cx_ecfp_get_domain_length+0x76>
c0d001a8:	2028      	movs	r0, #40	; 0x28
c0d001aa:	bd80      	pop	{r7, pc}
c0d001ac:	292d      	cmp	r1, #45	; 0x2d
c0d001ae:	d009      	beq.n	c0d001c4 <cx_ecfp_get_domain_length+0x74>
c0d001b0:	2941      	cmp	r1, #65	; 0x41
c0d001b2:	d007      	beq.n	c0d001c4 <cx_ecfp_get_domain_length+0x74>
c0d001b4:	e007      	b.n	c0d001c6 <cx_ecfp_get_domain_length+0x76>
c0d001b6:	292b      	cmp	r1, #43	; 0x2b
c0d001b8:	d001      	beq.n	c0d001be <cx_ecfp_get_domain_length+0x6e>
c0d001ba:	292c      	cmp	r1, #44	; 0x2c
c0d001bc:	d103      	bne.n	c0d001c6 <cx_ecfp_get_domain_length+0x76>
c0d001be:	2040      	movs	r0, #64	; 0x40
c0d001c0:	bd80      	pop	{r7, pc}
c0d001c2:	2039      	movs	r0, #57	; 0x39
c0d001c4:	bd80      	pop	{r7, pc}
    case CX_CURVE_Curve448:
        return 56;
    default:
        break;
    }
    THROW(INVALID_PARAMETER);
c0d001c6:	2002      	movs	r0, #2
c0d001c8:	f002 fce7 	bl	c0d02b9a <os_longjmp>

c0d001cc <cx_ecdsa_sign_X>:
}

int cx_ecdsa_sign_X(cx_ecfp_private_key_t WIDE *pv_key,
                    int mode,  cx_md_t hashID, unsigned char  WIDE *hash, unsigned int hash_len,
                    unsigned char *sig ,
                    unsigned int *info) {
c0d001cc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d001ce:	b085      	sub	sp, #20
c0d001d0:	461c      	mov	r4, r3
c0d001d2:	4615      	mov	r5, r2
c0d001d4:	460e      	mov	r6, r1
c0d001d6:	4607      	mov	r7, r0
    const unsigned int  domain_length =  cx_ecfp_get_domain_length(pv_key->curve);
c0d001d8:	7838      	ldrb	r0, [r7, #0]
c0d001da:	f7ff ffb9 	bl	c0d00150 <cx_ecfp_get_domain_length>
c0d001de:	990c      	ldr	r1, [sp, #48]	; 0x30
    return cx_ecdsa_sign(pv_key, mode, hashID, hash, hash_len, sig,  6+2*(domain_length+1), info);
c0d001e0:	466a      	mov	r2, sp
c0d001e2:	60d1      	str	r1, [r2, #12]
c0d001e4:	0040      	lsls	r0, r0, #1
c0d001e6:	3008      	adds	r0, #8
c0d001e8:	6090      	str	r0, [r2, #8]
c0d001ea:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d001ec:	6050      	str	r0, [r2, #4]
c0d001ee:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d001f0:	6010      	str	r0, [r2, #0]
c0d001f2:	4638      	mov	r0, r7
c0d001f4:	4631      	mov	r1, r6
c0d001f6:	462a      	mov	r2, r5
c0d001f8:	4623      	mov	r3, r4
c0d001fa:	f003 fe8d 	bl	c0d03f18 <cx_ecdsa_sign>
c0d001fe:	b005      	add	sp, #20
c0d00200:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d00202 <initTx>:
#define MAX_INT256 32
#define MAX_ADDRESS 20
#define MAX_V 4

void initTx(txContext_t *context, cx_sha3_t *sha3, txContent_t *content,
            ustreamProcess_t customProcessor, void *extra) {
c0d00202:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d00204:	b081      	sub	sp, #4
c0d00206:	461d      	mov	r5, r3
c0d00208:	4616      	mov	r6, r2
c0d0020a:	460c      	mov	r4, r1
c0d0020c:	4607      	mov	r7, r0
c0d0020e:	2100      	movs	r1, #0
    os_memset(context, 0, sizeof(txContext_t));
c0d00210:	223c      	movs	r2, #60	; 0x3c
c0d00212:	f002 fc05 	bl	c0d02a20 <os_memset>
    context->sha3 = sha3;
c0d00216:	607c      	str	r4, [r7, #4]
    context->content = content;
c0d00218:	637e      	str	r6, [r7, #52]	; 0x34
    context->customProcessor = customProcessor;
c0d0021a:	633d      	str	r5, [r7, #48]	; 0x30
c0d0021c:	9806      	ldr	r0, [sp, #24]
    context->extra = extra;
c0d0021e:	63b8      	str	r0, [r7, #56]	; 0x38
    context->currentField = TX_RLP_CONTENT;
c0d00220:	2001      	movs	r0, #1
c0d00222:	7038      	strb	r0, [r7, #0]
    cx_keccak_init(context->sha3, 256);
c0d00224:	0201      	lsls	r1, r0, #8
c0d00226:	4620      	mov	r0, r4
c0d00228:	f003 fe16 	bl	c0d03e58 <cx_keccak_init>
}
c0d0022c:	b001      	add	sp, #4
c0d0022e:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d00230 <readTxByte>:

uint8_t readTxByte(txContext_t *context) {
c0d00230:	b510      	push	{r4, lr}
c0d00232:	b082      	sub	sp, #8
    uint8_t data;
    if (context->commandLength < 1) {
c0d00234:	6a82      	ldr	r2, [r0, #40]	; 0x28
c0d00236:	2a00      	cmp	r2, #0
c0d00238:	d01d      	beq.n	c0d00276 <readTxByte+0x46>
        PRINTF("readTxByte Underflow\n");
        THROW(EXCEPTION);
    }
    data = *context->workBuffer;
c0d0023a:	6a43      	ldr	r3, [r0, #36]	; 0x24
c0d0023c:	7819      	ldrb	r1, [r3, #0]
c0d0023e:	ac01      	add	r4, sp, #4
c0d00240:	7021      	strb	r1, [r4, #0]
    context->workBuffer++;
c0d00242:	1c5b      	adds	r3, r3, #1
    context->commandLength--;
c0d00244:	1e52      	subs	r2, r2, #1
    if (context->commandLength < 1) {
        PRINTF("readTxByte Underflow\n");
        THROW(EXCEPTION);
    }
    data = *context->workBuffer;
    context->workBuffer++;
c0d00246:	6243      	str	r3, [r0, #36]	; 0x24
    context->commandLength--;
c0d00248:	6282      	str	r2, [r0, #40]	; 0x28
    if (context->processingField) {
c0d0024a:	7c42      	ldrb	r2, [r0, #17]
c0d0024c:	2a00      	cmp	r2, #0
c0d0024e:	d005      	beq.n	c0d0025c <readTxByte+0x2c>
        context->currentFieldPos++;
c0d00250:	68c2      	ldr	r2, [r0, #12]
c0d00252:	1c52      	adds	r2, r2, #1
c0d00254:	60c2      	str	r2, [r0, #12]
    }
    if (!(context->processingField && context->fieldSingleByte)) {
c0d00256:	7c82      	ldrb	r2, [r0, #18]
c0d00258:	2a00      	cmp	r2, #0
c0d0025a:	d109      	bne.n	c0d00270 <readTxByte+0x40>
        cx_hash((cx_hash_t*)context->sha3, 0, &data, 1, NULL);
c0d0025c:	6840      	ldr	r0, [r0, #4]
c0d0025e:	2100      	movs	r1, #0
c0d00260:	466a      	mov	r2, sp
c0d00262:	6011      	str	r1, [r2, #0]
c0d00264:	ac01      	add	r4, sp, #4
c0d00266:	2301      	movs	r3, #1
c0d00268:	4622      	mov	r2, r4
c0d0026a:	f7ff ff3f 	bl	c0d000ec <cx_hash_X>
c0d0026e:	7821      	ldrb	r1, [r4, #0]
    }
    return data;
c0d00270:	4608      	mov	r0, r1
c0d00272:	b002      	add	sp, #8
c0d00274:	bd10      	pop	{r4, pc}

uint8_t readTxByte(txContext_t *context) {
    uint8_t data;
    if (context->commandLength < 1) {
        PRINTF("readTxByte Underflow\n");
        THROW(EXCEPTION);
c0d00276:	2001      	movs	r0, #1
c0d00278:	f002 fc8f 	bl	c0d02b9a <os_longjmp>

c0d0027c <copyTxData>:
        cx_hash((cx_hash_t*)context->sha3, 0, &data, 1, NULL);
    }
    return data;
}

void copyTxData(txContext_t *context, uint8_t *out, uint32_t length) {
c0d0027c:	b5b0      	push	{r4, r5, r7, lr}
c0d0027e:	b082      	sub	sp, #8
c0d00280:	4614      	mov	r4, r2
c0d00282:	4605      	mov	r5, r0
    if (context->commandLength < length) {
c0d00284:	6aa8      	ldr	r0, [r5, #40]	; 0x28
c0d00286:	42a0      	cmp	r0, r4
c0d00288:	d32a      	bcc.n	c0d002e0 <copyTxData+0x64>
        PRINTF("copyTxData Underflow\n");
        THROW(EXCEPTION);
    }
    if (out != NULL) {
c0d0028a:	2900      	cmp	r1, #0
c0d0028c:	d005      	beq.n	c0d0029a <copyTxData+0x1e>
        os_memmove(out, context->workBuffer, length);
c0d0028e:	6a6a      	ldr	r2, [r5, #36]	; 0x24
c0d00290:	4608      	mov	r0, r1
c0d00292:	4611      	mov	r1, r2
c0d00294:	4622      	mov	r2, r4
c0d00296:	f002 fbcc 	bl	c0d02a32 <os_memmove>
    }
    if (!(context->processingField && context->fieldSingleByte)) {
c0d0029a:	7c68      	ldrb	r0, [r5, #17]
c0d0029c:	2800      	cmp	r0, #0
c0d0029e:	d009      	beq.n	c0d002b4 <copyTxData+0x38>
c0d002a0:	7ca8      	ldrb	r0, [r5, #18]
c0d002a2:	2800      	cmp	r0, #0
c0d002a4:	d006      	beq.n	c0d002b4 <copyTxData+0x38>
        cx_hash((cx_hash_t*)context->sha3, 0, context->workBuffer, length, NULL);
    }
    context->workBuffer += length;
c0d002a6:	6a68      	ldr	r0, [r5, #36]	; 0x24
c0d002a8:	1900      	adds	r0, r0, r4
c0d002aa:	6268      	str	r0, [r5, #36]	; 0x24
    context->commandLength -= length;
c0d002ac:	6aa8      	ldr	r0, [r5, #40]	; 0x28
c0d002ae:	1b00      	subs	r0, r0, r4
c0d002b0:	62a8      	str	r0, [r5, #40]	; 0x28
c0d002b2:	e010      	b.n	c0d002d6 <copyTxData+0x5a>
    }
    if (out != NULL) {
        os_memmove(out, context->workBuffer, length);
    }
    if (!(context->processingField && context->fieldSingleByte)) {
        cx_hash((cx_hash_t*)context->sha3, 0, context->workBuffer, length, NULL);
c0d002b4:	6a6a      	ldr	r2, [r5, #36]	; 0x24
c0d002b6:	6868      	ldr	r0, [r5, #4]
c0d002b8:	2100      	movs	r1, #0
c0d002ba:	466b      	mov	r3, sp
c0d002bc:	6019      	str	r1, [r3, #0]
c0d002be:	4623      	mov	r3, r4
c0d002c0:	f7ff ff14 	bl	c0d000ec <cx_hash_X>
    }
    context->workBuffer += length;
c0d002c4:	6a68      	ldr	r0, [r5, #36]	; 0x24
c0d002c6:	1900      	adds	r0, r0, r4
c0d002c8:	7c69      	ldrb	r1, [r5, #17]
c0d002ca:	6268      	str	r0, [r5, #36]	; 0x24
    context->commandLength -= length;
c0d002cc:	6aa8      	ldr	r0, [r5, #40]	; 0x28
c0d002ce:	1b00      	subs	r0, r0, r4
c0d002d0:	62a8      	str	r0, [r5, #40]	; 0x28
    if (context->processingField) {
c0d002d2:	2900      	cmp	r1, #0
c0d002d4:	d002      	beq.n	c0d002dc <copyTxData+0x60>
        context->currentFieldPos += length;
c0d002d6:	68e8      	ldr	r0, [r5, #12]
c0d002d8:	1900      	adds	r0, r0, r4
c0d002da:	60e8      	str	r0, [r5, #12]
    }
}
c0d002dc:	b002      	add	sp, #8
c0d002de:	bdb0      	pop	{r4, r5, r7, pc}
}

void copyTxData(txContext_t *context, uint8_t *out, uint32_t length) {
    if (context->commandLength < length) {
        PRINTF("copyTxData Underflow\n");
        THROW(EXCEPTION);
c0d002e0:	2001      	movs	r0, #1
c0d002e2:	f002 fc5a 	bl	c0d02b9a <os_longjmp>
	...

c0d002e8 <processTx>:
        }
    }
}

parserStatus_e processTx(txContext_t *context, uint8_t *buffer,
                         uint32_t length, uint32_t processingFlags) {
c0d002e8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d002ea:	b08d      	sub	sp, #52	; 0x34
c0d002ec:	9301      	str	r3, [sp, #4]
c0d002ee:	4616      	mov	r6, r2
c0d002f0:	460f      	mov	r7, r1
c0d002f2:	4605      	mov	r5, r0
c0d002f4:	ac02      	add	r4, sp, #8
    parserStatus_e result;
    BEGIN_TRY {
        TRY {
c0d002f6:	4620      	mov	r0, r4
c0d002f8:	f006 fe60 	bl	c0d06fbc <setjmp>
c0d002fc:	8520      	strh	r0, [r4, #40]	; 0x28
c0d002fe:	4912      	ldr	r1, [pc, #72]	; (c0d00348 <processTx+0x60>)
c0d00300:	4208      	tst	r0, r1
c0d00302:	d004      	beq.n	c0d0030e <processTx+0x26>
c0d00304:	a802      	add	r0, sp, #8
            context->workBuffer = buffer;
            context->commandLength = length;
            context->processingFlags = processingFlags;
            result = processTxInternal(context);
        }
        CATCH_OTHER(e) {
c0d00306:	2100      	movs	r1, #0
c0d00308:	8501      	strh	r1, [r0, #40]	; 0x28
c0d0030a:	2403      	movs	r4, #3
c0d0030c:	e00a      	b.n	c0d00324 <processTx+0x3c>
c0d0030e:	a802      	add	r0, sp, #8

parserStatus_e processTx(txContext_t *context, uint8_t *buffer,
                         uint32_t length, uint32_t processingFlags) {
    parserStatus_e result;
    BEGIN_TRY {
        TRY {
c0d00310:	f002 fadb 	bl	c0d028ca <try_context_set>
            context->workBuffer = buffer;
c0d00314:	626f      	str	r7, [r5, #36]	; 0x24
            context->commandLength = length;
c0d00316:	62ae      	str	r6, [r5, #40]	; 0x28
            context->processingFlags = processingFlags;
c0d00318:	9801      	ldr	r0, [sp, #4]
c0d0031a:	62e8      	str	r0, [r5, #44]	; 0x2c
            result = processTxInternal(context);
c0d0031c:	4628      	mov	r0, r5
c0d0031e:	f000 f815 	bl	c0d0034c <processTxInternal>
c0d00322:	4604      	mov	r4, r0
        }
        CATCH_OTHER(e) {
            result = USTREAM_FAULT;
        }
        FINALLY {
c0d00324:	f002 fc3e 	bl	c0d02ba4 <try_context_get>
c0d00328:	a902      	add	r1, sp, #8
c0d0032a:	4288      	cmp	r0, r1
c0d0032c:	d103      	bne.n	c0d00336 <processTx+0x4e>
c0d0032e:	f002 fc3b 	bl	c0d02ba8 <try_context_get_previous>
c0d00332:	f002 faca 	bl	c0d028ca <try_context_set>
c0d00336:	a802      	add	r0, sp, #8
        }
    }
    END_TRY;
c0d00338:	8d00      	ldrh	r0, [r0, #40]	; 0x28
c0d0033a:	2800      	cmp	r0, #0
c0d0033c:	d102      	bne.n	c0d00344 <processTx+0x5c>
    return result;
c0d0033e:	4620      	mov	r0, r4
c0d00340:	b00d      	add	sp, #52	; 0x34
c0d00342:	bdf0      	pop	{r4, r5, r6, r7, pc}
            result = USTREAM_FAULT;
        }
        FINALLY {
        }
    }
    END_TRY;
c0d00344:	f002 fc29 	bl	c0d02b9a <os_longjmp>
c0d00348:	0000ffff 	.word	0x0000ffff

c0d0034c <processTxInternal>:
        context->processingField = false;
    }
}


static parserStatus_e processTxInternal(txContext_t *context) {
c0d0034c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0034e:	b085      	sub	sp, #20
c0d00350:	4604      	mov	r4, r0
c0d00352:	4627      	mov	r7, r4
c0d00354:	3710      	adds	r7, #16
c0d00356:	3008      	adds	r0, #8
c0d00358:	9002      	str	r0, [sp, #8]
c0d0035a:	4626      	mov	r6, r4
c0d0035c:	3618      	adds	r6, #24
c0d0035e:	e0ad      	b.n	c0d004bc <processTxInternal+0x170>
c0d00360:	4602      	mov	r2, r0
c0d00362:	3a0a      	subs	r2, #10
c0d00364:	2a02      	cmp	r2, #2
c0d00366:	d323      	bcc.n	c0d003b0 <processTxInternal+0x64>
c0d00368:	2808      	cmp	r0, #8
c0d0036a:	d021      	beq.n	c0d003b0 <processTxInternal+0x64>
c0d0036c:	2809      	cmp	r0, #9
c0d0036e:	d000      	beq.n	c0d00372 <processTxInternal+0x26>
c0d00370:	e164      	b.n	c0d0063c <processTxInternal+0x2f0>
        context->processingField = false;
    }
}

static void processV(txContext_t *context) {
    if (context->currentFieldIsList) {
c0d00372:	7838      	ldrb	r0, [r7, #0]
c0d00374:	2800      	cmp	r0, #0
c0d00376:	d000      	beq.n	c0d0037a <processTxInternal+0x2e>
c0d00378:	e163      	b.n	c0d00642 <processTxInternal+0x2f6>
        PRINTF("Invalid type for RLP_V\n");
        THROW(EXCEPTION);
    }
    if (context->currentFieldLength > MAX_V) {
c0d0037a:	9802      	ldr	r0, [sp, #8]
c0d0037c:	6800      	ldr	r0, [r0, #0]
c0d0037e:	2805      	cmp	r0, #5
c0d00380:	d300      	bcc.n	c0d00384 <processTxInternal+0x38>
c0d00382:	e15e      	b.n	c0d00642 <processTxInternal+0x2f6>
        PRINTF("Invalid length for RLP_V\n");
        THROW(EXCEPTION);
    }
    if (context->currentFieldPos < context->currentFieldLength) {
c0d00384:	68e1      	ldr	r1, [r4, #12]
c0d00386:	4288      	cmp	r0, r1
c0d00388:	d90c      	bls.n	c0d003a4 <processTxInternal+0x58>
        uint32_t copySize =
            (context->commandLength <
                     ((context->currentFieldLength - context->currentFieldPos))
c0d0038a:	1a40      	subs	r0, r0, r1
        PRINTF("Invalid length for RLP_V\n");
        THROW(EXCEPTION);
    }
    if (context->currentFieldPos < context->currentFieldLength) {
        uint32_t copySize =
            (context->commandLength <
c0d0038c:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d0038e:	4282      	cmp	r2, r0
c0d00390:	d300      	bcc.n	c0d00394 <processTxInternal+0x48>
c0d00392:	4602      	mov	r2, r0
                     ((context->currentFieldLength - context->currentFieldPos))
                 ? context->commandLength
                 : context->currentFieldLength - context->currentFieldPos);
        copyTxData(context,
                   context->content->v + context->currentFieldPos,
c0d00394:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d00396:	1841      	adds	r1, r0, r1
c0d00398:	3178      	adds	r1, #120	; 0x78
        uint32_t copySize =
            (context->commandLength <
                     ((context->currentFieldLength - context->currentFieldPos))
                 ? context->commandLength
                 : context->currentFieldLength - context->currentFieldPos);
        copyTxData(context,
c0d0039a:	4620      	mov	r0, r4
c0d0039c:	f7ff ff6e 	bl	c0d0027c <copyTxData>
c0d003a0:	68a0      	ldr	r0, [r4, #8]
c0d003a2:	68e1      	ldr	r1, [r4, #12]
                   context->content->v + context->currentFieldPos,
                   copySize);
    }
    if (context->currentFieldPos == context->currentFieldLength) {
c0d003a4:	4281      	cmp	r1, r0
c0d003a6:	d000      	beq.n	c0d003aa <processTxInternal+0x5e>
c0d003a8:	e088      	b.n	c0d004bc <processTxInternal+0x170>
        context->content->vLength = context->currentFieldLength;
c0d003aa:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d003ac:	227c      	movs	r2, #124	; 0x7c
c0d003ae:	e07f      	b.n	c0d004b0 <processTxInternal+0x164>
        context->processingField = false;
    }
}

static void processData(txContext_t *context) {
    if (context->currentFieldIsList) {
c0d003b0:	7838      	ldrb	r0, [r7, #0]
c0d003b2:	2800      	cmp	r0, #0
c0d003b4:	d000      	beq.n	c0d003b8 <processTxInternal+0x6c>
c0d003b6:	e144      	b.n	c0d00642 <processTxInternal+0x2f6>
        PRINTF("Invalid type for RLP_DATA\n");
        THROW(EXCEPTION);
    }
    if (context->currentFieldPos < context->currentFieldLength) {
c0d003b8:	68a0      	ldr	r0, [r4, #8]
c0d003ba:	e02d      	b.n	c0d00418 <processTxInternal+0xcc>
c0d003bc:	2803      	cmp	r0, #3
c0d003be:	d022      	beq.n	c0d00406 <processTxInternal+0xba>
c0d003c0:	2804      	cmp	r0, #4
c0d003c2:	d000      	beq.n	c0d003c6 <processTxInternal+0x7a>
c0d003c4:	e13a      	b.n	c0d0063c <processTxInternal+0x2f0>
        context->processingField = false;
    }
}

static void processGasprice(txContext_t *context) {
    if (context->currentFieldIsList) {
c0d003c6:	7838      	ldrb	r0, [r7, #0]
c0d003c8:	2800      	cmp	r0, #0
c0d003ca:	d000      	beq.n	c0d003ce <processTxInternal+0x82>
c0d003cc:	e139      	b.n	c0d00642 <processTxInternal+0x2f6>
        PRINTF("Invalid type for RLP_GASPRICE\n");
        THROW(EXCEPTION);
    }
    if (context->currentFieldLength > MAX_INT256) {
c0d003ce:	9802      	ldr	r0, [sp, #8]
c0d003d0:	6800      	ldr	r0, [r0, #0]
c0d003d2:	2821      	cmp	r0, #33	; 0x21
c0d003d4:	d300      	bcc.n	c0d003d8 <processTxInternal+0x8c>
c0d003d6:	e134      	b.n	c0d00642 <processTxInternal+0x2f6>
        PRINTF("Invalid length for RLP_GASPRICE\n");
        THROW(EXCEPTION);
    }
    if (context->currentFieldPos < context->currentFieldLength) {
c0d003d8:	68e2      	ldr	r2, [r4, #12]
c0d003da:	4290      	cmp	r0, r2
c0d003dc:	d90b      	bls.n	c0d003f6 <processTxInternal+0xaa>
            (context->commandLength <
                     ((context->currentFieldLength - context->currentFieldPos))
                 ? context->commandLength
                 : context->currentFieldLength - context->currentFieldPos);
        copyTxData(context,
                   context->content->gasprice.value + context->currentFieldPos,
c0d003de:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d003e0:	1889      	adds	r1, r1, r2
        THROW(EXCEPTION);
    }
    if (context->currentFieldPos < context->currentFieldLength) {
        uint32_t copySize =
            (context->commandLength <
                     ((context->currentFieldLength - context->currentFieldPos))
c0d003e2:	1a80      	subs	r0, r0, r2
        PRINTF("Invalid length for RLP_GASPRICE\n");
        THROW(EXCEPTION);
    }
    if (context->currentFieldPos < context->currentFieldLength) {
        uint32_t copySize =
            (context->commandLength <
c0d003e4:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d003e6:	4282      	cmp	r2, r0
c0d003e8:	d300      	bcc.n	c0d003ec <processTxInternal+0xa0>
c0d003ea:	4602      	mov	r2, r0
                     ((context->currentFieldLength - context->currentFieldPos))
                 ? context->commandLength
                 : context->currentFieldLength - context->currentFieldPos);
        copyTxData(context,
c0d003ec:	4620      	mov	r0, r4
c0d003ee:	f7ff ff45 	bl	c0d0027c <copyTxData>
c0d003f2:	68a0      	ldr	r0, [r4, #8]
c0d003f4:	68e2      	ldr	r2, [r4, #12]
                   context->content->gasprice.value + context->currentFieldPos,
                   copySize);
    }
    if (context->currentFieldPos == context->currentFieldLength) {
c0d003f6:	4282      	cmp	r2, r0
c0d003f8:	d160      	bne.n	c0d004bc <processTxInternal+0x170>
        context->content->gasprice.length = context->currentFieldLength;
c0d003fa:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d003fc:	2220      	movs	r2, #32
c0d003fe:	e057      	b.n	c0d004b0 <processTxInternal+0x164>
c0d00400:	2802      	cmp	r0, #2
c0d00402:	d000      	beq.n	c0d00406 <processTxInternal+0xba>
c0d00404:	e11a      	b.n	c0d0063c <processTxInternal+0x2f0>
c0d00406:	7838      	ldrb	r0, [r7, #0]
c0d00408:	2800      	cmp	r0, #0
c0d0040a:	d000      	beq.n	c0d0040e <processTxInternal+0xc2>
c0d0040c:	e119      	b.n	c0d00642 <processTxInternal+0x2f6>
c0d0040e:	9802      	ldr	r0, [sp, #8]
c0d00410:	6800      	ldr	r0, [r0, #0]
c0d00412:	2821      	cmp	r0, #33	; 0x21
c0d00414:	d300      	bcc.n	c0d00418 <processTxInternal+0xcc>
c0d00416:	e114      	b.n	c0d00642 <processTxInternal+0x2f6>
c0d00418:	68e1      	ldr	r1, [r4, #12]
c0d0041a:	4288      	cmp	r0, r1
c0d0041c:	d90a      	bls.n	c0d00434 <processTxInternal+0xe8>
c0d0041e:	1a40      	subs	r0, r0, r1
c0d00420:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d00422:	4282      	cmp	r2, r0
c0d00424:	d300      	bcc.n	c0d00428 <processTxInternal+0xdc>
c0d00426:	4602      	mov	r2, r0
c0d00428:	2100      	movs	r1, #0
c0d0042a:	4620      	mov	r0, r4
c0d0042c:	f7ff ff26 	bl	c0d0027c <copyTxData>
c0d00430:	68a0      	ldr	r0, [r4, #8]
c0d00432:	68e1      	ldr	r1, [r4, #12]
c0d00434:	4281      	cmp	r1, r0
c0d00436:	d141      	bne.n	c0d004bc <processTxInternal+0x170>
c0d00438:	e03b      	b.n	c0d004b2 <processTxInternal+0x166>
        context->processingField = false;
    }
}

static void processStartGas(txContext_t *context) {
    if (context->currentFieldIsList) {
c0d0043a:	7838      	ldrb	r0, [r7, #0]
c0d0043c:	2800      	cmp	r0, #0
c0d0043e:	d000      	beq.n	c0d00442 <processTxInternal+0xf6>
c0d00440:	e0ff      	b.n	c0d00642 <processTxInternal+0x2f6>
        PRINTF("Invalid type for RLP_STARTGAS\n");
        THROW(EXCEPTION);
    }
    if (context->currentFieldLength > MAX_INT256) {
c0d00442:	9802      	ldr	r0, [sp, #8]
c0d00444:	6800      	ldr	r0, [r0, #0]
c0d00446:	2821      	cmp	r0, #33	; 0x21
c0d00448:	d300      	bcc.n	c0d0044c <processTxInternal+0x100>
c0d0044a:	e0fa      	b.n	c0d00642 <processTxInternal+0x2f6>
        PRINTF("Invalid length for RLP_STARTGAS %d\n",
                      context->currentFieldLength);
        THROW(EXCEPTION);
    }
    if (context->currentFieldPos < context->currentFieldLength) {
c0d0044c:	68e1      	ldr	r1, [r4, #12]
c0d0044e:	4288      	cmp	r0, r1
c0d00450:	d90c      	bls.n	c0d0046c <processTxInternal+0x120>
        uint32_t copySize =
            (context->commandLength <
                     ((context->currentFieldLength - context->currentFieldPos))
c0d00452:	1a40      	subs	r0, r0, r1
                      context->currentFieldLength);
        THROW(EXCEPTION);
    }
    if (context->currentFieldPos < context->currentFieldLength) {
        uint32_t copySize =
            (context->commandLength <
c0d00454:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d00456:	4282      	cmp	r2, r0
c0d00458:	d300      	bcc.n	c0d0045c <processTxInternal+0x110>
c0d0045a:	4602      	mov	r2, r0
                     ((context->currentFieldLength - context->currentFieldPos))
                 ? context->commandLength
                 : context->currentFieldLength - context->currentFieldPos);
        copyTxData(context,
                   context->content->startgas.value + context->currentFieldPos,
c0d0045c:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d0045e:	1841      	adds	r1, r0, r1
c0d00460:	3121      	adds	r1, #33	; 0x21
        uint32_t copySize =
            (context->commandLength <
                     ((context->currentFieldLength - context->currentFieldPos))
                 ? context->commandLength
                 : context->currentFieldLength - context->currentFieldPos);
        copyTxData(context,
c0d00462:	4620      	mov	r0, r4
c0d00464:	f7ff ff0a 	bl	c0d0027c <copyTxData>
c0d00468:	68a0      	ldr	r0, [r4, #8]
c0d0046a:	68e1      	ldr	r1, [r4, #12]
                   context->content->startgas.value + context->currentFieldPos,
                   copySize);
    }
    if (context->currentFieldPos == context->currentFieldLength) {
c0d0046c:	4281      	cmp	r1, r0
c0d0046e:	d125      	bne.n	c0d004bc <processTxInternal+0x170>
        context->content->startgas.length = context->currentFieldLength;
c0d00470:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d00472:	2241      	movs	r2, #65	; 0x41
c0d00474:	e01c      	b.n	c0d004b0 <processTxInternal+0x164>
        context->processingField = false;
    }
}

static void processTo(txContext_t *context) {
    if (context->currentFieldIsList) {
c0d00476:	7838      	ldrb	r0, [r7, #0]
c0d00478:	2800      	cmp	r0, #0
c0d0047a:	d000      	beq.n	c0d0047e <processTxInternal+0x132>
c0d0047c:	e0e1      	b.n	c0d00642 <processTxInternal+0x2f6>
        PRINTF("Invalid type for RLP_TO\n");
        THROW(EXCEPTION);
    }
    if (context->currentFieldLength > MAX_ADDRESS) {
c0d0047e:	9802      	ldr	r0, [sp, #8]
c0d00480:	6800      	ldr	r0, [r0, #0]
c0d00482:	2815      	cmp	r0, #21
c0d00484:	d300      	bcc.n	c0d00488 <processTxInternal+0x13c>
c0d00486:	e0dc      	b.n	c0d00642 <processTxInternal+0x2f6>
        PRINTF("Invalid length for RLP_TO\n");
        THROW(EXCEPTION);
    }
    if (context->currentFieldPos < context->currentFieldLength) {
c0d00488:	68e1      	ldr	r1, [r4, #12]
c0d0048a:	4288      	cmp	r0, r1
c0d0048c:	d90c      	bls.n	c0d004a8 <processTxInternal+0x15c>
        uint32_t copySize =
            (context->commandLength <
                     ((context->currentFieldLength - context->currentFieldPos))
c0d0048e:	1a40      	subs	r0, r0, r1
        PRINTF("Invalid length for RLP_TO\n");
        THROW(EXCEPTION);
    }
    if (context->currentFieldPos < context->currentFieldLength) {
        uint32_t copySize =
            (context->commandLength <
c0d00490:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d00492:	4282      	cmp	r2, r0
c0d00494:	d300      	bcc.n	c0d00498 <processTxInternal+0x14c>
c0d00496:	4602      	mov	r2, r0
                     ((context->currentFieldLength - context->currentFieldPos))
                 ? context->commandLength
                 : context->currentFieldLength - context->currentFieldPos);
        copyTxData(context,
                   context->content->destination + context->currentFieldPos,
c0d00498:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d0049a:	1841      	adds	r1, r0, r1
c0d0049c:	3163      	adds	r1, #99	; 0x63
        uint32_t copySize =
            (context->commandLength <
                     ((context->currentFieldLength - context->currentFieldPos))
                 ? context->commandLength
                 : context->currentFieldLength - context->currentFieldPos);
        copyTxData(context,
c0d0049e:	4620      	mov	r0, r4
c0d004a0:	f7ff feec 	bl	c0d0027c <copyTxData>
c0d004a4:	68a0      	ldr	r0, [r4, #8]
c0d004a6:	68e1      	ldr	r1, [r4, #12]
                   context->content->destination + context->currentFieldPos,
                   copySize);
    }
    if (context->currentFieldPos == context->currentFieldLength) {
c0d004a8:	4281      	cmp	r1, r0
c0d004aa:	d107      	bne.n	c0d004bc <processTxInternal+0x170>
        context->content->destinationLength = context->currentFieldLength;
c0d004ac:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d004ae:	2277      	movs	r2, #119	; 0x77
c0d004b0:	5488      	strb	r0, [r1, r2]
c0d004b2:	7820      	ldrb	r0, [r4, #0]
c0d004b4:	1c40      	adds	r0, r0, #1
c0d004b6:	7020      	strb	r0, [r4, #0]
c0d004b8:	2000      	movs	r0, #0
c0d004ba:	7460      	strb	r0, [r4, #17]

static parserStatus_e processTxInternal(txContext_t *context) {
    for (;;) {
        customStatus_e customStatus = CUSTOM_NOT_HANDLED;
        // EIP 155 style transasction
        if (context->currentField == TX_RLP_DONE) {
c0d004bc:	7820      	ldrb	r0, [r4, #0]
c0d004be:	e001      	b.n	c0d004c4 <processTxInternal+0x178>
c0d004c0:	2003      	movs	r0, #3
        if (customStatus == CUSTOM_NOT_HANDLED) {
            switch (context->currentField) {
            case TX_RLP_CONTENT:
                processContent(context);
                if ((context->processingFlags & TX_FLAG_TYPE) == 0) {
                    context->currentField++;
c0d004c2:	7020      	strb	r0, [r4, #0]
c0d004c4:	b2c0      	uxtb	r0, r0
c0d004c6:	2102      	movs	r1, #2

static parserStatus_e processTxInternal(txContext_t *context) {
    for (;;) {
        customStatus_e customStatus = CUSTOM_NOT_HANDLED;
        // EIP 155 style transasction
        if (context->currentField == TX_RLP_DONE) {
c0d004c8:	2809      	cmp	r0, #9
c0d004ca:	d007      	beq.n	c0d004dc <processTxInternal+0x190>
c0d004cc:	280c      	cmp	r0, #12
c0d004ce:	d100      	bne.n	c0d004d2 <processTxInternal+0x186>
c0d004d0:	e0b4      	b.n	c0d0063c <processTxInternal+0x2f0>
c0d004d2:	6aa0      	ldr	r0, [r4, #40]	; 0x28
c0d004d4:	2100      	movs	r1, #0
        // Old style transaction
        if ((context->currentField == TX_RLP_V) && (context->commandLength == 0)) {
            context->content->vLength = 0;
            return USTREAM_FINISHED;
        }
        if (context->commandLength == 0) {
c0d004d6:	2800      	cmp	r0, #0
c0d004d8:	d104      	bne.n	c0d004e4 <processTxInternal+0x198>
c0d004da:	e0af      	b.n	c0d0063c <processTxInternal+0x2f0>
        // EIP 155 style transasction
        if (context->currentField == TX_RLP_DONE) {
            return USTREAM_FINISHED;
        }
        // Old style transaction
        if ((context->currentField == TX_RLP_V) && (context->commandLength == 0)) {
c0d004dc:	6aa0      	ldr	r0, [r4, #40]	; 0x28
c0d004de:	2800      	cmp	r0, #0
c0d004e0:	d100      	bne.n	c0d004e4 <processTxInternal+0x198>
c0d004e2:	e0a7      	b.n	c0d00634 <processTxInternal+0x2e8>
            return USTREAM_FINISHED;
        }
        if (context->commandLength == 0) {
            return USTREAM_PROCESSING;
        }
        if (!context->processingField) {
c0d004e4:	7c61      	ldrb	r1, [r4, #17]
c0d004e6:	2900      	cmp	r1, #0
c0d004e8:	d154      	bne.n	c0d00594 <processTxInternal+0x248>
c0d004ea:	2100      	movs	r1, #0
            bool canDecode = false;
            uint32_t offset;
            while (context->commandLength != 0) {
c0d004ec:	2800      	cmp	r0, #0
c0d004ee:	d100      	bne.n	c0d004f2 <processTxInternal+0x1a6>
c0d004f0:	e0a4      	b.n	c0d0063c <processTxInternal+0x2f0>
c0d004f2:	2500      	movs	r5, #0
                bool valid;
                // Feed the RLP buffer until the length can be decoded
                context->rlpBuffer[context->rlpBufferPos++] =
                    readTxByte(context);
c0d004f4:	4620      	mov	r0, r4
c0d004f6:	f7ff fe9b 	bl	c0d00230 <readTxByte>
            bool canDecode = false;
            uint32_t offset;
            while (context->commandLength != 0) {
                bool valid;
                // Feed the RLP buffer until the length can be decoded
                context->rlpBuffer[context->rlpBufferPos++] =
c0d004fa:	6a21      	ldr	r1, [r4, #32]
c0d004fc:	1c4a      	adds	r2, r1, #1
c0d004fe:	6222      	str	r2, [r4, #32]
c0d00500:	1861      	adds	r1, r4, r1
c0d00502:	7608      	strb	r0, [r1, #24]
                    readTxByte(context);
                if (rlpCanDecode(context->rlpBuffer, context->rlpBufferPos,
c0d00504:	6a21      	ldr	r1, [r4, #32]
c0d00506:	aa03      	add	r2, sp, #12
c0d00508:	4630      	mov	r0, r6
c0d0050a:	f000 f8c9 	bl	c0d006a0 <rlpCanDecode>
c0d0050e:	2801      	cmp	r0, #1
c0d00510:	d10c      	bne.n	c0d0052c <processTxInternal+0x1e0>
c0d00512:	a803      	add	r0, sp, #12
                                 &valid)) {
                    // Can decode now, if valid
                    if (!valid) {
c0d00514:	7802      	ldrb	r2, [r0, #0]
                        PRINTF("RLP pre-decode error\n");
                        return USTREAM_FAULT;
c0d00516:	2101      	movs	r1, #1
c0d00518:	2305      	movs	r3, #5
c0d0051a:	2a00      	cmp	r2, #0
c0d0051c:	4608      	mov	r0, r1
c0d0051e:	d000      	beq.n	c0d00522 <processTxInternal+0x1d6>
c0d00520:	4618      	mov	r0, r3
c0d00522:	2a00      	cmp	r2, #0
c0d00524:	d100      	bne.n	c0d00528 <processTxInternal+0x1dc>
c0d00526:	4611      	mov	r1, r2
c0d00528:	430d      	orrs	r5, r1
c0d0052a:	e005      	b.n	c0d00538 <processTxInternal+0x1ec>
                    canDecode = true;
                    break;
                }
                // Cannot decode yet
                // Sanity check
                if (context->rlpBufferPos == sizeof(context->rlpBuffer)) {
c0d0052c:	6a22      	ldr	r2, [r4, #32]
c0d0052e:	2001      	movs	r0, #1
c0d00530:	2100      	movs	r1, #0
c0d00532:	2a05      	cmp	r2, #5
c0d00534:	d000      	beq.n	c0d00538 <processTxInternal+0x1ec>
c0d00536:	4608      	mov	r0, r1
c0d00538:	2107      	movs	r1, #7
c0d0053a:	4001      	ands	r1, r0
c0d0053c:	2900      	cmp	r1, #0
c0d0053e:	d103      	bne.n	c0d00548 <processTxInternal+0x1fc>
c0d00540:	6aa0      	ldr	r0, [r4, #40]	; 0x28
            return USTREAM_PROCESSING;
        }
        if (!context->processingField) {
            bool canDecode = false;
            uint32_t offset;
            while (context->commandLength != 0) {
c0d00542:	2800      	cmp	r0, #0
c0d00544:	d1d6      	bne.n	c0d004f4 <processTxInternal+0x1a8>
c0d00546:	e001      	b.n	c0d0054c <processTxInternal+0x200>
c0d00548:	2905      	cmp	r1, #5
c0d0054a:	d120      	bne.n	c0d0058e <processTxInternal+0x242>
                if (context->rlpBufferPos == sizeof(context->rlpBuffer)) {
                    PRINTF("RLP pre-decode logic error\n");
                    return USTREAM_FAULT;
                }
            }
            if (!canDecode) {
c0d0054c:	07e8      	lsls	r0, r5, #31
c0d0054e:	2100      	movs	r1, #0
c0d00550:	2800      	cmp	r0, #0
c0d00552:	d073      	beq.n	c0d0063c <processTxInternal+0x2f0>
                return USTREAM_PROCESSING;
            }
            // Ready to process this field
            if (!rlpDecodeLength(context->rlpBuffer, context->rlpBufferPos,
c0d00554:	6a21      	ldr	r1, [r4, #32]
c0d00556:	4668      	mov	r0, sp
c0d00558:	6007      	str	r7, [r0, #0]
c0d0055a:	ab04      	add	r3, sp, #16
c0d0055c:	4630      	mov	r0, r6
c0d0055e:	9a02      	ldr	r2, [sp, #8]
c0d00560:	f000 f8cd 	bl	c0d006fe <rlpDecodeLength>
c0d00564:	2103      	movs	r1, #3
c0d00566:	2801      	cmp	r0, #1
c0d00568:	d168      	bne.n	c0d0063c <processTxInternal+0x2f0>
c0d0056a:	2000      	movs	r0, #0
                                 &context->currentFieldLength, &offset,
                                 &context->currentFieldIsList)) {
                PRINTF("RLP decode error\n");
                return USTREAM_FAULT;
            }
            if (offset == 0) {
c0d0056c:	9904      	ldr	r1, [sp, #16]
c0d0056e:	2900      	cmp	r1, #0
c0d00570:	4601      	mov	r1, r0
c0d00572:	d106      	bne.n	c0d00582 <processTxInternal+0x236>
                // Hack for single byte, self encoded
                context->workBuffer--;
c0d00574:	6a61      	ldr	r1, [r4, #36]	; 0x24
c0d00576:	1e49      	subs	r1, r1, #1
c0d00578:	6261      	str	r1, [r4, #36]	; 0x24
                context->commandLength++;
c0d0057a:	6aa1      	ldr	r1, [r4, #40]	; 0x28
c0d0057c:	1c49      	adds	r1, r1, #1
c0d0057e:	62a1      	str	r1, [r4, #40]	; 0x28
c0d00580:	2101      	movs	r1, #1
c0d00582:	74a1      	strb	r1, [r4, #18]
                context->fieldSingleByte = true;
            } else {
                context->fieldSingleByte = false;
            }
            context->currentFieldPos = 0;
c0d00584:	60e0      	str	r0, [r4, #12]
            context->rlpBufferPos = 0;
c0d00586:	6220      	str	r0, [r4, #32]
            context->processingField = true;
c0d00588:	2001      	movs	r0, #1
c0d0058a:	7460      	strb	r0, [r4, #17]
c0d0058c:	e002      	b.n	c0d00594 <processTxInternal+0x248>
c0d0058e:	2103      	movs	r1, #3
c0d00590:	2800      	cmp	r0, #0
c0d00592:	d153      	bne.n	c0d0063c <processTxInternal+0x2f0>
        }
        if (context->customProcessor != NULL) {
c0d00594:	6b21      	ldr	r1, [r4, #48]	; 0x30
c0d00596:	2900      	cmp	r1, #0
c0d00598:	d004      	beq.n	c0d005a4 <processTxInternal+0x258>
            customStatus = context->customProcessor(context);
c0d0059a:	4620      	mov	r0, r4
c0d0059c:	4788      	blx	r1
c0d0059e:	2101      	movs	r1, #1
            switch(customStatus) {
c0d005a0:	2800      	cmp	r0, #0
c0d005a2:	d140      	bne.n	c0d00626 <processTxInternal+0x2da>
c0d005a4:	7820      	ldrb	r0, [r4, #0]
c0d005a6:	2103      	movs	r1, #3
                    PRINTF("Unhandled custom processor status\n");
                    return USTREAM_FAULT;
            }
        }
        if (customStatus == CUSTOM_NOT_HANDLED) {
            switch (context->currentField) {
c0d005a8:	2802      	cmp	r0, #2
c0d005aa:	dc11      	bgt.n	c0d005d0 <processTxInternal+0x284>
c0d005ac:	2801      	cmp	r0, #1
c0d005ae:	d000      	beq.n	c0d005b2 <processTxInternal+0x266>
c0d005b0:	e726      	b.n	c0d00400 <processTxInternal+0xb4>
    }
}

static void processContent(txContext_t *context) {
    // Keep the full length for sanity checks, move to the next field
    if (!context->currentFieldIsList) {
c0d005b2:	7838      	ldrb	r0, [r7, #0]
c0d005b4:	2800      	cmp	r0, #0
c0d005b6:	d044      	beq.n	c0d00642 <processTxInternal+0x2f6>
        PRINTF("Invalid type for RLP_CONTENT\n");
        THROW(EXCEPTION);
    }
    context->dataLength = context->currentFieldLength;
c0d005b8:	68a0      	ldr	r0, [r4, #8]
c0d005ba:	6160      	str	r0, [r4, #20]
    context->currentField++;
c0d005bc:	2002      	movs	r0, #2
c0d005be:	7020      	strb	r0, [r4, #0]
c0d005c0:	2000      	movs	r0, #0
    context->processingField = false;
c0d005c2:	7460      	strb	r0, [r4, #17]
        }
        if (customStatus == CUSTOM_NOT_HANDLED) {
            switch (context->currentField) {
            case TX_RLP_CONTENT:
                processContent(context);
                if ((context->processingFlags & TX_FLAG_TYPE) == 0) {
c0d005c4:	202c      	movs	r0, #44	; 0x2c
c0d005c6:	5c20      	ldrb	r0, [r4, r0]
c0d005c8:	07c0      	lsls	r0, r0, #31
c0d005ca:	d100      	bne.n	c0d005ce <processTxInternal+0x282>
c0d005cc:	e778      	b.n	c0d004c0 <processTxInternal+0x174>
c0d005ce:	e775      	b.n	c0d004bc <processTxInternal+0x170>
c0d005d0:	2807      	cmp	r0, #7
c0d005d2:	dd00      	ble.n	c0d005d6 <processTxInternal+0x28a>
c0d005d4:	e6c4      	b.n	c0d00360 <processTxInternal+0x14>
c0d005d6:	2804      	cmp	r0, #4
c0d005d8:	dc00      	bgt.n	c0d005dc <processTxInternal+0x290>
c0d005da:	e6ef      	b.n	c0d003bc <processTxInternal+0x70>
c0d005dc:	2805      	cmp	r0, #5
c0d005de:	d100      	bne.n	c0d005e2 <processTxInternal+0x296>
c0d005e0:	e72b      	b.n	c0d0043a <processTxInternal+0xee>
c0d005e2:	2806      	cmp	r0, #6
c0d005e4:	d100      	bne.n	c0d005e8 <processTxInternal+0x29c>
c0d005e6:	e746      	b.n	c0d00476 <processTxInternal+0x12a>
c0d005e8:	2807      	cmp	r0, #7
c0d005ea:	d127      	bne.n	c0d0063c <processTxInternal+0x2f0>
        context->processingField = false;
    }
}

static void processValue(txContext_t *context) {
    if (context->currentFieldIsList) {
c0d005ec:	7838      	ldrb	r0, [r7, #0]
c0d005ee:	2800      	cmp	r0, #0
c0d005f0:	d127      	bne.n	c0d00642 <processTxInternal+0x2f6>
        PRINTF("Invalid type for RLP_VALUE\n");
        THROW(EXCEPTION);
    }
    if (context->currentFieldLength > MAX_INT256) {
c0d005f2:	9802      	ldr	r0, [sp, #8]
c0d005f4:	6800      	ldr	r0, [r0, #0]
c0d005f6:	2821      	cmp	r0, #33	; 0x21
c0d005f8:	d223      	bcs.n	c0d00642 <processTxInternal+0x2f6>
        PRINTF("Invalid length for RLP_VALUE\n");
        THROW(EXCEPTION);
    }
    if (context->currentFieldPos < context->currentFieldLength) {
c0d005fa:	68e1      	ldr	r1, [r4, #12]
c0d005fc:	4288      	cmp	r0, r1
c0d005fe:	d90c      	bls.n	c0d0061a <processTxInternal+0x2ce>
        uint32_t copySize =
            (context->commandLength <
                     ((context->currentFieldLength - context->currentFieldPos))
c0d00600:	1a40      	subs	r0, r0, r1
        PRINTF("Invalid length for RLP_VALUE\n");
        THROW(EXCEPTION);
    }
    if (context->currentFieldPos < context->currentFieldLength) {
        uint32_t copySize =
            (context->commandLength <
c0d00602:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d00604:	4282      	cmp	r2, r0
c0d00606:	d300      	bcc.n	c0d0060a <processTxInternal+0x2be>
c0d00608:	4602      	mov	r2, r0
                     ((context->currentFieldLength - context->currentFieldPos))
                 ? context->commandLength
                 : context->currentFieldLength - context->currentFieldPos);
        copyTxData(context,
                   context->content->value.value + context->currentFieldPos,
c0d0060a:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d0060c:	1841      	adds	r1, r0, r1
c0d0060e:	3142      	adds	r1, #66	; 0x42
        uint32_t copySize =
            (context->commandLength <
                     ((context->currentFieldLength - context->currentFieldPos))
                 ? context->commandLength
                 : context->currentFieldLength - context->currentFieldPos);
        copyTxData(context,
c0d00610:	4620      	mov	r0, r4
c0d00612:	f7ff fe33 	bl	c0d0027c <copyTxData>
c0d00616:	68a0      	ldr	r0, [r4, #8]
c0d00618:	68e1      	ldr	r1, [r4, #12]
                   context->content->value.value + context->currentFieldPos,
                   copySize);
    }
    if (context->currentFieldPos == context->currentFieldLength) {
c0d0061a:	4281      	cmp	r1, r0
c0d0061c:	d000      	beq.n	c0d00620 <processTxInternal+0x2d4>
c0d0061e:	e74d      	b.n	c0d004bc <processTxInternal+0x170>
        context->content->value.length = context->currentFieldLength;
c0d00620:	6b61      	ldr	r1, [r4, #52]	; 0x34
c0d00622:	2262      	movs	r2, #98	; 0x62
c0d00624:	e744      	b.n	c0d004b0 <processTxInternal+0x164>
c0d00626:	2801      	cmp	r0, #1
c0d00628:	d100      	bne.n	c0d0062c <processTxInternal+0x2e0>
c0d0062a:	e747      	b.n	c0d004bc <processTxInternal+0x170>
c0d0062c:	2802      	cmp	r0, #2
c0d0062e:	d005      	beq.n	c0d0063c <processTxInternal+0x2f0>
c0d00630:	2103      	movs	r1, #3
c0d00632:	e003      	b.n	c0d0063c <processTxInternal+0x2f0>
        if (context->currentField == TX_RLP_DONE) {
            return USTREAM_FINISHED;
        }
        // Old style transaction
        if ((context->currentField == TX_RLP_V) && (context->commandLength == 0)) {
            context->content->vLength = 0;
c0d00634:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d00636:	227c      	movs	r2, #124	; 0x7c
c0d00638:	2300      	movs	r3, #0
c0d0063a:	5483      	strb	r3, [r0, r2]
                PRINTF("Invalid RLP decoder context\n");
                return USTREAM_FAULT;
            }
        }
    }
}
c0d0063c:	b2c8      	uxtb	r0, r1
c0d0063e:	b005      	add	sp, #20
c0d00640:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d00642:	2001      	movs	r0, #1
c0d00644:	f002 faa9 	bl	c0d02b9a <os_longjmp>

c0d00648 <continueTx>:
    }
    END_TRY;
    return result;
}

parserStatus_e continueTx(txContext_t *context) {
c0d00648:	b5b0      	push	{r4, r5, r7, lr}
c0d0064a:	b08c      	sub	sp, #48	; 0x30
c0d0064c:	4604      	mov	r4, r0
c0d0064e:	ad01      	add	r5, sp, #4
    parserStatus_e result;
    BEGIN_TRY {
        TRY {
c0d00650:	4628      	mov	r0, r5
c0d00652:	f006 fcb3 	bl	c0d06fbc <setjmp>
c0d00656:	8528      	strh	r0, [r5, #40]	; 0x28
c0d00658:	4910      	ldr	r1, [pc, #64]	; (c0d0069c <continueTx+0x54>)
c0d0065a:	4208      	tst	r0, r1
c0d0065c:	d004      	beq.n	c0d00668 <continueTx+0x20>
c0d0065e:	a801      	add	r0, sp, #4
            result = processTxInternal(context);
        }
        CATCH_OTHER(e) {
c0d00660:	2100      	movs	r1, #0
c0d00662:	8501      	strh	r1, [r0, #40]	; 0x28
c0d00664:	2403      	movs	r4, #3
c0d00666:	e006      	b.n	c0d00676 <continueTx+0x2e>
c0d00668:	a801      	add	r0, sp, #4
}

parserStatus_e continueTx(txContext_t *context) {
    parserStatus_e result;
    BEGIN_TRY {
        TRY {
c0d0066a:	f002 f92e 	bl	c0d028ca <try_context_set>
            result = processTxInternal(context);
c0d0066e:	4620      	mov	r0, r4
c0d00670:	f7ff fe6c 	bl	c0d0034c <processTxInternal>
c0d00674:	4604      	mov	r4, r0
        }
        CATCH_OTHER(e) {
            result = USTREAM_FAULT;
        }
        FINALLY {
c0d00676:	f002 fa95 	bl	c0d02ba4 <try_context_get>
c0d0067a:	a901      	add	r1, sp, #4
c0d0067c:	4288      	cmp	r0, r1
c0d0067e:	d103      	bne.n	c0d00688 <continueTx+0x40>
c0d00680:	f002 fa92 	bl	c0d02ba8 <try_context_get_previous>
c0d00684:	f002 f921 	bl	c0d028ca <try_context_set>
c0d00688:	a801      	add	r0, sp, #4
        }
    }
    END_TRY;
c0d0068a:	8d00      	ldrh	r0, [r0, #40]	; 0x28
c0d0068c:	2800      	cmp	r0, #0
c0d0068e:	d102      	bne.n	c0d00696 <continueTx+0x4e>
    return result;
c0d00690:	4620      	mov	r0, r4
c0d00692:	b00c      	add	sp, #48	; 0x30
c0d00694:	bdb0      	pop	{r4, r5, r7, pc}
            result = USTREAM_FAULT;
        }
        FINALLY {
        }
    }
    END_TRY;
c0d00696:	f002 fa80 	bl	c0d02b9a <os_longjmp>
c0d0069a:	46c0      	nop			; (mov r8, r8)
c0d0069c:	0000ffff 	.word	0x0000ffff

c0d006a0 <rlpCanDecode>:
#include "ethUtils.h"
#include "chainConfig.h"

extern chain_config_t *chainConfig;

bool rlpCanDecode(uint8_t *buffer, uint32_t bufferLength, bool *valid) {
c0d006a0:	b570      	push	{r4, r5, r6, lr}
    if (*buffer <= 0x7f) {
c0d006a2:	7800      	ldrb	r0, [r0, #0]
c0d006a4:	b240      	sxtb	r0, r0
c0d006a6:	2347      	movs	r3, #71	; 0x47
c0d006a8:	43db      	mvns	r3, r3
c0d006aa:	3347      	adds	r3, #71	; 0x47
c0d006ac:	b25d      	sxtb	r5, r3
c0d006ae:	2301      	movs	r3, #1
c0d006b0:	24b8      	movs	r4, #184	; 0xb8
c0d006b2:	42a8      	cmp	r0, r5
c0d006b4:	dc1f      	bgt.n	c0d006f6 <rlpCanDecode+0x56>
c0d006b6:	b2c5      	uxtb	r5, r0
c0d006b8:	42a5      	cmp	r5, r4
c0d006ba:	d31c      	bcc.n	c0d006f6 <rlpCanDecode+0x56>
    } else if (*buffer <= 0xb7) {
    } else if (*buffer <= 0xbf) {
c0d006bc:	4620      	mov	r0, r4
c0d006be:	3008      	adds	r0, #8
c0d006c0:	b2c0      	uxtb	r0, r0
c0d006c2:	4285      	cmp	r5, r0
c0d006c4:	d207      	bcs.n	c0d006d6 <rlpCanDecode+0x36>
        if (bufferLength < (1 + (*buffer - 0xb7))) {
c0d006c6:	462e      	mov	r6, r5
c0d006c8:	3eb6      	subs	r6, #182	; 0xb6
c0d006ca:	2000      	movs	r0, #0
c0d006cc:	428e      	cmp	r6, r1
c0d006ce:	d815      	bhi.n	c0d006fc <rlpCanDecode+0x5c>
            return false;
        }
        if (*buffer > 0xbb) {
c0d006d0:	1ce0      	adds	r0, r4, #3
c0d006d2:	b2c0      	uxtb	r0, r0
c0d006d4:	e00b      	b.n	c0d006ee <rlpCanDecode+0x4e>
            *valid = false; // arbitrary 32 bits length limitation
            return true;
        }
    } else if (*buffer <= 0xf7) {
c0d006d6:	4620      	mov	r0, r4
c0d006d8:	3040      	adds	r0, #64	; 0x40
c0d006da:	b2c0      	uxtb	r0, r0
c0d006dc:	4285      	cmp	r5, r0
c0d006de:	d30a      	bcc.n	c0d006f6 <rlpCanDecode+0x56>
    } else {
        if (bufferLength < (1 + (*buffer - 0xf7))) {
c0d006e0:	462e      	mov	r6, r5
c0d006e2:	3ef6      	subs	r6, #246	; 0xf6
c0d006e4:	2000      	movs	r0, #0
c0d006e6:	428e      	cmp	r6, r1
c0d006e8:	d808      	bhi.n	c0d006fc <rlpCanDecode+0x5c>
            return false;
        }
        if (*buffer > 0xfb) {
c0d006ea:	3443      	adds	r4, #67	; 0x43
c0d006ec:	b2e0      	uxtb	r0, r4
c0d006ee:	4285      	cmp	r5, r0
c0d006f0:	d901      	bls.n	c0d006f6 <rlpCanDecode+0x56>
c0d006f2:	2000      	movs	r0, #0
c0d006f4:	e000      	b.n	c0d006f8 <rlpCanDecode+0x58>
            *valid = false; // arbitrary 32 bits length limitation
            return true;
        }
    }
    *valid = true;
c0d006f6:	2001      	movs	r0, #1
c0d006f8:	7010      	strb	r0, [r2, #0]
c0d006fa:	4618      	mov	r0, r3
    return true;
}
c0d006fc:	bd70      	pop	{r4, r5, r6, pc}

c0d006fe <rlpDecodeLength>:

bool rlpDecodeLength(uint8_t *buffer, uint32_t bufferLength,
                     uint32_t *fieldLength, uint32_t *offset, bool *list) {
c0d006fe:	b5f0      	push	{r4, r5, r6, r7, lr}
    if (*buffer <= 0x7f) {
c0d00700:	7801      	ldrb	r1, [r0, #0]
c0d00702:	b249      	sxtb	r1, r1
c0d00704:	2447      	movs	r4, #71	; 0x47
c0d00706:	43e4      	mvns	r4, r4
c0d00708:	3447      	adds	r4, #71	; 0x47
c0d0070a:	b267      	sxtb	r7, r4
c0d0070c:	2401      	movs	r4, #1
c0d0070e:	26b8      	movs	r6, #184	; 0xb8
c0d00710:	9d05      	ldr	r5, [sp, #20]
c0d00712:	42b9      	cmp	r1, r7
c0d00714:	dd04      	ble.n	c0d00720 <rlpDecodeLength+0x22>
c0d00716:	2000      	movs	r0, #0
        *offset = 0;
c0d00718:	6018      	str	r0, [r3, #0]
        *fieldLength = 1;
c0d0071a:	2101      	movs	r1, #1
c0d0071c:	6011      	str	r1, [r2, #0]
c0d0071e:	e008      	b.n	c0d00732 <rlpDecodeLength+0x34>
    return true;
}

bool rlpDecodeLength(uint8_t *buffer, uint32_t bufferLength,
                     uint32_t *fieldLength, uint32_t *offset, bool *list) {
    if (*buffer <= 0x7f) {
c0d00720:	b2c9      	uxtb	r1, r1
        *offset = 0;
        *fieldLength = 1;
        *list = false;
    } else if (*buffer <= 0xb7) {
c0d00722:	42b1      	cmp	r1, r6
c0d00724:	d209      	bcs.n	c0d0073a <rlpDecodeLength+0x3c>
        *offset = 1;
c0d00726:	2101      	movs	r1, #1
c0d00728:	6019      	str	r1, [r3, #0]
        *fieldLength = *buffer - 0x80;
c0d0072a:	7800      	ldrb	r0, [r0, #0]
c0d0072c:	3880      	subs	r0, #128	; 0x80
c0d0072e:	6010      	str	r0, [r2, #0]
        *list = false;
c0d00730:	2000      	movs	r0, #0
c0d00732:	7028      	strb	r0, [r5, #0]
c0d00734:	4621      	mov	r1, r4
            return false; // arbitrary 32 bits length limitation
        }
    }

    return true;
}
c0d00736:	4608      	mov	r0, r1
c0d00738:	bdf0      	pop	{r4, r5, r6, r7, pc}
        *list = false;
    } else if (*buffer <= 0xb7) {
        *offset = 1;
        *fieldLength = *buffer - 0x80;
        *list = false;
    } else if (*buffer <= 0xbf) {
c0d0073a:	4637      	mov	r7, r6
c0d0073c:	3708      	adds	r7, #8
c0d0073e:	b2ff      	uxtb	r7, r7
c0d00740:	42b9      	cmp	r1, r7
c0d00742:	d20b      	bcs.n	c0d0075c <rlpDecodeLength+0x5e>
        *offset = 1 + (*buffer - 0xb7);
c0d00744:	39b6      	subs	r1, #182	; 0xb6
c0d00746:	6019      	str	r1, [r3, #0]
c0d00748:	2100      	movs	r1, #0
        *list = false;
c0d0074a:	7029      	strb	r1, [r5, #0]
c0d0074c:	7803      	ldrb	r3, [r0, #0]
        switch (*buffer) {
c0d0074e:	2bb9      	cmp	r3, #185	; 0xb9
c0d00750:	dc0f      	bgt.n	c0d00772 <rlpDecodeLength+0x74>
c0d00752:	2bb8      	cmp	r3, #184	; 0xb8
c0d00754:	d022      	beq.n	c0d0079c <rlpDecodeLength+0x9e>
c0d00756:	2bb9      	cmp	r3, #185	; 0xb9
c0d00758:	d01c      	beq.n	c0d00794 <rlpDecodeLength+0x96>
c0d0075a:	e7ec      	b.n	c0d00736 <rlpDecodeLength+0x38>
                           (*(buffer + 3) << 8) + *(buffer + 4);
            break;
        default:
            return false; // arbitrary 32 bits length limitation
        }
    } else if (*buffer <= 0xf7) {
c0d0075c:	3640      	adds	r6, #64	; 0x40
c0d0075e:	b2f6      	uxtb	r6, r6
c0d00760:	42b1      	cmp	r1, r6
c0d00762:	d20b      	bcs.n	c0d0077c <rlpDecodeLength+0x7e>
c0d00764:	2101      	movs	r1, #1
        *offset = 1;
c0d00766:	6019      	str	r1, [r3, #0]
        *fieldLength = *buffer - 0xc0;
c0d00768:	7800      	ldrb	r0, [r0, #0]
c0d0076a:	38c0      	subs	r0, #192	; 0xc0
c0d0076c:	6010      	str	r0, [r2, #0]
        *list = true;
c0d0076e:	7029      	strb	r1, [r5, #0]
c0d00770:	e7e0      	b.n	c0d00734 <rlpDecodeLength+0x36>
c0d00772:	2bba      	cmp	r3, #186	; 0xba
c0d00774:	d023      	beq.n	c0d007be <rlpDecodeLength+0xc0>
c0d00776:	2bbb      	cmp	r3, #187	; 0xbb
c0d00778:	d016      	beq.n	c0d007a8 <rlpDecodeLength+0xaa>
c0d0077a:	e7dc      	b.n	c0d00736 <rlpDecodeLength+0x38>
    } else {
        *offset = 1 + (*buffer - 0xf7);
c0d0077c:	39f6      	subs	r1, #246	; 0xf6
c0d0077e:	6019      	str	r1, [r3, #0]
        *list = true;
c0d00780:	2101      	movs	r1, #1
c0d00782:	7029      	strb	r1, [r5, #0]
c0d00784:	7803      	ldrb	r3, [r0, #0]
c0d00786:	2100      	movs	r1, #0
        switch (*buffer) {
c0d00788:	2bf9      	cmp	r3, #249	; 0xf9
c0d0078a:	dc09      	bgt.n	c0d007a0 <rlpDecodeLength+0xa2>
c0d0078c:	2bf8      	cmp	r3, #248	; 0xf8
c0d0078e:	d005      	beq.n	c0d0079c <rlpDecodeLength+0x9e>
c0d00790:	2bf9      	cmp	r3, #249	; 0xf9
c0d00792:	d1d0      	bne.n	c0d00736 <rlpDecodeLength+0x38>
c0d00794:	7881      	ldrb	r1, [r0, #2]
c0d00796:	7840      	ldrb	r0, [r0, #1]
c0d00798:	0200      	lsls	r0, r0, #8
c0d0079a:	e00e      	b.n	c0d007ba <rlpDecodeLength+0xbc>
c0d0079c:	7840      	ldrb	r0, [r0, #1]
c0d0079e:	e015      	b.n	c0d007cc <rlpDecodeLength+0xce>
c0d007a0:	2bfa      	cmp	r3, #250	; 0xfa
c0d007a2:	d00c      	beq.n	c0d007be <rlpDecodeLength+0xc0>
c0d007a4:	2bfb      	cmp	r3, #251	; 0xfb
c0d007a6:	d1c6      	bne.n	c0d00736 <rlpDecodeLength+0x38>
c0d007a8:	7841      	ldrb	r1, [r0, #1]
c0d007aa:	0609      	lsls	r1, r1, #24
c0d007ac:	7883      	ldrb	r3, [r0, #2]
c0d007ae:	041b      	lsls	r3, r3, #16
c0d007b0:	430b      	orrs	r3, r1
c0d007b2:	78c1      	ldrb	r1, [r0, #3]
c0d007b4:	0209      	lsls	r1, r1, #8
c0d007b6:	4319      	orrs	r1, r3
c0d007b8:	7900      	ldrb	r0, [r0, #4]
c0d007ba:	4308      	orrs	r0, r1
c0d007bc:	e006      	b.n	c0d007cc <rlpDecodeLength+0xce>
c0d007be:	7841      	ldrb	r1, [r0, #1]
c0d007c0:	0409      	lsls	r1, r1, #16
c0d007c2:	7883      	ldrb	r3, [r0, #2]
c0d007c4:	021b      	lsls	r3, r3, #8
c0d007c6:	430b      	orrs	r3, r1
c0d007c8:	78c0      	ldrb	r0, [r0, #3]
c0d007ca:	4318      	orrs	r0, r3
c0d007cc:	6010      	str	r0, [r2, #0]
c0d007ce:	e7b1      	b.n	c0d00734 <rlpDecodeLength+0x36>

c0d007d0 <getEthAddressStringFromKey>:
#else

static const uint8_t const HEXDIGITS[] = "0123456789abcdef";

void getEthAddressStringFromKey(cx_ecfp_public_key_t *publicKey, uint8_t *out,
                                cx_sha3_t *sha3Context) {
c0d007d0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d007d2:	b08b      	sub	sp, #44	; 0x2c
c0d007d4:	4614      	mov	r4, r2
c0d007d6:	9102      	str	r1, [sp, #8]
c0d007d8:	4606      	mov	r6, r0
    uint8_t hashAddress[32];
    cx_keccak_init(sha3Context, 256);
    cx_hash((cx_hash_t*)sha3Context, CX_LAST, publicKey->W + 1, 64, hashAddress);
c0d007da:	2701      	movs	r7, #1
static const uint8_t const HEXDIGITS[] = "0123456789abcdef";

void getEthAddressStringFromKey(cx_ecfp_public_key_t *publicKey, uint8_t *out,
                                cx_sha3_t *sha3Context) {
    uint8_t hashAddress[32];
    cx_keccak_init(sha3Context, 256);
c0d007dc:	0239      	lsls	r1, r7, #8
c0d007de:	4620      	mov	r0, r4
c0d007e0:	f003 fb3a 	bl	c0d03e58 <cx_keccak_init>
c0d007e4:	ad03      	add	r5, sp, #12
    cx_hash((cx_hash_t*)sha3Context, CX_LAST, publicKey->W + 1, 64, hashAddress);
c0d007e6:	4668      	mov	r0, sp
c0d007e8:	6005      	str	r5, [r0, #0]
c0d007ea:	3609      	adds	r6, #9
c0d007ec:	2340      	movs	r3, #64	; 0x40
c0d007ee:	4620      	mov	r0, r4
c0d007f0:	4639      	mov	r1, r7
c0d007f2:	4632      	mov	r2, r6
c0d007f4:	f7ff fc7a 	bl	c0d000ec <cx_hash_X>
    getEthAddressStringFromBinary(hashAddress + 12, out, sha3Context);
c0d007f8:	350c      	adds	r5, #12
c0d007fa:	4628      	mov	r0, r5
c0d007fc:	9902      	ldr	r1, [sp, #8]
c0d007fe:	4622      	mov	r2, r4
c0d00800:	f000 f802 	bl	c0d00808 <getEthAddressStringFromBinary>
}
c0d00804:	b00b      	add	sp, #44	; 0x2c
c0d00806:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d00808 <getEthAddressStringFromBinary>:

void getEthAddressStringFromBinary(uint8_t *address, uint8_t *out,
                                   cx_sha3_t *sha3Context) {
c0d00808:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0080a:	b0a7      	sub	sp, #156	; 0x9c
c0d0080c:	9203      	str	r2, [sp, #12]
c0d0080e:	9104      	str	r1, [sp, #16]
c0d00810:	4605      	mov	r5, r0
    uint8_t hashChecksum[32];
    uint8_t tmp[100];
    uint8_t i;
    bool eip1191 = false;
    uint32_t offset = 0;
    switch(chainConfig->chainId) {
c0d00812:	4831      	ldr	r0, [pc, #196]	; (c0d008d8 <getEthAddressStringFromBinary+0xd0>)
c0d00814:	6800      	ldr	r0, [r0, #0]
c0d00816:	6843      	ldr	r3, [r0, #4]
c0d00818:	2101      	movs	r1, #1
c0d0081a:	4618      	mov	r0, r3
c0d0081c:	9105      	str	r1, [sp, #20]
c0d0081e:	4388      	bics	r0, r1
c0d00820:	2600      	movs	r6, #0
        case 30:
        case 31:
            eip1191 = true;
            break;
    }
    if (eip1191) {
c0d00822:	281e      	cmp	r0, #30
c0d00824:	4630      	mov	r0, r6
c0d00826:	d108      	bne.n	c0d0083a <getEthAddressStringFromBinary+0x32>
c0d00828:	af06      	add	r7, sp, #24
        snprintf(tmp, sizeof(tmp), "%d0x", chainConfig->chainId);
c0d0082a:	2164      	movs	r1, #100	; 0x64
c0d0082c:	a22b      	add	r2, pc, #172	; (adr r2, c0d008dc <getEthAddressStringFromBinary+0xd4>)
c0d0082e:	4638      	mov	r0, r7
c0d00830:	f003 f842 	bl	c0d038b8 <snprintf>
        offset = strlen(tmp);
c0d00834:	4638      	mov	r0, r7
c0d00836:	f006 fbdb 	bl	c0d06ff0 <strlen>
c0d0083a:	a906      	add	r1, sp, #24
c0d0083c:	9002      	str	r0, [sp, #8]
    }
    for (i = 0; i < 20; i++) {
c0d0083e:	1808      	adds	r0, r1, r0
c0d00840:	9905      	ldr	r1, [sp, #20]
c0d00842:	43c9      	mvns	r1, r1
c0d00844:	a727      	add	r7, pc, #156	; (adr r7, c0d008e4 <HEXDIGITS>)
        uint8_t digit = address[i];
        tmp[offset + 2 * i] = HEXDIGITS[(digit >> 4) & 0x0f];
c0d00846:	460a      	mov	r2, r1
c0d00848:	4372      	muls	r2, r6
    if (eip1191) {
        snprintf(tmp, sizeof(tmp), "%d0x", chainConfig->chainId);
        offset = strlen(tmp);
    }
    for (i = 0; i < 20; i++) {
        uint8_t digit = address[i];
c0d0084a:	1c4b      	adds	r3, r1, #1
c0d0084c:	4373      	muls	r3, r6
        tmp[offset + 2 * i] = HEXDIGITS[(digit >> 4) & 0x0f];
c0d0084e:	5ceb      	ldrb	r3, [r5, r3]
c0d00850:	091c      	lsrs	r4, r3, #4
c0d00852:	5d3c      	ldrb	r4, [r7, r4]
c0d00854:	5484      	strb	r4, [r0, r2]
c0d00856:	1882      	adds	r2, r0, r2
        tmp[offset + 2 * i + 1] = HEXDIGITS[digit & 0x0f];
c0d00858:	240f      	movs	r4, #15
c0d0085a:	4023      	ands	r3, r4
c0d0085c:	5cfb      	ldrb	r3, [r7, r3]
c0d0085e:	7053      	strb	r3, [r2, #1]
    }
    if (eip1191) {
        snprintf(tmp, sizeof(tmp), "%d0x", chainConfig->chainId);
        offset = strlen(tmp);
    }
    for (i = 0; i < 20; i++) {
c0d00860:	1e76      	subs	r6, r6, #1
c0d00862:	4632      	mov	r2, r6
c0d00864:	3214      	adds	r2, #20
c0d00866:	d1ee      	bne.n	c0d00846 <getEthAddressStringFromBinary+0x3e>
        uint8_t digit = address[i];
        tmp[offset + 2 * i] = HEXDIGITS[(digit >> 4) & 0x0f];
        tmp[offset + 2 * i + 1] = HEXDIGITS[digit & 0x0f];
    }
    cx_keccak_init(sha3Context, 256);
c0d00868:	9805      	ldr	r0, [sp, #20]
c0d0086a:	0201      	lsls	r1, r0, #8
c0d0086c:	9e03      	ldr	r6, [sp, #12]
c0d0086e:	4630      	mov	r0, r6
c0d00870:	f003 faf2 	bl	c0d03e58 <cx_keccak_init>
c0d00874:	a81f      	add	r0, sp, #124	; 0x7c
    cx_hash((cx_hash_t*)sha3Context, CX_LAST, tmp, offset + 40, hashChecksum);
c0d00876:	4669      	mov	r1, sp
c0d00878:	6008      	str	r0, [r1, #0]
c0d0087a:	9b02      	ldr	r3, [sp, #8]
c0d0087c:	3328      	adds	r3, #40	; 0x28
c0d0087e:	aa06      	add	r2, sp, #24
c0d00880:	4630      	mov	r0, r6
c0d00882:	9905      	ldr	r1, [sp, #20]
c0d00884:	f7ff fc32 	bl	c0d000ec <cx_hash_X>
c0d00888:	2000      	movs	r0, #0
    for (i = 0; i < 40; i++) {
        uint8_t digit = address[i / 2];
        if ((i % 2) == 0) {
c0d0088a:	4601      	mov	r1, r0
c0d0088c:	9a05      	ldr	r2, [sp, #20]
c0d0088e:	4011      	ands	r1, r2
        tmp[offset + 2 * i + 1] = HEXDIGITS[digit & 0x0f];
    }
    cx_keccak_init(sha3Context, 256);
    cx_hash((cx_hash_t*)sha3Context, CX_LAST, tmp, offset + 40, hashChecksum);
    for (i = 0; i < 40; i++) {
        uint8_t digit = address[i / 2];
c0d00890:	0842      	lsrs	r2, r0, #1
c0d00892:	237f      	movs	r3, #127	; 0x7f
c0d00894:	4013      	ands	r3, r2
c0d00896:	5cee      	ldrb	r6, [r5, r3]
        if ((i % 2) == 0) {
            digit = (digit >> 4) & 0x0f;
c0d00898:	0932      	lsrs	r2, r6, #4
        } else {
            digit = digit & 0x0f;
c0d0089a:	4026      	ands	r6, r4
    }
    cx_keccak_init(sha3Context, 256);
    cx_hash((cx_hash_t*)sha3Context, CX_LAST, tmp, offset + 40, hashChecksum);
    for (i = 0; i < 40; i++) {
        uint8_t digit = address[i / 2];
        if ((i % 2) == 0) {
c0d0089c:	2900      	cmp	r1, #0
c0d0089e:	d000      	beq.n	c0d008a2 <getEthAddressStringFromBinary+0x9a>
c0d008a0:	4632      	mov	r2, r6
            digit = (digit >> 4) & 0x0f;
        } else {
            digit = digit & 0x0f;
        }
        if (digit < 10) {
c0d008a2:	2a09      	cmp	r2, #9
c0d008a4:	d801      	bhi.n	c0d008aa <getEthAddressStringFromBinary+0xa2>
            out[i] = HEXDIGITS[digit];
c0d008a6:	5cba      	ldrb	r2, [r7, r2]
c0d008a8:	e00a      	b.n	c0d008c0 <getEthAddressStringFromBinary+0xb8>
c0d008aa:	5cba      	ldrb	r2, [r7, r2]
c0d008ac:	ae1f      	add	r6, sp, #124	; 0x7c
        }
        else {
            int v = (hashChecksum[i / 2] >> (4 * (1 - i % 2))) & 0x0f;
c0d008ae:	5cf3      	ldrb	r3, [r6, r3]
c0d008b0:	0089      	lsls	r1, r1, #2
c0d008b2:	2604      	movs	r6, #4
c0d008b4:	404e      	eors	r6, r1
            if (v >= 8) {
c0d008b6:	2108      	movs	r1, #8
c0d008b8:	40b1      	lsls	r1, r6
c0d008ba:	420b      	tst	r3, r1
c0d008bc:	d000      	beq.n	c0d008c0 <getEthAddressStringFromBinary+0xb8>
                out[i] = HEXDIGITS[digit] - 'a' + 'A';
c0d008be:	32e0      	adds	r2, #224	; 0xe0
c0d008c0:	9904      	ldr	r1, [sp, #16]
c0d008c2:	540a      	strb	r2, [r1, r0]
        tmp[offset + 2 * i] = HEXDIGITS[(digit >> 4) & 0x0f];
        tmp[offset + 2 * i + 1] = HEXDIGITS[digit & 0x0f];
    }
    cx_keccak_init(sha3Context, 256);
    cx_hash((cx_hash_t*)sha3Context, CX_LAST, tmp, offset + 40, hashChecksum);
    for (i = 0; i < 40; i++) {
c0d008c4:	1c40      	adds	r0, r0, #1
c0d008c6:	2828      	cmp	r0, #40	; 0x28
c0d008c8:	d1df      	bne.n	c0d0088a <getEthAddressStringFromBinary+0x82>
            else {
                out[i] = HEXDIGITS[digit];
            }
        }
    }
    out[40] = '\0';
c0d008ca:	2028      	movs	r0, #40	; 0x28
c0d008cc:	2100      	movs	r1, #0
c0d008ce:	9a04      	ldr	r2, [sp, #16]
c0d008d0:	5411      	strb	r1, [r2, r0]
}
c0d008d2:	b027      	add	sp, #156	; 0x9c
c0d008d4:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d008d6:	46c0      	nop			; (mov r8, r8)
c0d008d8:	20001aa0 	.word	0x20001aa0
c0d008dc:	78306425 	.word	0x78306425
c0d008e0:	00000000 	.word	0x00000000

c0d008e4 <HEXDIGITS>:
c0d008e4:	33323130 	.word	0x33323130
c0d008e8:	37363534 	.word	0x37363534
c0d008ec:	62613938 	.word	0x62613938
c0d008f0:	66656463 	.word	0x66656463
c0d008f4:	00000000 	.word	0x00000000

c0d008f8 <adjustDecimals>:

#endif

bool adjustDecimals(char *src, uint32_t srcLength, char *target,
                    uint32_t targetLength, uint8_t decimals) {
c0d008f8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d008fa:	b083      	sub	sp, #12
c0d008fc:	4614      	mov	r4, r2
c0d008fe:	460d      	mov	r5, r1
c0d00900:	4606      	mov	r6, r0
c0d00902:	2001      	movs	r0, #1
    uint32_t startOffset;
    uint32_t lastZeroOffset = 0;
    uint32_t offset = 0;
    if ((srcLength == 1) && (*src == '0')) {
c0d00904:	9002      	str	r0, [sp, #8]
c0d00906:	2d01      	cmp	r5, #1
c0d00908:	d10a      	bne.n	c0d00920 <adjustDecimals+0x28>
c0d0090a:	7830      	ldrb	r0, [r6, #0]
c0d0090c:	2830      	cmp	r0, #48	; 0x30
c0d0090e:	d107      	bne.n	c0d00920 <adjustDecimals+0x28>
c0d00910:	2000      	movs	r0, #0
        if (targetLength < 2) {
c0d00912:	2b02      	cmp	r3, #2
c0d00914:	d371      	bcc.n	c0d009fa <adjustDecimals+0x102>
                return false;
        }
        target[0] = '0';
c0d00916:	2030      	movs	r0, #48	; 0x30
c0d00918:	7020      	strb	r0, [r4, #0]
        target[1] = '\0';
c0d0091a:	2000      	movs	r0, #0
c0d0091c:	7060      	strb	r0, [r4, #1]
c0d0091e:	e066      	b.n	c0d009ee <adjustDecimals+0xf6>
c0d00920:	9f08      	ldr	r7, [sp, #32]
        return true;
    }
    if (srcLength <= decimals) {
c0d00922:	42af      	cmp	r7, r5
c0d00924:	d227      	bcs.n	c0d00976 <adjustDecimals+0x7e>
            target[offset++] = src[i];
        }
        target[offset] = '\0';
    } else {
        uint32_t sourceOffset = 0;
        uint32_t delta = srcLength - decimals;
c0d00926:	1bea      	subs	r2, r5, r7
        if (targetLength < srcLength + 1 + 1) {
c0d00928:	1ca9      	adds	r1, r5, #2
c0d0092a:	2000      	movs	r0, #0
c0d0092c:	4299      	cmp	r1, r3
c0d0092e:	d864      	bhi.n	c0d009fa <adjustDecimals+0x102>
c0d00930:	2100      	movs	r1, #0
            return false;
        }
        while (offset < delta) {
c0d00932:	2a00      	cmp	r2, #0
c0d00934:	d00b      	beq.n	c0d0094e <adjustDecimals+0x56>
c0d00936:	4630      	mov	r0, r6
c0d00938:	9201      	str	r2, [sp, #4]
c0d0093a:	4611      	mov	r1, r2
c0d0093c:	4623      	mov	r3, r4
            target[offset++] = src[sourceOffset++];
c0d0093e:	7802      	ldrb	r2, [r0, #0]
c0d00940:	701a      	strb	r2, [r3, #0]
        uint32_t sourceOffset = 0;
        uint32_t delta = srcLength - decimals;
        if (targetLength < srcLength + 1 + 1) {
            return false;
        }
        while (offset < delta) {
c0d00942:	1c40      	adds	r0, r0, #1
c0d00944:	1e49      	subs	r1, r1, #1
c0d00946:	1c5b      	adds	r3, r3, #1
c0d00948:	2900      	cmp	r1, #0
c0d0094a:	d1f8      	bne.n	c0d0093e <adjustDecimals+0x46>
c0d0094c:	9901      	ldr	r1, [sp, #4]
            target[offset++] = src[sourceOffset++];
        }
        if (decimals != 0) {
c0d0094e:	2f00      	cmp	r7, #0
c0d00950:	4608      	mov	r0, r1
c0d00952:	d002      	beq.n	c0d0095a <adjustDecimals+0x62>
            target[offset++] = '.';
c0d00954:	202e      	movs	r0, #46	; 0x2e
c0d00956:	5460      	strb	r0, [r4, r1]
c0d00958:	1c48      	adds	r0, r1, #1
        }
        startOffset = offset;
        while (sourceOffset < srcLength) {
c0d0095a:	42a9      	cmp	r1, r5
c0d0095c:	d249      	bcs.n	c0d009f2 <adjustDecimals+0xfa>
            target[offset++] = src[sourceOffset++];
c0d0095e:	1822      	adds	r2, r4, r0
c0d00960:	1873      	adds	r3, r6, r1
c0d00962:	1a6e      	subs	r6, r5, r1
c0d00964:	1945      	adds	r5, r0, r5
c0d00966:	781f      	ldrb	r7, [r3, #0]
c0d00968:	7017      	strb	r7, [r2, #0]
        }
        if (decimals != 0) {
            target[offset++] = '.';
        }
        startOffset = offset;
        while (sourceOffset < srcLength) {
c0d0096a:	1c52      	adds	r2, r2, #1
c0d0096c:	1c5b      	adds	r3, r3, #1
c0d0096e:	1e76      	subs	r6, r6, #1
c0d00970:	d1f9      	bne.n	c0d00966 <adjustDecimals+0x6e>
            target[offset++] = src[sourceOffset++];
c0d00972:	1a69      	subs	r1, r5, r1
c0d00974:	e01d      	b.n	c0d009b2 <adjustDecimals+0xba>
        target[0] = '0';
        target[1] = '\0';
        return true;
    }
    if (srcLength <= decimals) {
        uint32_t delta = decimals - srcLength;
c0d00976:	1b79      	subs	r1, r7, r5
        if (targetLength < srcLength + 1 + 2 + delta) {
c0d00978:	1cfa      	adds	r2, r7, #3
c0d0097a:	2000      	movs	r0, #0
c0d0097c:	429a      	cmp	r2, r3
c0d0097e:	d83c      	bhi.n	c0d009fa <adjustDecimals+0x102>
            return false;
        }
        target[offset++] = '0';
c0d00980:	2030      	movs	r0, #48	; 0x30
c0d00982:	7020      	strb	r0, [r4, #0]
        target[offset++] = '.';
c0d00984:	202e      	movs	r0, #46	; 0x2e
c0d00986:	7060      	strb	r0, [r4, #1]
c0d00988:	2002      	movs	r0, #2
        for (uint32_t i = 0; i < delta; i++) {
c0d0098a:	2900      	cmp	r1, #0
c0d0098c:	d005      	beq.n	c0d0099a <adjustDecimals+0xa2>
            target[offset++] = '0';
c0d0098e:	1ca0      	adds	r0, r4, #2
c0d00990:	2230      	movs	r2, #48	; 0x30
c0d00992:	f006 fa87 	bl	c0d06ea4 <__aeabi_memset>
c0d00996:	1cb8      	adds	r0, r7, #2
c0d00998:	1b40      	subs	r0, r0, r5
        }
        startOffset = offset;
        for (uint32_t i = 0; i < srcLength; i++) {
c0d0099a:	2d00      	cmp	r5, #0
c0d0099c:	d029      	beq.n	c0d009f2 <adjustDecimals+0xfa>
            target[offset++] = src[i];
c0d0099e:	1821      	adds	r1, r4, r0
c0d009a0:	462a      	mov	r2, r5
c0d009a2:	7833      	ldrb	r3, [r6, #0]
c0d009a4:	700b      	strb	r3, [r1, #0]
        target[offset++] = '.';
        for (uint32_t i = 0; i < delta; i++) {
            target[offset++] = '0';
        }
        startOffset = offset;
        for (uint32_t i = 0; i < srcLength; i++) {
c0d009a6:	1c49      	adds	r1, r1, #1
c0d009a8:	1e52      	subs	r2, r2, #1
c0d009aa:	1c76      	adds	r6, r6, #1
c0d009ac:	2a00      	cmp	r2, #0
c0d009ae:	d1f8      	bne.n	c0d009a2 <adjustDecimals+0xaa>
            target[offset++] = src[i];
c0d009b0:	1941      	adds	r1, r0, r5
c0d009b2:	2300      	movs	r3, #0
c0d009b4:	5463      	strb	r3, [r4, r1]
        while (sourceOffset < srcLength) {
            target[offset++] = src[sourceOffset++];
        }
	target[offset] = '\0';
    }
    for (uint32_t i = startOffset; i < offset; i++) {
c0d009b6:	4288      	cmp	r0, r1
c0d009b8:	d219      	bcs.n	c0d009ee <adjustDecimals+0xf6>
        if (target[i] == '0') {
c0d009ba:	5c25      	ldrb	r5, [r4, r0]
            if (lastZeroOffset == 0) {
c0d009bc:	2b00      	cmp	r3, #0
c0d009be:	4602      	mov	r2, r0
c0d009c0:	d000      	beq.n	c0d009c4 <adjustDecimals+0xcc>
c0d009c2:	461a      	mov	r2, r3
c0d009c4:	2300      	movs	r3, #0
            target[offset++] = src[sourceOffset++];
        }
	target[offset] = '\0';
    }
    for (uint32_t i = startOffset; i < offset; i++) {
        if (target[i] == '0') {
c0d009c6:	2d30      	cmp	r5, #48	; 0x30
c0d009c8:	d000      	beq.n	c0d009cc <adjustDecimals+0xd4>
c0d009ca:	461a      	mov	r2, r3
        while (sourceOffset < srcLength) {
            target[offset++] = src[sourceOffset++];
        }
	target[offset] = '\0';
    }
    for (uint32_t i = startOffset; i < offset; i++) {
c0d009cc:	1c40      	adds	r0, r0, #1
c0d009ce:	4281      	cmp	r1, r0
c0d009d0:	4613      	mov	r3, r2
c0d009d2:	d1f2      	bne.n	c0d009ba <adjustDecimals+0xc2>
            }
        } else {
            lastZeroOffset = 0;
        }
    }
    if (lastZeroOffset != 0) {
c0d009d4:	2a00      	cmp	r2, #0
c0d009d6:	d00a      	beq.n	c0d009ee <adjustDecimals+0xf6>
        target[lastZeroOffset] = '\0';
c0d009d8:	2000      	movs	r0, #0
c0d009da:	54a0      	strb	r0, [r4, r2]
c0d009dc:	18a1      	adds	r1, r4, r2
        if (target[lastZeroOffset - 1] == '.') {
c0d009de:	43c2      	mvns	r2, r0
c0d009e0:	5c8a      	ldrb	r2, [r1, r2]
c0d009e2:	1e49      	subs	r1, r1, #1
c0d009e4:	2a2e      	cmp	r2, #46	; 0x2e
c0d009e6:	9a02      	ldr	r2, [sp, #8]
c0d009e8:	d106      	bne.n	c0d009f8 <adjustDecimals+0x100>
                target[lastZeroOffset - 1] = '\0';
c0d009ea:	7008      	strb	r0, [r1, #0]
c0d009ec:	e004      	b.n	c0d009f8 <adjustDecimals+0x100>
c0d009ee:	9802      	ldr	r0, [sp, #8]
c0d009f0:	e003      	b.n	c0d009fa <adjustDecimals+0x102>
c0d009f2:	9a02      	ldr	r2, [sp, #8]
c0d009f4:	2100      	movs	r1, #0
c0d009f6:	5421      	strb	r1, [r4, r0]
c0d009f8:	4610      	mov	r0, r2
        }
    }
    return true;
}
c0d009fa:	b003      	add	sp, #12
c0d009fc:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

c0d00a00 <menu_settings_data_change>:
const ux_menu_entry_t menu_settings_details[];

#ifdef HAVE_U2F

// change the setting
void menu_settings_data_change(unsigned int enabled) {
c0d00a00:	b510      	push	{r4, lr}
  dataAllowed = enabled;
c0d00a02:	4c08      	ldr	r4, [pc, #32]	; (c0d00a24 <menu_settings_data_change+0x24>)
c0d00a04:	7020      	strb	r0, [r4, #0]
  nvm_write(&N_storage.dataAllowed, (void*)&dataAllowed, sizeof(uint8_t));
c0d00a06:	4808      	ldr	r0, [pc, #32]	; (c0d00a28 <menu_settings_data_change+0x28>)
c0d00a08:	4478      	add	r0, pc
c0d00a0a:	f003 f96b 	bl	c0d03ce4 <pic>
c0d00a0e:	2201      	movs	r2, #1
c0d00a10:	4621      	mov	r1, r4
c0d00a12:	f003 f9a9 	bl	c0d03d68 <nvm_write>
  // go back to the menu entry
  UX_MENU_DISPLAY(0, menu_settings, NULL);
c0d00a16:	4905      	ldr	r1, [pc, #20]	; (c0d00a2c <menu_settings_data_change+0x2c>)
c0d00a18:	4479      	add	r1, pc
c0d00a1a:	2000      	movs	r0, #0
c0d00a1c:	4602      	mov	r2, r0
c0d00a1e:	f002 febb 	bl	c0d03798 <ux_menu_display>
}
c0d00a22:	bd10      	pop	{r4, pc}
c0d00a24:	20001800 	.word	0x20001800
c0d00a28:	0000feb4 	.word	0x0000feb4
c0d00a2c:	0000684c 	.word	0x0000684c

c0d00a30 <menu_settings_details_change>:

void menu_settings_details_change(unsigned int enabled) {
c0d00a30:	b510      	push	{r4, lr}
  contractDetails = enabled;
c0d00a32:	4c09      	ldr	r4, [pc, #36]	; (c0d00a58 <menu_settings_details_change+0x28>)
c0d00a34:	7020      	strb	r0, [r4, #0]
  nvm_write(&N_storage.contractDetails, (void*)&contractDetails, sizeof(uint8_t));
c0d00a36:	4809      	ldr	r0, [pc, #36]	; (c0d00a5c <menu_settings_details_change+0x2c>)
c0d00a38:	4478      	add	r0, pc
c0d00a3a:	f003 f953 	bl	c0d03ce4 <pic>
c0d00a3e:	1c40      	adds	r0, r0, #1
c0d00a40:	2201      	movs	r2, #1
c0d00a42:	4621      	mov	r1, r4
c0d00a44:	f003 f990 	bl	c0d03d68 <nvm_write>
  // go back to the menu entry
  UX_MENU_DISPLAY(0, menu_settings, NULL);
c0d00a48:	4905      	ldr	r1, [pc, #20]	; (c0d00a60 <menu_settings_details_change+0x30>)
c0d00a4a:	4479      	add	r1, pc
c0d00a4c:	2000      	movs	r0, #0
c0d00a4e:	4602      	mov	r2, r0
c0d00a50:	f002 fea2 	bl	c0d03798 <ux_menu_display>
}
c0d00a54:	bd10      	pop	{r4, pc}
c0d00a56:	46c0      	nop			; (mov r8, r8)
c0d00a58:	20001801 	.word	0x20001801
c0d00a5c:	0000fe84 	.word	0x0000fe84
c0d00a60:	0000681a 	.word	0x0000681a

c0d00a64 <menu_settings_data_init>:

// show the currently activated entry
void menu_settings_data_init(unsigned int ignored) {
c0d00a64:	b580      	push	{r7, lr}
  UNUSED(ignored);
  UX_MENU_DISPLAY(N_storage.dataAllowed?1:0, menu_settings_data, NULL);
c0d00a66:	4807      	ldr	r0, [pc, #28]	; (c0d00a84 <menu_settings_data_init+0x20>)
c0d00a68:	4478      	add	r0, pc
c0d00a6a:	f003 f93b 	bl	c0d03ce4 <pic>
c0d00a6e:	7801      	ldrb	r1, [r0, #0]
c0d00a70:	2001      	movs	r0, #1
c0d00a72:	2900      	cmp	r1, #0
c0d00a74:	d100      	bne.n	c0d00a78 <menu_settings_data_init+0x14>
c0d00a76:	4608      	mov	r0, r1
c0d00a78:	4903      	ldr	r1, [pc, #12]	; (c0d00a88 <menu_settings_data_init+0x24>)
c0d00a7a:	4479      	add	r1, pc
c0d00a7c:	2200      	movs	r2, #0
c0d00a7e:	f002 fe8b 	bl	c0d03798 <ux_menu_display>
}
c0d00a82:	bd80      	pop	{r7, pc}
c0d00a84:	0000fe54 	.word	0x0000fe54
c0d00a88:	00006742 	.word	0x00006742

c0d00a8c <menu_settings_details_init>:

void menu_settings_details_init(unsigned int ignored) {
c0d00a8c:	b580      	push	{r7, lr}
  UNUSED(ignored);
  UX_MENU_DISPLAY(N_storage.contractDetails?1:0, menu_settings_details, NULL);
c0d00a8e:	4807      	ldr	r0, [pc, #28]	; (c0d00aac <menu_settings_details_init+0x20>)
c0d00a90:	4478      	add	r0, pc
c0d00a92:	f003 f927 	bl	c0d03ce4 <pic>
c0d00a96:	7841      	ldrb	r1, [r0, #1]
c0d00a98:	2001      	movs	r0, #1
c0d00a9a:	2900      	cmp	r1, #0
c0d00a9c:	d100      	bne.n	c0d00aa0 <menu_settings_details_init+0x14>
c0d00a9e:	4608      	mov	r0, r1
c0d00aa0:	4903      	ldr	r1, [pc, #12]	; (c0d00ab0 <menu_settings_details_init+0x24>)
c0d00aa2:	4479      	add	r1, pc
c0d00aa4:	2200      	movs	r2, #0
c0d00aa6:	f002 fe77 	bl	c0d03798 <ux_menu_display>
}
c0d00aaa:	bd80      	pop	{r7, pc}
c0d00aac:	0000fe2c 	.word	0x0000fe2c
c0d00ab0:	0000676e 	.word	0x0000676e

c0d00ab4 <ui_address_prepro>:

  {{BAGL_LABELINE                       , 0x02,   0,  12, 128,  12, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_REGULAR_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, "Address", 0, 0, 0, NULL, NULL, NULL },
  {{BAGL_LABELINE                       , 0x02,  23,  26,  82,  12, 0x80|10, 0, 0  , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px|BAGL_FONT_ALIGNMENT_CENTER, 26  }, (char*)strings.common.fullAddress, 0, 0, 0, NULL, NULL, NULL },
};

unsigned int ui_address_prepro(const bagl_element_t* element) {
c0d00ab4:	b570      	push	{r4, r5, r6, lr}
c0d00ab6:	4605      	mov	r5, r0
    if (element->component.userid > 0) {
c0d00ab8:	7868      	ldrb	r0, [r5, #1]
c0d00aba:	2401      	movs	r4, #1
c0d00abc:	2800      	cmp	r0, #0
c0d00abe:	d01f      	beq.n	c0d00b00 <ui_address_prepro+0x4c>
        unsigned int display = (ux_step == element->component.userid-1);
c0d00ac0:	1e41      	subs	r1, r0, #1
c0d00ac2:	4a10      	ldr	r2, [pc, #64]	; (c0d00b04 <ui_address_prepro+0x50>)
c0d00ac4:	6812      	ldr	r2, [r2, #0]
c0d00ac6:	2401      	movs	r4, #1
c0d00ac8:	2300      	movs	r3, #0
c0d00aca:	428a      	cmp	r2, r1
c0d00acc:	d000      	beq.n	c0d00ad0 <ui_address_prepro+0x1c>
c0d00ace:	461c      	mov	r4, r3
        if(display) {
c0d00ad0:	428a      	cmp	r2, r1
c0d00ad2:	d115      	bne.n	c0d00b00 <ui_address_prepro+0x4c>
c0d00ad4:	267d      	movs	r6, #125	; 0x7d
c0d00ad6:	0131      	lsls	r1, r6, #4
          switch(element->component.userid) {
c0d00ad8:	2801      	cmp	r0, #1
c0d00ada:	d00f      	beq.n	c0d00afc <ui_address_prepro+0x48>
c0d00adc:	2802      	cmp	r0, #2
c0d00ade:	d10f      	bne.n	c0d00b00 <ui_address_prepro+0x4c>
          case 1:
            UX_CALLBACK_SET_INTERVAL(2000);
            break;
          case 2:
            UX_CALLBACK_SET_INTERVAL(MAX(3000, 1000+bagl_label_roundtrip_duration_ms(element, 7)));
c0d00ae0:	2107      	movs	r1, #7
c0d00ae2:	4628      	mov	r0, r5
c0d00ae4:	f002 fb4c 	bl	c0d03180 <bagl_label_roundtrip_duration_ms>
c0d00ae8:	00f6      	lsls	r6, r6, #3
c0d00aea:	1980      	adds	r0, r0, r6
c0d00aec:	4906      	ldr	r1, [pc, #24]	; (c0d00b08 <ui_address_prepro+0x54>)
c0d00aee:	4288      	cmp	r0, r1
c0d00af0:	d304      	bcc.n	c0d00afc <ui_address_prepro+0x48>
c0d00af2:	2107      	movs	r1, #7
c0d00af4:	4628      	mov	r0, r5
c0d00af6:	f002 fb43 	bl	c0d03180 <bagl_label_roundtrip_duration_ms>
c0d00afa:	1981      	adds	r1, r0, r6
c0d00afc:	4803      	ldr	r0, [pc, #12]	; (c0d00b0c <ui_address_prepro+0x58>)
c0d00afe:	6141      	str	r1, [r0, #20]
          }
        }
        return display;
    }
    return 1;
}
c0d00b00:	4620      	mov	r0, r4
c0d00b02:	bd70      	pop	{r4, r5, r6, pc}
c0d00b04:	20001894 	.word	0x20001894
c0d00b08:	00000bb8 	.word	0x00000bb8
c0d00b0c:	20001898 	.word	0x20001898

c0d00b10 <ui_approval_prepro>:
  {{BAGL_LABELINE                       , 0x05,   0,  12, 128,  32, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_REGULAR_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, "Maximum fees", 0, 0, 0, NULL, NULL, NULL },
  {{BAGL_LABELINE                       , 0x05,  23,  26,  82,  12, 0x80|10, 0, 0  , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px|BAGL_FONT_ALIGNMENT_CENTER, 26  }, (char*)strings.common.maxFee, 0, 0, 0, NULL, NULL, NULL },

};

unsigned int ui_approval_prepro(const bagl_element_t* element) {
c0d00b10:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d00b12:	b081      	sub	sp, #4
c0d00b14:	4605      	mov	r5, r0
    unsigned int display = 1;
    if (element->component.userid > 0) {
c0d00b16:	7868      	ldrb	r0, [r5, #1]
c0d00b18:	2401      	movs	r4, #1
c0d00b1a:	2800      	cmp	r0, #0
c0d00b1c:	d03d      	beq.n	c0d00b9a <ui_approval_prepro+0x8a>
        display = (ux_step == element->component.userid-1);
c0d00b1e:	1e42      	subs	r2, r0, #1
c0d00b20:	4f1f      	ldr	r7, [pc, #124]	; (c0d00ba0 <ui_approval_prepro+0x90>)
c0d00b22:	6839      	ldr	r1, [r7, #0]
c0d00b24:	2401      	movs	r4, #1
c0d00b26:	2300      	movs	r3, #0
c0d00b28:	4291      	cmp	r1, r2
c0d00b2a:	d000      	beq.n	c0d00b2e <ui_approval_prepro+0x1e>
c0d00b2c:	461c      	mov	r4, r3
        if(display) {
c0d00b2e:	4291      	cmp	r1, r2
c0d00b30:	d133      	bne.n	c0d00b9a <ui_approval_prepro+0x8a>
c0d00b32:	227d      	movs	r2, #125	; 0x7d
c0d00b34:	00d3      	lsls	r3, r2, #3
c0d00b36:	4e1b      	ldr	r6, [pc, #108]	; (c0d00ba4 <ui_approval_prepro+0x94>)
          switch(element->component.userid) {
c0d00b38:	2802      	cmp	r0, #2
c0d00b3a:	dd17      	ble.n	c0d00b6c <ui_approval_prepro+0x5c>
c0d00b3c:	2803      	cmp	r0, #3
c0d00b3e:	d003      	beq.n	c0d00b48 <ui_approval_prepro+0x38>
c0d00b40:	2804      	cmp	r0, #4
c0d00b42:	d001      	beq.n	c0d00b48 <ui_approval_prepro+0x38>
c0d00b44:	2805      	cmp	r0, #5
c0d00b46:	d128      	bne.n	c0d00b9a <ui_approval_prepro+0x8a>
c0d00b48:	2107      	movs	r1, #7
c0d00b4a:	4628      	mov	r0, r5
c0d00b4c:	461f      	mov	r7, r3
c0d00b4e:	f002 fb17 	bl	c0d03180 <bagl_label_roundtrip_duration_ms>
c0d00b52:	463a      	mov	r2, r7
c0d00b54:	1880      	adds	r0, r0, r2
c0d00b56:	42b0      	cmp	r0, r6
c0d00b58:	d305      	bcc.n	c0d00b66 <ui_approval_prepro+0x56>
c0d00b5a:	2107      	movs	r1, #7
c0d00b5c:	4628      	mov	r0, r5
c0d00b5e:	4615      	mov	r5, r2
c0d00b60:	f002 fb0e 	bl	c0d03180 <bagl_label_roundtrip_duration_ms>
c0d00b64:	1946      	adds	r6, r0, r5
c0d00b66:	4810      	ldr	r0, [pc, #64]	; (c0d00ba8 <ui_approval_prepro+0x98>)
c0d00b68:	6146      	str	r6, [r0, #20]
c0d00b6a:	e016      	b.n	c0d00b9a <ui_approval_prepro+0x8a>
c0d00b6c:	2801      	cmp	r0, #1
c0d00b6e:	d011      	beq.n	c0d00b94 <ui_approval_prepro+0x84>
c0d00b70:	2802      	cmp	r0, #2
c0d00b72:	d112      	bne.n	c0d00b9a <ui_approval_prepro+0x8a>
          case 1:
            UX_CALLBACK_SET_INTERVAL(2000);
            break;
          case 2:
            if (dataPresent && !N_storage.contractDetails) {
c0d00b74:	480d      	ldr	r0, [pc, #52]	; (c0d00bac <ui_approval_prepro+0x9c>)
c0d00b76:	7800      	ldrb	r0, [r0, #0]
c0d00b78:	2800      	cmp	r0, #0
c0d00b7a:	d007      	beq.n	c0d00b8c <ui_approval_prepro+0x7c>
c0d00b7c:	480c      	ldr	r0, [pc, #48]	; (c0d00bb0 <ui_approval_prepro+0xa0>)
c0d00b7e:	4478      	add	r0, pc
c0d00b80:	f003 f8b0 	bl	c0d03ce4 <pic>
c0d00b84:	7840      	ldrb	r0, [r0, #1]
c0d00b86:	2800      	cmp	r0, #0
c0d00b88:	d0ed      	beq.n	c0d00b66 <ui_approval_prepro+0x56>
c0d00b8a:	6839      	ldr	r1, [r7, #0]
              UX_CALLBACK_SET_INTERVAL(3000);
            }
            else {
              display = 0;
              ux_step++; // display the next step
c0d00b8c:	1c48      	adds	r0, r1, #1
c0d00b8e:	6038      	str	r0, [r7, #0]
c0d00b90:	2400      	movs	r4, #0
c0d00b92:	e002      	b.n	c0d00b9a <ui_approval_prepro+0x8a>
    if (element->component.userid > 0) {
        display = (ux_step == element->component.userid-1);
        if(display) {
          switch(element->component.userid) {
          case 1:
            UX_CALLBACK_SET_INTERVAL(2000);
c0d00b94:	0110      	lsls	r0, r2, #4
c0d00b96:	4904      	ldr	r1, [pc, #16]	; (c0d00ba8 <ui_approval_prepro+0x98>)
c0d00b98:	6148      	str	r0, [r1, #20]
            UX_CALLBACK_SET_INTERVAL(MAX(3000, 1000+bagl_label_roundtrip_duration_ms(element, 7)));
            break;
          }
        }
    }
    return display;
c0d00b9a:	4620      	mov	r0, r4
c0d00b9c:	b001      	add	sp, #4
c0d00b9e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d00ba0:	20001894 	.word	0x20001894
c0d00ba4:	00000bb8 	.word	0x00000bb8
c0d00ba8:	20001898 	.word	0x20001898
c0d00bac:	20001948 	.word	0x20001948
c0d00bb0:	0000fd3e 	.word	0x0000fd3e

c0d00bb4 <ui_approval_signMessage_prepro>:

unsigned int
ui_approval_signMessage_nanos_button(unsigned int button_mask, unsigned int button_mask_counter);

unsigned int ui_approval_signMessage_prepro(const bagl_element_t *element) {
    if (element->component.userid > 0) {
c0d00bb4:	7841      	ldrb	r1, [r0, #1]
c0d00bb6:	4a0a      	ldr	r2, [pc, #40]	; (c0d00be0 <ui_approval_signMessage_prepro+0x2c>)
c0d00bb8:	2001      	movs	r0, #1
c0d00bba:	2900      	cmp	r1, #0
c0d00bbc:	d00f      	beq.n	c0d00bde <ui_approval_signMessage_prepro+0x2a>
c0d00bbe:	2902      	cmp	r1, #2
c0d00bc0:	d003      	beq.n	c0d00bca <ui_approval_signMessage_prepro+0x16>
c0d00bc2:	2901      	cmp	r1, #1
c0d00bc4:	d103      	bne.n	c0d00bce <ui_approval_signMessage_prepro+0x1a>
c0d00bc6:	207d      	movs	r0, #125	; 0x7d
c0d00bc8:	0102      	lsls	r2, r0, #4
c0d00bca:	4806      	ldr	r0, [pc, #24]	; (c0d00be4 <ui_approval_signMessage_prepro+0x30>)
c0d00bcc:	6142      	str	r2, [r0, #20]
            break;
        case 2:
            UX_CALLBACK_SET_INTERVAL(3000);
            break;
        }
        return (ux_step == element->component.userid - 1);
c0d00bce:	1e4a      	subs	r2, r1, #1
c0d00bd0:	4805      	ldr	r0, [pc, #20]	; (c0d00be8 <ui_approval_signMessage_prepro+0x34>)
c0d00bd2:	6803      	ldr	r3, [r0, #0]
c0d00bd4:	2001      	movs	r0, #1
c0d00bd6:	2100      	movs	r1, #0
c0d00bd8:	4293      	cmp	r3, r2
c0d00bda:	d000      	beq.n	c0d00bde <ui_approval_signMessage_prepro+0x2a>
c0d00bdc:	4608      	mov	r0, r1
    }
    return 1;
}
c0d00bde:	4770      	bx	lr
c0d00be0:	00000bb8 	.word	0x00000bb8
c0d00be4:	20001898 	.word	0x20001898
c0d00be8:	20001894 	.word	0x20001894

c0d00bec <ui_data_selector_prepro>:

    {{BAGL_LABELINE, 0x02, 0, 12, 128, 12, 0, 0, 0, 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_REGULAR_11px | BAGL_FONT_ALIGNMENT_CENTER, 0}, "Selector", 0, 0, 0, NULL, NULL, NULL},
    {{BAGL_LABELINE, 0x02, 23, 26, 82, 12, 0x80 | 10, 0, 0, 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px | BAGL_FONT_ALIGNMENT_CENTER, 26}, (char *)strings.tmp.tmp, 0, 0, 0, NULL, NULL, NULL},
};

unsigned int ui_data_selector_prepro(const bagl_element_t *element) {
c0d00bec:	b570      	push	{r4, r5, r6, lr}
c0d00bee:	4605      	mov	r5, r0
    if (element->component.userid > 0) {
c0d00bf0:	7868      	ldrb	r0, [r5, #1]
c0d00bf2:	2401      	movs	r4, #1
c0d00bf4:	2800      	cmp	r0, #0
c0d00bf6:	d01f      	beq.n	c0d00c38 <ui_data_selector_prepro+0x4c>
        unsigned int display = (ux_step == element->component.userid - 1);
c0d00bf8:	1e41      	subs	r1, r0, #1
c0d00bfa:	4a10      	ldr	r2, [pc, #64]	; (c0d00c3c <ui_data_selector_prepro+0x50>)
c0d00bfc:	6812      	ldr	r2, [r2, #0]
c0d00bfe:	2401      	movs	r4, #1
c0d00c00:	2300      	movs	r3, #0
c0d00c02:	428a      	cmp	r2, r1
c0d00c04:	d000      	beq.n	c0d00c08 <ui_data_selector_prepro+0x1c>
c0d00c06:	461c      	mov	r4, r3
        if (display) {
c0d00c08:	428a      	cmp	r2, r1
c0d00c0a:	d115      	bne.n	c0d00c38 <ui_data_selector_prepro+0x4c>
c0d00c0c:	267d      	movs	r6, #125	; 0x7d
c0d00c0e:	0131      	lsls	r1, r6, #4
            switch (element->component.userid) {
c0d00c10:	2801      	cmp	r0, #1
c0d00c12:	d00f      	beq.n	c0d00c34 <ui_data_selector_prepro+0x48>
c0d00c14:	2802      	cmp	r0, #2
c0d00c16:	d10f      	bne.n	c0d00c38 <ui_data_selector_prepro+0x4c>
                case 1:
                    UX_CALLBACK_SET_INTERVAL(2000);
                    break;
                case 2:
                    UX_CALLBACK_SET_INTERVAL(MAX(
c0d00c18:	2107      	movs	r1, #7
c0d00c1a:	4628      	mov	r0, r5
c0d00c1c:	f002 fab0 	bl	c0d03180 <bagl_label_roundtrip_duration_ms>
c0d00c20:	00f6      	lsls	r6, r6, #3
c0d00c22:	1980      	adds	r0, r0, r6
c0d00c24:	4906      	ldr	r1, [pc, #24]	; (c0d00c40 <ui_data_selector_prepro+0x54>)
c0d00c26:	4288      	cmp	r0, r1
c0d00c28:	d304      	bcc.n	c0d00c34 <ui_data_selector_prepro+0x48>
c0d00c2a:	2107      	movs	r1, #7
c0d00c2c:	4628      	mov	r0, r5
c0d00c2e:	f002 faa7 	bl	c0d03180 <bagl_label_roundtrip_duration_ms>
c0d00c32:	1981      	adds	r1, r0, r6
c0d00c34:	4803      	ldr	r0, [pc, #12]	; (c0d00c44 <ui_data_selector_prepro+0x58>)
c0d00c36:	6141      	str	r1, [r0, #20]
            }
        }
        return display;
    }
    return 1;
}
c0d00c38:	4620      	mov	r0, r4
c0d00c3a:	bd70      	pop	{r4, r5, r6, pc}
c0d00c3c:	20001894 	.word	0x20001894
c0d00c40:	00000bb8 	.word	0x00000bb8
c0d00c44:	20001898 	.word	0x20001898

c0d00c48 <ui_data_parameter_prepro>:

    {{BAGL_LABELINE, 0x02, 0, 12, 128, 12, 0, 0, 0, 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_REGULAR_11px | BAGL_FONT_ALIGNMENT_CENTER, 0}, (char*)strings.tmp.tmp2, 0, 0, 0, NULL, NULL, NULL},
    {{BAGL_LABELINE, 0x02, 23, 26, 82, 12, 0x80 | 10, 0, 0, 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px | BAGL_FONT_ALIGNMENT_CENTER, 26}, (char *)strings.tmp.tmp, 0, 0, 0, NULL, NULL, NULL},
};

unsigned int ui_data_parameter_prepro(const bagl_element_t *element) {
c0d00c48:	b570      	push	{r4, r5, r6, lr}
c0d00c4a:	4605      	mov	r5, r0
    if (element->component.userid > 0) {
c0d00c4c:	7868      	ldrb	r0, [r5, #1]
c0d00c4e:	2401      	movs	r4, #1
c0d00c50:	2800      	cmp	r0, #0
c0d00c52:	d01f      	beq.n	c0d00c94 <ui_data_parameter_prepro+0x4c>
        unsigned int display = (ux_step == element->component.userid - 1);
c0d00c54:	1e41      	subs	r1, r0, #1
c0d00c56:	4a10      	ldr	r2, [pc, #64]	; (c0d00c98 <ui_data_parameter_prepro+0x50>)
c0d00c58:	6812      	ldr	r2, [r2, #0]
c0d00c5a:	2401      	movs	r4, #1
c0d00c5c:	2300      	movs	r3, #0
c0d00c5e:	428a      	cmp	r2, r1
c0d00c60:	d000      	beq.n	c0d00c64 <ui_data_parameter_prepro+0x1c>
c0d00c62:	461c      	mov	r4, r3
        if (display) {
c0d00c64:	428a      	cmp	r2, r1
c0d00c66:	d115      	bne.n	c0d00c94 <ui_data_parameter_prepro+0x4c>
c0d00c68:	267d      	movs	r6, #125	; 0x7d
c0d00c6a:	0131      	lsls	r1, r6, #4
            switch (element->component.userid) {
c0d00c6c:	2801      	cmp	r0, #1
c0d00c6e:	d00f      	beq.n	c0d00c90 <ui_data_parameter_prepro+0x48>
c0d00c70:	2802      	cmp	r0, #2
c0d00c72:	d10f      	bne.n	c0d00c94 <ui_data_parameter_prepro+0x4c>
            case 1:
                UX_CALLBACK_SET_INTERVAL(2000);
                break;
            case 2:
                UX_CALLBACK_SET_INTERVAL(MAX(
c0d00c74:	2107      	movs	r1, #7
c0d00c76:	4628      	mov	r0, r5
c0d00c78:	f002 fa82 	bl	c0d03180 <bagl_label_roundtrip_duration_ms>
c0d00c7c:	00f6      	lsls	r6, r6, #3
c0d00c7e:	1980      	adds	r0, r0, r6
c0d00c80:	4906      	ldr	r1, [pc, #24]	; (c0d00c9c <ui_data_parameter_prepro+0x54>)
c0d00c82:	4288      	cmp	r0, r1
c0d00c84:	d304      	bcc.n	c0d00c90 <ui_data_parameter_prepro+0x48>
c0d00c86:	2107      	movs	r1, #7
c0d00c88:	4628      	mov	r0, r5
c0d00c8a:	f002 fa79 	bl	c0d03180 <bagl_label_roundtrip_duration_ms>
c0d00c8e:	1981      	adds	r1, r0, r6
c0d00c90:	4803      	ldr	r0, [pc, #12]	; (c0d00ca0 <ui_data_parameter_prepro+0x58>)
c0d00c92:	6141      	str	r1, [r0, #20]
            }
        }
        return display;
    }
    return 1;
}
c0d00c94:	4620      	mov	r0, r4
c0d00c96:	bd70      	pop	{r4, r5, r6, pc}
c0d00c98:	20001894 	.word	0x20001894
c0d00c9c:	00000bb8 	.word	0x00000bb8
c0d00ca0:	20001898 	.word	0x20001898

c0d00ca4 <ui_idle>:


#endif // #if defined(TARGET_NANOX)


void ui_idle(void) {
c0d00ca4:	b580      	push	{r7, lr}
#if defined(TARGET_BLUE)
    UX_DISPLAY(ui_idle_blue, ui_idle_blue_prepro);
#elif defined(TARGET_NANOS)
    UX_MENU_DISPLAY(0, menu_main, NULL);
c0d00ca6:	4903      	ldr	r1, [pc, #12]	; (c0d00cb4 <ui_idle+0x10>)
c0d00ca8:	4479      	add	r1, pc
c0d00caa:	2000      	movs	r0, #0
c0d00cac:	4602      	mov	r2, r0
c0d00cae:	f002 fd73 	bl	c0d03798 <ux_menu_display>
    if(G_ux.stack_count == 0) {
        ux_stack_push();
    }
    ux_flow_init(0, ux_idle_flow, NULL);
#endif // #if TARGET_ID
}
c0d00cb2:	bd80      	pop	{r7, pc}
c0d00cb4:	00006680 	.word	0x00006680

c0d00cb8 <io_seproxyhal_touch_address_ok>:
    // Go back to the dashboard
    os_sched_exit(0);
    return 0; // do not redraw the widget
}

unsigned int io_seproxyhal_touch_address_ok(const bagl_element_t *e) {
c0d00cb8:	b510      	push	{r4, lr}
    uint32_t tx = set_result_get_publicKey();
c0d00cba:	f000 f817 	bl	c0d00cec <set_result_get_publicKey>
    G_io_apdu_buffer[tx++] = 0x90;
c0d00cbe:	4909      	ldr	r1, [pc, #36]	; (c0d00ce4 <io_seproxyhal_touch_address_ok+0x2c>)
c0d00cc0:	2290      	movs	r2, #144	; 0x90
c0d00cc2:	540a      	strb	r2, [r1, r0]
c0d00cc4:	1809      	adds	r1, r1, r0
c0d00cc6:	2400      	movs	r4, #0
    G_io_apdu_buffer[tx++] = 0x00;
c0d00cc8:	704c      	strb	r4, [r1, #1]
c0d00cca:	1c80      	adds	r0, r0, #2
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0d00ccc:	b281      	uxth	r1, r0
c0d00cce:	2020      	movs	r0, #32
c0d00cd0:	f002 fae0 	bl	c0d03294 <io_exchange>

void ui_idle(void) {
#if defined(TARGET_BLUE)
    UX_DISPLAY(ui_idle_blue, ui_idle_blue_prepro);
#elif defined(TARGET_NANOS)
    UX_MENU_DISPLAY(0, menu_main, NULL);
c0d00cd4:	4904      	ldr	r1, [pc, #16]	; (c0d00ce8 <io_seproxyhal_touch_address_ok+0x30>)
c0d00cd6:	4479      	add	r1, pc
c0d00cd8:	4620      	mov	r0, r4
c0d00cda:	4622      	mov	r2, r4
c0d00cdc:	f002 fd5c 	bl	c0d03798 <ux_menu_display>
    G_io_apdu_buffer[tx++] = 0x00;
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
    // Display back the original UX
    ui_idle();
    return 0; // do not redraw the widget
c0d00ce0:	4620      	mov	r0, r4
c0d00ce2:	bd10      	pop	{r4, pc}
c0d00ce4:	20001d4c 	.word	0x20001d4c
c0d00ce8:	00006652 	.word	0x00006652

c0d00cec <set_result_get_publicKey>:
        THROW(INVALID_PARAMETER);
    }
    return 0;
}

uint32_t set_result_get_publicKey() {
c0d00cec:	b5b0      	push	{r4, r5, r7, lr}
    uint32_t tx = 0;
    G_io_apdu_buffer[tx++] = 65;
c0d00cee:	4c10      	ldr	r4, [pc, #64]	; (c0d00d30 <set_result_get_publicKey+0x44>)
c0d00cf0:	2241      	movs	r2, #65	; 0x41
c0d00cf2:	7022      	strb	r2, [r4, #0]
    os_memmove(G_io_apdu_buffer + tx, tmpCtx.publicKeyContext.publicKey.W, 65);
c0d00cf4:	1c60      	adds	r0, r4, #1
c0d00cf6:	4d0f      	ldr	r5, [pc, #60]	; (c0d00d34 <set_result_get_publicKey+0x48>)
c0d00cf8:	4629      	mov	r1, r5
c0d00cfa:	3108      	adds	r1, #8
c0d00cfc:	f001 fe99 	bl	c0d02a32 <os_memmove>
    tx += 65;
    G_io_apdu_buffer[tx++] = 40;
c0d00d00:	2042      	movs	r0, #66	; 0x42
c0d00d02:	2228      	movs	r2, #40	; 0x28
c0d00d04:	5422      	strb	r2, [r4, r0]
    os_memmove(G_io_apdu_buffer + tx, tmpCtx.publicKeyContext.address, 40);
c0d00d06:	4620      	mov	r0, r4
c0d00d08:	3043      	adds	r0, #67	; 0x43
c0d00d0a:	4629      	mov	r1, r5
c0d00d0c:	314c      	adds	r1, #76	; 0x4c
c0d00d0e:	f001 fe90 	bl	c0d02a32 <os_memmove>
    tx += 40;
    if (tmpCtx.publicKeyContext.getChaincode) {
c0d00d12:	2095      	movs	r0, #149	; 0x95
c0d00d14:	5c29      	ldrb	r1, [r5, r0]
c0d00d16:	206b      	movs	r0, #107	; 0x6b
c0d00d18:	2900      	cmp	r1, #0
c0d00d1a:	d007      	beq.n	c0d00d2c <set_result_get_publicKey+0x40>
      os_memmove(G_io_apdu_buffer + tx, tmpCtx.publicKeyContext.chainCode, 32);
c0d00d1c:	346b      	adds	r4, #107	; 0x6b
c0d00d1e:	3575      	adds	r5, #117	; 0x75
c0d00d20:	2220      	movs	r2, #32
c0d00d22:	4620      	mov	r0, r4
c0d00d24:	4629      	mov	r1, r5
c0d00d26:	f001 fe84 	bl	c0d02a32 <os_memmove>
c0d00d2a:	208b      	movs	r0, #139	; 0x8b
      tx += 32;
    }
    return tx;
c0d00d2c:	bdb0      	pop	{r4, r5, r7, pc}
c0d00d2e:	46c0      	nop			; (mov r8, r8)
c0d00d30:	20001d4c 	.word	0x20001d4c
c0d00d34:	200019cc 	.word	0x200019cc

c0d00d38 <ui_address_nanos_button>:
    ui_idle();
    return 0; // do not redraw the widget
}

#if defined(TARGET_NANOS)
unsigned int ui_address_nanos_button(unsigned int button_mask, unsigned int button_mask_counter) {
c0d00d38:	b580      	push	{r7, lr}
    switch(button_mask) {
c0d00d3a:	490d      	ldr	r1, [pc, #52]	; (c0d00d70 <ui_address_nanos_button+0x38>)
c0d00d3c:	4288      	cmp	r0, r1
c0d00d3e:	d012      	beq.n	c0d00d66 <ui_address_nanos_button+0x2e>
c0d00d40:	490c      	ldr	r1, [pc, #48]	; (c0d00d74 <ui_address_nanos_button+0x3c>)
c0d00d42:	4288      	cmp	r0, r1
c0d00d44:	d111      	bne.n	c0d00d6a <ui_address_nanos_button+0x32>
    ui_idle();
    return 0; // do not redraw the widget
}

unsigned int io_seproxyhal_touch_address_cancel(const bagl_element_t *e) {
    G_io_apdu_buffer[0] = 0x69;
c0d00d46:	480c      	ldr	r0, [pc, #48]	; (c0d00d78 <ui_address_nanos_button+0x40>)
c0d00d48:	2169      	movs	r1, #105	; 0x69
c0d00d4a:	7001      	strb	r1, [r0, #0]
    G_io_apdu_buffer[1] = 0x85;
c0d00d4c:	2185      	movs	r1, #133	; 0x85
c0d00d4e:	7041      	strb	r1, [r0, #1]
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0d00d50:	2020      	movs	r0, #32
c0d00d52:	2102      	movs	r1, #2
c0d00d54:	f002 fa9e 	bl	c0d03294 <io_exchange>

void ui_idle(void) {
#if defined(TARGET_BLUE)
    UX_DISPLAY(ui_idle_blue, ui_idle_blue_prepro);
#elif defined(TARGET_NANOS)
    UX_MENU_DISPLAY(0, menu_main, NULL);
c0d00d58:	4908      	ldr	r1, [pc, #32]	; (c0d00d7c <ui_address_nanos_button+0x44>)
c0d00d5a:	4479      	add	r1, pc
c0d00d5c:	2000      	movs	r0, #0
c0d00d5e:	4602      	mov	r2, r0
c0d00d60:	f002 fd1a 	bl	c0d03798 <ux_menu_display>
c0d00d64:	e001      	b.n	c0d00d6a <ui_address_nanos_button+0x32>
        case BUTTON_EVT_RELEASED|BUTTON_LEFT: // CANCEL
			      io_seproxyhal_touch_address_cancel(NULL);
            break;

        case BUTTON_EVT_RELEASED|BUTTON_RIGHT: { // OK
			      io_seproxyhal_touch_address_ok(NULL);
c0d00d66:	f7ff ffa7 	bl	c0d00cb8 <io_seproxyhal_touch_address_ok>
			      break;
        }
    }
    return 0;
c0d00d6a:	2000      	movs	r0, #0
c0d00d6c:	bd80      	pop	{r7, pc}
c0d00d6e:	46c0      	nop			; (mov r8, r8)
c0d00d70:	80000002 	.word	0x80000002
c0d00d74:	80000001 	.word	0x80000001
c0d00d78:	20001d4c 	.word	0x20001d4c
c0d00d7c:	000065ce 	.word	0x000065ce

c0d00d80 <io_seproxyhal_touch_tx_ok>:
    G_io_apdu_buffer[0] = ((sw >> 8) & 0xff);
    G_io_apdu_buffer[1] = (sw & 0xff);
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
}

unsigned int io_seproxyhal_touch_tx_ok(const bagl_element_t *e) {
c0d00d80:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d00d82:	b0b1      	sub	sp, #196	; 0xc4
    uint8_t signature[100];
    uint8_t signatureLength;
    cx_ecfp_private_key_t privateKey;
    uint32_t tx = 0;
    uint8_t rLength, sLength, rOffset, sOffset;
    uint32_t v = getV(&tmpContent.txContent);
c0d00d84:	483a      	ldr	r0, [pc, #232]	; (c0d00e70 <io_seproxyhal_touch_tx_ok+0xf0>)
c0d00d86:	f005 ff94 	bl	c0d06cb2 <getV>
c0d00d8a:	9003      	str	r0, [sp, #12]
    os_perso_derive_node_bip32(CX_CURVE_256K1, tmpCtx.transactionContext.bip32Path,
                               tmpCtx.transactionContext.pathLength,
c0d00d8c:	4f39      	ldr	r7, [pc, #228]	; (c0d00e74 <io_seproxyhal_touch_tx_ok+0xf4>)
c0d00d8e:	783a      	ldrb	r2, [r7, #0]
c0d00d90:	2100      	movs	r1, #0
    uint8_t signatureLength;
    cx_ecfp_private_key_t privateKey;
    uint32_t tx = 0;
    uint8_t rLength, sLength, rOffset, sOffset;
    uint32_t v = getV(&tmpContent.txContent);
    os_perso_derive_node_bip32(CX_CURVE_256K1, tmpCtx.transactionContext.bip32Path,
c0d00d92:	9104      	str	r1, [sp, #16]
c0d00d94:	4668      	mov	r0, sp
c0d00d96:	6001      	str	r1, [r0, #0]
c0d00d98:	1d39      	adds	r1, r7, #4
c0d00d9a:	2621      	movs	r6, #33	; 0x21
c0d00d9c:	ac29      	add	r4, sp, #164	; 0xa4
c0d00d9e:	4630      	mov	r0, r6
c0d00da0:	4623      	mov	r3, r4
c0d00da2:	f003 f90f 	bl	c0d03fc4 <os_perso_derive_node_bip32>
                               tmpCtx.transactionContext.pathLength,
                               privateKeyData, NULL);
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32,
c0d00da6:	2520      	movs	r5, #32
c0d00da8:	ab06      	add	r3, sp, #24
c0d00daa:	4630      	mov	r0, r6
c0d00dac:	4621      	mov	r1, r4
c0d00dae:	462a      	mov	r2, r5
c0d00db0:	461e      	mov	r6, r3
c0d00db2:	f003 f881 	bl	c0d03eb8 <cx_ecfp_init_private_key>
                                 &privateKey);
    os_memset(privateKeyData, 0, sizeof(privateKeyData));
c0d00db6:	4620      	mov	r0, r4
c0d00db8:	9c04      	ldr	r4, [sp, #16]
c0d00dba:	4621      	mov	r1, r4
c0d00dbc:	462a      	mov	r2, r5
c0d00dbe:	f001 fe2f 	bl	c0d02a20 <os_memset>
    unsigned int info = 0;
c0d00dc2:	9405      	str	r4, [sp, #20]
c0d00dc4:	a805      	add	r0, sp, #20
    signatureLength =
        cx_ecdsa_sign(&privateKey, CX_RND_RFC6979 | CX_LAST, CX_SHA256,
c0d00dc6:	4669      	mov	r1, sp
c0d00dc8:	6088      	str	r0, [r1, #8]
c0d00dca:	a810      	add	r0, sp, #64	; 0x40
c0d00dcc:	6048      	str	r0, [r1, #4]
c0d00dce:	600d      	str	r5, [r1, #0]
c0d00dd0:	372c      	adds	r7, #44	; 0x2c
c0d00dd2:	4929      	ldr	r1, [pc, #164]	; (c0d00e78 <io_seproxyhal_touch_tx_ok+0xf8>)
c0d00dd4:	2203      	movs	r2, #3
c0d00dd6:	4635      	mov	r5, r6
c0d00dd8:	4628      	mov	r0, r5
c0d00dda:	463b      	mov	r3, r7
c0d00ddc:	f7ff f9f6 	bl	c0d001cc <cx_ecdsa_sign_X>
                      tmpCtx.transactionContext.hash,
                      sizeof(tmpCtx.transactionContext.hash), signature, &info);
    os_memset(&privateKey, 0, sizeof(privateKey));
c0d00de0:	2228      	movs	r2, #40	; 0x28
c0d00de2:	4628      	mov	r0, r5
c0d00de4:	4621      	mov	r1, r4
c0d00de6:	f001 fe1b 	bl	c0d02a20 <os_memset>
    // Parity is present in the sequence tag in the legacy API
    if (tmpContent.txContent.vLength == 0) {
c0d00dea:	207c      	movs	r0, #124	; 0x7c
c0d00dec:	4920      	ldr	r1, [pc, #128]	; (c0d00e70 <io_seproxyhal_touch_tx_ok+0xf0>)
c0d00dee:	5c09      	ldrb	r1, [r1, r0]
c0d00df0:	201b      	movs	r0, #27
c0d00df2:	2900      	cmp	r1, #0
c0d00df4:	d002      	beq.n	c0d00dfc <io_seproxyhal_touch_tx_ok+0x7c>
      G_io_apdu_buffer[0] = 27;
    }
    else {
      // New API
      // Note that this is wrong for a large v, but the client can always recover
      G_io_apdu_buffer[0] = (v * 2) + 35;
c0d00df6:	9803      	ldr	r0, [sp, #12]
c0d00df8:	0040      	lsls	r0, r0, #1
c0d00dfa:	3023      	adds	r0, #35	; 0x23
c0d00dfc:	4b1f      	ldr	r3, [pc, #124]	; (c0d00e7c <io_seproxyhal_touch_tx_ok+0xfc>)
c0d00dfe:	7018      	strb	r0, [r3, #0]
    }
    if (info & CX_ECCINFO_PARITY_ODD) {
c0d00e00:	9a05      	ldr	r2, [sp, #20]
c0d00e02:	2101      	movs	r1, #1
c0d00e04:	420a      	tst	r2, r1
c0d00e06:	d001      	beq.n	c0d00e0c <io_seproxyhal_touch_tx_ok+0x8c>
      G_io_apdu_buffer[0]++;
c0d00e08:	1c40      	adds	r0, r0, #1
c0d00e0a:	7018      	strb	r0, [r3, #0]
    }
    if (info & CX_ECCINFO_xGTn) {
c0d00e0c:	0792      	lsls	r2, r2, #30
c0d00e0e:	d501      	bpl.n	c0d00e14 <io_seproxyhal_touch_tx_ok+0x94>
      G_io_apdu_buffer[0] += 2;
c0d00e10:	1c80      	adds	r0, r0, #2
c0d00e12:	7018      	strb	r0, [r3, #0]
c0d00e14:	a810      	add	r0, sp, #64	; 0x40
    }
    rLength = signature[3];
    sLength = signature[4 + rLength + 1];
c0d00e16:	78c6      	ldrb	r6, [r0, #3]
      G_io_apdu_buffer[0]++;
    }
    if (info & CX_ECCINFO_xGTn) {
      G_io_apdu_buffer[0] += 2;
    }
    rLength = signature[3];
c0d00e18:	2e21      	cmp	r6, #33	; 0x21
c0d00e1a:	d000      	beq.n	c0d00e1e <io_seproxyhal_touch_tx_ok+0x9e>
c0d00e1c:	9904      	ldr	r1, [sp, #16]
    sLength = signature[4 + rLength + 1];
    rOffset = (rLength == 33 ? 1 : 0);
    sOffset = (sLength == 33 ? 1 : 0);
    os_memmove(G_io_apdu_buffer + 1, signature + 4 + rOffset, 32);
c0d00e1e:	1d07      	adds	r7, r0, #4
c0d00e20:	4339      	orrs	r1, r7
c0d00e22:	1980      	adds	r0, r0, r6
    }
    if (info & CX_ECCINFO_xGTn) {
      G_io_apdu_buffer[0] += 2;
    }
    rLength = signature[3];
    sLength = signature[4 + rLength + 1];
c0d00e24:	7944      	ldrb	r4, [r0, #5]
    rOffset = (rLength == 33 ? 1 : 0);
    sOffset = (sLength == 33 ? 1 : 0);
    os_memmove(G_io_apdu_buffer + 1, signature + 4 + rOffset, 32);
c0d00e26:	1c58      	adds	r0, r3, #1
c0d00e28:	2520      	movs	r5, #32
c0d00e2a:	462a      	mov	r2, r5
c0d00e2c:	f001 fe01 	bl	c0d02a32 <os_memmove>
    os_memmove(G_io_apdu_buffer + 1 + 32, signature + 4 + rLength + 2 + sOffset,
c0d00e30:	19b9      	adds	r1, r7, r6
c0d00e32:	1c48      	adds	r0, r1, #1
c0d00e34:	2c21      	cmp	r4, #33	; 0x21
c0d00e36:	d000      	beq.n	c0d00e3a <io_seproxyhal_touch_tx_ok+0xba>
c0d00e38:	4608      	mov	r0, r1
c0d00e3a:	1c81      	adds	r1, r0, #2
c0d00e3c:	480f      	ldr	r0, [pc, #60]	; (c0d00e7c <io_seproxyhal_touch_tx_ok+0xfc>)
c0d00e3e:	4606      	mov	r6, r0
c0d00e40:	3021      	adds	r0, #33	; 0x21
c0d00e42:	462a      	mov	r2, r5
c0d00e44:	f001 fdf5 	bl	c0d02a32 <os_memmove>
               32);
    tx = 65;
    G_io_apdu_buffer[tx++] = 0x90;
c0d00e48:	2041      	movs	r0, #65	; 0x41
c0d00e4a:	2190      	movs	r1, #144	; 0x90
c0d00e4c:	5431      	strb	r1, [r6, r0]
    G_io_apdu_buffer[tx++] = 0x00;
c0d00e4e:	2042      	movs	r0, #66	; 0x42
c0d00e50:	9c04      	ldr	r4, [sp, #16]
c0d00e52:	5434      	strb	r4, [r6, r0]

    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0d00e54:	2143      	movs	r1, #67	; 0x43
c0d00e56:	4628      	mov	r0, r5
c0d00e58:	f002 fa1c 	bl	c0d03294 <io_exchange>

void ui_idle(void) {
#if defined(TARGET_BLUE)
    UX_DISPLAY(ui_idle_blue, ui_idle_blue_prepro);
#elif defined(TARGET_NANOS)
    UX_MENU_DISPLAY(0, menu_main, NULL);
c0d00e5c:	4908      	ldr	r1, [pc, #32]	; (c0d00e80 <io_seproxyhal_touch_tx_ok+0x100>)
c0d00e5e:	4479      	add	r1, pc
c0d00e60:	4620      	mov	r0, r4
c0d00e62:	4622      	mov	r2, r4
c0d00e64:	f002 fc98 	bl	c0d03798 <ux_menu_display>

    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
    // Display back the original UX
    ui_idle();
    return 0; // do not redraw the widget
c0d00e68:	4620      	mov	r0, r4
c0d00e6a:	b031      	add	sp, #196	; 0xc4
c0d00e6c:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d00e6e:	46c0      	nop			; (mov r8, r8)
c0d00e70:	2000194c 	.word	0x2000194c
c0d00e74:	200019cc 	.word	0x200019cc
c0d00e78:	00000601 	.word	0x00000601
c0d00e7c:	20001d4c 	.word	0x20001d4c
c0d00e80:	000064ca 	.word	0x000064ca

c0d00e84 <io_seproxyhal_touch_signMessage_ok>:
    ui_idle();
    return 0; // do not redraw the widget
}


unsigned int io_seproxyhal_touch_signMessage_ok(const bagl_element_t *e) {
c0d00e84:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d00e86:	b0b3      	sub	sp, #204	; 0xcc
    cx_ecfp_private_key_t privateKey;
    uint32_t tx = 0;
    uint8_t rLength, sLength, rOffset, sOffset;
    os_perso_derive_node_bip32(
        CX_CURVE_256K1, tmpCtx.messageSigningContext.bip32Path,
        tmpCtx.messageSigningContext.pathLength, privateKeyData, NULL);
c0d00e88:	4e30      	ldr	r6, [pc, #192]	; (c0d00f4c <io_seproxyhal_touch_signMessage_ok+0xc8>)
c0d00e8a:	7832      	ldrb	r2, [r6, #0]
c0d00e8c:	2100      	movs	r1, #0
    uint8_t signature[100];
    uint8_t signatureLength;
    cx_ecfp_private_key_t privateKey;
    uint32_t tx = 0;
    uint8_t rLength, sLength, rOffset, sOffset;
    os_perso_derive_node_bip32(
c0d00e8e:	9106      	str	r1, [sp, #24]
c0d00e90:	4668      	mov	r0, sp
c0d00e92:	6001      	str	r1, [r0, #0]
c0d00e94:	1d31      	adds	r1, r6, #4
c0d00e96:	2421      	movs	r4, #33	; 0x21
c0d00e98:	ad2b      	add	r5, sp, #172	; 0xac
c0d00e9a:	4620      	mov	r0, r4
c0d00e9c:	462b      	mov	r3, r5
c0d00e9e:	f003 f891 	bl	c0d03fc4 <os_perso_derive_node_bip32>
c0d00ea2:	2720      	movs	r7, #32
c0d00ea4:	ab08      	add	r3, sp, #32
        CX_CURVE_256K1, tmpCtx.messageSigningContext.bip32Path,
        tmpCtx.messageSigningContext.pathLength, privateKeyData, NULL);
    cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
c0d00ea6:	9304      	str	r3, [sp, #16]
c0d00ea8:	4620      	mov	r0, r4
c0d00eaa:	4629      	mov	r1, r5
c0d00eac:	463a      	mov	r2, r7
c0d00eae:	f003 f803 	bl	c0d03eb8 <cx_ecfp_init_private_key>
    os_memset(privateKeyData, 0, sizeof(privateKeyData));
c0d00eb2:	4628      	mov	r0, r5
c0d00eb4:	9c06      	ldr	r4, [sp, #24]
c0d00eb6:	4621      	mov	r1, r4
c0d00eb8:	463a      	mov	r2, r7
c0d00eba:	f001 fdb1 	bl	c0d02a20 <os_memset>
    unsigned int info = 0;
c0d00ebe:	9407      	str	r4, [sp, #28]
c0d00ec0:	a807      	add	r0, sp, #28
    signatureLength =
        cx_ecdsa_sign(&privateKey, CX_RND_RFC6979 | CX_LAST, CX_SHA256,
c0d00ec2:	4669      	mov	r1, sp
c0d00ec4:	6088      	str	r0, [r1, #8]
c0d00ec6:	ad12      	add	r5, sp, #72	; 0x48
c0d00ec8:	604d      	str	r5, [r1, #4]
c0d00eca:	9705      	str	r7, [sp, #20]
c0d00ecc:	600f      	str	r7, [r1, #0]
c0d00ece:	362c      	adds	r6, #44	; 0x2c
c0d00ed0:	491f      	ldr	r1, [pc, #124]	; (c0d00f50 <io_seproxyhal_touch_signMessage_ok+0xcc>)
c0d00ed2:	2403      	movs	r4, #3
c0d00ed4:	9f04      	ldr	r7, [sp, #16]
c0d00ed6:	4638      	mov	r0, r7
c0d00ed8:	4622      	mov	r2, r4
c0d00eda:	4633      	mov	r3, r6
c0d00edc:	f7ff f976 	bl	c0d001cc <cx_ecdsa_sign_X>
                      tmpCtx.messageSigningContext.hash,
                      sizeof(tmpCtx.messageSigningContext.hash), signature, &info);
    os_memset(&privateKey, 0, sizeof(privateKey));
c0d00ee0:	2228      	movs	r2, #40	; 0x28
c0d00ee2:	4638      	mov	r0, r7
c0d00ee4:	9906      	ldr	r1, [sp, #24]
c0d00ee6:	f001 fd9b 	bl	c0d02a20 <os_memset>
    G_io_apdu_buffer[0] = 27;
    if (info & CX_ECCINFO_PARITY_ODD) {
c0d00eea:	9807      	ldr	r0, [sp, #28]
c0d00eec:	4020      	ands	r0, r4
      G_io_apdu_buffer[0]++;
    }
    if (info & CX_ECCINFO_xGTn) {
c0d00eee:	301b      	adds	r0, #27
                      tmpCtx.messageSigningContext.hash,
                      sizeof(tmpCtx.messageSigningContext.hash), signature, &info);
    os_memset(&privateKey, 0, sizeof(privateKey));
    G_io_apdu_buffer[0] = 27;
    if (info & CX_ECCINFO_PARITY_ODD) {
      G_io_apdu_buffer[0]++;
c0d00ef0:	4c18      	ldr	r4, [pc, #96]	; (c0d00f54 <io_seproxyhal_touch_signMessage_ok+0xd0>)
c0d00ef2:	7020      	strb	r0, [r4, #0]
    }
    rLength = signature[3];
    sLength = signature[4 + rLength + 1];
    rOffset = (rLength == 33 ? 1 : 0);
    sOffset = (sLength == 33 ? 1 : 0);
    os_memmove(G_io_apdu_buffer + 1, signature + 4 + rOffset, 32);
c0d00ef4:	1d69      	adds	r1, r5, #5
c0d00ef6:	1d2e      	adds	r6, r5, #4
      G_io_apdu_buffer[0]++;
    }
    if (info & CX_ECCINFO_xGTn) {
      G_io_apdu_buffer[0] += 2;
    }
    rLength = signature[3];
c0d00ef8:	78ef      	ldrb	r7, [r5, #3]
    sLength = signature[4 + rLength + 1];
    rOffset = (rLength == 33 ? 1 : 0);
    sOffset = (sLength == 33 ? 1 : 0);
    os_memmove(G_io_apdu_buffer + 1, signature + 4 + rOffset, 32);
c0d00efa:	2f21      	cmp	r7, #33	; 0x21
c0d00efc:	d000      	beq.n	c0d00f00 <io_seproxyhal_touch_signMessage_ok+0x7c>
c0d00efe:	4631      	mov	r1, r6
c0d00f00:	19e8      	adds	r0, r5, r7
    }
    if (info & CX_ECCINFO_xGTn) {
      G_io_apdu_buffer[0] += 2;
    }
    rLength = signature[3];
    sLength = signature[4 + rLength + 1];
c0d00f02:	7945      	ldrb	r5, [r0, #5]
    rOffset = (rLength == 33 ? 1 : 0);
    sOffset = (sLength == 33 ? 1 : 0);
    os_memmove(G_io_apdu_buffer + 1, signature + 4 + rOffset, 32);
c0d00f04:	1c60      	adds	r0, r4, #1
c0d00f06:	9a05      	ldr	r2, [sp, #20]
c0d00f08:	f001 fd93 	bl	c0d02a32 <os_memmove>
    os_memmove(G_io_apdu_buffer + 1 + 32, signature + 4 + rLength + 2 + sOffset,
c0d00f0c:	19f1      	adds	r1, r6, r7
c0d00f0e:	1c48      	adds	r0, r1, #1
c0d00f10:	2d21      	cmp	r5, #33	; 0x21
c0d00f12:	d000      	beq.n	c0d00f16 <io_seproxyhal_touch_signMessage_ok+0x92>
c0d00f14:	4608      	mov	r0, r1
c0d00f16:	1c81      	adds	r1, r0, #2
c0d00f18:	4620      	mov	r0, r4
c0d00f1a:	3021      	adds	r0, #33	; 0x21
c0d00f1c:	9e05      	ldr	r6, [sp, #20]
c0d00f1e:	4632      	mov	r2, r6
c0d00f20:	f001 fd87 	bl	c0d02a32 <os_memmove>
               32);
    tx = 65;
    G_io_apdu_buffer[tx++] = 0x90;
c0d00f24:	2041      	movs	r0, #65	; 0x41
c0d00f26:	2190      	movs	r1, #144	; 0x90
c0d00f28:	5421      	strb	r1, [r4, r0]
    G_io_apdu_buffer[tx++] = 0x00;
c0d00f2a:	2042      	movs	r0, #66	; 0x42
c0d00f2c:	9d06      	ldr	r5, [sp, #24]
c0d00f2e:	5425      	strb	r5, [r4, r0]
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
c0d00f30:	2143      	movs	r1, #67	; 0x43
c0d00f32:	4630      	mov	r0, r6
c0d00f34:	f002 f9ae 	bl	c0d03294 <io_exchange>

void ui_idle(void) {
#if defined(TARGET_BLUE)
    UX_DISPLAY(ui_idle_blue, ui_idle_blue_prepro);
#elif defined(TARGET_NANOS)
    UX_MENU_DISPLAY(0, menu_main, NULL);
c0d00f38:	4907      	ldr	r1, [pc, #28]	; (c0d00f58 <io_seproxyhal_touch_signMessage_ok+0xd4>)
c0d00f3a:	4479      	add	r1, pc
c0d00f3c:	4628      	mov	r0, r5
c0d00f3e:	462a      	mov	r2, r5
c0d00f40:	f002 fc2a 	bl	c0d03798 <ux_menu_display>
    G_io_apdu_buffer[tx++] = 0x00;
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, tx);
    // Display back the original UX
    ui_idle();
    return 0; // do not redraw the widget
c0d00f44:	4628      	mov	r0, r5
c0d00f46:	b033      	add	sp, #204	; 0xcc
c0d00f48:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d00f4a:	46c0      	nop			; (mov r8, r8)
c0d00f4c:	200019cc 	.word	0x200019cc
c0d00f50:	00000601 	.word	0x00000601
c0d00f54:	20001d4c 	.word	0x20001d4c
c0d00f58:	000063ee 	.word	0x000063ee

c0d00f5c <io_seproxyhal_touch_data_ok>:
    // Display back the original UX
    ui_idle();
    return 0; // do not redraw the widget
}

unsigned int io_seproxyhal_touch_data_ok(const bagl_element_t *e) {
c0d00f5c:	b510      	push	{r4, lr}
    parserStatus_e txResult = USTREAM_FINISHED;
    txResult = continueTx(&txContext);
c0d00f5e:	4819      	ldr	r0, [pc, #100]	; (c0d00fc4 <io_seproxyhal_touch_data_ok+0x68>)
c0d00f60:	f7ff fb72 	bl	c0d00648 <continueTx>
    return 0;
}
#endif // #if defined(TARGET_NANOS)

void io_seproxyhal_send_status(uint32_t sw) {
    G_io_apdu_buffer[0] = ((sw >> 8) & 0xff);
c0d00f64:	2180      	movs	r1, #128	; 0x80
}

unsigned int io_seproxyhal_touch_data_ok(const bagl_element_t *e) {
    parserStatus_e txResult = USTREAM_FINISHED;
    txResult = continueTx(&txContext);
    switch (txResult) {
c0d00f66:	2801      	cmp	r0, #1
c0d00f68:	dc04      	bgt.n	c0d00f74 <io_seproxyhal_touch_data_ok+0x18>
c0d00f6a:	2800      	cmp	r0, #0
c0d00f6c:	d014      	beq.n	c0d00f98 <io_seproxyhal_touch_data_ok+0x3c>
c0d00f6e:	2801      	cmp	r0, #1
c0d00f70:	d025      	beq.n	c0d00fbe <io_seproxyhal_touch_data_ok+0x62>
c0d00f72:	e002      	b.n	c0d00f7a <io_seproxyhal_touch_data_ok+0x1e>
c0d00f74:	2802      	cmp	r0, #2
c0d00f76:	d01f      	beq.n	c0d00fb8 <io_seproxyhal_touch_data_ok+0x5c>
c0d00f78:	2803      	cmp	r0, #3
c0d00f7a:	4813      	ldr	r0, [pc, #76]	; (c0d00fc8 <io_seproxyhal_touch_data_ok+0x6c>)
c0d00f7c:	226a      	movs	r2, #106	; 0x6a
c0d00f7e:	7002      	strb	r2, [r0, #0]
c0d00f80:	7041      	strb	r1, [r0, #1]
c0d00f82:	2020      	movs	r0, #32
c0d00f84:	2102      	movs	r1, #2
c0d00f86:	f002 f985 	bl	c0d03294 <io_exchange>
c0d00f8a:	4910      	ldr	r1, [pc, #64]	; (c0d00fcc <io_seproxyhal_touch_data_ok+0x70>)
c0d00f8c:	4479      	add	r1, pc
c0d00f8e:	2000      	movs	r0, #0
c0d00f90:	4602      	mov	r2, r0
c0d00f92:	f002 fc01 	bl	c0d03798 <ux_menu_display>
c0d00f96:	e012      	b.n	c0d00fbe <io_seproxyhal_touch_data_ok+0x62>
    return 0;
}
#endif // #if defined(TARGET_NANOS)

void io_seproxyhal_send_status(uint32_t sw) {
    G_io_apdu_buffer[0] = ((sw >> 8) & 0xff);
c0d00f98:	3110      	adds	r1, #16
c0d00f9a:	480b      	ldr	r0, [pc, #44]	; (c0d00fc8 <io_seproxyhal_touch_data_ok+0x6c>)
c0d00f9c:	7001      	strb	r1, [r0, #0]
c0d00f9e:	2400      	movs	r4, #0
    G_io_apdu_buffer[1] = (sw & 0xff);
c0d00fa0:	7044      	strb	r4, [r0, #1]
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0d00fa2:	2020      	movs	r0, #32
c0d00fa4:	2102      	movs	r1, #2
c0d00fa6:	f002 f975 	bl	c0d03294 <io_exchange>

void ui_idle(void) {
#if defined(TARGET_BLUE)
    UX_DISPLAY(ui_idle_blue, ui_idle_blue_prepro);
#elif defined(TARGET_NANOS)
    UX_MENU_DISPLAY(0, menu_main, NULL);
c0d00faa:	4909      	ldr	r1, [pc, #36]	; (c0d00fd0 <io_seproxyhal_touch_data_ok+0x74>)
c0d00fac:	4479      	add	r1, pc
c0d00fae:	4620      	mov	r0, r4
c0d00fb0:	4622      	mov	r2, r4
c0d00fb2:	f002 fbf1 	bl	c0d03798 <ux_menu_display>
c0d00fb6:	e002      	b.n	c0d00fbe <io_seproxyhal_touch_data_ok+0x62>
        io_seproxyhal_send_status(0x6A80);
        ui_idle();
    }

    if (txResult == USTREAM_FINISHED) {
        finalizeParsing(false);
c0d00fb8:	2000      	movs	r0, #0
c0d00fba:	f000 f80b 	bl	c0d00fd4 <finalizeParsing>
    }

    return 0;
c0d00fbe:	2000      	movs	r0, #0
c0d00fc0:	bd10      	pop	{r4, pc}
c0d00fc2:	46c0      	nop			; (mov r8, r8)
c0d00fc4:	20001a64 	.word	0x20001a64
c0d00fc8:	20001d4c 	.word	0x20001d4c
c0d00fcc:	0000639c 	.word	0x0000639c
c0d00fd0:	0000637c 	.word	0x0000637c

c0d00fd4 <finalizeParsing>:
    *flags |= IO_ASYNCH_REPLY;
  }
#endif // NO_CONSENT
}

void finalizeParsing(bool direct) {
c0d00fd4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d00fd6:	b0ab      	sub	sp, #172	; 0xac
c0d00fd8:	4604      	mov	r4, r0
  uint256_t gasPrice, startGas, uint256;
  uint32_t i;
  uint8_t address[41];
  uint8_t decimals = WEI_TO_ETHER;
  uint8_t *ticker = (uint8_t *)PIC(chainConfig->coinName);
c0d00fda:	4fb9      	ldr	r7, [pc, #740]	; (c0d012c0 <finalizeParsing+0x2ec>)
c0d00fdc:	6838      	ldr	r0, [r7, #0]
c0d00fde:	6800      	ldr	r0, [r0, #0]
c0d00fe0:	f002 fe80 	bl	c0d03ce4 <pic>
c0d00fe4:	9006      	str	r0, [sp, #24]
  uint8_t *feeTicker = (uint8_t *)PIC(chainConfig->coinName);
c0d00fe6:	6838      	ldr	r0, [r7, #0]
c0d00fe8:	6800      	ldr	r0, [r0, #0]
c0d00fea:	f002 fe7b 	bl	c0d03ce4 <pic>
c0d00fee:	9004      	str	r0, [sp, #16]
c0d00ff0:	20d5      	movs	r0, #213	; 0xd5
c0d00ff2:	01c5      	lsls	r5, r0, #7
  uint8_t tickerOffset = 0;

  // Verify the chain
  if (chainConfig->chainId != 0) {
c0d00ff4:	6838      	ldr	r0, [r7, #0]
c0d00ff6:	6840      	ldr	r0, [r0, #4]
}
#endif // #if defined(TARGET_NANOS)

void io_seproxyhal_send_status(uint32_t sw) {
    G_io_apdu_buffer[0] = ((sw >> 8) & 0xff);
    G_io_apdu_buffer[1] = (sw & 0xff);
c0d00ff8:	2680      	movs	r6, #128	; 0x80
  uint8_t *ticker = (uint8_t *)PIC(chainConfig->coinName);
  uint8_t *feeTicker = (uint8_t *)PIC(chainConfig->coinName);
  uint8_t tickerOffset = 0;

  // Verify the chain
  if (chainConfig->chainId != 0) {
c0d00ffa:	2800      	cmp	r0, #0
c0d00ffc:	d006      	beq.n	c0d0100c <finalizeParsing+0x38>
    uint32_t v = getV(&tmpContent.txContent);
c0d00ffe:	48b1      	ldr	r0, [pc, #708]	; (c0d012c4 <finalizeParsing+0x2f0>)
c0d01000:	f005 fe57 	bl	c0d06cb2 <getV>
    if (chainConfig->chainId != v) {
c0d01004:	6839      	ldr	r1, [r7, #0]
c0d01006:	6849      	ldr	r1, [r1, #4]
c0d01008:	4281      	cmp	r1, r0
c0d0100a:	d13f      	bne.n	c0d0108c <finalizeParsing+0xb8>
            return;
        }
    }
  }
  // Store the hash
  cx_hash((cx_hash_t *)&sha3, CX_LAST, tmpCtx.transactionContext.hash, 0, tmpCtx.transactionContext.hash);
c0d0100c:	4aaf      	ldr	r2, [pc, #700]	; (c0d012cc <finalizeParsing+0x2f8>)
c0d0100e:	322c      	adds	r2, #44	; 0x2c
c0d01010:	4668      	mov	r0, sp
c0d01012:	6002      	str	r2, [r0, #0]
c0d01014:	48ae      	ldr	r0, [pc, #696]	; (c0d012d0 <finalizeParsing+0x2fc>)
c0d01016:	2101      	movs	r1, #1
c0d01018:	2700      	movs	r7, #0
c0d0101a:	9103      	str	r1, [sp, #12]
c0d0101c:	463b      	mov	r3, r7
c0d0101e:	f7ff f865 	bl	c0d000ec <cx_hash_X>
    // If there is a token to process, check if it is well known
    if (tokenProvisioned) {
c0d01022:	48ac      	ldr	r0, [pc, #688]	; (c0d012d4 <finalizeParsing+0x300>)
c0d01024:	7800      	ldrb	r0, [r0, #0]
c0d01026:	2800      	cmp	r0, #0
c0d01028:	d023      	beq.n	c0d01072 <finalizeParsing+0x9e>
c0d0102a:	2512      	movs	r5, #18
        tokenDefinition_t *currentToken = getKnownToken();
c0d0102c:	f000 fa40 	bl	c0d014b0 <getKnownToken>
c0d01030:	4604      	mov	r4, r0
        if (currentToken != NULL) {
c0d01032:	2c00      	cmp	r4, #0
c0d01034:	d03c      	beq.n	c0d010b0 <finalizeParsing+0xdc>
            dataPresent = false;
c0d01036:	48a8      	ldr	r0, [pc, #672]	; (c0d012d8 <finalizeParsing+0x304>)
c0d01038:	7007      	strb	r7, [r0, #0]
            decimals = currentToken->decimals;
c0d0103a:	7fa0      	ldrb	r0, [r4, #30]
            ticker = currentToken->ticker;
            tmpContent.txContent.destinationLength = 20;
c0d0103c:	9002      	str	r0, [sp, #8]
c0d0103e:	2077      	movs	r0, #119	; 0x77
c0d01040:	49a0      	ldr	r1, [pc, #640]	; (c0d012c4 <finalizeParsing+0x2f0>)
c0d01042:	2214      	movs	r2, #20
c0d01044:	540a      	strb	r2, [r1, r0]
            os_memmove(tmpContent.txContent.destination, dataContext.tokenContext.data + 4 + 12, 20);
c0d01046:	4608      	mov	r0, r1
c0d01048:	460e      	mov	r6, r1
c0d0104a:	3063      	adds	r0, #99	; 0x63
c0d0104c:	4da3      	ldr	r5, [pc, #652]	; (c0d012dc <finalizeParsing+0x308>)
c0d0104e:	4629      	mov	r1, r5
c0d01050:	3110      	adds	r1, #16
c0d01052:	f001 fcee 	bl	c0d02a32 <os_memmove>
            os_memmove(tmpContent.txContent.value.value, dataContext.tokenContext.data + 4 + 32, 32);
c0d01056:	4630      	mov	r0, r6
c0d01058:	3042      	adds	r0, #66	; 0x42
c0d0105a:	3524      	adds	r5, #36	; 0x24
c0d0105c:	2620      	movs	r6, #32
c0d0105e:	4629      	mov	r1, r5
c0d01060:	4632      	mov	r2, r6
c0d01062:	f001 fce6 	bl	c0d02a32 <os_memmove>
            tmpContent.txContent.value.length = 32;
c0d01066:	2062      	movs	r0, #98	; 0x62
c0d01068:	4996      	ldr	r1, [pc, #600]	; (c0d012c4 <finalizeParsing+0x2f0>)
c0d0106a:	540e      	strb	r6, [r1, r0]
    if (tokenProvisioned) {
        tokenDefinition_t *currentToken = getKnownToken();
        if (currentToken != NULL) {
            dataPresent = false;
            decimals = currentToken->decimals;
            ticker = currentToken->ticker;
c0d0106c:	3414      	adds	r4, #20
c0d0106e:	9406      	str	r4, [sp, #24]
c0d01070:	e01f      	b.n	c0d010b2 <finalizeParsing+0xde>
            os_memmove(tmpContent.txContent.value.value, dataContext.tokenContext.data + 4 + 32, 32);
            tmpContent.txContent.value.length = 32;
        }
    }
    else {
      if (dataPresent && !N_storage.dataAllowed) {
c0d01072:	4899      	ldr	r0, [pc, #612]	; (c0d012d8 <finalizeParsing+0x304>)
c0d01074:	7800      	ldrb	r0, [r0, #0]
c0d01076:	2112      	movs	r1, #18
c0d01078:	9102      	str	r1, [sp, #8]
c0d0107a:	2800      	cmp	r0, #0
c0d0107c:	d019      	beq.n	c0d010b2 <finalizeParsing+0xde>
c0d0107e:	48a2      	ldr	r0, [pc, #648]	; (c0d01308 <finalizeParsing+0x334>)
c0d01080:	4478      	add	r0, pc
c0d01082:	f002 fe2f 	bl	c0d03ce4 <pic>
c0d01086:	7800      	ldrb	r0, [r0, #0]
c0d01088:	2800      	cmp	r0, #0
c0d0108a:	d112      	bne.n	c0d010b2 <finalizeParsing+0xde>
c0d0108c:	2c01      	cmp	r4, #1
c0d0108e:	d100      	bne.n	c0d01092 <finalizeParsing+0xbe>
c0d01090:	e112      	b.n	c0d012b8 <finalizeParsing+0x2e4>
c0d01092:	488d      	ldr	r0, [pc, #564]	; (c0d012c8 <finalizeParsing+0x2f4>)
c0d01094:	216a      	movs	r1, #106	; 0x6a
c0d01096:	7001      	strb	r1, [r0, #0]
c0d01098:	7046      	strb	r6, [r0, #1]
c0d0109a:	2020      	movs	r0, #32
c0d0109c:	2102      	movs	r1, #2
c0d0109e:	f002 f8f9 	bl	c0d03294 <io_exchange>
c0d010a2:	4998      	ldr	r1, [pc, #608]	; (c0d01304 <finalizeParsing+0x330>)
c0d010a4:	4479      	add	r1, pc
c0d010a6:	2000      	movs	r0, #0
c0d010a8:	4602      	mov	r2, r0
c0d010aa:	f002 fb75 	bl	c0d03798 <ux_menu_display>
c0d010ae:	e101      	b.n	c0d012b4 <finalizeParsing+0x2e0>
c0d010b0:	9502      	str	r5, [sp, #8]
            return;
          }
      }
    }
  // Add address
  if (tmpContent.txContent.destinationLength != 0) {
c0d010b2:	2077      	movs	r0, #119	; 0x77
c0d010b4:	4e83      	ldr	r6, [pc, #524]	; (c0d012c4 <finalizeParsing+0x2f0>)
c0d010b6:	5c30      	ldrb	r0, [r6, r0]
c0d010b8:	2800      	cmp	r0, #0
c0d010ba:	d013      	beq.n	c0d010e4 <finalizeParsing+0x110>
    getEthAddressStringFromBinary(tmpContent.txContent.destination, address, &sha3);
c0d010bc:	4630      	mov	r0, r6
c0d010be:	3063      	adds	r0, #99	; 0x63
c0d010c0:	ac07      	add	r4, sp, #28
c0d010c2:	4a83      	ldr	r2, [pc, #524]	; (c0d012d0 <finalizeParsing+0x2fc>)
c0d010c4:	4621      	mov	r1, r4
c0d010c6:	f7ff fb9f 	bl	c0d00808 <getEthAddressStringFromBinary>
    os_memmove((unsigned char *)(addressSummary + 6), "...", 3);
    os_memmove((unsigned char *)(addressSummary + 9), address + 40 - 4, 4);
    addressSummary[13] = '\0';
    */

    strings.common.fullAddress[0] = '0';
c0d010ca:	4d85      	ldr	r5, [pc, #532]	; (c0d012e0 <finalizeParsing+0x30c>)
c0d010cc:	2030      	movs	r0, #48	; 0x30
c0d010ce:	7028      	strb	r0, [r5, #0]
    strings.common.fullAddress[1] = 'x';
c0d010d0:	2078      	movs	r0, #120	; 0x78
c0d010d2:	7068      	strb	r0, [r5, #1]
    os_memmove((unsigned char *)strings.common.fullAddress+2, address, 40);
c0d010d4:	1ca8      	adds	r0, r5, #2
c0d010d6:	2228      	movs	r2, #40	; 0x28
c0d010d8:	4621      	mov	r1, r4
c0d010da:	f001 fcaa 	bl	c0d02a32 <os_memmove>
    strings.common.fullAddress[42] = '\0';
c0d010de:	202a      	movs	r0, #42	; 0x2a
c0d010e0:	542f      	strb	r7, [r5, r0]
c0d010e2:	e00a      	b.n	c0d010fa <finalizeParsing+0x126>
  }
  else
  {
    os_memmove((void*)addressSummary, CONTRACT_ADDRESS, sizeof(CONTRACT_ADDRESS));
c0d010e4:	487f      	ldr	r0, [pc, #508]	; (c0d012e4 <finalizeParsing+0x310>)
c0d010e6:	4989      	ldr	r1, [pc, #548]	; (c0d0130c <finalizeParsing+0x338>)
c0d010e8:	4479      	add	r1, pc
c0d010ea:	220d      	movs	r2, #13
c0d010ec:	f001 fca1 	bl	c0d02a32 <os_memmove>
    strcpy(strings.common.fullAddress, "Contract");
c0d010f0:	487b      	ldr	r0, [pc, #492]	; (c0d012e0 <finalizeParsing+0x30c>)
c0d010f2:	a17d      	add	r1, pc, #500	; (adr r1, c0d012e8 <finalizeParsing+0x314>)
c0d010f4:	2209      	movs	r2, #9
c0d010f6:	f005 fed1 	bl	c0d06e9c <__aeabi_memcpy>
  }
  // Add amount in ethers or tokens
  convertUint256BE(tmpContent.txContent.value.value, tmpContent.txContent.value.length, &uint256);
c0d010fa:	2062      	movs	r0, #98	; 0x62
c0d010fc:	5c31      	ldrb	r1, [r6, r0]
c0d010fe:	4635      	mov	r5, r6
c0d01100:	4630      	mov	r0, r6
c0d01102:	3042      	adds	r0, #66	; 0x42
c0d01104:	ac12      	add	r4, sp, #72	; 0x48
c0d01106:	4622      	mov	r2, r4
c0d01108:	f005 fdbc 	bl	c0d06c84 <convertUint256BE>
  tostring256(&uint256, 10, (char *)(G_io_apdu_buffer + 100), 100);
c0d0110c:	4e6e      	ldr	r6, [pc, #440]	; (c0d012c8 <finalizeParsing+0x2f4>)
c0d0110e:	4632      	mov	r2, r6
c0d01110:	3264      	adds	r2, #100	; 0x64
c0d01112:	210a      	movs	r1, #10
c0d01114:	2364      	movs	r3, #100	; 0x64
c0d01116:	4620      	mov	r0, r4
c0d01118:	9205      	str	r2, [sp, #20]
c0d0111a:	f004 fd51 	bl	c0d05bc0 <tostring256>
c0d0111e:	4632      	mov	r2, r6
c0d01120:	43fc      	mvns	r4, r7
c0d01122:	4621      	mov	r1, r4
  i = 0;
  while (G_io_apdu_buffer[100 + i]) {
c0d01124:	1850      	adds	r0, r2, r1
c0d01126:	2665      	movs	r6, #101	; 0x65
c0d01128:	5d80      	ldrb	r0, [r0, r6]
c0d0112a:	1c49      	adds	r1, r1, #1
c0d0112c:	2800      	cmp	r0, #0
c0d0112e:	d1f9      	bne.n	c0d01124 <finalizeParsing+0x150>
    i++;
  }
  adjustDecimals((char *)(G_io_apdu_buffer + 100), i, (char *)G_io_apdu_buffer, 100, decimals);
c0d01130:	4668      	mov	r0, sp
c0d01132:	9b02      	ldr	r3, [sp, #8]
c0d01134:	6003      	str	r3, [r0, #0]
c0d01136:	2364      	movs	r3, #100	; 0x64
c0d01138:	9805      	ldr	r0, [sp, #20]
c0d0113a:	f7ff fbdd 	bl	c0d008f8 <adjustDecimals>
  i = 0;
    tickerOffset = 0;
    while (ticker[tickerOffset]) {
c0d0113e:	9806      	ldr	r0, [sp, #24]
c0d01140:	7800      	ldrb	r0, [r0, #0]
c0d01142:	2800      	cmp	r0, #0
c0d01144:	d00b      	beq.n	c0d0115e <finalizeParsing+0x18a>
c0d01146:	2700      	movs	r7, #0
c0d01148:	4965      	ldr	r1, [pc, #404]	; (c0d012e0 <finalizeParsing+0x30c>)
c0d0114a:	463a      	mov	r2, r7
        strings.common.fullAmount[tickerOffset] = ticker[tickerOffset];
c0d0114c:	19cb      	adds	r3, r1, r7
c0d0114e:	272b      	movs	r7, #43	; 0x2b
c0d01150:	55d8      	strb	r0, [r3, r7]
        tickerOffset++;
c0d01152:	1c52      	adds	r2, r2, #1
    i++;
  }
  adjustDecimals((char *)(G_io_apdu_buffer + 100), i, (char *)G_io_apdu_buffer, 100, decimals);
  i = 0;
    tickerOffset = 0;
    while (ticker[tickerOffset]) {
c0d01154:	b2d7      	uxtb	r7, r2
c0d01156:	9806      	ldr	r0, [sp, #24]
c0d01158:	5dc0      	ldrb	r0, [r0, r7]
c0d0115a:	2800      	cmp	r0, #0
c0d0115c:	d1f6      	bne.n	c0d0114c <finalizeParsing+0x178>
c0d0115e:	4860      	ldr	r0, [pc, #384]	; (c0d012e0 <finalizeParsing+0x30c>)
c0d01160:	19c0      	adds	r0, r0, r7
c0d01162:	4602      	mov	r2, r0
c0d01164:	322b      	adds	r2, #43	; 0x2b
        strings.common.fullAmount[tickerOffset] = ticker[tickerOffset];
        tickerOffset++;
    }
    while (G_io_apdu_buffer[i]) {
c0d01166:	4958      	ldr	r1, [pc, #352]	; (c0d012c8 <finalizeParsing+0x2f4>)
c0d01168:	7809      	ldrb	r1, [r1, #0]
c0d0116a:	2900      	cmp	r1, #0
c0d0116c:	d00a      	beq.n	c0d01184 <finalizeParsing+0x1b0>
        strings.common.fullAmount[tickerOffset + i] = G_io_apdu_buffer[i];
c0d0116e:	302b      	adds	r0, #43	; 0x2b
c0d01170:	4a55      	ldr	r2, [pc, #340]	; (c0d012c8 <finalizeParsing+0x2f4>)
c0d01172:	1c52      	adds	r2, r2, #1
c0d01174:	7001      	strb	r1, [r0, #0]
    tickerOffset = 0;
    while (ticker[tickerOffset]) {
        strings.common.fullAmount[tickerOffset] = ticker[tickerOffset];
        tickerOffset++;
    }
    while (G_io_apdu_buffer[i]) {
c0d01176:	1c53      	adds	r3, r2, #1
c0d01178:	1c40      	adds	r0, r0, #1
c0d0117a:	7811      	ldrb	r1, [r2, #0]
c0d0117c:	2900      	cmp	r1, #0
c0d0117e:	461a      	mov	r2, r3
c0d01180:	d1f8      	bne.n	c0d01174 <finalizeParsing+0x1a0>
c0d01182:	4602      	mov	r2, r0
        strings.common.fullAmount[tickerOffset + i] = G_io_apdu_buffer[i];
        i++;
    }
  strings.common.fullAmount[tickerOffset + i] = '\0';
c0d01184:	2700      	movs	r7, #0
c0d01186:	7017      	strb	r7, [r2, #0]
  // Compute maximum fee
  convertUint256BE(tmpContent.txContent.gasprice.value, tmpContent.txContent.gasprice.length, &gasPrice);
c0d01188:	2020      	movs	r0, #32
c0d0118a:	5c29      	ldrb	r1, [r5, r0]
c0d0118c:	aa22      	add	r2, sp, #136	; 0x88
c0d0118e:	9206      	str	r2, [sp, #24]
c0d01190:	4628      	mov	r0, r5
c0d01192:	f005 fd77 	bl	c0d06c84 <convertUint256BE>
  convertUint256BE(tmpContent.txContent.startgas.value, tmpContent.txContent.startgas.length, &startGas);
c0d01196:	2041      	movs	r0, #65	; 0x41
c0d01198:	5c29      	ldrb	r1, [r5, r0]
c0d0119a:	3521      	adds	r5, #33	; 0x21
c0d0119c:	aa1a      	add	r2, sp, #104	; 0x68
c0d0119e:	4628      	mov	r0, r5
c0d011a0:	4615      	mov	r5, r2
c0d011a2:	f005 fd6f 	bl	c0d06c84 <convertUint256BE>
c0d011a6:	aa12      	add	r2, sp, #72	; 0x48
  mul256(&gasPrice, &startGas, &uint256);
c0d011a8:	9806      	ldr	r0, [sp, #24]
c0d011aa:	4629      	mov	r1, r5
c0d011ac:	4615      	mov	r5, r2
c0d011ae:	f004 fa3d 	bl	c0d0562c <mul256>
  tostring256(&uint256, 10, (char *)(G_io_apdu_buffer + 100), 100);
c0d011b2:	210a      	movs	r1, #10
c0d011b4:	2364      	movs	r3, #100	; 0x64
c0d011b6:	4628      	mov	r0, r5
c0d011b8:	9a05      	ldr	r2, [sp, #20]
c0d011ba:	f004 fd01 	bl	c0d05bc0 <tostring256>
c0d011be:	4a42      	ldr	r2, [pc, #264]	; (c0d012c8 <finalizeParsing+0x2f4>)
  i = 0;
  while (G_io_apdu_buffer[100 + i]) {
c0d011c0:	1910      	adds	r0, r2, r4
c0d011c2:	5d80      	ldrb	r0, [r0, r6]
c0d011c4:	1c64      	adds	r4, r4, #1
c0d011c6:	2800      	cmp	r0, #0
c0d011c8:	d1fa      	bne.n	c0d011c0 <finalizeParsing+0x1ec>
    i++;
  }
  adjustDecimals((char *)(G_io_apdu_buffer + 100), i, (char *)G_io_apdu_buffer, 100, WEI_TO_ETHER);
c0d011ca:	2012      	movs	r0, #18
c0d011cc:	4669      	mov	r1, sp
c0d011ce:	6008      	str	r0, [r1, #0]
c0d011d0:	2364      	movs	r3, #100	; 0x64
c0d011d2:	9805      	ldr	r0, [sp, #20]
c0d011d4:	4621      	mov	r1, r4
c0d011d6:	f7ff fb8f 	bl	c0d008f8 <adjustDecimals>
c0d011da:	9c04      	ldr	r4, [sp, #16]
  i = 0;
  tickerOffset=0;
  while (feeTicker[tickerOffset]) {
c0d011dc:	7820      	ldrb	r0, [r4, #0]
c0d011de:	2800      	cmp	r0, #0
c0d011e0:	9903      	ldr	r1, [sp, #12]
c0d011e2:	4d3f      	ldr	r5, [pc, #252]	; (c0d012e0 <finalizeParsing+0x30c>)
c0d011e4:	d00a      	beq.n	c0d011fc <finalizeParsing+0x228>
c0d011e6:	463a      	mov	r2, r7
c0d011e8:	4611      	mov	r1, r2
      strings.common.maxFee[tickerOffset] = feeTicker[tickerOffset];
c0d011ea:	19ea      	adds	r2, r5, r7
c0d011ec:	235d      	movs	r3, #93	; 0x5d
c0d011ee:	54d0      	strb	r0, [r2, r3]
      tickerOffset++;
c0d011f0:	1c4a      	adds	r2, r1, #1
    i++;
  }
  adjustDecimals((char *)(G_io_apdu_buffer + 100), i, (char *)G_io_apdu_buffer, 100, WEI_TO_ETHER);
  i = 0;
  tickerOffset=0;
  while (feeTicker[tickerOffset]) {
c0d011f2:	b2d7      	uxtb	r7, r2
c0d011f4:	5de0      	ldrb	r0, [r4, r7]
c0d011f6:	2800      	cmp	r0, #0
c0d011f8:	d1f6      	bne.n	c0d011e8 <finalizeParsing+0x214>
      strings.common.maxFee[tickerOffset] = feeTicker[tickerOffset];
      tickerOffset++;
  }
  tickerOffset++;
c0d011fa:	1c89      	adds	r1, r1, #2
c0d011fc:	b2c8      	uxtb	r0, r1
c0d011fe:	1828      	adds	r0, r5, r0
c0d01200:	4602      	mov	r2, r0
c0d01202:	325d      	adds	r2, #93	; 0x5d
c0d01204:	4b30      	ldr	r3, [pc, #192]	; (c0d012c8 <finalizeParsing+0x2f4>)
  while (G_io_apdu_buffer[i]) {
c0d01206:	7819      	ldrb	r1, [r3, #0]
c0d01208:	2900      	cmp	r1, #0
c0d0120a:	d009      	beq.n	c0d01220 <finalizeParsing+0x24c>
    strings.common.maxFee[tickerOffset + i] = G_io_apdu_buffer[i];
c0d0120c:	305d      	adds	r0, #93	; 0x5d
c0d0120e:	1c5a      	adds	r2, r3, #1
c0d01210:	7001      	strb	r1, [r0, #0]
  while (feeTicker[tickerOffset]) {
      strings.common.maxFee[tickerOffset] = feeTicker[tickerOffset];
      tickerOffset++;
  }
  tickerOffset++;
  while (G_io_apdu_buffer[i]) {
c0d01212:	1c53      	adds	r3, r2, #1
c0d01214:	1c40      	adds	r0, r0, #1
c0d01216:	7811      	ldrb	r1, [r2, #0]
c0d01218:	2900      	cmp	r1, #0
c0d0121a:	461a      	mov	r2, r3
c0d0121c:	d1f8      	bne.n	c0d01210 <finalizeParsing+0x23c>
c0d0121e:	4602      	mov	r2, r0
c0d01220:	2500      	movs	r5, #0
    strings.common.maxFee[tickerOffset + i] = G_io_apdu_buffer[i];
    i++;
  }
  strings.common.maxFee[tickerOffset + i] = '\0';
c0d01222:	7015      	strb	r5, [r2, #0]
  io_seproxyhal_touch_tx_ok(NULL);
#else // NO_CONSENT
#if defined(TARGET_BLUE)
  ui_approval_transaction_blue_init();
#elif defined(TARGET_NANOS)
  ux_step = 0;
c0d01224:	4833      	ldr	r0, [pc, #204]	; (c0d012f4 <finalizeParsing+0x320>)
c0d01226:	6005      	str	r5, [r0, #0]
  ux_step_count = 5;
c0d01228:	4833      	ldr	r0, [pc, #204]	; (c0d012f8 <finalizeParsing+0x324>)
c0d0122a:	2105      	movs	r1, #5
c0d0122c:	6001      	str	r1, [r0, #0]
  UX_DISPLAY(ui_approval_nanos, ui_approval_prepro);
c0d0122e:	4c33      	ldr	r4, [pc, #204]	; (c0d012fc <finalizeParsing+0x328>)
c0d01230:	4837      	ldr	r0, [pc, #220]	; (c0d01310 <finalizeParsing+0x33c>)
c0d01232:	4478      	add	r0, pc
c0d01234:	6020      	str	r0, [r4, #0]
c0d01236:	200d      	movs	r0, #13
c0d01238:	6060      	str	r0, [r4, #4]
c0d0123a:	4836      	ldr	r0, [pc, #216]	; (c0d01314 <finalizeParsing+0x340>)
c0d0123c:	4478      	add	r0, pc
c0d0123e:	6120      	str	r0, [r4, #16]
c0d01240:	4835      	ldr	r0, [pc, #212]	; (c0d01318 <finalizeParsing+0x344>)
c0d01242:	4478      	add	r0, pc
c0d01244:	60e0      	str	r0, [r4, #12]
c0d01246:	2003      	movs	r0, #3
c0d01248:	7620      	strb	r0, [r4, #24]
c0d0124a:	61e5      	str	r5, [r4, #28]
c0d0124c:	4620      	mov	r0, r4
c0d0124e:	3018      	adds	r0, #24
c0d01250:	f002 fee6 	bl	c0d04020 <os_ux>
c0d01254:	61e0      	str	r0, [r4, #28]
c0d01256:	f002 fb2d 	bl	c0d038b4 <ux_check_status_default>
c0d0125a:	f001 fdfb 	bl	c0d02e54 <io_seproxyhal_init_ux>
c0d0125e:	f001 fdff 	bl	c0d02e60 <io_seproxyhal_init_button>
c0d01262:	60a5      	str	r5, [r4, #8]
c0d01264:	6820      	ldr	r0, [r4, #0]
c0d01266:	2800      	cmp	r0, #0
c0d01268:	d024      	beq.n	c0d012b4 <finalizeParsing+0x2e0>
c0d0126a:	69e0      	ldr	r0, [r4, #28]
c0d0126c:	4924      	ldr	r1, [pc, #144]	; (c0d01300 <finalizeParsing+0x32c>)
c0d0126e:	4288      	cmp	r0, r1
c0d01270:	d11e      	bne.n	c0d012b0 <finalizeParsing+0x2dc>
c0d01272:	e01f      	b.n	c0d012b4 <finalizeParsing+0x2e0>
c0d01274:	6860      	ldr	r0, [r4, #4]
c0d01276:	4285      	cmp	r5, r0
c0d01278:	d21c      	bcs.n	c0d012b4 <finalizeParsing+0x2e0>
c0d0127a:	f002 ff41 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d0127e:	2800      	cmp	r0, #0
c0d01280:	d118      	bne.n	c0d012b4 <finalizeParsing+0x2e0>
c0d01282:	68a0      	ldr	r0, [r4, #8]
c0d01284:	68e1      	ldr	r1, [r4, #12]
c0d01286:	2538      	movs	r5, #56	; 0x38
c0d01288:	4368      	muls	r0, r5
c0d0128a:	6822      	ldr	r2, [r4, #0]
c0d0128c:	1810      	adds	r0, r2, r0
c0d0128e:	2900      	cmp	r1, #0
c0d01290:	d002      	beq.n	c0d01298 <finalizeParsing+0x2c4>
c0d01292:	4788      	blx	r1
c0d01294:	2800      	cmp	r0, #0
c0d01296:	d007      	beq.n	c0d012a8 <finalizeParsing+0x2d4>
c0d01298:	2801      	cmp	r0, #1
c0d0129a:	d103      	bne.n	c0d012a4 <finalizeParsing+0x2d0>
c0d0129c:	68a0      	ldr	r0, [r4, #8]
c0d0129e:	4345      	muls	r5, r0
c0d012a0:	6820      	ldr	r0, [r4, #0]
c0d012a2:	1940      	adds	r0, r0, r5
    return;
}

// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
  io_seproxyhal_display_default((bagl_element_t *)element);
c0d012a4:	f001 ff2a 	bl	c0d030fc <io_seproxyhal_display_default>
#if defined(TARGET_BLUE)
  ui_approval_transaction_blue_init();
#elif defined(TARGET_NANOS)
  ux_step = 0;
  ux_step_count = 5;
  UX_DISPLAY(ui_approval_nanos, ui_approval_prepro);
c0d012a8:	68a0      	ldr	r0, [r4, #8]
c0d012aa:	1c45      	adds	r5, r0, #1
c0d012ac:	60a5      	str	r5, [r4, #8]
c0d012ae:	6820      	ldr	r0, [r4, #0]
c0d012b0:	2800      	cmp	r0, #0
c0d012b2:	d1df      	bne.n	c0d01274 <finalizeParsing+0x2a0>
  ux_flow_init(0,
    ((dataPresent && !N_storage.contractDetails) ? ux_approval_tx_data_warning_flow : ux_approval_tx_flow),
    NULL);
#endif // #if TARGET_ID
#endif // NO_CONSENT
}
c0d012b4:	b02b      	add	sp, #172	; 0xac
c0d012b6:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d012b8:	4628      	mov	r0, r5
c0d012ba:	f001 fc6e 	bl	c0d02b9a <os_longjmp>
c0d012be:	46c0      	nop			; (mov r8, r8)
c0d012c0:	20001aa0 	.word	0x20001aa0
c0d012c4:	2000194c 	.word	0x2000194c
c0d012c8:	20001d4c 	.word	0x20001d4c
c0d012cc:	200019cc 	.word	0x200019cc
c0d012d0:	20001af8 	.word	0x20001af8
c0d012d4:	20001aa5 	.word	0x20001aa5
c0d012d8:	20001948 	.word	0x20001948
c0d012dc:	20001aa8 	.word	0x20001aa8
c0d012e0:	20001802 	.word	0x20001802
c0d012e4:	20001ca0 	.word	0x20001ca0
c0d012e8:	746e6f43 	.word	0x746e6f43
c0d012ec:	74636172 	.word	0x74636172
c0d012f0:	00000000 	.word	0x00000000
c0d012f4:	20001894 	.word	0x20001894
c0d012f8:	20001af0 	.word	0x20001af0
c0d012fc:	20001898 	.word	0x20001898
c0d01300:	b0105044 	.word	0xb0105044
c0d01304:	00006284 	.word	0x00006284
c0d01308:	0000f83c 	.word	0x0000f83c
c0d0130c:	00006bc8 	.word	0x00006bc8
c0d01310:	0000630a 	.word	0x0000630a
c0d01314:	000000dd 	.word	0x000000dd
c0d01318:	fffff8cb 	.word	0xfffff8cb

c0d0131c <ui_approval_nanos_button>:
  ui_approval_blue_values[2] = NULL;
  ui_approval_blue_init();
}

#elif defined(TARGET_NANOS)
unsigned int ui_approval_nanos_button(unsigned int button_mask, unsigned int button_mask_counter) {
c0d0131c:	b580      	push	{r7, lr}
    switch(button_mask) {
c0d0131e:	490d      	ldr	r1, [pc, #52]	; (c0d01354 <ui_approval_nanos_button+0x38>)
c0d01320:	4288      	cmp	r0, r1
c0d01322:	d012      	beq.n	c0d0134a <ui_approval_nanos_button+0x2e>
c0d01324:	490c      	ldr	r1, [pc, #48]	; (c0d01358 <ui_approval_nanos_button+0x3c>)
c0d01326:	4288      	cmp	r0, r1
c0d01328:	d111      	bne.n	c0d0134e <ui_approval_nanos_button+0x32>
    ui_idle();
    return 0; // do not redraw the widget
}

unsigned int io_seproxyhal_touch_tx_cancel(const bagl_element_t *e) {
    G_io_apdu_buffer[0] = 0x69;
c0d0132a:	480c      	ldr	r0, [pc, #48]	; (c0d0135c <ui_approval_nanos_button+0x40>)
c0d0132c:	2169      	movs	r1, #105	; 0x69
c0d0132e:	7001      	strb	r1, [r0, #0]
    G_io_apdu_buffer[1] = 0x85;
c0d01330:	2185      	movs	r1, #133	; 0x85
c0d01332:	7041      	strb	r1, [r0, #1]
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0d01334:	2020      	movs	r0, #32
c0d01336:	2102      	movs	r1, #2
c0d01338:	f001 ffac 	bl	c0d03294 <io_exchange>

void ui_idle(void) {
#if defined(TARGET_BLUE)
    UX_DISPLAY(ui_idle_blue, ui_idle_blue_prepro);
#elif defined(TARGET_NANOS)
    UX_MENU_DISPLAY(0, menu_main, NULL);
c0d0133c:	4908      	ldr	r1, [pc, #32]	; (c0d01360 <ui_approval_nanos_button+0x44>)
c0d0133e:	4479      	add	r1, pc
c0d01340:	2000      	movs	r0, #0
c0d01342:	4602      	mov	r2, r0
c0d01344:	f002 fa28 	bl	c0d03798 <ux_menu_display>
c0d01348:	e001      	b.n	c0d0134e <ui_approval_nanos_button+0x32>
        case BUTTON_EVT_RELEASED|BUTTON_LEFT:
            io_seproxyhal_touch_tx_cancel(NULL);
            break;

        case BUTTON_EVT_RELEASED|BUTTON_RIGHT: {
			      io_seproxyhal_touch_tx_ok(NULL);
c0d0134a:	f7ff fd19 	bl	c0d00d80 <io_seproxyhal_touch_tx_ok>
            break;
        }
    }
    return 0;
c0d0134e:	2000      	movs	r0, #0
c0d01350:	bd80      	pop	{r7, pc}
c0d01352:	46c0      	nop			; (mov r8, r8)
c0d01354:	80000002 	.word	0x80000002
c0d01358:	80000001 	.word	0x80000001
c0d0135c:	20001d4c 	.word	0x20001d4c
c0d01360:	00005fea 	.word	0x00005fea

c0d01364 <ui_approval_signMessage_nanos_button>:
}


unsigned int ui_approval_signMessage_nanos_button(unsigned int button_mask, unsigned int button_mask_counter) {
c0d01364:	b580      	push	{r7, lr}
    switch (button_mask) {
c0d01366:	490d      	ldr	r1, [pc, #52]	; (c0d0139c <ui_approval_signMessage_nanos_button+0x38>)
c0d01368:	4288      	cmp	r0, r1
c0d0136a:	d012      	beq.n	c0d01392 <ui_approval_signMessage_nanos_button+0x2e>
c0d0136c:	490c      	ldr	r1, [pc, #48]	; (c0d013a0 <ui_approval_signMessage_nanos_button+0x3c>)
c0d0136e:	4288      	cmp	r0, r1
c0d01370:	d111      	bne.n	c0d01396 <ui_approval_signMessage_nanos_button+0x32>
    ui_idle();
    return 0; // do not redraw the widget
}

unsigned int io_seproxyhal_touch_signMessage_cancel(const bagl_element_t *e) {
    G_io_apdu_buffer[0] = 0x69;
c0d01372:	480c      	ldr	r0, [pc, #48]	; (c0d013a4 <ui_approval_signMessage_nanos_button+0x40>)
c0d01374:	2169      	movs	r1, #105	; 0x69
c0d01376:	7001      	strb	r1, [r0, #0]
    G_io_apdu_buffer[1] = 0x85;
c0d01378:	2185      	movs	r1, #133	; 0x85
c0d0137a:	7041      	strb	r1, [r0, #1]
    // Send back the response, do not restart the event loop
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0d0137c:	2020      	movs	r0, #32
c0d0137e:	2102      	movs	r1, #2
c0d01380:	f001 ff88 	bl	c0d03294 <io_exchange>

void ui_idle(void) {
#if defined(TARGET_BLUE)
    UX_DISPLAY(ui_idle_blue, ui_idle_blue_prepro);
#elif defined(TARGET_NANOS)
    UX_MENU_DISPLAY(0, menu_main, NULL);
c0d01384:	4908      	ldr	r1, [pc, #32]	; (c0d013a8 <ui_approval_signMessage_nanos_button+0x44>)
c0d01386:	4479      	add	r1, pc
c0d01388:	2000      	movs	r0, #0
c0d0138a:	4602      	mov	r2, r0
c0d0138c:	f002 fa04 	bl	c0d03798 <ux_menu_display>
c0d01390:	e001      	b.n	c0d01396 <ui_approval_signMessage_nanos_button+0x32>
    case BUTTON_EVT_RELEASED | BUTTON_LEFT:
        io_seproxyhal_touch_signMessage_cancel(NULL);
        break;

    case BUTTON_EVT_RELEASED | BUTTON_RIGHT: {
        io_seproxyhal_touch_signMessage_ok(NULL);
c0d01392:	f7ff fd77 	bl	c0d00e84 <io_seproxyhal_touch_signMessage_ok>
        break;
    }
    }
    return 0;
c0d01396:	2000      	movs	r0, #0
c0d01398:	bd80      	pop	{r7, pc}
c0d0139a:	46c0      	nop			; (mov r8, r8)
c0d0139c:	80000002 	.word	0x80000002
c0d013a0:	80000001 	.word	0x80000001
c0d013a4:	20001d4c 	.word	0x20001d4c
c0d013a8:	00005fa2 	.word	0x00005fa2

c0d013ac <ui_data_selector_nanos_button>:
}

unsigned int ui_data_selector_nanos_button(unsigned int button_mask,
                                     unsigned int button_mask_counter) {
c0d013ac:	b580      	push	{r7, lr}
   switch (button_mask) {
c0d013ae:	490d      	ldr	r1, [pc, #52]	; (c0d013e4 <ui_data_selector_nanos_button+0x38>)
c0d013b0:	4288      	cmp	r0, r1
c0d013b2:	d012      	beq.n	c0d013da <ui_data_selector_nanos_button+0x2e>
c0d013b4:	490c      	ldr	r1, [pc, #48]	; (c0d013e8 <ui_data_selector_nanos_button+0x3c>)
c0d013b6:	4288      	cmp	r0, r1
c0d013b8:	d111      	bne.n	c0d013de <ui_data_selector_nanos_button+0x32>
    return 0;
}
#endif // #if defined(TARGET_NANOS)

void io_seproxyhal_send_status(uint32_t sw) {
    G_io_apdu_buffer[0] = ((sw >> 8) & 0xff);
c0d013ba:	480c      	ldr	r0, [pc, #48]	; (c0d013ec <ui_data_selector_nanos_button+0x40>)
c0d013bc:	2169      	movs	r1, #105	; 0x69
c0d013be:	7001      	strb	r1, [r0, #0]
    G_io_apdu_buffer[1] = (sw & 0xff);
c0d013c0:	2185      	movs	r1, #133	; 0x85
c0d013c2:	7041      	strb	r1, [r0, #1]
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0d013c4:	2020      	movs	r0, #32
c0d013c6:	2102      	movs	r1, #2
c0d013c8:	f001 ff64 	bl	c0d03294 <io_exchange>

void ui_idle(void) {
#if defined(TARGET_BLUE)
    UX_DISPLAY(ui_idle_blue, ui_idle_blue_prepro);
#elif defined(TARGET_NANOS)
    UX_MENU_DISPLAY(0, menu_main, NULL);
c0d013cc:	4908      	ldr	r1, [pc, #32]	; (c0d013f0 <ui_data_selector_nanos_button+0x44>)
c0d013ce:	4479      	add	r1, pc
c0d013d0:	2000      	movs	r0, #0
c0d013d2:	4602      	mov	r2, r0
c0d013d4:	f002 f9e0 	bl	c0d03798 <ux_menu_display>
c0d013d8:	e001      	b.n	c0d013de <ui_data_selector_nanos_button+0x32>
    case BUTTON_EVT_RELEASED | BUTTON_LEFT:
        io_seproxyhal_touch_data_cancel(NULL);
        break;

    case BUTTON_EVT_RELEASED | BUTTON_RIGHT: {
        io_seproxyhal_touch_data_ok(NULL);
c0d013da:	f7ff fdbf 	bl	c0d00f5c <io_seproxyhal_touch_data_ok>
        break;
    }
    }
    return 0;
c0d013de:	2000      	movs	r0, #0
c0d013e0:	bd80      	pop	{r7, pc}
c0d013e2:	46c0      	nop			; (mov r8, r8)
c0d013e4:	80000002 	.word	0x80000002
c0d013e8:	80000001 	.word	0x80000001
c0d013ec:	20001d4c 	.word	0x20001d4c
c0d013f0:	00005f5a 	.word	0x00005f5a

c0d013f4 <ui_data_parameter_nanos_button>:
}

unsigned int ui_data_parameter_nanos_button(unsigned int button_mask,
                                     unsigned int button_mask_counter) {
c0d013f4:	b580      	push	{r7, lr}
   switch (button_mask) {
c0d013f6:	490d      	ldr	r1, [pc, #52]	; (c0d0142c <ui_data_parameter_nanos_button+0x38>)
c0d013f8:	4288      	cmp	r0, r1
c0d013fa:	d012      	beq.n	c0d01422 <ui_data_parameter_nanos_button+0x2e>
c0d013fc:	490c      	ldr	r1, [pc, #48]	; (c0d01430 <ui_data_parameter_nanos_button+0x3c>)
c0d013fe:	4288      	cmp	r0, r1
c0d01400:	d111      	bne.n	c0d01426 <ui_data_parameter_nanos_button+0x32>
    return 0;
}
#endif // #if defined(TARGET_NANOS)

void io_seproxyhal_send_status(uint32_t sw) {
    G_io_apdu_buffer[0] = ((sw >> 8) & 0xff);
c0d01402:	480c      	ldr	r0, [pc, #48]	; (c0d01434 <ui_data_parameter_nanos_button+0x40>)
c0d01404:	2169      	movs	r1, #105	; 0x69
c0d01406:	7001      	strb	r1, [r0, #0]
    G_io_apdu_buffer[1] = (sw & 0xff);
c0d01408:	2185      	movs	r1, #133	; 0x85
c0d0140a:	7041      	strb	r1, [r0, #1]
    io_exchange(CHANNEL_APDU | IO_RETURN_AFTER_TX, 2);
c0d0140c:	2020      	movs	r0, #32
c0d0140e:	2102      	movs	r1, #2
c0d01410:	f001 ff40 	bl	c0d03294 <io_exchange>

void ui_idle(void) {
#if defined(TARGET_BLUE)
    UX_DISPLAY(ui_idle_blue, ui_idle_blue_prepro);
#elif defined(TARGET_NANOS)
    UX_MENU_DISPLAY(0, menu_main, NULL);
c0d01414:	4908      	ldr	r1, [pc, #32]	; (c0d01438 <ui_data_parameter_nanos_button+0x44>)
c0d01416:	4479      	add	r1, pc
c0d01418:	2000      	movs	r0, #0
c0d0141a:	4602      	mov	r2, r0
c0d0141c:	f002 f9bc 	bl	c0d03798 <ux_menu_display>
c0d01420:	e001      	b.n	c0d01426 <ui_data_parameter_nanos_button+0x32>
    case BUTTON_EVT_RELEASED | BUTTON_LEFT:
        io_seproxyhal_touch_data_cancel(NULL);
        break;

    case BUTTON_EVT_RELEASED | BUTTON_RIGHT: {
        io_seproxyhal_touch_data_ok(NULL);
c0d01422:	f7ff fd9b 	bl	c0d00f5c <io_seproxyhal_touch_data_ok>
        break;
    }
    }
    return 0;
c0d01426:	2000      	movs	r0, #0
c0d01428:	bd80      	pop	{r7, pc}
c0d0142a:	46c0      	nop			; (mov r8, r8)
c0d0142c:	80000002 	.word	0x80000002
c0d01430:	80000001 	.word	0x80000001
c0d01434:	20001d4c 	.word	0x20001d4c
c0d01438:	00005f12 	.word	0x00005f12

c0d0143c <io_exchange_al>:
}

#endif // #if defined(TARGET_NANOS)

unsigned short io_exchange_al(unsigned char channel, unsigned short tx_len) {
c0d0143c:	b5b0      	push	{r4, r5, r7, lr}
c0d0143e:	4605      	mov	r5, r0
c0d01440:	2007      	movs	r0, #7
    switch (channel & ~(IO_FLAGS)) {
c0d01442:	4028      	ands	r0, r5
c0d01444:	2400      	movs	r4, #0
c0d01446:	2801      	cmp	r0, #1
c0d01448:	d013      	beq.n	c0d01472 <io_exchange_al+0x36>
c0d0144a:	2802      	cmp	r0, #2
c0d0144c:	d113      	bne.n	c0d01476 <io_exchange_al+0x3a>
    case CHANNEL_KEYBOARD:
        break;

    // multiplexed io exchange over a SPI channel and TLV encapsulated protocol
    case CHANNEL_SPI:
        if (tx_len) {
c0d0144e:	2900      	cmp	r1, #0
c0d01450:	d008      	beq.n	c0d01464 <io_exchange_al+0x28>
            io_seproxyhal_spi_send(G_io_apdu_buffer, tx_len);
c0d01452:	480a      	ldr	r0, [pc, #40]	; (c0d0147c <io_exchange_al+0x40>)
c0d01454:	f002 fe3e 	bl	c0d040d4 <io_seproxyhal_spi_send>

            if (channel & IO_RESET_AFTER_REPLIED) {
c0d01458:	b268      	sxtb	r0, r5
c0d0145a:	2800      	cmp	r0, #0
c0d0145c:	da09      	bge.n	c0d01472 <io_exchange_al+0x36>
                reset();
c0d0145e:	f002 fc6f 	bl	c0d03d40 <reset>
c0d01462:	e006      	b.n	c0d01472 <io_exchange_al+0x36>
            }
            return 0; // nothing received from the master so far (it's a tx
                      // transaction)
        } else {
            return io_seproxyhal_spi_recv(G_io_apdu_buffer,
c0d01464:	21ff      	movs	r1, #255	; 0xff
c0d01466:	3152      	adds	r1, #82	; 0x52
c0d01468:	4804      	ldr	r0, [pc, #16]	; (c0d0147c <io_exchange_al+0x40>)
c0d0146a:	2200      	movs	r2, #0
c0d0146c:	f002 fe5e 	bl	c0d0412c <io_seproxyhal_spi_recv>
c0d01470:	4604      	mov	r4, r0

    default:
        THROW(INVALID_PARAMETER);
    }
    return 0;
}
c0d01472:	4620      	mov	r0, r4
c0d01474:	bdb0      	pop	{r4, r5, r7, pc}
            return io_seproxyhal_spi_recv(G_io_apdu_buffer,
                                          sizeof(G_io_apdu_buffer), 0);
        }

    default:
        THROW(INVALID_PARAMETER);
c0d01476:	2002      	movs	r0, #2
c0d01478:	f001 fb8f 	bl	c0d02b9a <os_longjmp>
c0d0147c:	20001d4c 	.word	0x20001d4c

c0d01480 <splitBinaryParameterPart>:
      tx += 32;
    }
    return tx;
}

uint32_t splitBinaryParameterPart(char *result, uint8_t *parameter) {
c0d01480:	b510      	push	{r4, lr}
c0d01482:	2200      	movs	r2, #0
    uint32_t i;
    for (i=0; i<8; i++) {
        if (parameter[i] != 0x00) {
c0d01484:	5c8b      	ldrb	r3, [r1, r2]
c0d01486:	2b00      	cmp	r3, #0
c0d01488:	d10a      	bne.n	c0d014a0 <splitBinaryParameterPart+0x20>
    return tx;
}

uint32_t splitBinaryParameterPart(char *result, uint8_t *parameter) {
    uint32_t i;
    for (i=0; i<8; i++) {
c0d0148a:	1c52      	adds	r2, r2, #1
c0d0148c:	2a08      	cmp	r2, #8
c0d0148e:	d3f9      	bcc.n	c0d01484 <splitBinaryParameterPart+0x4>
c0d01490:	d106      	bne.n	c0d014a0 <splitBinaryParameterPart+0x20>
        if (parameter[i] != 0x00) {
            break;
        }
    }
    if (i == 8) {
        result[0] = '0';
c0d01492:	2130      	movs	r1, #48	; 0x30
c0d01494:	7001      	strb	r1, [r0, #0]
        result[1] = '0';
c0d01496:	7041      	strb	r1, [r0, #1]
        result[2] = '\0';
c0d01498:	2100      	movs	r1, #0
c0d0149a:	7081      	strb	r1, [r0, #2]
c0d0149c:	2002      	movs	r0, #2
    }
    else {
        array_hexstr(result, parameter + i, 8 - i);
        return ((8 - i) * 2);
    }
}
c0d0149e:	bd10      	pop	{r4, pc}
        result[1] = '0';
        result[2] = '\0';
        return 2;
    }
    else {
        array_hexstr(result, parameter + i, 8 - i);
c0d014a0:	1889      	adds	r1, r1, r2
c0d014a2:	2308      	movs	r3, #8
c0d014a4:	1a9c      	subs	r4, r3, r2
c0d014a6:	4622      	mov	r2, r4
c0d014a8:	f005 fbcc 	bl	c0d06c44 <array_hexstr>
        return ((8 - i) * 2);
c0d014ac:	0060      	lsls	r0, r4, #1
    }
}
c0d014ae:	bd10      	pop	{r4, pc}

c0d014b0 <getKnownToken>:

tokenDefinition_t* getKnownToken() {
c0d014b0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d014b2:	b081      	sub	sp, #4
    tokenDefinition_t *currentToken = NULL;
#ifdef HAVE_TOKENS_LIST
    uint32_t numTokens = 0;
    uint32_t i;
    switch(chainConfig->kind) {
c0d014b4:	487b      	ldr	r0, [pc, #492]	; (c0d016a4 <getKnownToken+0x1f4>)
c0d014b6:	6800      	ldr	r0, [r0, #0]
c0d014b8:	2108      	movs	r1, #8
c0d014ba:	5641      	ldrsb	r1, [r0, r1]
c0d014bc:	b2c8      	uxtb	r0, r1
c0d014be:	2816      	cmp	r0, #22
c0d014c0:	d900      	bls.n	c0d014c4 <getKnownToken+0x14>
c0d014c2:	e0d5      	b.n	c0d01670 <getKnownToken+0x1c0>
c0d014c4:	008a      	lsls	r2, r1, #2
            break;
        case CHAIN_KIND_DEXON:
          numTokens = NUM_TOKENS_DEXON;
          break;
    }
    for (i=0; i<numTokens; i++) {
c0d014c6:	4b78      	ldr	r3, [pc, #480]	; (c0d016a8 <getKnownToken+0x1f8>)
c0d014c8:	40cb      	lsrs	r3, r1
c0d014ca:	07d9      	lsls	r1, r3, #31
c0d014cc:	d000      	beq.n	c0d014d0 <getKnownToken+0x20>
c0d014ce:	e0cf      	b.n	c0d01670 <getKnownToken+0x1c0>
tokenDefinition_t* getKnownToken() {
    tokenDefinition_t *currentToken = NULL;
#ifdef HAVE_TOKENS_LIST
    uint32_t numTokens = 0;
    uint32_t i;
    switch(chainConfig->kind) {
c0d014d0:	497a      	ldr	r1, [pc, #488]	; (c0d016bc <getKnownToken+0x20c>)
c0d014d2:	4479      	add	r1, pc
c0d014d4:	5889      	ldr	r1, [r1, r2]
c0d014d6:	9100      	str	r1, [sp, #0]
c0d014d8:	2700      	movs	r7, #0
c0d014da:	2501      	movs	r5, #1
c0d014dc:	4e78      	ldr	r6, [pc, #480]	; (c0d016c0 <getKnownToken+0x210>)
c0d014de:	447e      	add	r6, pc
c0d014e0:	463c      	mov	r4, r7
c0d014e2:	e008      	b.n	c0d014f6 <getKnownToken+0x46>
            break;
        case CHAIN_KIND_DEXON:
          numTokens = NUM_TOKENS_DEXON;
          break;
    }
    for (i=0; i<numTokens; i++) {
c0d014e4:	9800      	ldr	r0, [sp, #0]
c0d014e6:	4285      	cmp	r5, r0
c0d014e8:	d300      	bcc.n	c0d014ec <getKnownToken+0x3c>
c0d014ea:	e0c1      	b.n	c0d01670 <getKnownToken+0x1c0>
c0d014ec:	361f      	adds	r6, #31
c0d014ee:	1c6d      	adds	r5, r5, #1
c0d014f0:	486c      	ldr	r0, [pc, #432]	; (c0d016a4 <getKnownToken+0x1f4>)
c0d014f2:	6800      	ldr	r0, [r0, #0]
c0d014f4:	7a00      	ldrb	r0, [r0, #8]
c0d014f6:	b2c0      	uxtb	r0, r0
        switch(chainConfig->kind) {
c0d014f8:	280a      	cmp	r0, #10
c0d014fa:	dd0f      	ble.n	c0d0151c <getKnownToken+0x6c>
c0d014fc:	2810      	cmp	r0, #16
c0d014fe:	dc1d      	bgt.n	c0d0153c <getKnownToken+0x8c>
c0d01500:	280d      	cmp	r0, #13
c0d01502:	dc36      	bgt.n	c0d01572 <getKnownToken+0xc2>
c0d01504:	280b      	cmp	r0, #11
c0d01506:	d05b      	beq.n	c0d015c0 <getKnownToken+0x110>
c0d01508:	280c      	cmp	r0, #12
c0d0150a:	d05e      	beq.n	c0d015ca <getKnownToken+0x11a>
c0d0150c:	280d      	cmp	r0, #13
c0d0150e:	d000      	beq.n	c0d01512 <getKnownToken+0x62>
c0d01510:	e0a4      	b.n	c0d0165c <getKnownToken+0x1ac>
                break;
            case CHAIN_KIND_ETHERSOCIAL:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_ETHERSOCIAL[i]);
                break;
            case CHAIN_KIND_ELLAISM:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_ELLAISM[i]);
c0d01512:	201f      	movs	r0, #31
c0d01514:	4378      	muls	r0, r7
c0d01516:	496f      	ldr	r1, [pc, #444]	; (c0d016d4 <getKnownToken+0x224>)
c0d01518:	4479      	add	r1, pc
c0d0151a:	e09b      	b.n	c0d01654 <getKnownToken+0x1a4>
c0d0151c:	2804      	cmp	r0, #4
c0d0151e:	dd1b      	ble.n	c0d01558 <getKnownToken+0xa8>
c0d01520:	2807      	cmp	r0, #7
c0d01522:	dc31      	bgt.n	c0d01588 <getKnownToken+0xd8>
c0d01524:	2805      	cmp	r0, #5
c0d01526:	d055      	beq.n	c0d015d4 <getKnownToken+0x124>
c0d01528:	2806      	cmp	r0, #6
c0d0152a:	d058      	beq.n	c0d015de <getKnownToken+0x12e>
c0d0152c:	2807      	cmp	r0, #7
c0d0152e:	d000      	beq.n	c0d01532 <getKnownToken+0x82>
c0d01530:	e094      	b.n	c0d0165c <getKnownToken+0x1ac>
                break;
            case CHAIN_KIND_WANCHAIN:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_WANCHAIN[i]);
                break;
            case CHAIN_KIND_KUSD:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_KUSD[i]);
c0d01532:	201f      	movs	r0, #31
c0d01534:	4378      	muls	r0, r7
c0d01536:	4965      	ldr	r1, [pc, #404]	; (c0d016cc <getKnownToken+0x21c>)
c0d01538:	4479      	add	r1, pc
c0d0153a:	e08b      	b.n	c0d01654 <getKnownToken+0x1a4>
c0d0153c:	2813      	cmp	r0, #19
c0d0153e:	dc2e      	bgt.n	c0d0159e <getKnownToken+0xee>
c0d01540:	2811      	cmp	r0, #17
c0d01542:	d051      	beq.n	c0d015e8 <getKnownToken+0x138>
c0d01544:	2812      	cmp	r0, #18
c0d01546:	d054      	beq.n	c0d015f2 <getKnownToken+0x142>
c0d01548:	2813      	cmp	r0, #19
c0d0154a:	d000      	beq.n	c0d0154e <getKnownToken+0x9e>
c0d0154c:	e086      	b.n	c0d0165c <getKnownToken+0x1ac>
                break;
            case CHAIN_KIND_MIX:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_MIX[i]);
                break;
            case CHAIN_KIND_REOSC:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_REOSC[i]);
c0d0154e:	201f      	movs	r0, #31
c0d01550:	4378      	muls	r0, r7
c0d01552:	4962      	ldr	r1, [pc, #392]	; (c0d016dc <getKnownToken+0x22c>)
c0d01554:	4479      	add	r1, pc
c0d01556:	e07d      	b.n	c0d01654 <getKnownToken+0x1a4>
c0d01558:	2801      	cmp	r0, #1
c0d0155a:	dd28      	ble.n	c0d015ae <getKnownToken+0xfe>
c0d0155c:	2802      	cmp	r0, #2
c0d0155e:	d04d      	beq.n	c0d015fc <getKnownToken+0x14c>
c0d01560:	2803      	cmp	r0, #3
c0d01562:	d050      	beq.n	c0d01606 <getKnownToken+0x156>
c0d01564:	2804      	cmp	r0, #4
c0d01566:	d179      	bne.n	c0d0165c <getKnownToken+0x1ac>
                break;
            case CHAIN_KIND_POA:
                    currentToken = (tokenDefinition_t *)PIC(&TOKENS_POA[i]);
                    break;
            case CHAIN_KIND_RSK:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_RSK[i]);
c0d01568:	201f      	movs	r0, #31
c0d0156a:	4378      	muls	r0, r7
c0d0156c:	4956      	ldr	r1, [pc, #344]	; (c0d016c8 <getKnownToken+0x218>)
c0d0156e:	4479      	add	r1, pc
c0d01570:	e070      	b.n	c0d01654 <getKnownToken+0x1a4>
c0d01572:	280e      	cmp	r0, #14
c0d01574:	d04c      	beq.n	c0d01610 <getKnownToken+0x160>
c0d01576:	280f      	cmp	r0, #15
c0d01578:	d04f      	beq.n	c0d0161a <getKnownToken+0x16a>
c0d0157a:	2810      	cmp	r0, #16
c0d0157c:	d16e      	bne.n	c0d0165c <getKnownToken+0x1ac>
                break;
            case CHAIN_KIND_ETHERGEM:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_ETHERGEM[i]);
                break;
            case CHAIN_KIND_ATHEIOS:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_ATHEIOS[i]);
c0d0157e:	201f      	movs	r0, #31
c0d01580:	4378      	muls	r0, r7
c0d01582:	4955      	ldr	r1, [pc, #340]	; (c0d016d8 <getKnownToken+0x228>)
c0d01584:	4479      	add	r1, pc
c0d01586:	e065      	b.n	c0d01654 <getKnownToken+0x1a4>
c0d01588:	2808      	cmp	r0, #8
c0d0158a:	d04b      	beq.n	c0d01624 <getKnownToken+0x174>
c0d0158c:	2809      	cmp	r0, #9
c0d0158e:	d04e      	beq.n	c0d0162e <getKnownToken+0x17e>
c0d01590:	280a      	cmp	r0, #10
c0d01592:	d163      	bne.n	c0d0165c <getKnownToken+0x1ac>
                break;
            case CHAIN_KIND_KUSD:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_KUSD[i]);
                break;
            case CHAIN_KIND_MUSICOIN:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_MUSICOIN[i]);
c0d01594:	201f      	movs	r0, #31
c0d01596:	4378      	muls	r0, r7
c0d01598:	494d      	ldr	r1, [pc, #308]	; (c0d016d0 <getKnownToken+0x220>)
c0d0159a:	4479      	add	r1, pc
c0d0159c:	e05a      	b.n	c0d01654 <getKnownToken+0x1a4>
c0d0159e:	2814      	cmp	r0, #20
c0d015a0:	d04a      	beq.n	c0d01638 <getKnownToken+0x188>
c0d015a2:	2815      	cmp	r0, #21
c0d015a4:	d04d      	beq.n	c0d01642 <getKnownToken+0x192>
c0d015a6:	2816      	cmp	r0, #22
c0d015a8:	4630      	mov	r0, r6
c0d015aa:	d054      	beq.n	c0d01656 <getKnownToken+0x1a6>
c0d015ac:	e056      	b.n	c0d0165c <getKnownToken+0x1ac>
c0d015ae:	2800      	cmp	r0, #0
c0d015b0:	d04c      	beq.n	c0d0164c <getKnownToken+0x19c>
c0d015b2:	2801      	cmp	r0, #1
c0d015b4:	d152      	bne.n	c0d0165c <getKnownToken+0x1ac>
                break;
            case CHAIN_KIND_ETHEREUM:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_ETHEREUM[i]);
                break;
            case CHAIN_KIND_ETHEREUM_CLASSIC:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_ETHEREUM_CLASSIC[i]);
c0d015b6:	201f      	movs	r0, #31
c0d015b8:	4378      	muls	r0, r7
c0d015ba:	4942      	ldr	r1, [pc, #264]	; (c0d016c4 <getKnownToken+0x214>)
c0d015bc:	4479      	add	r1, pc
c0d015be:	e049      	b.n	c0d01654 <getKnownToken+0x1a4>
                break;
            case CHAIN_KIND_MUSICOIN:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_MUSICOIN[i]);
                break;
            case CHAIN_KIND_CALLISTO:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_CALLISTO[i]);
c0d015c0:	201f      	movs	r0, #31
c0d015c2:	4378      	muls	r0, r7
c0d015c4:	494d      	ldr	r1, [pc, #308]	; (c0d016fc <getKnownToken+0x24c>)
c0d015c6:	4479      	add	r1, pc
c0d015c8:	e044      	b.n	c0d01654 <getKnownToken+0x1a4>
                break;
            case CHAIN_KIND_ETHERSOCIAL:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_ETHERSOCIAL[i]);
c0d015ca:	201f      	movs	r0, #31
c0d015cc:	4378      	muls	r0, r7
c0d015ce:	494c      	ldr	r1, [pc, #304]	; (c0d01700 <getKnownToken+0x250>)
c0d015d0:	4479      	add	r1, pc
c0d015d2:	e03f      	b.n	c0d01654 <getKnownToken+0x1a4>
                break;
            case CHAIN_KIND_EXPANSE:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_EXPANSE[i]);
                break;
            case CHAIN_KIND_UBIQ:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_UBIQ[i]);
c0d015d4:	201f      	movs	r0, #31
c0d015d6:	4378      	muls	r0, r7
c0d015d8:	4946      	ldr	r1, [pc, #280]	; (c0d016f4 <getKnownToken+0x244>)
c0d015da:	4479      	add	r1, pc
c0d015dc:	e03a      	b.n	c0d01654 <getKnownToken+0x1a4>
                break;
            case CHAIN_KIND_WANCHAIN:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_WANCHAIN[i]);
c0d015de:	201f      	movs	r0, #31
c0d015e0:	4378      	muls	r0, r7
c0d015e2:	4945      	ldr	r1, [pc, #276]	; (c0d016f8 <getKnownToken+0x248>)
c0d015e4:	4479      	add	r1, pc
c0d015e6:	e035      	b.n	c0d01654 <getKnownToken+0x1a4>
                break;
            case CHAIN_KIND_ATHEIOS:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_ATHEIOS[i]);
                break;
            case CHAIN_KIND_GOCHAIN:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_GOCHAIN[i]);
c0d015e8:	201f      	movs	r0, #31
c0d015ea:	4378      	muls	r0, r7
c0d015ec:	4947      	ldr	r1, [pc, #284]	; (c0d0170c <getKnownToken+0x25c>)
c0d015ee:	4479      	add	r1, pc
c0d015f0:	e030      	b.n	c0d01654 <getKnownToken+0x1a4>
                break;
            case CHAIN_KIND_MIX:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_MIX[i]);
c0d015f2:	201f      	movs	r0, #31
c0d015f4:	4378      	muls	r0, r7
c0d015f6:	4946      	ldr	r1, [pc, #280]	; (c0d01710 <getKnownToken+0x260>)
c0d015f8:	4479      	add	r1, pc
c0d015fa:	e02b      	b.n	c0d01654 <getKnownToken+0x1a4>
                    break;
            case CHAIN_KIND_RSK:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_RSK[i]);
                break;
            case CHAIN_KIND_EXPANSE:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_EXPANSE[i]);
c0d015fc:	201f      	movs	r0, #31
c0d015fe:	4378      	muls	r0, r7
c0d01600:	493b      	ldr	r1, [pc, #236]	; (c0d016f0 <getKnownToken+0x240>)
c0d01602:	4479      	add	r1, pc
c0d01604:	e026      	b.n	c0d01654 <getKnownToken+0x1a4>
                break;
            case CHAIN_KIND_PIRL:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_PIRL[i]);
                break;
            case CHAIN_KIND_POA:
                    currentToken = (tokenDefinition_t *)PIC(&TOKENS_POA[i]);
c0d01606:	201f      	movs	r0, #31
c0d01608:	4378      	muls	r0, r7
c0d0160a:	4938      	ldr	r1, [pc, #224]	; (c0d016ec <getKnownToken+0x23c>)
c0d0160c:	4479      	add	r1, pc
c0d0160e:	e021      	b.n	c0d01654 <getKnownToken+0x1a4>
                break;
            case CHAIN_KIND_ELLAISM:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_ELLAISM[i]);
                break;
            case CHAIN_KIND_ETHER1:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_ETHER1[i]);
c0d01610:	201f      	movs	r0, #31
c0d01612:	4378      	muls	r0, r7
c0d01614:	493b      	ldr	r1, [pc, #236]	; (c0d01704 <getKnownToken+0x254>)
c0d01616:	4479      	add	r1, pc
c0d01618:	e01c      	b.n	c0d01654 <getKnownToken+0x1a4>
                break;
            case CHAIN_KIND_ETHERGEM:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_ETHERGEM[i]);
c0d0161a:	201f      	movs	r0, #31
c0d0161c:	4378      	muls	r0, r7
c0d0161e:	493a      	ldr	r1, [pc, #232]	; (c0d01708 <getKnownToken+0x258>)
c0d01620:	4479      	add	r1, pc
c0d01622:	e017      	b.n	c0d01654 <getKnownToken+0x1a4>
                break;
            case CHAIN_KIND_ETHEREUM_CLASSIC:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_ETHEREUM_CLASSIC[i]);
                break;
            case CHAIN_KIND_PIRL:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_PIRL[i]);
c0d01624:	201f      	movs	r0, #31
c0d01626:	4378      	muls	r0, r7
c0d01628:	492f      	ldr	r1, [pc, #188]	; (c0d016e8 <getKnownToken+0x238>)
c0d0162a:	4479      	add	r1, pc
c0d0162c:	e012      	b.n	c0d01654 <getKnownToken+0x1a4>
          break;
    }
    for (i=0; i<numTokens; i++) {
        switch(chainConfig->kind) {
            case CHAIN_KIND_AKROMA:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_AKROMA[i]);
c0d0162e:	201f      	movs	r0, #31
c0d01630:	4378      	muls	r0, r7
c0d01632:	492b      	ldr	r1, [pc, #172]	; (c0d016e0 <getKnownToken+0x230>)
c0d01634:	4479      	add	r1, pc
c0d01636:	e00d      	b.n	c0d01654 <getKnownToken+0x1a4>
                break;
            case CHAIN_KIND_REOSC:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_REOSC[i]);
                break;
            case CHAIN_KIND_HPB:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_HPB[i]);
c0d01638:	201f      	movs	r0, #31
c0d0163a:	4378      	muls	r0, r7
c0d0163c:	4935      	ldr	r1, [pc, #212]	; (c0d01714 <getKnownToken+0x264>)
c0d0163e:	4479      	add	r1, pc
c0d01640:	e008      	b.n	c0d01654 <getKnownToken+0x1a4>
                break;
            case CHAIN_KIND_TOMOCHAIN:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_TOMOCHAIN[i]);
c0d01642:	201f      	movs	r0, #31
c0d01644:	4378      	muls	r0, r7
c0d01646:	4934      	ldr	r1, [pc, #208]	; (c0d01718 <getKnownToken+0x268>)
c0d01648:	4479      	add	r1, pc
c0d0164a:	e003      	b.n	c0d01654 <getKnownToken+0x1a4>
        switch(chainConfig->kind) {
            case CHAIN_KIND_AKROMA:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_AKROMA[i]);
                break;
            case CHAIN_KIND_ETHEREUM:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_ETHEREUM[i]);
c0d0164c:	201f      	movs	r0, #31
c0d0164e:	4378      	muls	r0, r7
c0d01650:	4924      	ldr	r1, [pc, #144]	; (c0d016e4 <getKnownToken+0x234>)
c0d01652:	4479      	add	r1, pc
c0d01654:	1808      	adds	r0, r1, r0
                break;
            case CHAIN_KIND_TOMOCHAIN:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_TOMOCHAIN[i]);
                break;
            case CHAIN_KIND_DEXON:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_DEXON[i]);
c0d01656:	f002 fb45 	bl	c0d03ce4 <pic>
c0d0165a:	4604      	mov	r4, r0
                break;
        }
        if (os_memcmp(currentToken->address, tmpContent.txContent.destination, 20) == 0) {
c0d0165c:	4913      	ldr	r1, [pc, #76]	; (c0d016ac <getKnownToken+0x1fc>)
c0d0165e:	3163      	adds	r1, #99	; 0x63
c0d01660:	2214      	movs	r2, #20
c0d01662:	4620      	mov	r0, r4
c0d01664:	f001 fa82 	bl	c0d02b6c <os_memcmp>
            break;
        case CHAIN_KIND_DEXON:
          numTokens = NUM_TOKENS_DEXON;
          break;
    }
    for (i=0; i<numTokens; i++) {
c0d01668:	1c7f      	adds	r7, r7, #1
                break;
            case CHAIN_KIND_DEXON:
                currentToken = (tokenDefinition_t *)PIC(&TOKENS_DEXON[i]);
                break;
        }
        if (os_memcmp(currentToken->address, tmpContent.txContent.destination, 20) == 0) {
c0d0166a:	2800      	cmp	r0, #0
c0d0166c:	d017      	beq.n	c0d0169e <getKnownToken+0x1ee>
c0d0166e:	e739      	b.n	c0d014e4 <getKnownToken+0x34>
            return currentToken;
        }
    }
#endif

    if ((currentTokenSet || tokenProvisioned) && (os_memcmp(tmpCtx.transactionContext.currentToken.address, tmpContent.txContent.destination, 20) == 0)) {
c0d01670:	4e0f      	ldr	r6, [pc, #60]	; (c0d016b0 <getKnownToken+0x200>)
c0d01672:	7830      	ldrb	r0, [r6, #0]
c0d01674:	2800      	cmp	r0, #0
c0d01676:	d104      	bne.n	c0d01682 <getKnownToken+0x1d2>
c0d01678:	480e      	ldr	r0, [pc, #56]	; (c0d016b4 <getKnownToken+0x204>)
c0d0167a:	7800      	ldrb	r0, [r0, #0]
c0d0167c:	2400      	movs	r4, #0
c0d0167e:	2800      	cmp	r0, #0
c0d01680:	d00d      	beq.n	c0d0169e <getKnownToken+0x1ee>
c0d01682:	4d0d      	ldr	r5, [pc, #52]	; (c0d016b8 <getKnownToken+0x208>)
c0d01684:	354c      	adds	r5, #76	; 0x4c
c0d01686:	4909      	ldr	r1, [pc, #36]	; (c0d016ac <getKnownToken+0x1fc>)
c0d01688:	3163      	adds	r1, #99	; 0x63
c0d0168a:	2214      	movs	r2, #20
c0d0168c:	4628      	mov	r0, r5
c0d0168e:	f001 fa6d 	bl	c0d02b6c <os_memcmp>
c0d01692:	2400      	movs	r4, #0
c0d01694:	2800      	cmp	r0, #0
c0d01696:	d102      	bne.n	c0d0169e <getKnownToken+0x1ee>
      currentTokenSet = false;
c0d01698:	2000      	movs	r0, #0
c0d0169a:	7030      	strb	r0, [r6, #0]
c0d0169c:	462c      	mov	r4, r5
      return &tmpCtx.transactionContext.currentToken;
    }

    return NULL;
}
c0d0169e:	4620      	mov	r0, r4
c0d016a0:	b001      	add	sp, #4
c0d016a2:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d016a4:	20001aa0 	.word	0x20001aa0
c0d016a8:	007fdfdc 	.word	0x007fdfdc
c0d016ac:	2000194c 	.word	0x2000194c
c0d016b0:	20001aa4 	.word	0x20001aa4
c0d016b4:	20001aa5 	.word	0x20001aa5
c0d016b8:	200019cc 	.word	0x200019cc
c0d016bc:	0000685a 	.word	0x0000685a
c0d016c0:	0000f185 	.word	0x0000f185
c0d016c4:	0000ef71 	.word	0x0000ef71
c0d016c8:	0000f03b 	.word	0x0000f03b
c0d016cc:	0000f12b 	.word	0x0000f12b
c0d016d0:	0000f0c9 	.word	0x0000f0c9
c0d016d4:	0000eff6 	.word	0x0000eff6
c0d016d8:	0000f0df 	.word	0x0000f0df
c0d016dc:	0000f10f 	.word	0x0000f10f
c0d016e0:	00006968 	.word	0x00006968
c0d016e4:	0000694a 	.word	0x0000694a
c0d016e8:	0000ef7f 	.word	0x0000ef7f
c0d016ec:	0000ef9d 	.word	0x0000ef9d
c0d016f0:	0000f061 	.word	0x0000f061
c0d016f4:	0000efcf 	.word	0x0000efcf
c0d016f8:	0000f07f 	.word	0x0000f07f
c0d016fc:	0000f09d 	.word	0x0000f09d
c0d01700:	0000efd9 	.word	0x0000efd9
c0d01704:	0000ef93 	.word	0x0000ef93
c0d01708:	0000f043 	.word	0x0000f043
c0d0170c:	0000f075 	.word	0x0000f075
c0d01710:	0000f06b 	.word	0x0000f06b
c0d01714:	0000f025 	.word	0x0000f025
c0d01718:	0000f01b 	.word	0x0000f01b

c0d0171c <customProcessor>:

customStatus_e customProcessor(txContext_t *context) {
c0d0171c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0171e:	b083      	sub	sp, #12
c0d01720:	4604      	mov	r4, r0
    if ((context->currentField == TX_RLP_DATA) &&
c0d01722:	7820      	ldrb	r0, [r4, #0]
c0d01724:	2600      	movs	r6, #0
c0d01726:	2808      	cmp	r0, #8
c0d01728:	d127      	bne.n	c0d0177a <customProcessor+0x5e>
        (context->currentFieldLength != 0)) {
c0d0172a:	68a0      	ldr	r0, [r4, #8]

    return NULL;
}

customStatus_e customProcessor(txContext_t *context) {
    if ((context->currentField == TX_RLP_DATA) &&
c0d0172c:	2800      	cmp	r0, #0
c0d0172e:	d024      	beq.n	c0d0177a <customProcessor+0x5e>
        (context->currentFieldLength != 0)) {
        dataPresent = true;
c0d01730:	49a6      	ldr	r1, [pc, #664]	; (c0d019cc <customProcessor+0x2b0>)
c0d01732:	2701      	movs	r7, #1
c0d01734:	700f      	strb	r7, [r1, #0]
        // If handling a new contract rather than a function call, abort immediately
        if (tmpContent.txContent.destinationLength == 0) {
c0d01736:	2177      	movs	r1, #119	; 0x77
c0d01738:	4aa5      	ldr	r2, [pc, #660]	; (c0d019d0 <customProcessor+0x2b4>)
c0d0173a:	5c51      	ldrb	r1, [r2, r1]
c0d0173c:	2900      	cmp	r1, #0
c0d0173e:	d01c      	beq.n	c0d0177a <customProcessor+0x5e>
            return CUSTOM_NOT_HANDLED;
        }
        if (context->currentFieldPos == 0) {
c0d01740:	68e5      	ldr	r5, [r4, #12]
c0d01742:	2d00      	cmp	r5, #0
c0d01744:	d121      	bne.n	c0d0178a <customProcessor+0x6e>
c0d01746:	463d      	mov	r5, r7
            // If handling the beginning of the data field, assume that the function selector is present
            if (context->commandLength < 4) {
c0d01748:	6aa1      	ldr	r1, [r4, #40]	; 0x28
c0d0174a:	2703      	movs	r7, #3
c0d0174c:	2904      	cmp	r1, #4
c0d0174e:	d315      	bcc.n	c0d0177c <customProcessor+0x60>
c0d01750:	2100      	movs	r1, #0
                PRINTF("Missing function selector\n");
                return CUSTOM_FAULT;
            }
            // Initial check to see if the token content can be processed
            tokenProvisioned =
                (context->currentFieldLength == sizeof(dataContext.tokenContext.data)) &&
c0d01752:	2844      	cmp	r0, #68	; 0x44
c0d01754:	d115      	bne.n	c0d01782 <customProcessor+0x66>
                (os_memcmp(context->workBuffer, TOKEN_TRANSFER_ID, 4) == 0) &&
c0d01756:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0d01758:	460f      	mov	r7, r1
c0d0175a:	49a8      	ldr	r1, [pc, #672]	; (c0d019fc <customProcessor+0x2e0>)
c0d0175c:	4479      	add	r1, pc
c0d0175e:	2204      	movs	r2, #4
c0d01760:	f001 fa04 	bl	c0d02b6c <os_memcmp>
c0d01764:	4639      	mov	r1, r7
c0d01766:	2800      	cmp	r0, #0
c0d01768:	462f      	mov	r7, r5
c0d0176a:	d10b      	bne.n	c0d01784 <customProcessor+0x68>
                (getKnownToken() != NULL);
c0d0176c:	f7ff fea0 	bl	c0d014b0 <getKnownToken>
c0d01770:	2101      	movs	r1, #1
c0d01772:	2800      	cmp	r0, #0
c0d01774:	d106      	bne.n	c0d01784 <customProcessor+0x68>
c0d01776:	4601      	mov	r1, r0
c0d01778:	e004      	b.n	c0d01784 <customProcessor+0x68>
c0d0177a:	4637      	mov	r7, r6

            return CUSTOM_SUSPENDED;
        }
    }
    return CUSTOM_NOT_HANDLED;
}
c0d0177c:	b2f8      	uxtb	r0, r7
c0d0177e:	b003      	add	sp, #12
c0d01780:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d01782:	462f      	mov	r7, r5
            if (context->commandLength < 4) {
                PRINTF("Missing function selector\n");
                return CUSTOM_FAULT;
            }
            // Initial check to see if the token content can be processed
            tokenProvisioned =
c0d01784:	4893      	ldr	r0, [pc, #588]	; (c0d019d4 <customProcessor+0x2b8>)
c0d01786:	7001      	strb	r1, [r0, #0]
c0d01788:	68e5      	ldr	r5, [r4, #12]
                (context->currentFieldLength == sizeof(dataContext.tokenContext.data)) &&
                (os_memcmp(context->workBuffer, TOKEN_TRANSFER_ID, 4) == 0) &&
                (getKnownToken() != NULL);
        }
        if (tokenProvisioned) {
c0d0178a:	4892      	ldr	r0, [pc, #584]	; (c0d019d4 <customProcessor+0x2b8>)
c0d0178c:	7800      	ldrb	r0, [r0, #0]
c0d0178e:	2800      	cmp	r0, #0
c0d01790:	d016      	beq.n	c0d017c0 <customProcessor+0xa4>
            if (context->currentFieldPos < context->currentFieldLength) {
c0d01792:	68a0      	ldr	r0, [r4, #8]
c0d01794:	42a8      	cmp	r0, r5
c0d01796:	d90b      	bls.n	c0d017b0 <customProcessor+0x94>
                                                   context->currentFieldPos))
                                        ? context->commandLength
                                            : context->currentFieldLength -
                                                   context->currentFieldPos);
                copyTxData(context,
                    dataContext.tokenContext.data + context->currentFieldPos,
c0d01798:	498f      	ldr	r1, [pc, #572]	; (c0d019d8 <customProcessor+0x2bc>)
c0d0179a:	1949      	adds	r1, r1, r5
                (getKnownToken() != NULL);
        }
        if (tokenProvisioned) {
            if (context->currentFieldPos < context->currentFieldLength) {
                uint32_t copySize = (context->commandLength <
                                        ((context->currentFieldLength -
c0d0179c:	1b40      	subs	r0, r0, r5
                (os_memcmp(context->workBuffer, TOKEN_TRANSFER_ID, 4) == 0) &&
                (getKnownToken() != NULL);
        }
        if (tokenProvisioned) {
            if (context->currentFieldPos < context->currentFieldLength) {
                uint32_t copySize = (context->commandLength <
c0d0179e:	6aa2      	ldr	r2, [r4, #40]	; 0x28
c0d017a0:	4282      	cmp	r2, r0
c0d017a2:	d300      	bcc.n	c0d017a6 <customProcessor+0x8a>
c0d017a4:	4602      	mov	r2, r0
                                        ((context->currentFieldLength -
                                                   context->currentFieldPos))
                                        ? context->commandLength
                                            : context->currentFieldLength -
                                                   context->currentFieldPos);
                copyTxData(context,
c0d017a6:	4620      	mov	r0, r4
c0d017a8:	f7fe fd68 	bl	c0d0027c <copyTxData>
c0d017ac:	68a0      	ldr	r0, [r4, #8]
c0d017ae:	68e5      	ldr	r5, [r4, #12]
                    dataContext.tokenContext.data + context->currentFieldPos,
                    copySize);
            }
            if (context->currentFieldPos == context->currentFieldLength) {
c0d017b0:	4285      	cmp	r5, r0
c0d017b2:	d1e3      	bne.n	c0d0177c <customProcessor+0x60>
                context->currentField++;
c0d017b4:	7820      	ldrb	r0, [r4, #0]
c0d017b6:	1c40      	adds	r0, r0, #1
c0d017b8:	7020      	strb	r0, [r4, #0]
                context->processingField = false;
c0d017ba:	2000      	movs	r0, #0
c0d017bc:	7460      	strb	r0, [r4, #17]
c0d017be:	e7dd      	b.n	c0d0177c <customProcessor+0x60>
c0d017c0:	9702      	str	r7, [sp, #8]
        else {
            uint32_t blockSize;
            uint32_t copySize;
            uint32_t fieldPos = context->currentFieldPos;
            if (fieldPos == 0) {
                if (!N_storage.dataAllowed) {
c0d017c2:	488f      	ldr	r0, [pc, #572]	; (c0d01a00 <customProcessor+0x2e4>)
c0d017c4:	4478      	add	r0, pc
c0d017c6:	f002 fa8d 	bl	c0d03ce4 <pic>
        }
        else {
            uint32_t blockSize;
            uint32_t copySize;
            uint32_t fieldPos = context->currentFieldPos;
            if (fieldPos == 0) {
c0d017ca:	2d00      	cmp	r5, #0
c0d017cc:	d00b      	beq.n	c0d017e6 <customProcessor+0xca>
                dataContext.rawDataContext.fieldIndex = 0;
                dataContext.rawDataContext.fieldOffset = 0;
                blockSize = 4;
            }
            else {
                if (!N_storage.contractDetails) {
c0d017ce:	7840      	ldrb	r0, [r0, #1]
c0d017d0:	2800      	cmp	r0, #0
c0d017d2:	4637      	mov	r7, r6
c0d017d4:	d0d2      	beq.n	c0d0177c <customProcessor+0x60>
                  return CUSTOM_NOT_HANDLED;
                }
                blockSize = 32 - (dataContext.rawDataContext.fieldOffset % 32);
c0d017d6:	2021      	movs	r0, #33	; 0x21
c0d017d8:	497f      	ldr	r1, [pc, #508]	; (c0d019d8 <customProcessor+0x2bc>)
c0d017da:	5c08      	ldrb	r0, [r1, r0]
c0d017dc:	211f      	movs	r1, #31
c0d017de:	4001      	ands	r1, r0
c0d017e0:	2220      	movs	r2, #32
c0d017e2:	1a56      	subs	r6, r2, r1
c0d017e4:	e00f      	b.n	c0d01806 <customProcessor+0xea>
        else {
            uint32_t blockSize;
            uint32_t copySize;
            uint32_t fieldPos = context->currentFieldPos;
            if (fieldPos == 0) {
                if (!N_storage.dataAllowed) {
c0d017e6:	7800      	ldrb	r0, [r0, #0]
c0d017e8:	2703      	movs	r7, #3
c0d017ea:	2800      	cmp	r0, #0
c0d017ec:	d0c6      	beq.n	c0d0177c <customProcessor+0x60>
                  PRINTF("Data field forbidden\n");
                  return CUSTOM_FAULT;
                }
                if (!N_storage.contractDetails) {
c0d017ee:	4885      	ldr	r0, [pc, #532]	; (c0d01a04 <customProcessor+0x2e8>)
c0d017f0:	4478      	add	r0, pc
c0d017f2:	f002 fa77 	bl	c0d03ce4 <pic>
c0d017f6:	7840      	ldrb	r0, [r0, #1]
c0d017f8:	2800      	cmp	r0, #0
c0d017fa:	4637      	mov	r7, r6
c0d017fc:	d0be      	beq.n	c0d0177c <customProcessor+0x60>
                  return CUSTOM_NOT_HANDLED;
                }
                dataContext.rawDataContext.fieldIndex = 0;
c0d017fe:	4976      	ldr	r1, [pc, #472]	; (c0d019d8 <customProcessor+0x2bc>)
c0d01800:	2000      	movs	r0, #0
c0d01802:	8408      	strh	r0, [r1, #32]
c0d01804:	2604      	movs	r6, #4
                }
                blockSize = 32 - (dataContext.rawDataContext.fieldOffset % 32);
            }

            // Sanity check
            if ((context->currentFieldLength - fieldPos) < blockSize) {
c0d01806:	68a1      	ldr	r1, [r4, #8]
c0d01808:	1b49      	subs	r1, r1, r5
c0d0180a:	2703      	movs	r7, #3
c0d0180c:	42b1      	cmp	r1, r6
c0d0180e:	d3b5      	bcc.n	c0d0177c <customProcessor+0x60>
                return CUSTOM_FAULT;
            }

            copySize = (context->commandLength < blockSize ? context->commandLength : blockSize);
            copyTxData(context,
                        dataContext.rawDataContext.data + dataContext.rawDataContext.fieldOffset,
c0d01810:	4971      	ldr	r1, [pc, #452]	; (c0d019d8 <customProcessor+0x2bc>)
c0d01812:	1809      	adds	r1, r1, r0
            if ((context->currentFieldLength - fieldPos) < blockSize) {
                PRINTF("Unconsistent data\n");
                return CUSTOM_FAULT;
            }

            copySize = (context->commandLength < blockSize ? context->commandLength : blockSize);
c0d01814:	6aa7      	ldr	r7, [r4, #40]	; 0x28
c0d01816:	42b7      	cmp	r7, r6
c0d01818:	463a      	mov	r2, r7
c0d0181a:	d300      	bcc.n	c0d0181e <customProcessor+0x102>
c0d0181c:	4632      	mov	r2, r6
            copyTxData(context,
c0d0181e:	4620      	mov	r0, r4
c0d01820:	9201      	str	r2, [sp, #4]
c0d01822:	f7fe fd2b 	bl	c0d0027c <copyTxData>
                        dataContext.rawDataContext.data + dataContext.rawDataContext.fieldOffset,
                        copySize);

            if (context->currentFieldPos == context->currentFieldLength) {
c0d01826:	68a0      	ldr	r0, [r4, #8]
c0d01828:	68e1      	ldr	r1, [r4, #12]
c0d0182a:	4281      	cmp	r1, r0
c0d0182c:	d104      	bne.n	c0d01838 <customProcessor+0x11c>
                context->currentField++;
c0d0182e:	7820      	ldrb	r0, [r4, #0]
c0d01830:	1c40      	adds	r0, r0, #1
c0d01832:	7020      	strb	r0, [r4, #0]
                context->processingField = false;
c0d01834:	2000      	movs	r0, #0
c0d01836:	7460      	strb	r0, [r4, #17]
            }

            dataContext.rawDataContext.fieldOffset += copySize;
c0d01838:	2021      	movs	r0, #33	; 0x21
c0d0183a:	4967      	ldr	r1, [pc, #412]	; (c0d019d8 <customProcessor+0x2bc>)
c0d0183c:	460a      	mov	r2, r1
c0d0183e:	5c11      	ldrb	r1, [r2, r0]
c0d01840:	9b01      	ldr	r3, [sp, #4]
c0d01842:	18c9      	adds	r1, r1, r3
c0d01844:	5411      	strb	r1, [r2, r0]

            if (copySize == blockSize) {
c0d01846:	42b7      	cmp	r7, r6
c0d01848:	9f02      	ldr	r7, [sp, #8]
c0d0184a:	d397      	bcc.n	c0d0177c <customProcessor+0x60>
                // Can display
                if (fieldPos != 0) {
c0d0184c:	2d00      	cmp	r5, #0
c0d0184e:	d069      	beq.n	c0d01924 <customProcessor+0x208>
                    dataContext.rawDataContext.fieldIndex++;
c0d01850:	2120      	movs	r1, #32
c0d01852:	4f61      	ldr	r7, [pc, #388]	; (c0d019d8 <customProcessor+0x2bc>)
c0d01854:	5c7a      	ldrb	r2, [r7, r1]
c0d01856:	1c52      	adds	r2, r2, #1
c0d01858:	547a      	strb	r2, [r7, r1]
c0d0185a:	2400      	movs	r4, #0
                }
                dataContext.rawDataContext.fieldOffset = 0;
c0d0185c:	543c      	strb	r4, [r7, r0]
#endif // #if TARGET_ID
                }
                else {
                    uint32_t offset = 0;
                    uint32_t i;
                    snprintf(strings.tmp.tmp2, sizeof(strings.tmp.tmp2), "Field %d", dataContext.rawDataContext.fieldIndex);
c0d0185e:	b2d3      	uxtb	r3, r2
c0d01860:	4d5e      	ldr	r5, [pc, #376]	; (c0d019dc <customProcessor+0x2c0>)
c0d01862:	4628      	mov	r0, r5
c0d01864:	3064      	adds	r0, #100	; 0x64
c0d01866:	2128      	movs	r1, #40	; 0x28
c0d01868:	a25d      	add	r2, pc, #372	; (adr r2, c0d019e0 <customProcessor+0x2c4>)
c0d0186a:	f002 f825 	bl	c0d038b8 <snprintf>
c0d0186e:	4626      	mov	r6, r4
                    for (i=0; i<4; i++) {
                        offset += splitBinaryParameterPart(strings.tmp.tmp + offset, dataContext.rawDataContext.data + 8 * i);
c0d01870:	19a8      	adds	r0, r5, r6
c0d01872:	1939      	adds	r1, r7, r4
c0d01874:	f7ff fe04 	bl	c0d01480 <splitBinaryParameterPart>
c0d01878:	1980      	adds	r0, r0, r6
                        if (i != 3) {
c0d0187a:	2c18      	cmp	r4, #24
c0d0187c:	d005      	beq.n	c0d0188a <customProcessor+0x16e>
                            strings.tmp.tmp[offset++] = ':';
c0d0187e:	213a      	movs	r1, #58	; 0x3a
c0d01880:	5429      	strb	r1, [r5, r0]
                }
                else {
                    uint32_t offset = 0;
                    uint32_t i;
                    snprintf(strings.tmp.tmp2, sizeof(strings.tmp.tmp2), "Field %d", dataContext.rawDataContext.fieldIndex);
                    for (i=0; i<4; i++) {
c0d01882:	3408      	adds	r4, #8
                        offset += splitBinaryParameterPart(strings.tmp.tmp + offset, dataContext.rawDataContext.data + 8 * i);
                        if (i != 3) {
                            strings.tmp.tmp[offset++] = ':';
c0d01884:	1c46      	adds	r6, r0, #1
                }
                else {
                    uint32_t offset = 0;
                    uint32_t i;
                    snprintf(strings.tmp.tmp2, sizeof(strings.tmp.tmp2), "Field %d", dataContext.rawDataContext.fieldIndex);
                    for (i=0; i<4; i++) {
c0d01886:	2c20      	cmp	r4, #32
c0d01888:	d1f2      	bne.n	c0d01870 <customProcessor+0x154>
                        }
                    }
#if defined(TARGET_BLUE)
                    UX_DISPLAY(ui_data_parameter_blue, ui_data_parameter_blue_prepro);
#elif defined(TARGET_NANOS)
                    ux_step = 0;
c0d0188a:	4858      	ldr	r0, [pc, #352]	; (c0d019ec <customProcessor+0x2d0>)
c0d0188c:	2500      	movs	r5, #0
c0d0188e:	6005      	str	r5, [r0, #0]
                    ux_step_count = 2;
c0d01890:	4857      	ldr	r0, [pc, #348]	; (c0d019f0 <customProcessor+0x2d4>)
c0d01892:	2702      	movs	r7, #2
c0d01894:	6007      	str	r7, [r0, #0]
                    UX_DISPLAY(ui_data_parameter_nanos, ui_data_parameter_prepro);
c0d01896:	4c57      	ldr	r4, [pc, #348]	; (c0d019f4 <customProcessor+0x2d8>)
c0d01898:	485e      	ldr	r0, [pc, #376]	; (c0d01a14 <customProcessor+0x2f8>)
c0d0189a:	4478      	add	r0, pc
c0d0189c:	6020      	str	r0, [r4, #0]
c0d0189e:	2007      	movs	r0, #7
c0d018a0:	6060      	str	r0, [r4, #4]
c0d018a2:	485d      	ldr	r0, [pc, #372]	; (c0d01a18 <customProcessor+0x2fc>)
c0d018a4:	4478      	add	r0, pc
c0d018a6:	6120      	str	r0, [r4, #16]
c0d018a8:	485c      	ldr	r0, [pc, #368]	; (c0d01a1c <customProcessor+0x300>)
c0d018aa:	4478      	add	r0, pc
c0d018ac:	60e0      	str	r0, [r4, #12]
c0d018ae:	2003      	movs	r0, #3
c0d018b0:	7620      	strb	r0, [r4, #24]
c0d018b2:	61e5      	str	r5, [r4, #28]
c0d018b4:	4620      	mov	r0, r4
c0d018b6:	3018      	adds	r0, #24
c0d018b8:	f002 fbb2 	bl	c0d04020 <os_ux>
c0d018bc:	61e0      	str	r0, [r4, #28]
c0d018be:	f001 fff9 	bl	c0d038b4 <ux_check_status_default>
c0d018c2:	f001 fac7 	bl	c0d02e54 <io_seproxyhal_init_ux>
c0d018c6:	f001 facb 	bl	c0d02e60 <io_seproxyhal_init_button>
c0d018ca:	60a5      	str	r5, [r4, #8]
c0d018cc:	6820      	ldr	r0, [r4, #0]
c0d018ce:	2800      	cmp	r0, #0
c0d018d0:	d100      	bne.n	c0d018d4 <customProcessor+0x1b8>
c0d018d2:	e753      	b.n	c0d0177c <customProcessor+0x60>
c0d018d4:	69e0      	ldr	r0, [r4, #28]
c0d018d6:	4948      	ldr	r1, [pc, #288]	; (c0d019f8 <customProcessor+0x2dc>)
c0d018d8:	4288      	cmp	r0, r1
c0d018da:	d120      	bne.n	c0d0191e <customProcessor+0x202>
c0d018dc:	e74e      	b.n	c0d0177c <customProcessor+0x60>
c0d018de:	6860      	ldr	r0, [r4, #4]
c0d018e0:	4285      	cmp	r5, r0
c0d018e2:	d300      	bcc.n	c0d018e6 <customProcessor+0x1ca>
c0d018e4:	e74a      	b.n	c0d0177c <customProcessor+0x60>
c0d018e6:	f002 fc0b 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d018ea:	2800      	cmp	r0, #0
c0d018ec:	d000      	beq.n	c0d018f0 <customProcessor+0x1d4>
c0d018ee:	e745      	b.n	c0d0177c <customProcessor+0x60>
c0d018f0:	68a0      	ldr	r0, [r4, #8]
c0d018f2:	68e1      	ldr	r1, [r4, #12]
c0d018f4:	2538      	movs	r5, #56	; 0x38
c0d018f6:	4368      	muls	r0, r5
c0d018f8:	6822      	ldr	r2, [r4, #0]
c0d018fa:	1810      	adds	r0, r2, r0
c0d018fc:	2900      	cmp	r1, #0
c0d018fe:	d002      	beq.n	c0d01906 <customProcessor+0x1ea>
c0d01900:	4788      	blx	r1
c0d01902:	2800      	cmp	r0, #0
c0d01904:	d007      	beq.n	c0d01916 <customProcessor+0x1fa>
c0d01906:	2801      	cmp	r0, #1
c0d01908:	d103      	bne.n	c0d01912 <customProcessor+0x1f6>
c0d0190a:	68a0      	ldr	r0, [r4, #8]
c0d0190c:	4345      	muls	r5, r0
c0d0190e:	6820      	ldr	r0, [r4, #0]
c0d01910:	1940      	adds	r0, r0, r5
    return;
}

// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
  io_seproxyhal_display_default((bagl_element_t *)element);
c0d01912:	f001 fbf3 	bl	c0d030fc <io_seproxyhal_display_default>
#if defined(TARGET_BLUE)
                    UX_DISPLAY(ui_data_parameter_blue, ui_data_parameter_blue_prepro);
#elif defined(TARGET_NANOS)
                    ux_step = 0;
                    ux_step_count = 2;
                    UX_DISPLAY(ui_data_parameter_nanos, ui_data_parameter_prepro);
c0d01916:	68a0      	ldr	r0, [r4, #8]
c0d01918:	1c45      	adds	r5, r0, #1
c0d0191a:	60a5      	str	r5, [r4, #8]
c0d0191c:	6820      	ldr	r0, [r4, #0]
c0d0191e:	2800      	cmp	r0, #0
c0d01920:	d1dd      	bne.n	c0d018de <customProcessor+0x1c2>
c0d01922:	e72b      	b.n	c0d0177c <customProcessor+0x60>
c0d01924:	2500      	movs	r5, #0
c0d01926:	492c      	ldr	r1, [pc, #176]	; (c0d019d8 <customProcessor+0x2bc>)
            if (copySize == blockSize) {
                // Can display
                if (fieldPos != 0) {
                    dataContext.rawDataContext.fieldIndex++;
                }
                dataContext.rawDataContext.fieldOffset = 0;
c0d01928:	540d      	strb	r5, [r1, r0]
                if (fieldPos == 0) {
                    array_hexstr(strings.tmp.tmp, dataContext.rawDataContext.data, 4);
c0d0192a:	482c      	ldr	r0, [pc, #176]	; (c0d019dc <customProcessor+0x2c0>)
c0d0192c:	2204      	movs	r2, #4
c0d0192e:	f005 f989 	bl	c0d06c44 <array_hexstr>
#if defined(TARGET_BLUE)
                    UX_DISPLAY(ui_data_selector_blue, ui_data_selector_blue_prepro);
#elif defined(TARGET_NANOS)
                    ux_step = 0;
c0d01932:	482e      	ldr	r0, [pc, #184]	; (c0d019ec <customProcessor+0x2d0>)
c0d01934:	6005      	str	r5, [r0, #0]
                    ux_step_count = 2;
c0d01936:	482e      	ldr	r0, [pc, #184]	; (c0d019f0 <customProcessor+0x2d4>)
c0d01938:	2702      	movs	r7, #2
c0d0193a:	6007      	str	r7, [r0, #0]
                    UX_DISPLAY(ui_data_selector_nanos, ui_data_selector_prepro);
c0d0193c:	4c2d      	ldr	r4, [pc, #180]	; (c0d019f4 <customProcessor+0x2d8>)
c0d0193e:	4832      	ldr	r0, [pc, #200]	; (c0d01a08 <customProcessor+0x2ec>)
c0d01940:	4478      	add	r0, pc
c0d01942:	6020      	str	r0, [r4, #0]
c0d01944:	2007      	movs	r0, #7
c0d01946:	6060      	str	r0, [r4, #4]
c0d01948:	4830      	ldr	r0, [pc, #192]	; (c0d01a0c <customProcessor+0x2f0>)
c0d0194a:	4478      	add	r0, pc
c0d0194c:	6120      	str	r0, [r4, #16]
c0d0194e:	4830      	ldr	r0, [pc, #192]	; (c0d01a10 <customProcessor+0x2f4>)
c0d01950:	4478      	add	r0, pc
c0d01952:	60e0      	str	r0, [r4, #12]
c0d01954:	2003      	movs	r0, #3
c0d01956:	7620      	strb	r0, [r4, #24]
c0d01958:	61e5      	str	r5, [r4, #28]
c0d0195a:	4620      	mov	r0, r4
c0d0195c:	3018      	adds	r0, #24
c0d0195e:	f002 fb5f 	bl	c0d04020 <os_ux>
c0d01962:	61e0      	str	r0, [r4, #28]
c0d01964:	f001 ffa6 	bl	c0d038b4 <ux_check_status_default>
c0d01968:	f001 fa74 	bl	c0d02e54 <io_seproxyhal_init_ux>
c0d0196c:	f001 fa78 	bl	c0d02e60 <io_seproxyhal_init_button>
c0d01970:	60a5      	str	r5, [r4, #8]
c0d01972:	6820      	ldr	r0, [r4, #0]
c0d01974:	2800      	cmp	r0, #0
c0d01976:	d100      	bne.n	c0d0197a <customProcessor+0x25e>
c0d01978:	e700      	b.n	c0d0177c <customProcessor+0x60>
c0d0197a:	69e0      	ldr	r0, [r4, #28]
c0d0197c:	491e      	ldr	r1, [pc, #120]	; (c0d019f8 <customProcessor+0x2dc>)
c0d0197e:	4288      	cmp	r0, r1
c0d01980:	d120      	bne.n	c0d019c4 <customProcessor+0x2a8>
c0d01982:	e6fb      	b.n	c0d0177c <customProcessor+0x60>
c0d01984:	6860      	ldr	r0, [r4, #4]
c0d01986:	4285      	cmp	r5, r0
c0d01988:	d300      	bcc.n	c0d0198c <customProcessor+0x270>
c0d0198a:	e6f7      	b.n	c0d0177c <customProcessor+0x60>
c0d0198c:	f002 fbb8 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d01990:	2800      	cmp	r0, #0
c0d01992:	d000      	beq.n	c0d01996 <customProcessor+0x27a>
c0d01994:	e6f2      	b.n	c0d0177c <customProcessor+0x60>
c0d01996:	68a0      	ldr	r0, [r4, #8]
c0d01998:	68e1      	ldr	r1, [r4, #12]
c0d0199a:	2538      	movs	r5, #56	; 0x38
c0d0199c:	4368      	muls	r0, r5
c0d0199e:	6822      	ldr	r2, [r4, #0]
c0d019a0:	1810      	adds	r0, r2, r0
c0d019a2:	2900      	cmp	r1, #0
c0d019a4:	d002      	beq.n	c0d019ac <customProcessor+0x290>
c0d019a6:	4788      	blx	r1
c0d019a8:	2800      	cmp	r0, #0
c0d019aa:	d007      	beq.n	c0d019bc <customProcessor+0x2a0>
c0d019ac:	2801      	cmp	r0, #1
c0d019ae:	d103      	bne.n	c0d019b8 <customProcessor+0x29c>
c0d019b0:	68a0      	ldr	r0, [r4, #8]
c0d019b2:	4345      	muls	r5, r0
c0d019b4:	6820      	ldr	r0, [r4, #0]
c0d019b6:	1940      	adds	r0, r0, r5
    return;
}

// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
  io_seproxyhal_display_default((bagl_element_t *)element);
c0d019b8:	f001 fba0 	bl	c0d030fc <io_seproxyhal_display_default>
#if defined(TARGET_BLUE)
                    UX_DISPLAY(ui_data_selector_blue, ui_data_selector_blue_prepro);
#elif defined(TARGET_NANOS)
                    ux_step = 0;
                    ux_step_count = 2;
                    UX_DISPLAY(ui_data_selector_nanos, ui_data_selector_prepro);
c0d019bc:	68a0      	ldr	r0, [r4, #8]
c0d019be:	1c45      	adds	r5, r0, #1
c0d019c0:	60a5      	str	r5, [r4, #8]
c0d019c2:	6820      	ldr	r0, [r4, #0]
c0d019c4:	2800      	cmp	r0, #0
c0d019c6:	d1dd      	bne.n	c0d01984 <customProcessor+0x268>
c0d019c8:	e6d8      	b.n	c0d0177c <customProcessor+0x60>
c0d019ca:	46c0      	nop			; (mov r8, r8)
c0d019cc:	20001948 	.word	0x20001948
c0d019d0:	2000194c 	.word	0x2000194c
c0d019d4:	20001aa5 	.word	0x20001aa5
c0d019d8:	20001aa8 	.word	0x20001aa8
c0d019dc:	20001802 	.word	0x20001802
c0d019e0:	6c656946 	.word	0x6c656946
c0d019e4:	64252064 	.word	0x64252064
c0d019e8:	00000000 	.word	0x00000000
c0d019ec:	20001894 	.word	0x20001894
c0d019f0:	20001af0 	.word	0x20001af0
c0d019f4:	20001898 	.word	0x20001898
c0d019f8:	b0105044 	.word	0xb0105044
c0d019fc:	00006550 	.word	0x00006550
c0d01a00:	0000f0f8 	.word	0x0000f0f8
c0d01a04:	0000f0cc 	.word	0x0000f0cc
c0d01a08:	0000605c 	.word	0x0000605c
c0d01a0c:	fffffa5f 	.word	0xfffffa5f
c0d01a10:	fffff299 	.word	0xfffff299
c0d01a14:	0000628a 	.word	0x0000628a
c0d01a18:	fffffb4d 	.word	0xfffffb4d
c0d01a1c:	fffff39b 	.word	0xfffff39b

c0d01a20 <io_seproxyhal_display>:
//return_to_dashboard:
    return;
}

// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
c0d01a20:	b580      	push	{r7, lr}
  io_seproxyhal_display_default((bagl_element_t *)element);
c0d01a22:	f001 fb6b 	bl	c0d030fc <io_seproxyhal_display_default>
}
c0d01a26:	bd80      	pop	{r7, pc}

c0d01a28 <handleGetPublicKey>:
    }
    return CUSTOM_NOT_HANDLED;
}


void handleGetPublicKey(uint8_t p1, uint8_t p2, uint8_t *dataBuffer, uint16_t dataLength, volatile unsigned int *flags, volatile unsigned int *tx) {
c0d01a28:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d01a2a:	b0a1      	sub	sp, #132	; 0x84
c0d01a2c:	4613      	mov	r3, r2
c0d01a2e:	4605      	mov	r5, r0
  UNUSED(dataLength);
  uint8_t privateKeyData[32];
  uint32_t bip32Path[MAX_BIP32_PATH];
  uint32_t i;
  uint8_t bip32PathLength = *(dataBuffer++);
c0d01a30:	781a      	ldrb	r2, [r3, #0]
c0d01a32:	1c5b      	adds	r3, r3, #1
c0d01a34:	20d5      	movs	r0, #213	; 0xd5
c0d01a36:	01c0      	lsls	r0, r0, #7
  cx_ecfp_private_key_t privateKey;

  if ((bip32PathLength < 0x01) ||
c0d01a38:	1e54      	subs	r4, r2, #1
c0d01a3a:	b2e4      	uxtb	r4, r4
c0d01a3c:	2c0a      	cmp	r4, #10
c0d01a3e:	d300      	bcc.n	c0d01a42 <handleGetPublicKey+0x1a>
c0d01a40:	e0ae      	b.n	c0d01ba0 <handleGetPublicKey+0x178>
      (bip32PathLength > MAX_BIP32_PATH)) {
    PRINTF("Invalid path\n");
    THROW(0x6a80);
  }
  if ((p1 != P1_CONFIRM) && (p1 != P1_NON_CONFIRM)) {
c0d01a42:	2d02      	cmp	r5, #2
c0d01a44:	d300      	bcc.n	c0d01a48 <handleGetPublicKey+0x20>
c0d01a46:	e0a8      	b.n	c0d01b9a <handleGetPublicKey+0x172>
c0d01a48:	9504      	str	r5, [sp, #16]
    THROW(0x6B00);
  }
  if ((p2 != P2_CHAINCODE) && (p2 != P2_NO_CHAINCODE)) {
c0d01a4a:	2901      	cmp	r1, #1
c0d01a4c:	d900      	bls.n	c0d01a50 <handleGetPublicKey+0x28>
c0d01a4e:	e0a4      	b.n	c0d01b9a <handleGetPublicKey+0x172>
c0d01a50:	9827      	ldr	r0, [sp, #156]	; 0x9c
c0d01a52:	9001      	str	r0, [sp, #4]
c0d01a54:	9826      	ldr	r0, [sp, #152]	; 0x98
c0d01a56:	9002      	str	r0, [sp, #8]
c0d01a58:	a80f      	add	r0, sp, #60	; 0x3c
c0d01a5a:	4614      	mov	r4, r2
    THROW(0x6B00);
  }
  for (i = 0; i < bip32PathLength; i++) {
    bip32Path[i] = U4BE(dataBuffer, 0);
c0d01a5c:	78dd      	ldrb	r5, [r3, #3]
c0d01a5e:	789e      	ldrb	r6, [r3, #2]
c0d01a60:	0236      	lsls	r6, r6, #8
c0d01a62:	432e      	orrs	r6, r5
c0d01a64:	785d      	ldrb	r5, [r3, #1]
c0d01a66:	781f      	ldrb	r7, [r3, #0]
c0d01a68:	023f      	lsls	r7, r7, #8
c0d01a6a:	432f      	orrs	r7, r5
c0d01a6c:	043d      	lsls	r5, r7, #16
c0d01a6e:	4335      	orrs	r5, r6
c0d01a70:	c020      	stmia	r0!, {r5}
    THROW(0x6B00);
  }
  if ((p2 != P2_CHAINCODE) && (p2 != P2_NO_CHAINCODE)) {
    THROW(0x6B00);
  }
  for (i = 0; i < bip32PathLength; i++) {
c0d01a72:	1d1b      	adds	r3, r3, #4
c0d01a74:	1e64      	subs	r4, r4, #1
c0d01a76:	d1f1      	bne.n	c0d01a5c <handleGetPublicKey+0x34>
c0d01a78:	2400      	movs	r4, #0
    bip32Path[i] = U4BE(dataBuffer, 0);
    dataBuffer += 4;
  }
  tmpCtx.publicKeyContext.getChaincode = (p2 == P2_CHAINCODE);
c0d01a7a:	2901      	cmp	r1, #1
c0d01a7c:	4620      	mov	r0, r4
c0d01a7e:	d100      	bne.n	c0d01a82 <handleGetPublicKey+0x5a>
c0d01a80:	4608      	mov	r0, r1
c0d01a82:	2395      	movs	r3, #149	; 0x95
c0d01a84:	4d4b      	ldr	r5, [pc, #300]	; (c0d01bb4 <handleGetPublicKey+0x18c>)
c0d01a86:	54e8      	strb	r0, [r5, r3]
  os_perso_derive_node_bip32(CX_CURVE_256K1, bip32Path, bip32PathLength, privateKeyData, (tmpCtx.publicKeyContext.getChaincode ? tmpCtx.publicKeyContext.chainCode : NULL));
c0d01a88:	4628      	mov	r0, r5
c0d01a8a:	3075      	adds	r0, #117	; 0x75
c0d01a8c:	2901      	cmp	r1, #1
c0d01a8e:	d000      	beq.n	c0d01a92 <handleGetPublicKey+0x6a>
c0d01a90:	4620      	mov	r0, r4
c0d01a92:	4669      	mov	r1, sp
c0d01a94:	6008      	str	r0, [r1, #0]
c0d01a96:	2621      	movs	r6, #33	; 0x21
c0d01a98:	a90f      	add	r1, sp, #60	; 0x3c
c0d01a9a:	af19      	add	r7, sp, #100	; 0x64
c0d01a9c:	4630      	mov	r0, r6
c0d01a9e:	463b      	mov	r3, r7
c0d01aa0:	f002 fa90 	bl	c0d03fc4 <os_perso_derive_node_bip32>
  cx_ecfp_init_private_key(CX_CURVE_256K1, privateKeyData, 32, &privateKey);
c0d01aa4:	2220      	movs	r2, #32
c0d01aa6:	9203      	str	r2, [sp, #12]
c0d01aa8:	ad05      	add	r5, sp, #20
c0d01aaa:	4630      	mov	r0, r6
c0d01aac:	4639      	mov	r1, r7
c0d01aae:	462b      	mov	r3, r5
c0d01ab0:	f002 fa02 	bl	c0d03eb8 <cx_ecfp_init_private_key>
c0d01ab4:	2301      	movs	r3, #1
  cx_ecfp_generate_pair(CX_CURVE_256K1, &tmpCtx.publicKeyContext.publicKey, &privateKey, 1);
c0d01ab6:	4630      	mov	r0, r6
c0d01ab8:	4e3e      	ldr	r6, [pc, #248]	; (c0d01bb4 <handleGetPublicKey+0x18c>)
c0d01aba:	4631      	mov	r1, r6
c0d01abc:	462a      	mov	r2, r5
c0d01abe:	f002 fa13 	bl	c0d03ee8 <cx_ecfp_generate_pair>
  os_memset(&privateKey, 0, sizeof(privateKey));
c0d01ac2:	2228      	movs	r2, #40	; 0x28
c0d01ac4:	4628      	mov	r0, r5
c0d01ac6:	4621      	mov	r1, r4
c0d01ac8:	f000 ffaa 	bl	c0d02a20 <os_memset>
  os_memset(privateKeyData, 0, sizeof(privateKeyData));
c0d01acc:	4638      	mov	r0, r7
c0d01ace:	4621      	mov	r1, r4
c0d01ad0:	9a03      	ldr	r2, [sp, #12]
c0d01ad2:	f000 ffa5 	bl	c0d02a20 <os_memset>
  getEthAddressStringFromKey(&tmpCtx.publicKeyContext.publicKey, tmpCtx.publicKeyContext.address, &sha3);
c0d01ad6:	4634      	mov	r4, r6
c0d01ad8:	344c      	adds	r4, #76	; 0x4c
c0d01ada:	4a37      	ldr	r2, [pc, #220]	; (c0d01bb8 <handleGetPublicKey+0x190>)
c0d01adc:	4630      	mov	r0, r6
c0d01ade:	4621      	mov	r1, r4
c0d01ae0:	f7fe fe76 	bl	c0d007d0 <getEthAddressStringFromKey>
#ifndef NO_CONSENT
  if (p1 == P1_NON_CONFIRM)
c0d01ae4:	9804      	ldr	r0, [sp, #16]
c0d01ae6:	2800      	cmp	r0, #0
c0d01ae8:	d05c      	beq.n	c0d01ba4 <handleGetPublicKey+0x17c>
    // prepare for a UI based reply
#if defined(TARGET_BLUE)
    snprintf(strings.common.fullAddress, sizeof(strings.common.fullAddress), "0x%.*s", 40, tmpCtx.publicKeyContext.address);
    UX_DISPLAY(ui_address_blue, ui_address_blue_prepro);
#elif defined(TARGET_NANOS)
    snprintf(strings.common.fullAddress, sizeof(strings.common.fullAddress), "0x%.*s", 40, tmpCtx.publicKeyContext.address);
c0d01aea:	4668      	mov	r0, sp
c0d01aec:	6004      	str	r4, [r0, #0]
c0d01aee:	4833      	ldr	r0, [pc, #204]	; (c0d01bbc <handleGetPublicKey+0x194>)
c0d01af0:	212b      	movs	r1, #43	; 0x2b
c0d01af2:	a233      	add	r2, pc, #204	; (adr r2, c0d01bc0 <handleGetPublicKey+0x198>)
c0d01af4:	2328      	movs	r3, #40	; 0x28
c0d01af6:	f001 fedf 	bl	c0d038b8 <snprintf>
    ux_step = 0;
c0d01afa:	4833      	ldr	r0, [pc, #204]	; (c0d01bc8 <handleGetPublicKey+0x1a0>)
c0d01afc:	2500      	movs	r5, #0
c0d01afe:	6005      	str	r5, [r0, #0]
    ux_step_count = 2;
c0d01b00:	4832      	ldr	r0, [pc, #200]	; (c0d01bcc <handleGetPublicKey+0x1a4>)
c0d01b02:	2102      	movs	r1, #2
c0d01b04:	6001      	str	r1, [r0, #0]
    UX_DISPLAY(ui_address_nanos, ui_address_prepro);
c0d01b06:	4c32      	ldr	r4, [pc, #200]	; (c0d01bd0 <handleGetPublicKey+0x1a8>)
c0d01b08:	4833      	ldr	r0, [pc, #204]	; (c0d01bd8 <handleGetPublicKey+0x1b0>)
c0d01b0a:	4478      	add	r0, pc
c0d01b0c:	6020      	str	r0, [r4, #0]
c0d01b0e:	2007      	movs	r0, #7
c0d01b10:	6060      	str	r0, [r4, #4]
c0d01b12:	4832      	ldr	r0, [pc, #200]	; (c0d01bdc <handleGetPublicKey+0x1b4>)
c0d01b14:	4478      	add	r0, pc
c0d01b16:	6120      	str	r0, [r4, #16]
c0d01b18:	4831      	ldr	r0, [pc, #196]	; (c0d01be0 <handleGetPublicKey+0x1b8>)
c0d01b1a:	4478      	add	r0, pc
c0d01b1c:	60e0      	str	r0, [r4, #12]
c0d01b1e:	2003      	movs	r0, #3
c0d01b20:	7620      	strb	r0, [r4, #24]
c0d01b22:	61e5      	str	r5, [r4, #28]
c0d01b24:	4620      	mov	r0, r4
c0d01b26:	3018      	adds	r0, #24
c0d01b28:	f002 fa7a 	bl	c0d04020 <os_ux>
c0d01b2c:	61e0      	str	r0, [r4, #28]
c0d01b2e:	f001 fec1 	bl	c0d038b4 <ux_check_status_default>
c0d01b32:	f001 f98f 	bl	c0d02e54 <io_seproxyhal_init_ux>
c0d01b36:	f001 f993 	bl	c0d02e60 <io_seproxyhal_init_button>
c0d01b3a:	60a5      	str	r5, [r4, #8]
c0d01b3c:	6820      	ldr	r0, [r4, #0]
c0d01b3e:	2800      	cmp	r0, #0
c0d01b40:	d024      	beq.n	c0d01b8c <handleGetPublicKey+0x164>
c0d01b42:	69e0      	ldr	r0, [r4, #28]
c0d01b44:	4923      	ldr	r1, [pc, #140]	; (c0d01bd4 <handleGetPublicKey+0x1ac>)
c0d01b46:	4288      	cmp	r0, r1
c0d01b48:	d11e      	bne.n	c0d01b88 <handleGetPublicKey+0x160>
c0d01b4a:	e01f      	b.n	c0d01b8c <handleGetPublicKey+0x164>
c0d01b4c:	6860      	ldr	r0, [r4, #4]
c0d01b4e:	4285      	cmp	r5, r0
c0d01b50:	d21c      	bcs.n	c0d01b8c <handleGetPublicKey+0x164>
c0d01b52:	f002 fad5 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d01b56:	2800      	cmp	r0, #0
c0d01b58:	d118      	bne.n	c0d01b8c <handleGetPublicKey+0x164>
c0d01b5a:	68a0      	ldr	r0, [r4, #8]
c0d01b5c:	68e1      	ldr	r1, [r4, #12]
c0d01b5e:	2538      	movs	r5, #56	; 0x38
c0d01b60:	4368      	muls	r0, r5
c0d01b62:	6822      	ldr	r2, [r4, #0]
c0d01b64:	1810      	adds	r0, r2, r0
c0d01b66:	2900      	cmp	r1, #0
c0d01b68:	d002      	beq.n	c0d01b70 <handleGetPublicKey+0x148>
c0d01b6a:	4788      	blx	r1
c0d01b6c:	2800      	cmp	r0, #0
c0d01b6e:	d007      	beq.n	c0d01b80 <handleGetPublicKey+0x158>
c0d01b70:	2801      	cmp	r0, #1
c0d01b72:	d103      	bne.n	c0d01b7c <handleGetPublicKey+0x154>
c0d01b74:	68a0      	ldr	r0, [r4, #8]
c0d01b76:	4345      	muls	r5, r0
c0d01b78:	6820      	ldr	r0, [r4, #0]
c0d01b7a:	1940      	adds	r0, r0, r5
    return;
}

// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
  io_seproxyhal_display_default((bagl_element_t *)element);
c0d01b7c:	f001 fabe 	bl	c0d030fc <io_seproxyhal_display_default>
    UX_DISPLAY(ui_address_blue, ui_address_blue_prepro);
#elif defined(TARGET_NANOS)
    snprintf(strings.common.fullAddress, sizeof(strings.common.fullAddress), "0x%.*s", 40, tmpCtx.publicKeyContext.address);
    ux_step = 0;
    ux_step_count = 2;
    UX_DISPLAY(ui_address_nanos, ui_address_prepro);
c0d01b80:	68a0      	ldr	r0, [r4, #8]
c0d01b82:	1c45      	adds	r5, r0, #1
c0d01b84:	60a5      	str	r5, [r4, #8]
c0d01b86:	6820      	ldr	r0, [r4, #0]
c0d01b88:	2800      	cmp	r0, #0
c0d01b8a:	d1df      	bne.n	c0d01b4c <handleGetPublicKey+0x124>
c0d01b8c:	9a02      	ldr	r2, [sp, #8]
#elif defined(TARGET_NANOX)
    snprintf(strings.common.fullAddress, sizeof(strings.common.fullAddress), "0x%.*s", 40, tmpCtx.publicKeyContext.address);
    ux_flow_init(0, ux_display_public_flow, NULL);
#endif // #if TARGET_ID

    *flags |= IO_ASYNCH_REPLY;
c0d01b8e:	6810      	ldr	r0, [r2, #0]
c0d01b90:	2110      	movs	r1, #16
c0d01b92:	4301      	orrs	r1, r0
c0d01b94:	6011      	str	r1, [r2, #0]
  }
#endif // NO_CONSENT
}
c0d01b96:	b021      	add	sp, #132	; 0x84
c0d01b98:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d01b9a:	3080      	adds	r0, #128	; 0x80
c0d01b9c:	f000 fffd 	bl	c0d02b9a <os_longjmp>
  cx_ecfp_private_key_t privateKey;

  if ((bip32PathLength < 0x01) ||
      (bip32PathLength > MAX_BIP32_PATH)) {
    PRINTF("Invalid path\n");
    THROW(0x6a80);
c0d01ba0:	f000 fffb 	bl	c0d02b9a <os_longjmp>
  getEthAddressStringFromKey(&tmpCtx.publicKeyContext.publicKey, tmpCtx.publicKeyContext.address, &sha3);
#ifndef NO_CONSENT
  if (p1 == P1_NON_CONFIRM)
#endif // NO_CONSENT
  {
    *tx = set_result_get_publicKey();
c0d01ba4:	f7ff f8a2 	bl	c0d00cec <set_result_get_publicKey>
c0d01ba8:	9901      	ldr	r1, [sp, #4]
c0d01baa:	6008      	str	r0, [r1, #0]
    THROW(0x9000);
c0d01bac:	2009      	movs	r0, #9
c0d01bae:	0300      	lsls	r0, r0, #12
c0d01bb0:	f000 fff3 	bl	c0d02b9a <os_longjmp>
c0d01bb4:	200019cc 	.word	0x200019cc
c0d01bb8:	20001af8 	.word	0x20001af8
c0d01bbc:	20001802 	.word	0x20001802
c0d01bc0:	2e257830 	.word	0x2e257830
c0d01bc4:	0000732a 	.word	0x0000732a
c0d01bc8:	20001894 	.word	0x20001894
c0d01bcc:	20001af0 	.word	0x20001af0
c0d01bd0:	20001898 	.word	0x20001898
c0d01bd4:	b0105044 	.word	0xb0105044
c0d01bd8:	000058aa 	.word	0x000058aa
c0d01bdc:	fffff221 	.word	0xfffff221
c0d01be0:	ffffef97 	.word	0xffffef97

c0d01be4 <handleProvideErc20TokenInformation>:
    NULL);
#endif // #if TARGET_ID
#endif // NO_CONSENT
}

void handleProvideErc20TokenInformation(uint8_t p1, uint8_t p2, uint8_t *workBuffer, uint16_t dataLength, volatile unsigned int *flags, volatile unsigned int *tx) {
c0d01be4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d01be6:	b0a1      	sub	sp, #132	; 0x84
c0d01be8:	4616      	mov	r6, r2
c0d01bea:	20d5      	movs	r0, #213	; 0xd5
c0d01bec:	01c0      	lsls	r0, r0, #7
  uint32_t offset = 0;
  uint8_t tickerLength;
  uint32_t chainId;
  uint8_t hash[32];
  cx_ecfp_public_key_t tokenKey;
  if (dataLength < 1) {
c0d01bee:	2b00      	cmp	r3, #0
c0d01bf0:	d058      	beq.n	c0d01ca4 <handleProvideErc20TokenInformation+0xc0>
    THROW(0x6A80);
  }
  tickerLength = workBuffer[offset++];
  dataLength--;
  if (tickerLength >= sizeof(tmpCtx.transactionContext.currentToken.ticker)) {
c0d01bf2:	7835      	ldrb	r5, [r6, #0]
c0d01bf4:	2d0a      	cmp	r5, #10
c0d01bf6:	d255      	bcs.n	c0d01ca4 <handleProvideErc20TokenInformation+0xc0>
    THROW(0x6A80);
  }
  if (dataLength < tickerLength + 20 + 4 + 4) {
c0d01bf8:	462f      	mov	r7, r5
c0d01bfa:	371c      	adds	r7, #28
  cx_ecfp_public_key_t tokenKey;
  if (dataLength < 1) {
    THROW(0x6A80);
  }
  tickerLength = workBuffer[offset++];
  dataLength--;
c0d01bfc:	1e59      	subs	r1, r3, #1
  if (tickerLength >= sizeof(tmpCtx.transactionContext.currentToken.ticker)) {
    THROW(0x6A80);
  }
  if (dataLength < tickerLength + 20 + 4 + 4) {
c0d01bfe:	b289      	uxth	r1, r1
c0d01c00:	42b9      	cmp	r1, r7
c0d01c02:	d34f      	bcc.n	c0d01ca4 <handleProvideErc20TokenInformation+0xc0>
c0d01c04:	9104      	str	r1, [sp, #16]
c0d01c06:	9003      	str	r0, [sp, #12]
    THROW(0x6A80);
  }
  cx_hash_sha256(workBuffer + offset, tickerLength + 20 + 4 + 4, hash);
c0d01c08:	1c70      	adds	r0, r6, #1
c0d01c0a:	9005      	str	r0, [sp, #20]
c0d01c0c:	aa19      	add	r2, sp, #100	; 0x64
c0d01c0e:	4639      	mov	r1, r7
c0d01c10:	f7fe fa99 	bl	c0d00146 <cx_hash_sha256_X>
  os_memmove(tmpCtx.transactionContext.currentToken.ticker, workBuffer + offset, tickerLength);
c0d01c14:	4c24      	ldr	r4, [pc, #144]	; (c0d01ca8 <handleProvideErc20TokenInformation+0xc4>)
c0d01c16:	3460      	adds	r4, #96	; 0x60
c0d01c18:	4620      	mov	r0, r4
c0d01c1a:	9905      	ldr	r1, [sp, #20]
c0d01c1c:	462a      	mov	r2, r5
c0d01c1e:	f000 ff08 	bl	c0d02a32 <os_memmove>
c0d01c22:	2000      	movs	r0, #0
  tmpCtx.transactionContext.currentToken.ticker[tickerLength] = '\0';
c0d01c24:	5560      	strb	r0, [r4, r5]
    THROW(0x6A80);
  }
  if (dataLength < tickerLength + 20 + 4 + 4) {
    THROW(0x6A80);
  }
  cx_hash_sha256(workBuffer + offset, tickerLength + 20 + 4 + 4, hash);
c0d01c26:	1974      	adds	r4, r6, r5
  os_memmove(tmpCtx.transactionContext.currentToken.ticker, workBuffer + offset, tickerLength);
  tmpCtx.transactionContext.currentToken.ticker[tickerLength] = '\0';
  offset += tickerLength;
  dataLength -= tickerLength;
  os_memmove(tmpCtx.transactionContext.currentToken.address, workBuffer + offset, 20);
c0d01c28:	1c61      	adds	r1, r4, #1
  }
  if (dataLength < tickerLength + 20 + 4 + 4) {
    THROW(0x6A80);
  }
  cx_hash_sha256(workBuffer + offset, tickerLength + 20 + 4 + 4, hash);
  os_memmove(tmpCtx.transactionContext.currentToken.ticker, workBuffer + offset, tickerLength);
c0d01c2a:	481f      	ldr	r0, [pc, #124]	; (c0d01ca8 <handleProvideErc20TokenInformation+0xc4>)
c0d01c2c:	304c      	adds	r0, #76	; 0x4c
c0d01c2e:	2214      	movs	r2, #20
  tmpCtx.transactionContext.currentToken.ticker[tickerLength] = '\0';
  offset += tickerLength;
  dataLength -= tickerLength;
  os_memmove(tmpCtx.transactionContext.currentToken.address, workBuffer + offset, 20);
c0d01c30:	f000 feff 	bl	c0d02a32 <os_memmove>
  offset += 20;
  dataLength -= 20;
  tmpCtx.transactionContext.currentToken.decimals = U4BE(workBuffer, offset);
c0d01c34:	7e20      	ldrb	r0, [r4, #24]
c0d01c36:	216a      	movs	r1, #106	; 0x6a
c0d01c38:	4a1b      	ldr	r2, [pc, #108]	; (c0d01ca8 <handleProvideErc20TokenInformation+0xc4>)
c0d01c3a:	5450      	strb	r0, [r2, r1]
  offset += 4;
  dataLength -= 4;
  chainId = U4BE(workBuffer, offset);
  if ((chainConfig->chainId != 0) && (chainConfig->chainId != chainId)) {
c0d01c3c:	481b      	ldr	r0, [pc, #108]	; (c0d01cac <handleProvideErc20TokenInformation+0xc8>)
c0d01c3e:	6800      	ldr	r0, [r0, #0]
c0d01c40:	6840      	ldr	r0, [r0, #4]
c0d01c42:	2800      	cmp	r0, #0
c0d01c44:	d00b      	beq.n	c0d01c5e <handleProvideErc20TokenInformation+0x7a>
  offset += 20;
  dataLength -= 20;
  tmpCtx.transactionContext.currentToken.decimals = U4BE(workBuffer, offset);
  offset += 4;
  dataLength -= 4;
  chainId = U4BE(workBuffer, offset);
c0d01c46:	5df1      	ldrb	r1, [r6, r7]
c0d01c48:	7ee2      	ldrb	r2, [r4, #27]
c0d01c4a:	0212      	lsls	r2, r2, #8
c0d01c4c:	430a      	orrs	r2, r1
c0d01c4e:	7ea1      	ldrb	r1, [r4, #26]
c0d01c50:	7e63      	ldrb	r3, [r4, #25]
c0d01c52:	021b      	lsls	r3, r3, #8
c0d01c54:	430b      	orrs	r3, r1
c0d01c56:	0419      	lsls	r1, r3, #16
c0d01c58:	4311      	orrs	r1, r2
  if ((chainConfig->chainId != 0) && (chainConfig->chainId != chainId)) {
c0d01c5a:	4288      	cmp	r0, r1
c0d01c5c:	d11b      	bne.n	c0d01c96 <handleProvideErc20TokenInformation+0xb2>
    PRINTF("ChainId token mismatch\n");
    THROW(0x6A80);
  }
  offset += 4;
  dataLength -= 4;
  cx_ecfp_init_public_key(CX_CURVE_256K1, TOKEN_SIGNATURE_PUBLIC_KEY, sizeof(TOKEN_SIGNATURE_PUBLIC_KEY), &tokenKey);
c0d01c5e:	2021      	movs	r0, #33	; 0x21
c0d01c60:	4915      	ldr	r1, [pc, #84]	; (c0d01cb8 <handleProvideErc20TokenInformation+0xd4>)
c0d01c62:	4479      	add	r1, pc
c0d01c64:	2241      	movs	r2, #65	; 0x41
c0d01c66:	ae06      	add	r6, sp, #24
c0d01c68:	4633      	mov	r3, r6
c0d01c6a:	f002 f90d 	bl	c0d03e88 <cx_ecfp_init_public_key>
  if (!cx_ecdsa_verify(&tokenKey, CX_LAST, CX_SHA256, hash, 32, workBuffer + offset, dataLength)) {
c0d01c6e:	4810      	ldr	r0, [pc, #64]	; (c0d01cb0 <handleProvideErc20TokenInformation+0xcc>)
  }
  cx_hash_sha256(workBuffer + offset, tickerLength + 20 + 4 + 4, hash);
  os_memmove(tmpCtx.transactionContext.currentToken.ticker, workBuffer + offset, tickerLength);
  tmpCtx.transactionContext.currentToken.ticker[tickerLength] = '\0';
  offset += tickerLength;
  dataLength -= tickerLength;
c0d01c70:	9904      	ldr	r1, [sp, #16]
c0d01c72:	1809      	adds	r1, r1, r0
  if ((chainConfig->chainId != 0) && (chainConfig->chainId != chainId)) {
    PRINTF("ChainId token mismatch\n");
    THROW(0x6A80);
  }
  offset += 4;
  dataLength -= 4;
c0d01c74:	1b49      	subs	r1, r1, r5
  cx_ecfp_init_public_key(CX_CURVE_256K1, TOKEN_SIGNATURE_PUBLIC_KEY, sizeof(TOKEN_SIGNATURE_PUBLIC_KEY), &tokenKey);
  if (!cx_ecdsa_verify(&tokenKey, CX_LAST, CX_SHA256, hash, 32, workBuffer + offset, dataLength)) {
c0d01c76:	301b      	adds	r0, #27
c0d01c78:	4008      	ands	r0, r1
c0d01c7a:	4669      	mov	r1, sp
c0d01c7c:	341d      	adds	r4, #29
c0d01c7e:	2220      	movs	r2, #32
c0d01c80:	c114      	stmia	r1!, {r2, r4}
c0d01c82:	6008      	str	r0, [r1, #0]
c0d01c84:	2501      	movs	r5, #1
c0d01c86:	2203      	movs	r2, #3
c0d01c88:	ab19      	add	r3, sp, #100	; 0x64
c0d01c8a:	4630      	mov	r0, r6
c0d01c8c:	4629      	mov	r1, r5
c0d01c8e:	f002 f963 	bl	c0d03f58 <cx_ecdsa_verify>
c0d01c92:	2800      	cmp	r0, #0
c0d01c94:	d102      	bne.n	c0d01c9c <handleProvideErc20TokenInformation+0xb8>
c0d01c96:	9803      	ldr	r0, [sp, #12]
c0d01c98:	f000 ff7f 	bl	c0d02b9a <os_longjmp>
    PRINTF("Invalid token signature\n");
    THROW(0x6A80);
  }
  currentTokenSet = true;
c0d01c9c:	4805      	ldr	r0, [pc, #20]	; (c0d01cb4 <handleProvideErc20TokenInformation+0xd0>)
c0d01c9e:	7005      	strb	r5, [r0, #0]
  THROW(0x9000);
c0d01ca0:	2009      	movs	r0, #9
c0d01ca2:	0300      	lsls	r0, r0, #12
c0d01ca4:	f000 ff79 	bl	c0d02b9a <os_longjmp>
c0d01ca8:	200019cc 	.word	0x200019cc
c0d01cac:	20001aa0 	.word	0x20001aa0
c0d01cb0:	0000ffe4 	.word	0x0000ffe4
c0d01cb4:	20001aa4 	.word	0x20001aa4
c0d01cb8:	0000605b 	.word	0x0000605b

c0d01cbc <handleSign>:
}

void handleSign(uint8_t p1, uint8_t p2, uint8_t *workBuffer, uint16_t dataLength, volatile unsigned int *flags, volatile unsigned int *tx) {
c0d01cbc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d01cbe:	b085      	sub	sp, #20
c0d01cc0:	461e      	mov	r6, r3
c0d01cc2:	4615      	mov	r5, r2
c0d01cc4:	22d5      	movs	r2, #213	; 0xd5
c0d01cc6:	01d4      	lsls	r4, r2, #7
c0d01cc8:	226b      	movs	r2, #107	; 0x6b
c0d01cca:	0213      	lsls	r3, r2, #8
  UNUSED(tx);
  parserStatus_e txResult;
  uint32_t i;
  if (p1 == P1_FIRST) {
c0d01ccc:	2880      	cmp	r0, #128	; 0x80
c0d01cce:	d033      	beq.n	c0d01d38 <handleSign+0x7c>
c0d01cd0:	2800      	cmp	r0, #0
c0d01cd2:	d153      	bne.n	c0d01d7c <handleSign+0xc0>
c0d01cd4:	9103      	str	r1, [sp, #12]
c0d01cd6:	9404      	str	r4, [sp, #16]
    tmpCtx.transactionContext.pathLength = workBuffer[0];
c0d01cd8:	7828      	ldrb	r0, [r5, #0]
c0d01cda:	4932      	ldr	r1, [pc, #200]	; (c0d01da4 <handleSign+0xe8>)
c0d01cdc:	7008      	strb	r0, [r1, #0]
    if ((tmpCtx.transactionContext.pathLength < 0x01) ||
c0d01cde:	1e42      	subs	r2, r0, #1
c0d01ce0:	b2d2      	uxtb	r2, r2
c0d01ce2:	2a0a      	cmp	r2, #10
c0d01ce4:	d25a      	bcs.n	c0d01d9c <handleSign+0xe0>
c0d01ce6:	9302      	str	r3, [sp, #8]
        (tmpCtx.transactionContext.pathLength > MAX_BIP32_PATH)) {
      PRINTF("Invalid path\n");
      THROW(0x6a80);
    }
    workBuffer++;
    dataLength--;
c0d01ce8:	1e76      	subs	r6, r6, #1
    if ((tmpCtx.transactionContext.pathLength < 0x01) ||
        (tmpCtx.transactionContext.pathLength > MAX_BIP32_PATH)) {
      PRINTF("Invalid path\n");
      THROW(0x6a80);
    }
    workBuffer++;
c0d01cea:	1c6d      	adds	r5, r5, #1
c0d01cec:	2200      	movs	r2, #0
    dataLength--;
    for (i = 0; i < tmpCtx.transactionContext.pathLength; i++) {
      tmpCtx.transactionContext.bip32Path[i] = U4BE(workBuffer, 0);
c0d01cee:	78eb      	ldrb	r3, [r5, #3]
c0d01cf0:	78af      	ldrb	r7, [r5, #2]
c0d01cf2:	023f      	lsls	r7, r7, #8
c0d01cf4:	431f      	orrs	r7, r3
c0d01cf6:	786b      	ldrb	r3, [r5, #1]
c0d01cf8:	782c      	ldrb	r4, [r5, #0]
c0d01cfa:	0224      	lsls	r4, r4, #8
c0d01cfc:	431c      	orrs	r4, r3
c0d01cfe:	0423      	lsls	r3, r4, #16
c0d01d00:	433b      	orrs	r3, r7
c0d01d02:	0094      	lsls	r4, r2, #2
c0d01d04:	190c      	adds	r4, r1, r4
c0d01d06:	6063      	str	r3, [r4, #4]
      workBuffer += 4;
      dataLength -= 4;
c0d01d08:	b2b3      	uxth	r3, r6
c0d01d0a:	4c27      	ldr	r4, [pc, #156]	; (c0d01da8 <handleSign+0xec>)
c0d01d0c:	191e      	adds	r6, r3, r4
    }
    workBuffer++;
    dataLength--;
    for (i = 0; i < tmpCtx.transactionContext.pathLength; i++) {
      tmpCtx.transactionContext.bip32Path[i] = U4BE(workBuffer, 0);
      workBuffer += 4;
c0d01d0e:	1d2d      	adds	r5, r5, #4
      PRINTF("Invalid path\n");
      THROW(0x6a80);
    }
    workBuffer++;
    dataLength--;
    for (i = 0; i < tmpCtx.transactionContext.pathLength; i++) {
c0d01d10:	1c52      	adds	r2, r2, #1
c0d01d12:	4282      	cmp	r2, r0
c0d01d14:	d3eb      	bcc.n	c0d01cee <handleSign+0x32>
      tmpCtx.transactionContext.bip32Path[i] = U4BE(workBuffer, 0);
      workBuffer += 4;
      dataLength -= 4;
    }
    dataPresent = false;
c0d01d16:	4825      	ldr	r0, [pc, #148]	; (c0d01dac <handleSign+0xf0>)
c0d01d18:	2100      	movs	r1, #0
c0d01d1a:	7001      	strb	r1, [r0, #0]
    tokenProvisioned = false;
c0d01d1c:	4824      	ldr	r0, [pc, #144]	; (c0d01db0 <handleSign+0xf4>)
c0d01d1e:	7001      	strb	r1, [r0, #0]
    initTx(&txContext, &sha3, &tmpContent.txContent, customProcessor, NULL);
c0d01d20:	4668      	mov	r0, sp
c0d01d22:	6001      	str	r1, [r0, #0]
c0d01d24:	4823      	ldr	r0, [pc, #140]	; (c0d01db4 <handleSign+0xf8>)
c0d01d26:	4924      	ldr	r1, [pc, #144]	; (c0d01db8 <handleSign+0xfc>)
c0d01d28:	4a24      	ldr	r2, [pc, #144]	; (c0d01dbc <handleSign+0x100>)
c0d01d2a:	4b26      	ldr	r3, [pc, #152]	; (c0d01dc4 <handleSign+0x108>)
c0d01d2c:	447b      	add	r3, pc
c0d01d2e:	f7fe fa68 	bl	c0d00202 <initTx>
c0d01d32:	9c04      	ldr	r4, [sp, #16]
c0d01d34:	9b02      	ldr	r3, [sp, #8]
c0d01d36:	9903      	ldr	r1, [sp, #12]
  }
  else
  if (p1 != P1_MORE) {
    THROW(0x6B00);
  }
  if (p2 != 0) {
c0d01d38:	2900      	cmp	r1, #0
c0d01d3a:	d11f      	bne.n	c0d01d7c <handleSign+0xc0>
    THROW(0x6B00);
  }
  if (txContext.currentField == TX_RLP_NONE) {
c0d01d3c:	481d      	ldr	r0, [pc, #116]	; (c0d01db4 <handleSign+0xf8>)
c0d01d3e:	7800      	ldrb	r0, [r0, #0]
c0d01d40:	2800      	cmp	r0, #0
c0d01d42:	d01e      	beq.n	c0d01d82 <handleSign+0xc6>
    PRINTF("Parser not initialized\n");
    THROW(0x6985);
  }
  txResult = processTx(&txContext, workBuffer, dataLength, (chainConfig->kind == CHAIN_KIND_WANCHAIN ? TX_FLAG_TYPE : 0));
c0d01d44:	481e      	ldr	r0, [pc, #120]	; (c0d01dc0 <handleSign+0x104>)
c0d01d46:	6800      	ldr	r0, [r0, #0]
c0d01d48:	7a01      	ldrb	r1, [r0, #8]
c0d01d4a:	2301      	movs	r3, #1
c0d01d4c:	2000      	movs	r0, #0
c0d01d4e:	2906      	cmp	r1, #6
c0d01d50:	d000      	beq.n	c0d01d54 <handleSign+0x98>
c0d01d52:	4603      	mov	r3, r0
c0d01d54:	b2b2      	uxth	r2, r6
c0d01d56:	4817      	ldr	r0, [pc, #92]	; (c0d01db4 <handleSign+0xf8>)
c0d01d58:	4629      	mov	r1, r5
c0d01d5a:	f7fe fac5 	bl	c0d002e8 <processTx>
  switch (txResult) {
c0d01d5e:	1e41      	subs	r1, r0, #1
c0d01d60:	2902      	cmp	r1, #2
c0d01d62:	d210      	bcs.n	c0d01d86 <handleSign+0xca>
c0d01d64:	990a      	ldr	r1, [sp, #40]	; 0x28
    default:
      PRINTF("Unexpected parser status\n");
      THROW(0x6A80);
  }

  *flags |= IO_ASYNCH_REPLY;
c0d01d66:	680a      	ldr	r2, [r1, #0]
c0d01d68:	2310      	movs	r3, #16
c0d01d6a:	4313      	orrs	r3, r2
c0d01d6c:	600b      	str	r3, [r1, #0]

  if (txResult == USTREAM_FINISHED) {
c0d01d6e:	2802      	cmp	r0, #2
c0d01d70:	d102      	bne.n	c0d01d78 <handleSign+0xbc>
    finalizeParsing(true);
c0d01d72:	2001      	movs	r0, #1
c0d01d74:	f7ff f92e 	bl	c0d00fd4 <finalizeParsing>
  }
}
c0d01d78:	b005      	add	sp, #20
c0d01d7a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d01d7c:	4618      	mov	r0, r3
c0d01d7e:	f000 ff0c 	bl	c0d02b9a <os_longjmp>
  if (p2 != 0) {
    THROW(0x6B00);
  }
  if (txContext.currentField == TX_RLP_NONE) {
    PRINTF("Parser not initialized\n");
    THROW(0x6985);
c0d01d82:	3cfb      	subs	r4, #251	; 0xfb
c0d01d84:	e007      	b.n	c0d01d96 <handleSign+0xda>
c0d01d86:	2803      	cmp	r0, #3
c0d01d88:	d005      	beq.n	c0d01d96 <handleSign+0xda>
c0d01d8a:	2800      	cmp	r0, #0
c0d01d8c:	d103      	bne.n	c0d01d96 <handleSign+0xda>
    case USTREAM_SUSPENDED:
      break;
    case USTREAM_FINISHED:
      break;
    case USTREAM_PROCESSING:
      THROW(0x9000);
c0d01d8e:	2009      	movs	r0, #9
c0d01d90:	0300      	lsls	r0, r0, #12
c0d01d92:	f000 ff02 	bl	c0d02b9a <os_longjmp>
c0d01d96:	4620      	mov	r0, r4
c0d01d98:	f000 feff 	bl	c0d02b9a <os_longjmp>
  if (p1 == P1_FIRST) {
    tmpCtx.transactionContext.pathLength = workBuffer[0];
    if ((tmpCtx.transactionContext.pathLength < 0x01) ||
        (tmpCtx.transactionContext.pathLength > MAX_BIP32_PATH)) {
      PRINTF("Invalid path\n");
      THROW(0x6a80);
c0d01d9c:	9804      	ldr	r0, [sp, #16]
c0d01d9e:	f000 fefc 	bl	c0d02b9a <os_longjmp>
c0d01da2:	46c0      	nop			; (mov r8, r8)
c0d01da4:	200019cc 	.word	0x200019cc
c0d01da8:	0000fffc 	.word	0x0000fffc
c0d01dac:	20001948 	.word	0x20001948
c0d01db0:	20001aa5 	.word	0x20001aa5
c0d01db4:	20001a64 	.word	0x20001a64
c0d01db8:	20001af8 	.word	0x20001af8
c0d01dbc:	2000194c 	.word	0x2000194c
c0d01dc0:	20001aa0 	.word	0x20001aa0
c0d01dc4:	fffff9ed 	.word	0xfffff9ed

c0d01dc8 <handleGetAppConfiguration>:
  if (txResult == USTREAM_FINISHED) {
    finalizeParsing(true);
  }
}

void handleGetAppConfiguration(uint8_t p1, uint8_t p2, uint8_t *workBuffer, uint16_t dataLength, volatile unsigned int *flags, volatile unsigned int *tx) {
c0d01dc8:	b580      	push	{r7, lr}
  UNUSED(p1);
  UNUSED(p2);
  UNUSED(workBuffer);
  UNUSED(dataLength);
  UNUSED(flags);
  G_io_apdu_buffer[0] = (N_storage.dataAllowed ? APP_FLAG_DATA_ALLOWED : 0x00);
c0d01dca:	480c      	ldr	r0, [pc, #48]	; (c0d01dfc <handleGetAppConfiguration+0x34>)
c0d01dcc:	4478      	add	r0, pc
c0d01dce:	f001 ff89 	bl	c0d03ce4 <pic>
c0d01dd2:	7801      	ldrb	r1, [r0, #0]
c0d01dd4:	2001      	movs	r0, #1
c0d01dd6:	2900      	cmp	r1, #0
c0d01dd8:	4602      	mov	r2, r0
c0d01dda:	d100      	bne.n	c0d01dde <handleGetAppConfiguration+0x16>
c0d01ddc:	460a      	mov	r2, r1
c0d01dde:	4906      	ldr	r1, [pc, #24]	; (c0d01df8 <handleGetAppConfiguration+0x30>)
c0d01de0:	700a      	strb	r2, [r1, #0]
#ifndef HAVE_TOKENS_LIST
  G_io_apdu_buffer[0] |= APP_FLAG_EXTERNAL_TOKEN_NEEDED;
#endif
  G_io_apdu_buffer[1] = LEDGER_MAJOR_VERSION;
c0d01de2:	7048      	strb	r0, [r1, #1]
  G_io_apdu_buffer[2] = LEDGER_MINOR_VERSION;
c0d01de4:	2202      	movs	r2, #2
c0d01de6:	708a      	strb	r2, [r1, #2]
  G_io_apdu_buffer[3] = LEDGER_PATCH_VERSION;
c0d01de8:	70c8      	strb	r0, [r1, #3]
c0d01dea:	9803      	ldr	r0, [sp, #12]
  *tx = 4;
c0d01dec:	2104      	movs	r1, #4
c0d01dee:	6001      	str	r1, [r0, #0]
  THROW(0x9000);
c0d01df0:	2009      	movs	r0, #9
c0d01df2:	0300      	lsls	r0, r0, #12
c0d01df4:	f000 fed1 	bl	c0d02b9a <os_longjmp>
c0d01df8:	20001d4c 	.word	0x20001d4c
c0d01dfc:	0000eaf0 	.word	0x0000eaf0

c0d01e00 <handleSignPersonalMessage>:
}

void handleSignPersonalMessage(uint8_t p1, uint8_t p2, uint8_t *workBuffer, uint16_t dataLength, volatile unsigned int *flags, volatile unsigned int *tx) {
c0d01e00:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d01e02:	b08f      	sub	sp, #60	; 0x3c
c0d01e04:	4617      	mov	r7, r2
c0d01e06:	22d5      	movs	r2, #213	; 0xd5
c0d01e08:	01d2      	lsls	r2, r2, #7
  UNUSED(tx);
  uint8_t hashMessage[32];
  if (p1 == P1_FIRST) {
c0d01e0a:	2880      	cmp	r0, #128	; 0x80
c0d01e0c:	d100      	bne.n	c0d01e10 <handleSignPersonalMessage+0x10>
c0d01e0e:	e08f      	b.n	c0d01f30 <handleSignPersonalMessage+0x130>
c0d01e10:	2800      	cmp	r0, #0
c0d01e12:	d000      	beq.n	c0d01e16 <handleSignPersonalMessage+0x16>
c0d01e14:	e11e      	b.n	c0d02054 <handleSignPersonalMessage+0x254>
c0d01e16:	9205      	str	r2, [sp, #20]
    char tmp[11];
    uint32_t index;
    uint32_t base = 10;
    uint8_t pos = 0;
    uint32_t i;
    tmpCtx.messageSigningContext.pathLength = workBuffer[0];
c0d01e18:	783a      	ldrb	r2, [r7, #0]
c0d01e1a:	4e94      	ldr	r6, [pc, #592]	; (c0d0206c <handleSignPersonalMessage+0x26c>)
c0d01e1c:	7032      	strb	r2, [r6, #0]
    if ((tmpCtx.messageSigningContext.pathLength < 0x01) ||
c0d01e1e:	1e50      	subs	r0, r2, #1
c0d01e20:	b2c0      	uxtb	r0, r0
c0d01e22:	280a      	cmp	r0, #10
c0d01e24:	d300      	bcc.n	c0d01e28 <handleSignPersonalMessage+0x28>
c0d01e26:	e11d      	b.n	c0d02064 <handleSignPersonalMessage+0x264>
c0d01e28:	9104      	str	r1, [sp, #16]
c0d01e2a:	7938      	ldrb	r0, [r7, #4]
c0d01e2c:	78f9      	ldrb	r1, [r7, #3]
c0d01e2e:	0209      	lsls	r1, r1, #8
c0d01e30:	4301      	orrs	r1, r0
c0d01e32:	78b8      	ldrb	r0, [r7, #2]
c0d01e34:	463c      	mov	r4, r7
c0d01e36:	787d      	ldrb	r5, [r7, #1]
c0d01e38:	022d      	lsls	r5, r5, #8
c0d01e3a:	4305      	orrs	r5, r0
c0d01e3c:	0428      	lsls	r0, r5, #16
c0d01e3e:	4308      	orrs	r0, r1
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    workBuffer++;
    dataLength--;
    for (i = 0; i < tmpCtx.messageSigningContext.pathLength; i++) {
c0d01e40:	0091      	lsls	r1, r2, #2
c0d01e42:	2501      	movs	r5, #1
c0d01e44:	9103      	str	r1, [sp, #12]
c0d01e46:	4329      	orrs	r1, r5
c0d01e48:	9102      	str	r1, [sp, #8]
        (tmpCtx.messageSigningContext.pathLength > MAX_BIP32_PATH)) {
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    workBuffer++;
    dataLength--;
c0d01e4a:	1e59      	subs	r1, r3, #1
    for (i = 0; i < tmpCtx.messageSigningContext.pathLength; i++) {
c0d01e4c:	9101      	str	r1, [sp, #4]
c0d01e4e:	2a00      	cmp	r2, #0
c0d01e50:	9406      	str	r4, [sp, #24]
c0d01e52:	d01b      	beq.n	c0d01e8c <handleSignPersonalMessage+0x8c>
c0d01e54:	2103      	movs	r1, #3
c0d01e56:	43c9      	mvns	r1, r1
        tmpCtx.messageSigningContext.bip32Path[i] = U4BE(workBuffer, 0);
c0d01e58:	4252      	negs	r2, r2
c0d01e5a:	2300      	movs	r3, #0
c0d01e5c:	4637      	mov	r7, r6
c0d01e5e:	1cce      	adds	r6, r1, #3
c0d01e60:	435e      	muls	r6, r3
c0d01e62:	00b6      	lsls	r6, r6, #2
c0d01e64:	19be      	adds	r6, r7, r6
c0d01e66:	6070      	str	r0, [r6, #4]
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    workBuffer++;
    dataLength--;
    for (i = 0; i < tmpCtx.messageSigningContext.pathLength; i++) {
c0d01e68:	4608      	mov	r0, r1
c0d01e6a:	4358      	muls	r0, r3
c0d01e6c:	9c06      	ldr	r4, [sp, #24]
c0d01e6e:	1820      	adds	r0, r4, r0
c0d01e70:	7a06      	ldrb	r6, [r0, #8]
c0d01e72:	79c4      	ldrb	r4, [r0, #7]
c0d01e74:	0224      	lsls	r4, r4, #8
c0d01e76:	4334      	orrs	r4, r6
c0d01e78:	7986      	ldrb	r6, [r0, #6]
c0d01e7a:	7940      	ldrb	r0, [r0, #5]
c0d01e7c:	0200      	lsls	r0, r0, #8
c0d01e7e:	4330      	orrs	r0, r6
c0d01e80:	0400      	lsls	r0, r0, #16
c0d01e82:	4320      	orrs	r0, r4
c0d01e84:	1e5b      	subs	r3, r3, #1
c0d01e86:	429a      	cmp	r2, r3
c0d01e88:	d1e9      	bne.n	c0d01e5e <handleSignPersonalMessage+0x5e>
c0d01e8a:	e000      	b.n	c0d01e8e <handleSignPersonalMessage+0x8e>
c0d01e8c:	4637      	mov	r7, r6
        tmpCtx.messageSigningContext.bip32Path[i] = U4BE(workBuffer, 0);
        workBuffer += 4;
        dataLength -= 4;
    }
    tmpCtx.messageSigningContext.remainingLength = U4BE(workBuffer, 0);
c0d01e8e:	64f8      	str	r0, [r7, #76]	; 0x4c
    workBuffer += 4;
    dataLength -= 4;
    // Initialize message header + length
    cx_keccak_init(&sha3, 256);
c0d01e90:	0229      	lsls	r1, r5, #8
c0d01e92:	4c77      	ldr	r4, [pc, #476]	; (c0d02070 <handleSignPersonalMessage+0x270>)
c0d01e94:	4620      	mov	r0, r4
c0d01e96:	f001 ffdf 	bl	c0d03e58 <cx_keccak_init>
c0d01e9a:	2600      	movs	r6, #0
    cx_hash((cx_hash_t *)&sha3, 0, SIGN_MAGIC, sizeof(SIGN_MAGIC) - 1, NULL);
c0d01e9c:	4668      	mov	r0, sp
c0d01e9e:	6006      	str	r6, [r0, #0]
c0d01ea0:	4a7b      	ldr	r2, [pc, #492]	; (c0d02090 <handleSignPersonalMessage+0x290>)
c0d01ea2:	447a      	add	r2, pc
c0d01ea4:	231a      	movs	r3, #26
c0d01ea6:	4620      	mov	r0, r4
c0d01ea8:	4631      	mov	r1, r6
c0d01eaa:	f7fe f91f 	bl	c0d000ec <cx_hash_X>
        PRINTF("Invalid path\n");
        THROW(0x6a80);
    }
    workBuffer++;
    dataLength--;
    for (i = 0; i < tmpCtx.messageSigningContext.pathLength; i++) {
c0d01eae:	9802      	ldr	r0, [sp, #8]
c0d01eb0:	9906      	ldr	r1, [sp, #24]
c0d01eb2:	1808      	adds	r0, r1, r0
c0d01eb4:	9006      	str	r0, [sp, #24]
c0d01eb6:	9803      	ldr	r0, [sp, #12]
c0d01eb8:	9901      	ldr	r1, [sp, #4]
c0d01eba:	1a08      	subs	r0, r1, r0
        workBuffer += 4;
        dataLength -= 4;
    }
    tmpCtx.messageSigningContext.remainingLength = U4BE(workBuffer, 0);
    workBuffer += 4;
    dataLength -= 4;
c0d01ebc:	b280      	uxth	r0, r0
c0d01ebe:	496d      	ldr	r1, [pc, #436]	; (c0d02074 <handleSignPersonalMessage+0x274>)
c0d01ec0:	1840      	adds	r0, r0, r1
c0d01ec2:	9003      	str	r0, [sp, #12]
c0d01ec4:	6cff      	ldr	r7, [r7, #76]	; 0x4c
c0d01ec6:	462c      	mov	r4, r5
    // Initialize message header + length
    cx_keccak_init(&sha3, 256);
    cx_hash((cx_hash_t *)&sha3, 0, SIGN_MAGIC, sizeof(SIGN_MAGIC) - 1, NULL);
    for (index = 1; (((index * base) <= tmpCtx.messageSigningContext.remainingLength) &&
c0d01ec8:	210a      	movs	r1, #10
c0d01eca:	460d      	mov	r5, r1
c0d01ecc:	4365      	muls	r5, r4
                         (((index * base) / base) == index));
c0d01ece:	4628      	mov	r0, r5
c0d01ed0:	f004 ff26 	bl	c0d06d20 <__aeabi_uidiv>
    workBuffer += 4;
    dataLength -= 4;
    // Initialize message header + length
    cx_keccak_init(&sha3, 256);
    cx_hash((cx_hash_t *)&sha3, 0, SIGN_MAGIC, sizeof(SIGN_MAGIC) - 1, NULL);
    for (index = 1; (((index * base) <= tmpCtx.messageSigningContext.remainingLength) &&
c0d01ed4:	42bd      	cmp	r5, r7
c0d01ed6:	d801      	bhi.n	c0d01edc <handleSignPersonalMessage+0xdc>
c0d01ed8:	42a0      	cmp	r0, r4
c0d01eda:	d0f4      	beq.n	c0d01ec6 <handleSignPersonalMessage+0xc6>
        tmpCtx.messageSigningContext.bip32Path[i] = U4BE(workBuffer, 0);
        workBuffer += 4;
        dataLength -= 4;
    }
    tmpCtx.messageSigningContext.remainingLength = U4BE(workBuffer, 0);
    workBuffer += 4;
c0d01edc:	9806      	ldr	r0, [sp, #24]
c0d01ede:	1d00      	adds	r0, r0, #4
    cx_keccak_init(&sha3, 256);
    cx_hash((cx_hash_t *)&sha3, 0, SIGN_MAGIC, sizeof(SIGN_MAGIC) - 1, NULL);
    for (index = 1; (((index * base) <= tmpCtx.messageSigningContext.remainingLength) &&
                         (((index * base) / base) == index));
             index *= base);
    for (; index; index /= base) {
c0d01ee0:	9006      	str	r0, [sp, #24]
c0d01ee2:	2c00      	cmp	r4, #0
c0d01ee4:	d015      	beq.n	c0d01f12 <handleSignPersonalMessage+0x112>
c0d01ee6:	2600      	movs	r6, #0
      tmp[pos++] = '0' + ((tmpCtx.messageSigningContext.remainingLength / index) % base);
c0d01ee8:	4638      	mov	r0, r7
c0d01eea:	4621      	mov	r1, r4
c0d01eec:	f004 ff18 	bl	c0d06d20 <__aeabi_uidiv>
c0d01ef0:	250a      	movs	r5, #10
c0d01ef2:	4629      	mov	r1, r5
c0d01ef4:	f004 ff9a 	bl	c0d06e2c <__aeabi_uidivmod>
c0d01ef8:	2030      	movs	r0, #48	; 0x30
c0d01efa:	4308      	orrs	r0, r1
c0d01efc:	b2f1      	uxtb	r1, r6
c0d01efe:	aa07      	add	r2, sp, #28
c0d01f00:	5450      	strb	r0, [r2, r1]
    cx_keccak_init(&sha3, 256);
    cx_hash((cx_hash_t *)&sha3, 0, SIGN_MAGIC, sizeof(SIGN_MAGIC) - 1, NULL);
    for (index = 1; (((index * base) <= tmpCtx.messageSigningContext.remainingLength) &&
                         (((index * base) / base) == index));
             index *= base);
    for (; index; index /= base) {
c0d01f02:	4620      	mov	r0, r4
c0d01f04:	4629      	mov	r1, r5
c0d01f06:	f004 ff0b 	bl	c0d06d20 <__aeabi_uidiv>
      tmp[pos++] = '0' + ((tmpCtx.messageSigningContext.remainingLength / index) % base);
c0d01f0a:	1c76      	adds	r6, r6, #1
    cx_keccak_init(&sha3, 256);
    cx_hash((cx_hash_t *)&sha3, 0, SIGN_MAGIC, sizeof(SIGN_MAGIC) - 1, NULL);
    for (index = 1; (((index * base) <= tmpCtx.messageSigningContext.remainingLength) &&
                         (((index * base) / base) == index));
             index *= base);
    for (; index; index /= base) {
c0d01f0c:	2c09      	cmp	r4, #9
c0d01f0e:	4604      	mov	r4, r0
c0d01f10:	d8ea      	bhi.n	c0d01ee8 <handleSignPersonalMessage+0xe8>
      tmp[pos++] = '0' + ((tmpCtx.messageSigningContext.remainingLength / index) % base);
    }
    tmp[pos] = '\0';
c0d01f12:	b2f3      	uxtb	r3, r6
c0d01f14:	aa07      	add	r2, sp, #28
c0d01f16:	2100      	movs	r1, #0
c0d01f18:	54d1      	strb	r1, [r2, r3]
    cx_hash((cx_hash_t *)&sha3, 0, tmp, pos, NULL);
c0d01f1a:	4668      	mov	r0, sp
c0d01f1c:	6001      	str	r1, [r0, #0]
c0d01f1e:	4854      	ldr	r0, [pc, #336]	; (c0d02070 <handleSignPersonalMessage+0x270>)
c0d01f20:	f7fe f8e4 	bl	c0d000ec <cx_hash_X>
    cx_sha256_init(&tmpContent.sha2);
c0d01f24:	4854      	ldr	r0, [pc, #336]	; (c0d02078 <handleSignPersonalMessage+0x278>)
c0d01f26:	f001 ff69 	bl	c0d03dfc <cx_sha256_init>
c0d01f2a:	af04      	add	r7, sp, #16
c0d01f2c:	cf86      	ldmia	r7, {r1, r2, r7}
c0d01f2e:	9b03      	ldr	r3, [sp, #12]
  }
  else if (p1 != P1_MORE) {
    THROW(0x6B00);
  }
  if (p2 != 0) {
c0d01f30:	2900      	cmp	r1, #0
c0d01f32:	d000      	beq.n	c0d01f36 <handleSignPersonalMessage+0x136>
c0d01f34:	e08e      	b.n	c0d02054 <handleSignPersonalMessage+0x254>
    THROW(0x6B00);
  }
  if (dataLength > tmpCtx.messageSigningContext.remainingLength) {
c0d01f36:	b29c      	uxth	r4, r3
c0d01f38:	4e4c      	ldr	r6, [pc, #304]	; (c0d0206c <handleSignPersonalMessage+0x26c>)
c0d01f3a:	6cf0      	ldr	r0, [r6, #76]	; 0x4c
c0d01f3c:	4284      	cmp	r4, r0
c0d01f3e:	d900      	bls.n	c0d01f42 <handleSignPersonalMessage+0x142>
c0d01f40:	e089      	b.n	c0d02056 <handleSignPersonalMessage+0x256>
c0d01f42:	2500      	movs	r5, #0
      THROW(0x6A80);
  }
  cx_hash((cx_hash_t *)&sha3, 0, workBuffer, dataLength, NULL);
c0d01f44:	4668      	mov	r0, sp
c0d01f46:	6005      	str	r5, [r0, #0]
c0d01f48:	4849      	ldr	r0, [pc, #292]	; (c0d02070 <handleSignPersonalMessage+0x270>)
c0d01f4a:	4629      	mov	r1, r5
c0d01f4c:	463a      	mov	r2, r7
c0d01f4e:	4623      	mov	r3, r4
c0d01f50:	f7fe f8cc 	bl	c0d000ec <cx_hash_X>
  cx_hash((cx_hash_t *)&tmpContent.sha2, 0, workBuffer, dataLength, NULL);
c0d01f54:	4668      	mov	r0, sp
c0d01f56:	6005      	str	r5, [r0, #0]
c0d01f58:	4847      	ldr	r0, [pc, #284]	; (c0d02078 <handleSignPersonalMessage+0x278>)
c0d01f5a:	4629      	mov	r1, r5
c0d01f5c:	463a      	mov	r2, r7
c0d01f5e:	4623      	mov	r3, r4
c0d01f60:	f7fe f8c4 	bl	c0d000ec <cx_hash_X>
  tmpCtx.messageSigningContext.remainingLength -= dataLength;
c0d01f64:	6cf0      	ldr	r0, [r6, #76]	; 0x4c
c0d01f66:	1b00      	subs	r0, r0, r4
c0d01f68:	64f0      	str	r0, [r6, #76]	; 0x4c
  if (tmpCtx.messageSigningContext.remainingLength == 0) {
c0d01f6a:	d177      	bne.n	c0d0205c <handleSignPersonalMessage+0x25c>
c0d01f6c:	9814      	ldr	r0, [sp, #80]	; 0x50
    cx_hash((cx_hash_t *)&sha3, CX_LAST, workBuffer, 0, tmpCtx.messageSigningContext.hash);
c0d01f6e:	9006      	str	r0, [sp, #24]
c0d01f70:	362c      	adds	r6, #44	; 0x2c
c0d01f72:	4668      	mov	r0, sp
c0d01f74:	6006      	str	r6, [r0, #0]
c0d01f76:	483e      	ldr	r0, [pc, #248]	; (c0d02070 <handleSignPersonalMessage+0x270>)
c0d01f78:	2601      	movs	r6, #1
c0d01f7a:	4631      	mov	r1, r6
c0d01f7c:	463a      	mov	r2, r7
c0d01f7e:	462b      	mov	r3, r5
c0d01f80:	f7fe f8b4 	bl	c0d000ec <cx_hash_X>
c0d01f84:	ac07      	add	r4, sp, #28
    cx_hash((cx_hash_t *)&tmpContent.sha2, CX_LAST, workBuffer, 0, hashMessage);
c0d01f86:	4668      	mov	r0, sp
c0d01f88:	6004      	str	r4, [r0, #0]
c0d01f8a:	483b      	ldr	r0, [pc, #236]	; (c0d02078 <handleSignPersonalMessage+0x278>)
c0d01f8c:	4631      	mov	r1, r6
c0d01f8e:	463a      	mov	r2, r7
c0d01f90:	462b      	mov	r3, r5
c0d01f92:	f7fe f8ab 	bl	c0d000ec <cx_hash_X>

#define HASH_LENGTH 4
    array_hexstr(strings.common.fullAddress, hashMessage, HASH_LENGTH / 2);
c0d01f96:	4f39      	ldr	r7, [pc, #228]	; (c0d0207c <handleSignPersonalMessage+0x27c>)
c0d01f98:	2602      	movs	r6, #2
c0d01f9a:	4638      	mov	r0, r7
c0d01f9c:	4621      	mov	r1, r4
c0d01f9e:	4632      	mov	r2, r6
c0d01fa0:	f004 fe50 	bl	c0d06c44 <array_hexstr>
    strings.common.fullAddress[HASH_LENGTH / 2 * 2] = '.';
c0d01fa4:	202e      	movs	r0, #46	; 0x2e
c0d01fa6:	7138      	strb	r0, [r7, #4]
    strings.common.fullAddress[HASH_LENGTH / 2 * 2 + 1] = '.';
c0d01fa8:	7178      	strb	r0, [r7, #5]
    strings.common.fullAddress[HASH_LENGTH / 2 * 2 + 2] = '.';
c0d01faa:	71b8      	strb	r0, [r7, #6]
    array_hexstr(strings.common.fullAddress + HASH_LENGTH / 2 * 2 + 3, hashMessage + 32 - HASH_LENGTH / 2, HASH_LENGTH / 2);
c0d01fac:	1df8      	adds	r0, r7, #7
c0d01fae:	341e      	adds	r4, #30
c0d01fb0:	4621      	mov	r1, r4
c0d01fb2:	4632      	mov	r2, r6
c0d01fb4:	f004 fe46 	bl	c0d06c44 <array_hexstr>
    io_seproxyhal_touch_signMessage_ok(NULL);
#else NO_CONSENT
#if defined(TARGET_BLUE)
    ui_approval_message_sign_blue_init();
#elif defined(TARGET_NANOS)
    ux_step = 0;
c0d01fb8:	4831      	ldr	r0, [pc, #196]	; (c0d02080 <handleSignPersonalMessage+0x280>)
c0d01fba:	6005      	str	r5, [r0, #0]
    ux_step_count = 2;
c0d01fbc:	4831      	ldr	r0, [pc, #196]	; (c0d02084 <handleSignPersonalMessage+0x284>)
c0d01fbe:	6006      	str	r6, [r0, #0]
    UX_DISPLAY(ui_approval_signMessage_nanos,
c0d01fc0:	4c31      	ldr	r4, [pc, #196]	; (c0d02088 <handleSignPersonalMessage+0x288>)
c0d01fc2:	4834      	ldr	r0, [pc, #208]	; (c0d02094 <handleSignPersonalMessage+0x294>)
c0d01fc4:	4478      	add	r0, pc
c0d01fc6:	6020      	str	r0, [r4, #0]
c0d01fc8:	2007      	movs	r0, #7
c0d01fca:	6060      	str	r0, [r4, #4]
c0d01fcc:	4832      	ldr	r0, [pc, #200]	; (c0d02098 <handleSignPersonalMessage+0x298>)
c0d01fce:	4478      	add	r0, pc
c0d01fd0:	6120      	str	r0, [r4, #16]
c0d01fd2:	4832      	ldr	r0, [pc, #200]	; (c0d0209c <handleSignPersonalMessage+0x29c>)
c0d01fd4:	4478      	add	r0, pc
c0d01fd6:	60e0      	str	r0, [r4, #12]
c0d01fd8:	2003      	movs	r0, #3
c0d01fda:	7620      	strb	r0, [r4, #24]
c0d01fdc:	61e5      	str	r5, [r4, #28]
c0d01fde:	4620      	mov	r0, r4
c0d01fe0:	3018      	adds	r0, #24
c0d01fe2:	f002 f81d 	bl	c0d04020 <os_ux>
c0d01fe6:	61e0      	str	r0, [r4, #28]
c0d01fe8:	f001 fc64 	bl	c0d038b4 <ux_check_status_default>
c0d01fec:	f000 ff32 	bl	c0d02e54 <io_seproxyhal_init_ux>
c0d01ff0:	f000 ff36 	bl	c0d02e60 <io_seproxyhal_init_button>
c0d01ff4:	60a5      	str	r5, [r4, #8]
c0d01ff6:	6820      	ldr	r0, [r4, #0]
c0d01ff8:	2800      	cmp	r0, #0
c0d01ffa:	d024      	beq.n	c0d02046 <handleSignPersonalMessage+0x246>
c0d01ffc:	69e0      	ldr	r0, [r4, #28]
c0d01ffe:	4923      	ldr	r1, [pc, #140]	; (c0d0208c <handleSignPersonalMessage+0x28c>)
c0d02000:	4288      	cmp	r0, r1
c0d02002:	d11e      	bne.n	c0d02042 <handleSignPersonalMessage+0x242>
c0d02004:	e01f      	b.n	c0d02046 <handleSignPersonalMessage+0x246>
c0d02006:	6860      	ldr	r0, [r4, #4]
c0d02008:	4285      	cmp	r5, r0
c0d0200a:	d21c      	bcs.n	c0d02046 <handleSignPersonalMessage+0x246>
c0d0200c:	f002 f878 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d02010:	2800      	cmp	r0, #0
c0d02012:	d118      	bne.n	c0d02046 <handleSignPersonalMessage+0x246>
c0d02014:	68a0      	ldr	r0, [r4, #8]
c0d02016:	68e1      	ldr	r1, [r4, #12]
c0d02018:	2538      	movs	r5, #56	; 0x38
c0d0201a:	4368      	muls	r0, r5
c0d0201c:	6822      	ldr	r2, [r4, #0]
c0d0201e:	1810      	adds	r0, r2, r0
c0d02020:	2900      	cmp	r1, #0
c0d02022:	d002      	beq.n	c0d0202a <handleSignPersonalMessage+0x22a>
c0d02024:	4788      	blx	r1
c0d02026:	2800      	cmp	r0, #0
c0d02028:	d007      	beq.n	c0d0203a <handleSignPersonalMessage+0x23a>
c0d0202a:	2801      	cmp	r0, #1
c0d0202c:	d103      	bne.n	c0d02036 <handleSignPersonalMessage+0x236>
c0d0202e:	68a0      	ldr	r0, [r4, #8]
c0d02030:	4345      	muls	r5, r0
c0d02032:	6820      	ldr	r0, [r4, #0]
c0d02034:	1940      	adds	r0, r0, r5
    return;
}

// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
  io_seproxyhal_display_default((bagl_element_t *)element);
c0d02036:	f001 f861 	bl	c0d030fc <io_seproxyhal_display_default>
#if defined(TARGET_BLUE)
    ui_approval_message_sign_blue_init();
#elif defined(TARGET_NANOS)
    ux_step = 0;
    ux_step_count = 2;
    UX_DISPLAY(ui_approval_signMessage_nanos,
c0d0203a:	68a0      	ldr	r0, [r4, #8]
c0d0203c:	1c45      	adds	r5, r0, #1
c0d0203e:	60a5      	str	r5, [r4, #8]
c0d02040:	6820      	ldr	r0, [r4, #0]
c0d02042:	2800      	cmp	r0, #0
c0d02044:	d1df      	bne.n	c0d02006 <handleSignPersonalMessage+0x206>
c0d02046:	9a06      	ldr	r2, [sp, #24]
#elif defined(TARGET_NANOX)
    ux_flow_init(0, ux_sign_flow, NULL);
#endif // #if TARGET_ID
#endif // NO_CONSENT

    *flags |= IO_ASYNCH_REPLY;
c0d02048:	6810      	ldr	r0, [r2, #0]
c0d0204a:	2110      	movs	r1, #16
c0d0204c:	4301      	orrs	r1, r0
c0d0204e:	6011      	str	r1, [r2, #0]

  } else {
    THROW(0x9000);
  }
}
c0d02050:	b00f      	add	sp, #60	; 0x3c
c0d02052:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d02054:	3280      	adds	r2, #128	; 0x80
c0d02056:	4610      	mov	r0, r2
c0d02058:	f000 fd9f 	bl	c0d02b9a <os_longjmp>
#endif // NO_CONSENT

    *flags |= IO_ASYNCH_REPLY;

  } else {
    THROW(0x9000);
c0d0205c:	2009      	movs	r0, #9
c0d0205e:	0300      	lsls	r0, r0, #12
c0d02060:	f000 fd9b 	bl	c0d02b9a <os_longjmp>
    uint32_t i;
    tmpCtx.messageSigningContext.pathLength = workBuffer[0];
    if ((tmpCtx.messageSigningContext.pathLength < 0x01) ||
        (tmpCtx.messageSigningContext.pathLength > MAX_BIP32_PATH)) {
        PRINTF("Invalid path\n");
        THROW(0x6a80);
c0d02064:	9805      	ldr	r0, [sp, #20]
c0d02066:	f000 fd98 	bl	c0d02b9a <os_longjmp>
c0d0206a:	46c0      	nop			; (mov r8, r8)
c0d0206c:	200019cc 	.word	0x200019cc
c0d02070:	20001af8 	.word	0x20001af8
c0d02074:	0000fffc 	.word	0x0000fffc
c0d02078:	2000194c 	.word	0x2000194c
c0d0207c:	20001802 	.word	0x20001802
c0d02080:	20001894 	.word	0x20001894
c0d02084:	20001af0 	.word	0x20001af0
c0d02088:	20001898 	.word	0x20001898
c0d0208c:	b0105044 	.word	0xb0105044
c0d02090:	00005e5c 	.word	0x00005e5c
c0d02094:	00005850 	.word	0x00005850
c0d02098:	fffff393 	.word	0xfffff393
c0d0209c:	ffffebdd 	.word	0xffffebdd

c0d020a0 <handleApdu>:
  } else {
    THROW(0x9000);
  }
}

void handleApdu(volatile unsigned int *flags, volatile unsigned int *tx) {
c0d020a0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d020a2:	b08d      	sub	sp, #52	; 0x34
c0d020a4:	460c      	mov	r4, r1
c0d020a6:	4606      	mov	r6, r0
c0d020a8:	af02      	add	r7, sp, #8
  unsigned short sw = 0;

  BEGIN_TRY {
    TRY {
c0d020aa:	4638      	mov	r0, r7
c0d020ac:	f004 ff86 	bl	c0d06fbc <setjmp>
c0d020b0:	4605      	mov	r5, r0
c0d020b2:	853d      	strh	r5, [r7, #40]	; 0x28
c0d020b4:	b2a8      	uxth	r0, r5
c0d020b6:	2800      	cmp	r0, #0
c0d020b8:	d017      	beq.n	c0d020ea <handleApdu+0x4a>
c0d020ba:	2810      	cmp	r0, #16
c0d020bc:	d064      	beq.n	c0d02188 <handleApdu+0xe8>
c0d020be:	a802      	add	r0, sp, #8
c0d020c0:	2100      	movs	r1, #0
      }
    }
    CATCH(EXCEPTION_IO_RESET) {
      THROW(EXCEPTION_IO_RESET);
    }
    CATCH_OTHER(e) {
c0d020c2:	8501      	strh	r1, [r0, #40]	; 0x28
c0d020c4:	200f      	movs	r0, #15
c0d020c6:	0300      	lsls	r0, r0, #12
      switch (e & 0xF000) {
c0d020c8:	4028      	ands	r0, r5
c0d020ca:	0a29      	lsrs	r1, r5, #8
c0d020cc:	b2ce      	uxtb	r6, r1
c0d020ce:	2109      	movs	r1, #9
c0d020d0:	0309      	lsls	r1, r1, #12
c0d020d2:	4288      	cmp	r0, r1
c0d020d4:	d034      	beq.n	c0d02140 <handleApdu+0xa0>
c0d020d6:	2103      	movs	r1, #3
c0d020d8:	0349      	lsls	r1, r1, #13
c0d020da:	4288      	cmp	r0, r1
c0d020dc:	d12a      	bne.n	c0d02134 <handleApdu+0x94>
        case 0x6000:
          // Wipe the transaction context and report the exception
          sw = e;
          os_memset(&txContext, 0, sizeof(txContext));
c0d020de:	483e      	ldr	r0, [pc, #248]	; (c0d021d8 <handleApdu+0x138>)
c0d020e0:	2100      	movs	r1, #0
c0d020e2:	223c      	movs	r2, #60	; 0x3c
c0d020e4:	f000 fc9c 	bl	c0d02a20 <os_memset>
c0d020e8:	e02a      	b.n	c0d02140 <handleApdu+0xa0>
c0d020ea:	a802      	add	r0, sp, #8

void handleApdu(volatile unsigned int *flags, volatile unsigned int *tx) {
  unsigned short sw = 0;

  BEGIN_TRY {
    TRY {
c0d020ec:	f000 fbed 	bl	c0d028ca <try_context_set>
      if (G_io_apdu_buffer[OFFSET_CLA] != CLA) {
c0d020f0:	4a37      	ldr	r2, [pc, #220]	; (c0d021d0 <handleApdu+0x130>)
c0d020f2:	7810      	ldrb	r0, [r2, #0]
c0d020f4:	28e0      	cmp	r0, #224	; 0xe0
c0d020f6:	d14f      	bne.n	c0d02198 <handleApdu+0xf8>
c0d020f8:	7850      	ldrb	r0, [r2, #1]
        THROW(0x6E00);
      }

      switch (G_io_apdu_buffer[OFFSET_INS]) {
c0d020fa:	2805      	cmp	r0, #5
c0d020fc:	dc0c      	bgt.n	c0d02118 <handleApdu+0x78>
c0d020fe:	2802      	cmp	r0, #2
c0d02100:	d028      	beq.n	c0d02154 <handleApdu+0xb4>
c0d02102:	2804      	cmp	r0, #4
c0d02104:	d15f      	bne.n	c0d021c6 <handleApdu+0x126>
          currentTokenSet = false;
          handleProvideErc20TokenInformation(G_io_apdu_buffer[OFFSET_P1], G_io_apdu_buffer[OFFSET_P2], G_io_apdu_buffer + OFFSET_CDATA, G_io_apdu_buffer[OFFSET_LC], flags, tx);
          break;

        case INS_SIGN:
          handleSign(G_io_apdu_buffer[OFFSET_P1], G_io_apdu_buffer[OFFSET_P2], G_io_apdu_buffer + OFFSET_CDATA, G_io_apdu_buffer[OFFSET_LC], flags, tx);
c0d02106:	7913      	ldrb	r3, [r2, #4]
c0d02108:	78d1      	ldrb	r1, [r2, #3]
c0d0210a:	7890      	ldrb	r0, [r2, #2]
c0d0210c:	466c      	mov	r4, sp
c0d0210e:	6026      	str	r6, [r4, #0]
c0d02110:	1d52      	adds	r2, r2, #5
c0d02112:	f7ff fdd3 	bl	c0d01cbc <handleSign>
c0d02116:	e028      	b.n	c0d0216a <handleApdu+0xca>
c0d02118:	2808      	cmp	r0, #8
c0d0211a:	d141      	bne.n	c0d021a0 <handleApdu+0x100>
        case INS_GET_APP_CONFIGURATION:
          handleGetAppConfiguration(G_io_apdu_buffer[OFFSET_P1], G_io_apdu_buffer[OFFSET_P2], G_io_apdu_buffer + OFFSET_CDATA, G_io_apdu_buffer[OFFSET_LC], flags, tx);
          break;

        case INS_SIGN_PERSONAL_MESSAGE:
          currentTokenSet = false;
c0d0211c:	482d      	ldr	r0, [pc, #180]	; (c0d021d4 <handleApdu+0x134>)
c0d0211e:	2100      	movs	r1, #0
c0d02120:	7001      	strb	r1, [r0, #0]
          handleSignPersonalMessage(G_io_apdu_buffer[OFFSET_P1], G_io_apdu_buffer[OFFSET_P2], G_io_apdu_buffer + OFFSET_CDATA, G_io_apdu_buffer[OFFSET_LC], flags, tx);
c0d02122:	7913      	ldrb	r3, [r2, #4]
c0d02124:	78d1      	ldrb	r1, [r2, #3]
c0d02126:	7890      	ldrb	r0, [r2, #2]
c0d02128:	466c      	mov	r4, sp
c0d0212a:	6026      	str	r6, [r4, #0]
c0d0212c:	1d52      	adds	r2, r2, #5
c0d0212e:	f7ff fe67 	bl	c0d01e00 <handleSignPersonalMessage>
c0d02132:	e01a      	b.n	c0d0216a <handleApdu+0xca>
          // All is well
          sw = e;
          break;
        default:
          // Internal error
          sw = 0x6800 | (e & 0x7FF);
c0d02134:	4829      	ldr	r0, [pc, #164]	; (c0d021dc <handleApdu+0x13c>)
c0d02136:	4005      	ands	r5, r0
c0d02138:	200d      	movs	r0, #13
c0d0213a:	02c0      	lsls	r0, r0, #11
c0d0213c:	4305      	orrs	r5, r0
          break;
c0d0213e:	0a2e      	lsrs	r6, r5, #8
        }
        // Unexpected exception => report
        G_io_apdu_buffer[*tx] = sw >> 8;
c0d02140:	6820      	ldr	r0, [r4, #0]
c0d02142:	4923      	ldr	r1, [pc, #140]	; (c0d021d0 <handleApdu+0x130>)
c0d02144:	540e      	strb	r6, [r1, r0]
        G_io_apdu_buffer[*tx + 1] = sw;
c0d02146:	6820      	ldr	r0, [r4, #0]
          // Internal error
          sw = 0x6800 | (e & 0x7FF);
          break;
        }
        // Unexpected exception => report
        G_io_apdu_buffer[*tx] = sw >> 8;
c0d02148:	1808      	adds	r0, r1, r0
        G_io_apdu_buffer[*tx + 1] = sw;
c0d0214a:	7045      	strb	r5, [r0, #1]
        *tx += 2;
c0d0214c:	6820      	ldr	r0, [r4, #0]
c0d0214e:	1c80      	adds	r0, r0, #2
c0d02150:	6020      	str	r0, [r4, #0]
c0d02152:	e00a      	b.n	c0d0216a <handleApdu+0xca>
        THROW(0x6E00);
      }

      switch (G_io_apdu_buffer[OFFSET_INS]) {
        case INS_GET_PUBLIC_KEY:
          currentTokenSet = false;
c0d02154:	481f      	ldr	r0, [pc, #124]	; (c0d021d4 <handleApdu+0x134>)
c0d02156:	2300      	movs	r3, #0
c0d02158:	7003      	strb	r3, [r0, #0]
          handleGetPublicKey(G_io_apdu_buffer[OFFSET_P1], G_io_apdu_buffer[OFFSET_P2], G_io_apdu_buffer + OFFSET_CDATA, G_io_apdu_buffer[OFFSET_LC], flags, tx);
c0d0215a:	78d1      	ldrb	r1, [r2, #3]
c0d0215c:	7890      	ldrb	r0, [r2, #2]
c0d0215e:	466d      	mov	r5, sp
c0d02160:	602e      	str	r6, [r5, #0]
c0d02162:	606c      	str	r4, [r5, #4]
c0d02164:	1d52      	adds	r2, r2, #5
c0d02166:	f7ff fc5f 	bl	c0d01a28 <handleGetPublicKey>
        // Unexpected exception => report
        G_io_apdu_buffer[*tx] = sw >> 8;
        G_io_apdu_buffer[*tx + 1] = sw;
        *tx += 2;
      }
      FINALLY {
c0d0216a:	f000 fd1b 	bl	c0d02ba4 <try_context_get>
c0d0216e:	a902      	add	r1, sp, #8
c0d02170:	4288      	cmp	r0, r1
c0d02172:	d103      	bne.n	c0d0217c <handleApdu+0xdc>
c0d02174:	f000 fd18 	bl	c0d02ba8 <try_context_get_previous>
c0d02178:	f000 fba7 	bl	c0d028ca <try_context_set>
c0d0217c:	a802      	add	r0, sp, #8
      }
  }
  END_TRY;
c0d0217e:	8d00      	ldrh	r0, [r0, #40]	; 0x28
c0d02180:	2800      	cmp	r0, #0
c0d02182:	d107      	bne.n	c0d02194 <handleApdu+0xf4>
}
c0d02184:	b00d      	add	sp, #52	; 0x34
c0d02186:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d02188:	a802      	add	r0, sp, #8
        default:
          THROW(0x6D00);
          break;
      }
    }
    CATCH(EXCEPTION_IO_RESET) {
c0d0218a:	2100      	movs	r1, #0
c0d0218c:	8501      	strh	r1, [r0, #40]	; 0x28
      THROW(EXCEPTION_IO_RESET);
c0d0218e:	2010      	movs	r0, #16
c0d02190:	f000 fd03 	bl	c0d02b9a <os_longjmp>
        *tx += 2;
      }
      FINALLY {
      }
  }
  END_TRY;
c0d02194:	f000 fd01 	bl	c0d02b9a <os_longjmp>
  unsigned short sw = 0;

  BEGIN_TRY {
    TRY {
      if (G_io_apdu_buffer[OFFSET_CLA] != CLA) {
        THROW(0x6E00);
c0d02198:	2037      	movs	r0, #55	; 0x37
c0d0219a:	0240      	lsls	r0, r0, #9
c0d0219c:	f000 fcfd 	bl	c0d02b9a <os_longjmp>
c0d021a0:	2806      	cmp	r0, #6
c0d021a2:	d009      	beq.n	c0d021b8 <handleApdu+0x118>
c0d021a4:	280a      	cmp	r0, #10
c0d021a6:	d10e      	bne.n	c0d021c6 <handleApdu+0x126>
          currentTokenSet = false;
          handleGetPublicKey(G_io_apdu_buffer[OFFSET_P1], G_io_apdu_buffer[OFFSET_P2], G_io_apdu_buffer + OFFSET_CDATA, G_io_apdu_buffer[OFFSET_LC], flags, tx);
          break;

        case INS_PROVIDE_ERC20_TOKEN_INFORMATION:
          currentTokenSet = false;
c0d021a8:	490a      	ldr	r1, [pc, #40]	; (c0d021d4 <handleApdu+0x134>)
c0d021aa:	2000      	movs	r0, #0
c0d021ac:	7008      	strb	r0, [r1, #0]
          handleProvideErc20TokenInformation(G_io_apdu_buffer[OFFSET_P1], G_io_apdu_buffer[OFFSET_P2], G_io_apdu_buffer + OFFSET_CDATA, G_io_apdu_buffer[OFFSET_LC], flags, tx);
c0d021ae:	7913      	ldrb	r3, [r2, #4]
c0d021b0:	1d52      	adds	r2, r2, #5
c0d021b2:	4601      	mov	r1, r0
c0d021b4:	f7ff fd16 	bl	c0d01be4 <handleProvideErc20TokenInformation>
        case INS_SIGN:
          handleSign(G_io_apdu_buffer[OFFSET_P1], G_io_apdu_buffer[OFFSET_P2], G_io_apdu_buffer + OFFSET_CDATA, G_io_apdu_buffer[OFFSET_LC], flags, tx);
          break;

        case INS_GET_APP_CONFIGURATION:
          handleGetAppConfiguration(G_io_apdu_buffer[OFFSET_P1], G_io_apdu_buffer[OFFSET_P2], G_io_apdu_buffer + OFFSET_CDATA, G_io_apdu_buffer[OFFSET_LC], flags, tx);
c0d021b8:	4668      	mov	r0, sp
c0d021ba:	6044      	str	r4, [r0, #4]
c0d021bc:	2000      	movs	r0, #0
c0d021be:	4601      	mov	r1, r0
c0d021c0:	4603      	mov	r3, r0
c0d021c2:	f7ff fe01 	bl	c0d01dc8 <handleGetAppConfiguration>
        case 0xFF: // return to dashboard
          goto return_to_dashboard;
#endif

        default:
          THROW(0x6D00);
c0d021c6:	206d      	movs	r0, #109	; 0x6d
c0d021c8:	0200      	lsls	r0, r0, #8
c0d021ca:	f000 fce6 	bl	c0d02b9a <os_longjmp>
c0d021ce:	46c0      	nop			; (mov r8, r8)
c0d021d0:	20001d4c 	.word	0x20001d4c
c0d021d4:	20001aa4 	.word	0x20001aa4
c0d021d8:	20001a64 	.word	0x20001a64
c0d021dc:	000007ff 	.word	0x000007ff

c0d021e0 <sample_main>:
      }
  }
  END_TRY;
}

void sample_main(void) {
c0d021e0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d021e2:	b08f      	sub	sp, #60	; 0x3c
c0d021e4:	2600      	movs	r6, #0
    volatile unsigned int rx = 0;
c0d021e6:	960e      	str	r6, [sp, #56]	; 0x38
    volatile unsigned int tx = 0;
c0d021e8:	960d      	str	r6, [sp, #52]	; 0x34
    volatile unsigned int flags = 0;
c0d021ea:	960c      	str	r6, [sp, #48]	; 0x30
c0d021ec:	4f38      	ldr	r7, [pc, #224]	; (c0d022d0 <sample_main+0xf0>)
c0d021ee:	a80b      	add	r0, sp, #44	; 0x2c
    // When APDU are to be fetched from multiple IOs, like NFC+USB+BLE, make
    // sure the io_event is called with a
    // switch event, before the apdu is replied to the bootloader. This avoid
    // APDU injection faults.
    for (;;) {
        volatile unsigned short sw = 0;
c0d021f0:	8006      	strh	r6, [r0, #0]
c0d021f2:	466d      	mov	r5, sp

        BEGIN_TRY {
            TRY {
c0d021f4:	4628      	mov	r0, r5
c0d021f6:	f004 fee1 	bl	c0d06fbc <setjmp>
c0d021fa:	8528      	strh	r0, [r5, #40]	; 0x28
c0d021fc:	b285      	uxth	r5, r0
c0d021fe:	2d00      	cmp	r5, #0
c0d02200:	d016      	beq.n	c0d02230 <sample_main+0x50>
c0d02202:	2d10      	cmp	r5, #16
c0d02204:	d055      	beq.n	c0d022b2 <sample_main+0xd2>
c0d02206:	4669      	mov	r1, sp
                handleApdu(&flags, &tx);
            }
            CATCH(EXCEPTION_IO_RESET) {
              THROW(EXCEPTION_IO_RESET);
            }
            CATCH_OTHER(e) {
c0d02208:	850e      	strh	r6, [r1, #40]	; 0x28
c0d0220a:	210f      	movs	r1, #15
c0d0220c:	0309      	lsls	r1, r1, #12
                switch (e & 0xF000) {
c0d0220e:	4001      	ands	r1, r0
c0d02210:	2209      	movs	r2, #9
c0d02212:	0314      	lsls	r4, r2, #12
c0d02214:	42a1      	cmp	r1, r4
c0d02216:	d022      	beq.n	c0d0225e <sample_main+0x7e>
c0d02218:	2203      	movs	r2, #3
c0d0221a:	0352      	lsls	r2, r2, #13
c0d0221c:	4291      	cmp	r1, r2
c0d0221e:	d121      	bne.n	c0d02264 <sample_main+0x84>
c0d02220:	a90b      	add	r1, sp, #44	; 0x2c
                case 0x6000:
                    // Wipe the transaction context and report the exception
                    sw = e;
c0d02222:	8008      	strh	r0, [r1, #0]
c0d02224:	2100      	movs	r1, #0
                    os_memset(&txContext, 0, sizeof(txContext));
c0d02226:	223c      	movs	r2, #60	; 0x3c
c0d02228:	4827      	ldr	r0, [pc, #156]	; (c0d022c8 <sample_main+0xe8>)
c0d0222a:	f000 fbf9 	bl	c0d02a20 <os_memset>
c0d0222e:	e020      	b.n	c0d02272 <sample_main+0x92>
c0d02230:	4668      	mov	r0, sp
    // APDU injection faults.
    for (;;) {
        volatile unsigned short sw = 0;

        BEGIN_TRY {
            TRY {
c0d02232:	f000 fb4a 	bl	c0d028ca <try_context_set>
                rx = tx;
c0d02236:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d02238:	900e      	str	r0, [sp, #56]	; 0x38
c0d0223a:	2400      	movs	r4, #0
                tx = 0; // ensure no race in catch_other if io_exchange throws
c0d0223c:	940d      	str	r4, [sp, #52]	; 0x34
                        // an error
                rx = io_exchange(CHANNEL_APDU | flags, rx);
c0d0223e:	980c      	ldr	r0, [sp, #48]	; 0x30
c0d02240:	990e      	ldr	r1, [sp, #56]	; 0x38
c0d02242:	b2c0      	uxtb	r0, r0
c0d02244:	b289      	uxth	r1, r1
c0d02246:	f001 f825 	bl	c0d03294 <io_exchange>
c0d0224a:	900e      	str	r0, [sp, #56]	; 0x38
                flags = 0;
c0d0224c:	940c      	str	r4, [sp, #48]	; 0x30

                // no apdu received, well, reset the session, and reset the
                // bootloader configuration
                if (rx == 0) {
c0d0224e:	980e      	ldr	r0, [sp, #56]	; 0x38
c0d02250:	2800      	cmp	r0, #0
c0d02252:	d033      	beq.n	c0d022bc <sample_main+0xdc>
c0d02254:	a80c      	add	r0, sp, #48	; 0x30
c0d02256:	a90d      	add	r1, sp, #52	; 0x34
                    THROW(0x6982);
                }

                handleApdu(&flags, &tx);
c0d02258:	f7ff ff22 	bl	c0d020a0 <handleApdu>
c0d0225c:	e01a      	b.n	c0d02294 <sample_main+0xb4>
c0d0225e:	a90b      	add	r1, sp, #44	; 0x2c
                    sw = e;
                    os_memset(&txContext, 0, sizeof(txContext));
                    break;
                case 0x9000:
                    // All is well
                    sw = e;
c0d02260:	8008      	strh	r0, [r1, #0]
c0d02262:	e006      	b.n	c0d02272 <sample_main+0x92>
                    break;
                default:
                    // Internal error
                    sw = 0x6800 | (e & 0x7FF);
c0d02264:	4919      	ldr	r1, [pc, #100]	; (c0d022cc <sample_main+0xec>)
c0d02266:	4008      	ands	r0, r1
c0d02268:	210d      	movs	r1, #13
c0d0226a:	02c9      	lsls	r1, r1, #11
c0d0226c:	4301      	orrs	r1, r0
c0d0226e:	a80b      	add	r0, sp, #44	; 0x2c
c0d02270:	8001      	strh	r1, [r0, #0]
                    break;
                }
                if (e != 0x9000) {
c0d02272:	42a5      	cmp	r5, r4
c0d02274:	d003      	beq.n	c0d0227e <sample_main+0x9e>
                    flags &= ~IO_ASYNCH_REPLY;
c0d02276:	2010      	movs	r0, #16
c0d02278:	990c      	ldr	r1, [sp, #48]	; 0x30
c0d0227a:	4381      	bics	r1, r0
c0d0227c:	910c      	str	r1, [sp, #48]	; 0x30
                }
                // Unexpected exception => report
                G_io_apdu_buffer[tx] = sw >> 8;
c0d0227e:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d02280:	0a00      	lsrs	r0, r0, #8
c0d02282:	990d      	ldr	r1, [sp, #52]	; 0x34
c0d02284:	5478      	strb	r0, [r7, r1]
                G_io_apdu_buffer[tx + 1] = sw;
c0d02286:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d02288:	990d      	ldr	r1, [sp, #52]	; 0x34
                }
                if (e != 0x9000) {
                    flags &= ~IO_ASYNCH_REPLY;
                }
                // Unexpected exception => report
                G_io_apdu_buffer[tx] = sw >> 8;
c0d0228a:	1879      	adds	r1, r7, r1
                G_io_apdu_buffer[tx + 1] = sw;
c0d0228c:	7048      	strb	r0, [r1, #1]
                tx += 2;
c0d0228e:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d02290:	1c80      	adds	r0, r0, #2
c0d02292:	900d      	str	r0, [sp, #52]	; 0x34
            }
            FINALLY {
c0d02294:	f000 fc86 	bl	c0d02ba4 <try_context_get>
c0d02298:	4669      	mov	r1, sp
c0d0229a:	4288      	cmp	r0, r1
c0d0229c:	d103      	bne.n	c0d022a6 <sample_main+0xc6>
c0d0229e:	f000 fc83 	bl	c0d02ba8 <try_context_get_previous>
c0d022a2:	f000 fb12 	bl	c0d028ca <try_context_set>
c0d022a6:	4668      	mov	r0, sp
            }
        }
        END_TRY;
c0d022a8:	8d00      	ldrh	r0, [r0, #40]	; 0x28
c0d022aa:	2800      	cmp	r0, #0
c0d022ac:	d09f      	beq.n	c0d021ee <sample_main+0xe>
c0d022ae:	f000 fc74 	bl	c0d02b9a <os_longjmp>
c0d022b2:	4668      	mov	r0, sp
                    THROW(0x6982);
                }

                handleApdu(&flags, &tx);
            }
            CATCH(EXCEPTION_IO_RESET) {
c0d022b4:	8506      	strh	r6, [r0, #40]	; 0x28
              THROW(EXCEPTION_IO_RESET);
c0d022b6:	2010      	movs	r0, #16
c0d022b8:	f000 fc6f 	bl	c0d02b9a <os_longjmp>
                flags = 0;

                // no apdu received, well, reset the session, and reset the
                // bootloader configuration
                if (rx == 0) {
                    THROW(0x6982);
c0d022bc:	4801      	ldr	r0, [pc, #4]	; (c0d022c4 <sample_main+0xe4>)
c0d022be:	f000 fc6c 	bl	c0d02b9a <os_longjmp>
c0d022c2:	46c0      	nop			; (mov r8, r8)
c0d022c4:	00006982 	.word	0x00006982
c0d022c8:	20001a64 	.word	0x20001a64
c0d022cc:	000007ff 	.word	0x000007ff
c0d022d0:	20001d4c 	.word	0x20001d4c

c0d022d4 <io_event>:
// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
  io_seproxyhal_display_default((bagl_element_t *)element);
}

unsigned char io_event(unsigned char channel) {
c0d022d4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d022d6:	b085      	sub	sp, #20
    // nothing done with the event, throw an error on the transport layer if
    // needed

    // can't have more than one tag in the reply, not supported yet.
    switch (G_io_seproxyhal_spi_buffer[0]) {
c0d022d8:	4de0      	ldr	r5, [pc, #896]	; (c0d0265c <io_event+0x388>)
c0d022da:	7828      	ldrb	r0, [r5, #0]
c0d022dc:	4fe0      	ldr	r7, [pc, #896]	; (c0d02660 <io_event+0x38c>)
c0d022de:	280c      	cmp	r0, #12
c0d022e0:	dd10      	ble.n	c0d02304 <io_event+0x30>
c0d022e2:	280d      	cmp	r0, #13
c0d022e4:	d07b      	beq.n	c0d023de <io_event+0x10a>
c0d022e6:	280e      	cmp	r0, #14
c0d022e8:	d100      	bne.n	c0d022ec <io_event+0x18>
c0d022ea:	e0b8      	b.n	c0d0245e <io_event+0x18a>
c0d022ec:	2815      	cmp	r0, #21
c0d022ee:	d135      	bne.n	c0d0235c <io_event+0x88>
    case SEPROXYHAL_TAG_BUTTON_PUSH_EVENT:
        UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
        break;

    case SEPROXYHAL_TAG_STATUS_EVENT:
        if (G_io_apdu_media == IO_APDU_MEDIA_USB_HID && !(U4BE(G_io_seproxyhal_spi_buffer, 3) & SEPROXYHAL_TAG_STATUS_EVENT_FLAG_USB_POWERED)) {
c0d022f0:	48dc      	ldr	r0, [pc, #880]	; (c0d02664 <io_event+0x390>)
c0d022f2:	7800      	ldrb	r0, [r0, #0]
c0d022f4:	2801      	cmp	r0, #1
c0d022f6:	d131      	bne.n	c0d0235c <io_event+0x88>
c0d022f8:	79a8      	ldrb	r0, [r5, #6]
c0d022fa:	0700      	lsls	r0, r0, #28
c0d022fc:	d42e      	bmi.n	c0d0235c <io_event+0x88>
         THROW(EXCEPTION_IO_RESET);
c0d022fe:	2010      	movs	r0, #16
c0d02300:	f000 fc4b 	bl	c0d02b9a <os_longjmp>
c0d02304:	2805      	cmp	r0, #5
c0d02306:	d100      	bne.n	c0d0230a <io_event+0x36>
c0d02308:	e0eb      	b.n	c0d024e2 <io_event+0x20e>
c0d0230a:	280c      	cmp	r0, #12
c0d0230c:	d126      	bne.n	c0d0235c <io_event+0x88>
    // needed

    // can't have more than one tag in the reply, not supported yet.
    switch (G_io_seproxyhal_spi_buffer[0]) {
    case SEPROXYHAL_TAG_FINGER_EVENT:
    		UX_FINGER_EVENT(G_io_seproxyhal_spi_buffer);
c0d0230e:	4cd6      	ldr	r4, [pc, #856]	; (c0d02668 <io_event+0x394>)
c0d02310:	2001      	movs	r0, #1
c0d02312:	7620      	strb	r0, [r4, #24]
c0d02314:	2600      	movs	r6, #0
c0d02316:	61e6      	str	r6, [r4, #28]
c0d02318:	4620      	mov	r0, r4
c0d0231a:	3018      	adds	r0, #24
c0d0231c:	f001 fe80 	bl	c0d04020 <os_ux>
c0d02320:	61e0      	str	r0, [r4, #28]
c0d02322:	f001 fac7 	bl	c0d038b4 <ux_check_status_default>
c0d02326:	69e0      	ldr	r0, [r4, #28]
c0d02328:	49d0      	ldr	r1, [pc, #832]	; (c0d0266c <io_event+0x398>)
c0d0232a:	4288      	cmp	r0, r1
c0d0232c:	d100      	bne.n	c0d02330 <io_event+0x5c>
c0d0232e:	e291      	b.n	c0d02854 <io_event+0x580>
c0d02330:	2800      	cmp	r0, #0
c0d02332:	d100      	bne.n	c0d02336 <io_event+0x62>
c0d02334:	e28e      	b.n	c0d02854 <io_event+0x580>
c0d02336:	49fd      	ldr	r1, [pc, #1012]	; (c0d0272c <io_event+0x458>)
c0d02338:	4288      	cmp	r0, r1
c0d0233a:	d000      	beq.n	c0d0233e <io_event+0x6a>
c0d0233c:	e21f      	b.n	c0d0277e <io_event+0x4aa>
c0d0233e:	f000 fd89 	bl	c0d02e54 <io_seproxyhal_init_ux>
c0d02342:	f000 fd8d 	bl	c0d02e60 <io_seproxyhal_init_button>
c0d02346:	60a6      	str	r6, [r4, #8]
c0d02348:	6820      	ldr	r0, [r4, #0]
c0d0234a:	2800      	cmp	r0, #0
c0d0234c:	d100      	bne.n	c0d02350 <io_event+0x7c>
c0d0234e:	e281      	b.n	c0d02854 <io_event+0x580>
c0d02350:	69e0      	ldr	r0, [r4, #28]
c0d02352:	49f8      	ldr	r1, [pc, #992]	; (c0d02734 <io_event+0x460>)
c0d02354:	4288      	cmp	r0, r1
c0d02356:	d000      	beq.n	c0d0235a <io_event+0x86>
c0d02358:	e131      	b.n	c0d025be <io_event+0x2ea>
c0d0235a:	e27b      	b.n	c0d02854 <io_event+0x580>
        if (G_io_apdu_media == IO_APDU_MEDIA_USB_HID && !(U4BE(G_io_seproxyhal_spi_buffer, 3) & SEPROXYHAL_TAG_STATUS_EVENT_FLAG_USB_POWERED)) {
         THROW(EXCEPTION_IO_RESET);
        }
        // no break is intentional
    default:
        UX_DEFAULT_EVENT();
c0d0235c:	4cf4      	ldr	r4, [pc, #976]	; (c0d02730 <io_event+0x45c>)
c0d0235e:	2001      	movs	r0, #1
c0d02360:	7620      	strb	r0, [r4, #24]
c0d02362:	2500      	movs	r5, #0
c0d02364:	61e5      	str	r5, [r4, #28]
c0d02366:	4620      	mov	r0, r4
c0d02368:	3018      	adds	r0, #24
c0d0236a:	f001 fe59 	bl	c0d04020 <os_ux>
c0d0236e:	61e0      	str	r0, [r4, #28]
c0d02370:	f001 faa0 	bl	c0d038b4 <ux_check_status_default>
c0d02374:	69e0      	ldr	r0, [r4, #28]
c0d02376:	42b8      	cmp	r0, r7
c0d02378:	d000      	beq.n	c0d0237c <io_event+0xa8>
c0d0237a:	e0d8      	b.n	c0d0252e <io_event+0x25a>
c0d0237c:	f000 fd6a 	bl	c0d02e54 <io_seproxyhal_init_ux>
c0d02380:	f000 fd6e 	bl	c0d02e60 <io_seproxyhal_init_button>
c0d02384:	60a5      	str	r5, [r4, #8]
c0d02386:	6820      	ldr	r0, [r4, #0]
c0d02388:	2800      	cmp	r0, #0
c0d0238a:	d100      	bne.n	c0d0238e <io_event+0xba>
c0d0238c:	e262      	b.n	c0d02854 <io_event+0x580>
c0d0238e:	69e0      	ldr	r0, [r4, #28]
c0d02390:	49e8      	ldr	r1, [pc, #928]	; (c0d02734 <io_event+0x460>)
c0d02392:	4288      	cmp	r0, r1
c0d02394:	d120      	bne.n	c0d023d8 <io_event+0x104>
c0d02396:	e25d      	b.n	c0d02854 <io_event+0x580>
c0d02398:	6860      	ldr	r0, [r4, #4]
c0d0239a:	4285      	cmp	r5, r0
c0d0239c:	d300      	bcc.n	c0d023a0 <io_event+0xcc>
c0d0239e:	e259      	b.n	c0d02854 <io_event+0x580>
c0d023a0:	f001 feae 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d023a4:	2800      	cmp	r0, #0
c0d023a6:	d000      	beq.n	c0d023aa <io_event+0xd6>
c0d023a8:	e254      	b.n	c0d02854 <io_event+0x580>
c0d023aa:	68a0      	ldr	r0, [r4, #8]
c0d023ac:	68e1      	ldr	r1, [r4, #12]
c0d023ae:	2538      	movs	r5, #56	; 0x38
c0d023b0:	4368      	muls	r0, r5
c0d023b2:	6822      	ldr	r2, [r4, #0]
c0d023b4:	1810      	adds	r0, r2, r0
c0d023b6:	2900      	cmp	r1, #0
c0d023b8:	d002      	beq.n	c0d023c0 <io_event+0xec>
c0d023ba:	4788      	blx	r1
c0d023bc:	2800      	cmp	r0, #0
c0d023be:	d007      	beq.n	c0d023d0 <io_event+0xfc>
c0d023c0:	2801      	cmp	r0, #1
c0d023c2:	d103      	bne.n	c0d023cc <io_event+0xf8>
c0d023c4:	68a0      	ldr	r0, [r4, #8]
c0d023c6:	4345      	muls	r5, r0
c0d023c8:	6820      	ldr	r0, [r4, #0]
c0d023ca:	1940      	adds	r0, r0, r5
    return;
}

// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
  io_seproxyhal_display_default((bagl_element_t *)element);
c0d023cc:	f000 fe96 	bl	c0d030fc <io_seproxyhal_display_default>
        if (G_io_apdu_media == IO_APDU_MEDIA_USB_HID && !(U4BE(G_io_seproxyhal_spi_buffer, 3) & SEPROXYHAL_TAG_STATUS_EVENT_FLAG_USB_POWERED)) {
         THROW(EXCEPTION_IO_RESET);
        }
        // no break is intentional
    default:
        UX_DEFAULT_EVENT();
c0d023d0:	68a0      	ldr	r0, [r4, #8]
c0d023d2:	1c45      	adds	r5, r0, #1
c0d023d4:	60a5      	str	r5, [r4, #8]
c0d023d6:	6820      	ldr	r0, [r4, #0]
c0d023d8:	2800      	cmp	r0, #0
c0d023da:	d1dd      	bne.n	c0d02398 <io_event+0xc4>
c0d023dc:	e23a      	b.n	c0d02854 <io_event+0x580>
        break;

    case SEPROXYHAL_TAG_DISPLAY_PROCESSED_EVENT:
        UX_DISPLAYED_EVENT({});
c0d023de:	4cd4      	ldr	r4, [pc, #848]	; (c0d02730 <io_event+0x45c>)
c0d023e0:	2001      	movs	r0, #1
c0d023e2:	7620      	strb	r0, [r4, #24]
c0d023e4:	2500      	movs	r5, #0
c0d023e6:	61e5      	str	r5, [r4, #28]
c0d023e8:	4620      	mov	r0, r4
c0d023ea:	3018      	adds	r0, #24
c0d023ec:	f001 fe18 	bl	c0d04020 <os_ux>
c0d023f0:	61e0      	str	r0, [r4, #28]
c0d023f2:	f001 fa5f 	bl	c0d038b4 <ux_check_status_default>
c0d023f6:	69e0      	ldr	r0, [r4, #28]
c0d023f8:	49ce      	ldr	r1, [pc, #824]	; (c0d02734 <io_event+0x460>)
c0d023fa:	4288      	cmp	r0, r1
c0d023fc:	d100      	bne.n	c0d02400 <io_event+0x12c>
c0d023fe:	e229      	b.n	c0d02854 <io_event+0x580>
c0d02400:	49ca      	ldr	r1, [pc, #808]	; (c0d0272c <io_event+0x458>)
c0d02402:	4288      	cmp	r0, r1
c0d02404:	d100      	bne.n	c0d02408 <io_event+0x134>
c0d02406:	e182      	b.n	c0d0270e <io_event+0x43a>
c0d02408:	2800      	cmp	r0, #0
c0d0240a:	d100      	bne.n	c0d0240e <io_event+0x13a>
c0d0240c:	e222      	b.n	c0d02854 <io_event+0x580>
c0d0240e:	6820      	ldr	r0, [r4, #0]
c0d02410:	2800      	cmp	r0, #0
c0d02412:	d100      	bne.n	c0d02416 <io_event+0x142>
c0d02414:	e218      	b.n	c0d02848 <io_event+0x574>
c0d02416:	68a0      	ldr	r0, [r4, #8]
c0d02418:	6861      	ldr	r1, [r4, #4]
c0d0241a:	4288      	cmp	r0, r1
c0d0241c:	d300      	bcc.n	c0d02420 <io_event+0x14c>
c0d0241e:	e213      	b.n	c0d02848 <io_event+0x574>
c0d02420:	f001 fe6e 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d02424:	2800      	cmp	r0, #0
c0d02426:	d000      	beq.n	c0d0242a <io_event+0x156>
c0d02428:	e20e      	b.n	c0d02848 <io_event+0x574>
c0d0242a:	68a0      	ldr	r0, [r4, #8]
c0d0242c:	68e1      	ldr	r1, [r4, #12]
c0d0242e:	2538      	movs	r5, #56	; 0x38
c0d02430:	4368      	muls	r0, r5
c0d02432:	6822      	ldr	r2, [r4, #0]
c0d02434:	1810      	adds	r0, r2, r0
c0d02436:	2900      	cmp	r1, #0
c0d02438:	d002      	beq.n	c0d02440 <io_event+0x16c>
c0d0243a:	4788      	blx	r1
c0d0243c:	2800      	cmp	r0, #0
c0d0243e:	d007      	beq.n	c0d02450 <io_event+0x17c>
c0d02440:	2801      	cmp	r0, #1
c0d02442:	d103      	bne.n	c0d0244c <io_event+0x178>
c0d02444:	68a0      	ldr	r0, [r4, #8]
c0d02446:	4345      	muls	r5, r0
c0d02448:	6820      	ldr	r0, [r4, #0]
c0d0244a:	1940      	adds	r0, r0, r5
    return;
}

// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
  io_seproxyhal_display_default((bagl_element_t *)element);
c0d0244c:	f000 fe56 	bl	c0d030fc <io_seproxyhal_display_default>
    default:
        UX_DEFAULT_EVENT();
        break;

    case SEPROXYHAL_TAG_DISPLAY_PROCESSED_EVENT:
        UX_DISPLAYED_EVENT({});
c0d02450:	68a0      	ldr	r0, [r4, #8]
c0d02452:	1c40      	adds	r0, r0, #1
c0d02454:	60a0      	str	r0, [r4, #8]
c0d02456:	6821      	ldr	r1, [r4, #0]
c0d02458:	2900      	cmp	r1, #0
c0d0245a:	d1dd      	bne.n	c0d02418 <io_event+0x144>
c0d0245c:	e1f4      	b.n	c0d02848 <io_event+0x574>
        break;

    case SEPROXYHAL_TAG_TICKER_EVENT:
        UX_TICKER_EVENT(G_io_seproxyhal_spi_buffer,
c0d0245e:	4cb4      	ldr	r4, [pc, #720]	; (c0d02730 <io_event+0x45c>)
c0d02460:	2001      	movs	r0, #1
c0d02462:	7620      	strb	r0, [r4, #24]
c0d02464:	2600      	movs	r6, #0
c0d02466:	61e6      	str	r6, [r4, #28]
c0d02468:	4620      	mov	r0, r4
c0d0246a:	3018      	adds	r0, #24
c0d0246c:	f001 fdd8 	bl	c0d04020 <os_ux>
c0d02470:	61e0      	str	r0, [r4, #28]
c0d02472:	f001 fa1f 	bl	c0d038b4 <ux_check_status_default>
c0d02476:	69e5      	ldr	r5, [r4, #28]
c0d02478:	42bd      	cmp	r5, r7
c0d0247a:	d000      	beq.n	c0d0247e <io_event+0x1aa>
c0d0247c:	e0c5      	b.n	c0d0260a <io_event+0x336>
c0d0247e:	f000 fce9 	bl	c0d02e54 <io_seproxyhal_init_ux>
c0d02482:	f000 fced 	bl	c0d02e60 <io_seproxyhal_init_button>
c0d02486:	2000      	movs	r0, #0
c0d02488:	60a0      	str	r0, [r4, #8]
c0d0248a:	6821      	ldr	r1, [r4, #0]
c0d0248c:	2900      	cmp	r1, #0
c0d0248e:	d100      	bne.n	c0d02492 <io_event+0x1be>
c0d02490:	e1e0      	b.n	c0d02854 <io_event+0x580>
c0d02492:	69e1      	ldr	r1, [r4, #28]
c0d02494:	4af8      	ldr	r2, [pc, #992]	; (c0d02878 <io_event+0x5a4>)
c0d02496:	4291      	cmp	r1, r2
c0d02498:	d120      	bne.n	c0d024dc <io_event+0x208>
c0d0249a:	e1db      	b.n	c0d02854 <io_event+0x580>
c0d0249c:	6861      	ldr	r1, [r4, #4]
c0d0249e:	4288      	cmp	r0, r1
c0d024a0:	d300      	bcc.n	c0d024a4 <io_event+0x1d0>
c0d024a2:	e1d7      	b.n	c0d02854 <io_event+0x580>
c0d024a4:	f001 fe2c 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d024a8:	2800      	cmp	r0, #0
c0d024aa:	d000      	beq.n	c0d024ae <io_event+0x1da>
c0d024ac:	e1d2      	b.n	c0d02854 <io_event+0x580>
c0d024ae:	68a0      	ldr	r0, [r4, #8]
c0d024b0:	68e1      	ldr	r1, [r4, #12]
c0d024b2:	2538      	movs	r5, #56	; 0x38
c0d024b4:	4368      	muls	r0, r5
c0d024b6:	6822      	ldr	r2, [r4, #0]
c0d024b8:	1810      	adds	r0, r2, r0
c0d024ba:	2900      	cmp	r1, #0
c0d024bc:	d002      	beq.n	c0d024c4 <io_event+0x1f0>
c0d024be:	4788      	blx	r1
c0d024c0:	2800      	cmp	r0, #0
c0d024c2:	d007      	beq.n	c0d024d4 <io_event+0x200>
c0d024c4:	2801      	cmp	r0, #1
c0d024c6:	d103      	bne.n	c0d024d0 <io_event+0x1fc>
c0d024c8:	68a0      	ldr	r0, [r4, #8]
c0d024ca:	4345      	muls	r5, r0
c0d024cc:	6820      	ldr	r0, [r4, #0]
c0d024ce:	1940      	adds	r0, r0, r5
    return;
}

// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
  io_seproxyhal_display_default((bagl_element_t *)element);
c0d024d0:	f000 fe14 	bl	c0d030fc <io_seproxyhal_display_default>
    case SEPROXYHAL_TAG_DISPLAY_PROCESSED_EVENT:
        UX_DISPLAYED_EVENT({});
        break;

    case SEPROXYHAL_TAG_TICKER_EVENT:
        UX_TICKER_EVENT(G_io_seproxyhal_spi_buffer,
c0d024d4:	68a0      	ldr	r0, [r4, #8]
c0d024d6:	1c40      	adds	r0, r0, #1
c0d024d8:	60a0      	str	r0, [r4, #8]
c0d024da:	6821      	ldr	r1, [r4, #0]
c0d024dc:	2900      	cmp	r1, #0
c0d024de:	d1dd      	bne.n	c0d0249c <io_event+0x1c8>
c0d024e0:	e1b8      	b.n	c0d02854 <io_event+0x580>
    case SEPROXYHAL_TAG_FINGER_EVENT:
    		UX_FINGER_EVENT(G_io_seproxyhal_spi_buffer);
    		break;

    case SEPROXYHAL_TAG_BUTTON_PUSH_EVENT:
        UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0d024e2:	4ce2      	ldr	r4, [pc, #904]	; (c0d0286c <io_event+0x598>)
c0d024e4:	2001      	movs	r0, #1
c0d024e6:	7620      	strb	r0, [r4, #24]
c0d024e8:	2600      	movs	r6, #0
c0d024ea:	61e6      	str	r6, [r4, #28]
c0d024ec:	4620      	mov	r0, r4
c0d024ee:	3018      	adds	r0, #24
c0d024f0:	f001 fd96 	bl	c0d04020 <os_ux>
c0d024f4:	61e0      	str	r0, [r4, #28]
c0d024f6:	f001 f9dd 	bl	c0d038b4 <ux_check_status_default>
c0d024fa:	69e0      	ldr	r0, [r4, #28]
c0d024fc:	49de      	ldr	r1, [pc, #888]	; (c0d02878 <io_event+0x5a4>)
c0d024fe:	4288      	cmp	r0, r1
c0d02500:	d100      	bne.n	c0d02504 <io_event+0x230>
c0d02502:	e1a7      	b.n	c0d02854 <io_event+0x580>
c0d02504:	2800      	cmp	r0, #0
c0d02506:	d100      	bne.n	c0d0250a <io_event+0x236>
c0d02508:	e1a4      	b.n	c0d02854 <io_event+0x580>
c0d0250a:	49d7      	ldr	r1, [pc, #860]	; (c0d02868 <io_event+0x594>)
c0d0250c:	4288      	cmp	r0, r1
c0d0250e:	d000      	beq.n	c0d02512 <io_event+0x23e>
c0d02510:	e16f      	b.n	c0d027f2 <io_event+0x51e>
c0d02512:	f000 fc9f 	bl	c0d02e54 <io_seproxyhal_init_ux>
c0d02516:	f000 fca3 	bl	c0d02e60 <io_seproxyhal_init_button>
c0d0251a:	60a6      	str	r6, [r4, #8]
c0d0251c:	6820      	ldr	r0, [r4, #0]
c0d0251e:	2800      	cmp	r0, #0
c0d02520:	d100      	bne.n	c0d02524 <io_event+0x250>
c0d02522:	e197      	b.n	c0d02854 <io_event+0x580>
c0d02524:	69e0      	ldr	r0, [r4, #28]
c0d02526:	49d4      	ldr	r1, [pc, #848]	; (c0d02878 <io_event+0x5a4>)
c0d02528:	4288      	cmp	r0, r1
c0d0252a:	d16b      	bne.n	c0d02604 <io_event+0x330>
c0d0252c:	e192      	b.n	c0d02854 <io_event+0x580>
        if (G_io_apdu_media == IO_APDU_MEDIA_USB_HID && !(U4BE(G_io_seproxyhal_spi_buffer, 3) & SEPROXYHAL_TAG_STATUS_EVENT_FLAG_USB_POWERED)) {
         THROW(EXCEPTION_IO_RESET);
        }
        // no break is intentional
    default:
        UX_DEFAULT_EVENT();
c0d0252e:	6820      	ldr	r0, [r4, #0]
c0d02530:	2800      	cmp	r0, #0
c0d02532:	d100      	bne.n	c0d02536 <io_event+0x262>
c0d02534:	e188      	b.n	c0d02848 <io_event+0x574>
c0d02536:	68a0      	ldr	r0, [r4, #8]
c0d02538:	6861      	ldr	r1, [r4, #4]
c0d0253a:	4288      	cmp	r0, r1
c0d0253c:	d300      	bcc.n	c0d02540 <io_event+0x26c>
c0d0253e:	e183      	b.n	c0d02848 <io_event+0x574>
c0d02540:	f001 fdde 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d02544:	2800      	cmp	r0, #0
c0d02546:	d000      	beq.n	c0d0254a <io_event+0x276>
c0d02548:	e17e      	b.n	c0d02848 <io_event+0x574>
c0d0254a:	68a0      	ldr	r0, [r4, #8]
c0d0254c:	68e1      	ldr	r1, [r4, #12]
c0d0254e:	2538      	movs	r5, #56	; 0x38
c0d02550:	4368      	muls	r0, r5
c0d02552:	6822      	ldr	r2, [r4, #0]
c0d02554:	1810      	adds	r0, r2, r0
c0d02556:	2900      	cmp	r1, #0
c0d02558:	d002      	beq.n	c0d02560 <io_event+0x28c>
c0d0255a:	4788      	blx	r1
c0d0255c:	2800      	cmp	r0, #0
c0d0255e:	d007      	beq.n	c0d02570 <io_event+0x29c>
c0d02560:	2801      	cmp	r0, #1
c0d02562:	d103      	bne.n	c0d0256c <io_event+0x298>
c0d02564:	68a0      	ldr	r0, [r4, #8]
c0d02566:	4345      	muls	r5, r0
c0d02568:	6820      	ldr	r0, [r4, #0]
c0d0256a:	1940      	adds	r0, r0, r5
    return;
}

// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
  io_seproxyhal_display_default((bagl_element_t *)element);
c0d0256c:	f000 fdc6 	bl	c0d030fc <io_seproxyhal_display_default>
        if (G_io_apdu_media == IO_APDU_MEDIA_USB_HID && !(U4BE(G_io_seproxyhal_spi_buffer, 3) & SEPROXYHAL_TAG_STATUS_EVENT_FLAG_USB_POWERED)) {
         THROW(EXCEPTION_IO_RESET);
        }
        // no break is intentional
    default:
        UX_DEFAULT_EVENT();
c0d02570:	68a0      	ldr	r0, [r4, #8]
c0d02572:	1c40      	adds	r0, r0, #1
c0d02574:	60a0      	str	r0, [r4, #8]
c0d02576:	6821      	ldr	r1, [r4, #0]
c0d02578:	2900      	cmp	r1, #0
c0d0257a:	d1dd      	bne.n	c0d02538 <io_event+0x264>
c0d0257c:	e164      	b.n	c0d02848 <io_event+0x574>
    // needed

    // can't have more than one tag in the reply, not supported yet.
    switch (G_io_seproxyhal_spi_buffer[0]) {
    case SEPROXYHAL_TAG_FINGER_EVENT:
    		UX_FINGER_EVENT(G_io_seproxyhal_spi_buffer);
c0d0257e:	6860      	ldr	r0, [r4, #4]
c0d02580:	4286      	cmp	r6, r0
c0d02582:	d300      	bcc.n	c0d02586 <io_event+0x2b2>
c0d02584:	e166      	b.n	c0d02854 <io_event+0x580>
c0d02586:	f001 fdbb 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d0258a:	2800      	cmp	r0, #0
c0d0258c:	d000      	beq.n	c0d02590 <io_event+0x2bc>
c0d0258e:	e161      	b.n	c0d02854 <io_event+0x580>
c0d02590:	68a0      	ldr	r0, [r4, #8]
c0d02592:	68e1      	ldr	r1, [r4, #12]
c0d02594:	2538      	movs	r5, #56	; 0x38
c0d02596:	4368      	muls	r0, r5
c0d02598:	6822      	ldr	r2, [r4, #0]
c0d0259a:	1810      	adds	r0, r2, r0
c0d0259c:	2900      	cmp	r1, #0
c0d0259e:	d002      	beq.n	c0d025a6 <io_event+0x2d2>
c0d025a0:	4788      	blx	r1
c0d025a2:	2800      	cmp	r0, #0
c0d025a4:	d007      	beq.n	c0d025b6 <io_event+0x2e2>
c0d025a6:	2801      	cmp	r0, #1
c0d025a8:	d103      	bne.n	c0d025b2 <io_event+0x2de>
c0d025aa:	68a0      	ldr	r0, [r4, #8]
c0d025ac:	4345      	muls	r5, r0
c0d025ae:	6820      	ldr	r0, [r4, #0]
c0d025b0:	1940      	adds	r0, r0, r5
    return;
}

// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
  io_seproxyhal_display_default((bagl_element_t *)element);
c0d025b2:	f000 fda3 	bl	c0d030fc <io_seproxyhal_display_default>
    // needed

    // can't have more than one tag in the reply, not supported yet.
    switch (G_io_seproxyhal_spi_buffer[0]) {
    case SEPROXYHAL_TAG_FINGER_EVENT:
    		UX_FINGER_EVENT(G_io_seproxyhal_spi_buffer);
c0d025b6:	68a0      	ldr	r0, [r4, #8]
c0d025b8:	1c46      	adds	r6, r0, #1
c0d025ba:	60a6      	str	r6, [r4, #8]
c0d025bc:	6820      	ldr	r0, [r4, #0]
c0d025be:	2800      	cmp	r0, #0
c0d025c0:	d1dd      	bne.n	c0d0257e <io_event+0x2aa>
c0d025c2:	e147      	b.n	c0d02854 <io_event+0x580>
    		break;

    case SEPROXYHAL_TAG_BUTTON_PUSH_EVENT:
        UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0d025c4:	6860      	ldr	r0, [r4, #4]
c0d025c6:	4286      	cmp	r6, r0
c0d025c8:	d300      	bcc.n	c0d025cc <io_event+0x2f8>
c0d025ca:	e143      	b.n	c0d02854 <io_event+0x580>
c0d025cc:	f001 fd98 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d025d0:	2800      	cmp	r0, #0
c0d025d2:	d000      	beq.n	c0d025d6 <io_event+0x302>
c0d025d4:	e13e      	b.n	c0d02854 <io_event+0x580>
c0d025d6:	68a0      	ldr	r0, [r4, #8]
c0d025d8:	68e1      	ldr	r1, [r4, #12]
c0d025da:	2538      	movs	r5, #56	; 0x38
c0d025dc:	4368      	muls	r0, r5
c0d025de:	6822      	ldr	r2, [r4, #0]
c0d025e0:	1810      	adds	r0, r2, r0
c0d025e2:	2900      	cmp	r1, #0
c0d025e4:	d002      	beq.n	c0d025ec <io_event+0x318>
c0d025e6:	4788      	blx	r1
c0d025e8:	2800      	cmp	r0, #0
c0d025ea:	d007      	beq.n	c0d025fc <io_event+0x328>
c0d025ec:	2801      	cmp	r0, #1
c0d025ee:	d103      	bne.n	c0d025f8 <io_event+0x324>
c0d025f0:	68a0      	ldr	r0, [r4, #8]
c0d025f2:	4345      	muls	r5, r0
c0d025f4:	6820      	ldr	r0, [r4, #0]
c0d025f6:	1940      	adds	r0, r0, r5
    return;
}

// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
  io_seproxyhal_display_default((bagl_element_t *)element);
c0d025f8:	f000 fd80 	bl	c0d030fc <io_seproxyhal_display_default>
    case SEPROXYHAL_TAG_FINGER_EVENT:
    		UX_FINGER_EVENT(G_io_seproxyhal_spi_buffer);
    		break;

    case SEPROXYHAL_TAG_BUTTON_PUSH_EVENT:
        UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0d025fc:	68a0      	ldr	r0, [r4, #8]
c0d025fe:	1c46      	adds	r6, r0, #1
c0d02600:	60a6      	str	r6, [r4, #8]
c0d02602:	6820      	ldr	r0, [r4, #0]
c0d02604:	2800      	cmp	r0, #0
c0d02606:	d1dd      	bne.n	c0d025c4 <io_event+0x2f0>
c0d02608:	e124      	b.n	c0d02854 <io_event+0x580>
    case SEPROXYHAL_TAG_DISPLAY_PROCESSED_EVENT:
        UX_DISPLAYED_EVENT({});
        break;

    case SEPROXYHAL_TAG_TICKER_EVENT:
        UX_TICKER_EVENT(G_io_seproxyhal_spi_buffer,
c0d0260a:	6960      	ldr	r0, [r4, #20]
c0d0260c:	2800      	cmp	r0, #0
c0d0260e:	d04f      	beq.n	c0d026b0 <io_event+0x3dc>
c0d02610:	2164      	movs	r1, #100	; 0x64
c0d02612:	2864      	cmp	r0, #100	; 0x64
c0d02614:	4602      	mov	r2, r0
c0d02616:	d300      	bcc.n	c0d0261a <io_event+0x346>
c0d02618:	460a      	mov	r2, r1
c0d0261a:	1a80      	subs	r0, r0, r2
c0d0261c:	6160      	str	r0, [r4, #20]
c0d0261e:	3f11      	subs	r7, #17
c0d02620:	42bd      	cmp	r5, r7
c0d02622:	d045      	beq.n	c0d026b0 <io_event+0x3dc>
c0d02624:	2d00      	cmp	r5, #0
c0d02626:	d043      	beq.n	c0d026b0 <io_event+0x3dc>
c0d02628:	2800      	cmp	r0, #0
c0d0262a:	d141      	bne.n	c0d026b0 <io_event+0x3dc>
c0d0262c:	4890      	ldr	r0, [pc, #576]	; (c0d02870 <io_event+0x59c>)
c0d0262e:	6801      	ldr	r1, [r0, #0]
c0d02630:	2900      	cmp	r1, #0
c0d02632:	d03d      	beq.n	c0d026b0 <io_event+0x3dc>
c0d02634:	4f8f      	ldr	r7, [pc, #572]	; (c0d02874 <io_event+0x5a0>)
c0d02636:	6838      	ldr	r0, [r7, #0]
c0d02638:	1c40      	adds	r0, r0, #1
c0d0263a:	f004 fbf7 	bl	c0d06e2c <__aeabi_uidivmod>
c0d0263e:	6039      	str	r1, [r7, #0]
c0d02640:	f000 fc08 	bl	c0d02e54 <io_seproxyhal_init_ux>
c0d02644:	f000 fc0c 	bl	c0d02e60 <io_seproxyhal_init_button>
c0d02648:	60a6      	str	r6, [r4, #8]
c0d0264a:	6820      	ldr	r0, [r4, #0]
c0d0264c:	2800      	cmp	r0, #0
c0d0264e:	d02f      	beq.n	c0d026b0 <io_event+0x3dc>
c0d02650:	69e0      	ldr	r0, [r4, #28]
c0d02652:	4989      	ldr	r1, [pc, #548]	; (c0d02878 <io_event+0x5a4>)
c0d02654:	4288      	cmp	r0, r1
c0d02656:	d129      	bne.n	c0d026ac <io_event+0x3d8>
c0d02658:	e02a      	b.n	c0d026b0 <io_event+0x3dc>
c0d0265a:	46c0      	nop			; (mov r8, r8)
c0d0265c:	20001cc0 	.word	0x20001cc0
c0d02660:	b0105055 	.word	0xb0105055
c0d02664:	20001ea8 	.word	0x20001ea8
c0d02668:	20001898 	.word	0x20001898
c0d0266c:	b0105044 	.word	0xb0105044
c0d02670:	6860      	ldr	r0, [r4, #4]
c0d02672:	4286      	cmp	r6, r0
c0d02674:	d21c      	bcs.n	c0d026b0 <io_event+0x3dc>
c0d02676:	f001 fd43 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d0267a:	2800      	cmp	r0, #0
c0d0267c:	d118      	bne.n	c0d026b0 <io_event+0x3dc>
c0d0267e:	68a0      	ldr	r0, [r4, #8]
c0d02680:	68e1      	ldr	r1, [r4, #12]
c0d02682:	2638      	movs	r6, #56	; 0x38
c0d02684:	4370      	muls	r0, r6
c0d02686:	6822      	ldr	r2, [r4, #0]
c0d02688:	1810      	adds	r0, r2, r0
c0d0268a:	2900      	cmp	r1, #0
c0d0268c:	d002      	beq.n	c0d02694 <io_event+0x3c0>
c0d0268e:	4788      	blx	r1
c0d02690:	2800      	cmp	r0, #0
c0d02692:	d007      	beq.n	c0d026a4 <io_event+0x3d0>
c0d02694:	2801      	cmp	r0, #1
c0d02696:	d103      	bne.n	c0d026a0 <io_event+0x3cc>
c0d02698:	68a0      	ldr	r0, [r4, #8]
c0d0269a:	4346      	muls	r6, r0
c0d0269c:	6820      	ldr	r0, [r4, #0]
c0d0269e:	1980      	adds	r0, r0, r6
    return;
}

// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
  io_seproxyhal_display_default((bagl_element_t *)element);
c0d026a0:	f000 fd2c 	bl	c0d030fc <io_seproxyhal_display_default>
    case SEPROXYHAL_TAG_DISPLAY_PROCESSED_EVENT:
        UX_DISPLAYED_EVENT({});
        break;

    case SEPROXYHAL_TAG_TICKER_EVENT:
        UX_TICKER_EVENT(G_io_seproxyhal_spi_buffer,
c0d026a4:	68a0      	ldr	r0, [r4, #8]
c0d026a6:	1c46      	adds	r6, r0, #1
c0d026a8:	60a6      	str	r6, [r4, #8]
c0d026aa:	6820      	ldr	r0, [r4, #0]
c0d026ac:	2800      	cmp	r0, #0
c0d026ae:	d1df      	bne.n	c0d02670 <io_event+0x39c>
c0d026b0:	4871      	ldr	r0, [pc, #452]	; (c0d02878 <io_event+0x5a4>)
c0d026b2:	4285      	cmp	r5, r0
c0d026b4:	d100      	bne.n	c0d026b8 <io_event+0x3e4>
c0d026b6:	e0cd      	b.n	c0d02854 <io_event+0x580>
c0d026b8:	2d00      	cmp	r5, #0
c0d026ba:	d100      	bne.n	c0d026be <io_event+0x3ea>
c0d026bc:	e0ca      	b.n	c0d02854 <io_event+0x580>
c0d026be:	6820      	ldr	r0, [r4, #0]
c0d026c0:	2800      	cmp	r0, #0
c0d026c2:	d100      	bne.n	c0d026c6 <io_event+0x3f2>
c0d026c4:	e0c0      	b.n	c0d02848 <io_event+0x574>
c0d026c6:	68a0      	ldr	r0, [r4, #8]
c0d026c8:	6861      	ldr	r1, [r4, #4]
c0d026ca:	4288      	cmp	r0, r1
c0d026cc:	d300      	bcc.n	c0d026d0 <io_event+0x3fc>
c0d026ce:	e0bb      	b.n	c0d02848 <io_event+0x574>
c0d026d0:	f001 fd16 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d026d4:	2800      	cmp	r0, #0
c0d026d6:	d000      	beq.n	c0d026da <io_event+0x406>
c0d026d8:	e0b6      	b.n	c0d02848 <io_event+0x574>
c0d026da:	68a0      	ldr	r0, [r4, #8]
c0d026dc:	68e1      	ldr	r1, [r4, #12]
c0d026de:	2538      	movs	r5, #56	; 0x38
c0d026e0:	4368      	muls	r0, r5
c0d026e2:	6822      	ldr	r2, [r4, #0]
c0d026e4:	1810      	adds	r0, r2, r0
c0d026e6:	2900      	cmp	r1, #0
c0d026e8:	d002      	beq.n	c0d026f0 <io_event+0x41c>
c0d026ea:	4788      	blx	r1
c0d026ec:	2800      	cmp	r0, #0
c0d026ee:	d007      	beq.n	c0d02700 <io_event+0x42c>
c0d026f0:	2801      	cmp	r0, #1
c0d026f2:	d103      	bne.n	c0d026fc <io_event+0x428>
c0d026f4:	68a0      	ldr	r0, [r4, #8]
c0d026f6:	4345      	muls	r5, r0
c0d026f8:	6820      	ldr	r0, [r4, #0]
c0d026fa:	1940      	adds	r0, r0, r5
    return;
}

// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
  io_seproxyhal_display_default((bagl_element_t *)element);
c0d026fc:	f000 fcfe 	bl	c0d030fc <io_seproxyhal_display_default>
    case SEPROXYHAL_TAG_DISPLAY_PROCESSED_EVENT:
        UX_DISPLAYED_EVENT({});
        break;

    case SEPROXYHAL_TAG_TICKER_EVENT:
        UX_TICKER_EVENT(G_io_seproxyhal_spi_buffer,
c0d02700:	68a0      	ldr	r0, [r4, #8]
c0d02702:	1c40      	adds	r0, r0, #1
c0d02704:	60a0      	str	r0, [r4, #8]
c0d02706:	6821      	ldr	r1, [r4, #0]
c0d02708:	2900      	cmp	r1, #0
c0d0270a:	d1dd      	bne.n	c0d026c8 <io_event+0x3f4>
c0d0270c:	e09c      	b.n	c0d02848 <io_event+0x574>
    default:
        UX_DEFAULT_EVENT();
        break;

    case SEPROXYHAL_TAG_DISPLAY_PROCESSED_EVENT:
        UX_DISPLAYED_EVENT({});
c0d0270e:	f000 fba1 	bl	c0d02e54 <io_seproxyhal_init_ux>
c0d02712:	f000 fba5 	bl	c0d02e60 <io_seproxyhal_init_button>
c0d02716:	60a5      	str	r5, [r4, #8]
c0d02718:	6820      	ldr	r0, [r4, #0]
c0d0271a:	2800      	cmp	r0, #0
c0d0271c:	d100      	bne.n	c0d02720 <io_event+0x44c>
c0d0271e:	e099      	b.n	c0d02854 <io_event+0x580>
c0d02720:	69e0      	ldr	r0, [r4, #28]
c0d02722:	4955      	ldr	r1, [pc, #340]	; (c0d02878 <io_event+0x5a4>)
c0d02724:	4288      	cmp	r0, r1
c0d02726:	d127      	bne.n	c0d02778 <io_event+0x4a4>
c0d02728:	e094      	b.n	c0d02854 <io_event+0x580>
c0d0272a:	46c0      	nop			; (mov r8, r8)
c0d0272c:	b0105055 	.word	0xb0105055
c0d02730:	20001898 	.word	0x20001898
c0d02734:	b0105044 	.word	0xb0105044
c0d02738:	6860      	ldr	r0, [r4, #4]
c0d0273a:	4285      	cmp	r5, r0
c0d0273c:	d300      	bcc.n	c0d02740 <io_event+0x46c>
c0d0273e:	e089      	b.n	c0d02854 <io_event+0x580>
c0d02740:	f001 fcde 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d02744:	2800      	cmp	r0, #0
c0d02746:	d000      	beq.n	c0d0274a <io_event+0x476>
c0d02748:	e084      	b.n	c0d02854 <io_event+0x580>
c0d0274a:	68a0      	ldr	r0, [r4, #8]
c0d0274c:	68e1      	ldr	r1, [r4, #12]
c0d0274e:	2538      	movs	r5, #56	; 0x38
c0d02750:	4368      	muls	r0, r5
c0d02752:	6822      	ldr	r2, [r4, #0]
c0d02754:	1810      	adds	r0, r2, r0
c0d02756:	2900      	cmp	r1, #0
c0d02758:	d002      	beq.n	c0d02760 <io_event+0x48c>
c0d0275a:	4788      	blx	r1
c0d0275c:	2800      	cmp	r0, #0
c0d0275e:	d007      	beq.n	c0d02770 <io_event+0x49c>
c0d02760:	2801      	cmp	r0, #1
c0d02762:	d103      	bne.n	c0d0276c <io_event+0x498>
c0d02764:	68a0      	ldr	r0, [r4, #8]
c0d02766:	4345      	muls	r5, r0
c0d02768:	6820      	ldr	r0, [r4, #0]
c0d0276a:	1940      	adds	r0, r0, r5
    return;
}

// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
  io_seproxyhal_display_default((bagl_element_t *)element);
c0d0276c:	f000 fcc6 	bl	c0d030fc <io_seproxyhal_display_default>
    default:
        UX_DEFAULT_EVENT();
        break;

    case SEPROXYHAL_TAG_DISPLAY_PROCESSED_EVENT:
        UX_DISPLAYED_EVENT({});
c0d02770:	68a0      	ldr	r0, [r4, #8]
c0d02772:	1c45      	adds	r5, r0, #1
c0d02774:	60a5      	str	r5, [r4, #8]
c0d02776:	6820      	ldr	r0, [r4, #0]
c0d02778:	2800      	cmp	r0, #0
c0d0277a:	d1dd      	bne.n	c0d02738 <io_event+0x464>
c0d0277c:	e06a      	b.n	c0d02854 <io_event+0x580>
    // needed

    // can't have more than one tag in the reply, not supported yet.
    switch (G_io_seproxyhal_spi_buffer[0]) {
    case SEPROXYHAL_TAG_FINGER_EVENT:
    		UX_FINGER_EVENT(G_io_seproxyhal_spi_buffer);
c0d0277e:	88a0      	ldrh	r0, [r4, #4]
c0d02780:	9004      	str	r0, [sp, #16]
c0d02782:	6820      	ldr	r0, [r4, #0]
c0d02784:	9003      	str	r0, [sp, #12]
c0d02786:	79ee      	ldrb	r6, [r5, #7]
c0d02788:	79ab      	ldrb	r3, [r5, #6]
c0d0278a:	796f      	ldrb	r7, [r5, #5]
c0d0278c:	792a      	ldrb	r2, [r5, #4]
c0d0278e:	78ed      	ldrb	r5, [r5, #3]
c0d02790:	68e1      	ldr	r1, [r4, #12]
c0d02792:	4668      	mov	r0, sp
c0d02794:	6005      	str	r5, [r0, #0]
c0d02796:	6041      	str	r1, [r0, #4]
c0d02798:	0212      	lsls	r2, r2, #8
c0d0279a:	433a      	orrs	r2, r7
c0d0279c:	021b      	lsls	r3, r3, #8
c0d0279e:	4333      	orrs	r3, r6
c0d027a0:	9803      	ldr	r0, [sp, #12]
c0d027a2:	9904      	ldr	r1, [sp, #16]
c0d027a4:	f000 fbdc 	bl	c0d02f60 <io_seproxyhal_touch_element_callback>
c0d027a8:	6820      	ldr	r0, [r4, #0]
c0d027aa:	2800      	cmp	r0, #0
c0d027ac:	d04c      	beq.n	c0d02848 <io_event+0x574>
c0d027ae:	68a0      	ldr	r0, [r4, #8]
c0d027b0:	6861      	ldr	r1, [r4, #4]
c0d027b2:	4288      	cmp	r0, r1
c0d027b4:	d248      	bcs.n	c0d02848 <io_event+0x574>
c0d027b6:	f001 fca3 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d027ba:	2800      	cmp	r0, #0
c0d027bc:	d144      	bne.n	c0d02848 <io_event+0x574>
c0d027be:	68a0      	ldr	r0, [r4, #8]
c0d027c0:	68e1      	ldr	r1, [r4, #12]
c0d027c2:	2538      	movs	r5, #56	; 0x38
c0d027c4:	4368      	muls	r0, r5
c0d027c6:	6822      	ldr	r2, [r4, #0]
c0d027c8:	1810      	adds	r0, r2, r0
c0d027ca:	2900      	cmp	r1, #0
c0d027cc:	d002      	beq.n	c0d027d4 <io_event+0x500>
c0d027ce:	4788      	blx	r1
c0d027d0:	2800      	cmp	r0, #0
c0d027d2:	d007      	beq.n	c0d027e4 <io_event+0x510>
c0d027d4:	2801      	cmp	r0, #1
c0d027d6:	d103      	bne.n	c0d027e0 <io_event+0x50c>
c0d027d8:	68a0      	ldr	r0, [r4, #8]
c0d027da:	4345      	muls	r5, r0
c0d027dc:	6820      	ldr	r0, [r4, #0]
c0d027de:	1940      	adds	r0, r0, r5
    return;
}

// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
  io_seproxyhal_display_default((bagl_element_t *)element);
c0d027e0:	f000 fc8c 	bl	c0d030fc <io_seproxyhal_display_default>
    // needed

    // can't have more than one tag in the reply, not supported yet.
    switch (G_io_seproxyhal_spi_buffer[0]) {
    case SEPROXYHAL_TAG_FINGER_EVENT:
    		UX_FINGER_EVENT(G_io_seproxyhal_spi_buffer);
c0d027e4:	68a0      	ldr	r0, [r4, #8]
c0d027e6:	1c40      	adds	r0, r0, #1
c0d027e8:	60a0      	str	r0, [r4, #8]
c0d027ea:	6821      	ldr	r1, [r4, #0]
c0d027ec:	2900      	cmp	r1, #0
c0d027ee:	d1df      	bne.n	c0d027b0 <io_event+0x4dc>
c0d027f0:	e02a      	b.n	c0d02848 <io_event+0x574>
    		break;

    case SEPROXYHAL_TAG_BUTTON_PUSH_EVENT:
        UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0d027f2:	6920      	ldr	r0, [r4, #16]
c0d027f4:	2800      	cmp	r0, #0
c0d027f6:	d003      	beq.n	c0d02800 <io_event+0x52c>
c0d027f8:	78e9      	ldrb	r1, [r5, #3]
c0d027fa:	0849      	lsrs	r1, r1, #1
c0d027fc:	f000 fcec 	bl	c0d031d8 <io_seproxyhal_button_push>
c0d02800:	6820      	ldr	r0, [r4, #0]
c0d02802:	2800      	cmp	r0, #0
c0d02804:	d020      	beq.n	c0d02848 <io_event+0x574>
c0d02806:	68a0      	ldr	r0, [r4, #8]
c0d02808:	6861      	ldr	r1, [r4, #4]
c0d0280a:	4288      	cmp	r0, r1
c0d0280c:	d21c      	bcs.n	c0d02848 <io_event+0x574>
c0d0280e:	f001 fc77 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d02812:	2800      	cmp	r0, #0
c0d02814:	d118      	bne.n	c0d02848 <io_event+0x574>
c0d02816:	68a0      	ldr	r0, [r4, #8]
c0d02818:	68e1      	ldr	r1, [r4, #12]
c0d0281a:	2538      	movs	r5, #56	; 0x38
c0d0281c:	4368      	muls	r0, r5
c0d0281e:	6822      	ldr	r2, [r4, #0]
c0d02820:	1810      	adds	r0, r2, r0
c0d02822:	2900      	cmp	r1, #0
c0d02824:	d002      	beq.n	c0d0282c <io_event+0x558>
c0d02826:	4788      	blx	r1
c0d02828:	2800      	cmp	r0, #0
c0d0282a:	d007      	beq.n	c0d0283c <io_event+0x568>
c0d0282c:	2801      	cmp	r0, #1
c0d0282e:	d103      	bne.n	c0d02838 <io_event+0x564>
c0d02830:	68a0      	ldr	r0, [r4, #8]
c0d02832:	4345      	muls	r5, r0
c0d02834:	6820      	ldr	r0, [r4, #0]
c0d02836:	1940      	adds	r0, r0, r5
    return;
}

// override point, but nothing more to do
void io_seproxyhal_display(const bagl_element_t *element) {
  io_seproxyhal_display_default((bagl_element_t *)element);
c0d02838:	f000 fc60 	bl	c0d030fc <io_seproxyhal_display_default>
    case SEPROXYHAL_TAG_FINGER_EVENT:
    		UX_FINGER_EVENT(G_io_seproxyhal_spi_buffer);
    		break;

    case SEPROXYHAL_TAG_BUTTON_PUSH_EVENT:
        UX_BUTTON_PUSH_EVENT(G_io_seproxyhal_spi_buffer);
c0d0283c:	68a0      	ldr	r0, [r4, #8]
c0d0283e:	1c40      	adds	r0, r0, #1
c0d02840:	60a0      	str	r0, [r4, #8]
c0d02842:	6821      	ldr	r1, [r4, #0]
c0d02844:	2900      	cmp	r1, #0
c0d02846:	d1df      	bne.n	c0d02808 <io_event+0x534>
c0d02848:	6860      	ldr	r0, [r4, #4]
c0d0284a:	68a1      	ldr	r1, [r4, #8]
c0d0284c:	4281      	cmp	r1, r0
c0d0284e:	d301      	bcc.n	c0d02854 <io_event+0x580>
c0d02850:	f001 fc56 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
        });
        break;
    }

    // close the event if not done previously (by a display or whatever)
    if (!io_seproxyhal_spi_is_status_sent()) {
c0d02854:	f001 fc54 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d02858:	2800      	cmp	r0, #0
c0d0285a:	d101      	bne.n	c0d02860 <io_event+0x58c>
        io_seproxyhal_general_status();
c0d0285c:	f000 f9aa 	bl	c0d02bb4 <io_seproxyhal_general_status>
    }

    // command has been processed, DO NOT reset the current APDU transport
    return 1;
c0d02860:	2001      	movs	r0, #1
c0d02862:	b005      	add	sp, #20
c0d02864:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d02866:	46c0      	nop			; (mov r8, r8)
c0d02868:	b0105055 	.word	0xb0105055
c0d0286c:	20001898 	.word	0x20001898
c0d02870:	20001af0 	.word	0x20001af0
c0d02874:	20001894 	.word	0x20001894
c0d02878:	b0105044 	.word	0xb0105044

c0d0287c <app_exit>:
}

void app_exit(void) {
c0d0287c:	b510      	push	{r4, lr}
c0d0287e:	b08c      	sub	sp, #48	; 0x30
c0d02880:	ac01      	add	r4, sp, #4

    BEGIN_TRY_L(exit) {
        TRY_L(exit) {
c0d02882:	4620      	mov	r0, r4
c0d02884:	f004 fb9a 	bl	c0d06fbc <setjmp>
c0d02888:	8520      	strh	r0, [r4, #40]	; 0x28
c0d0288a:	490d      	ldr	r1, [pc, #52]	; (c0d028c0 <app_exit+0x44>)
c0d0288c:	4208      	tst	r0, r1
c0d0288e:	d106      	bne.n	c0d0289e <app_exit+0x22>
c0d02890:	a801      	add	r0, sp, #4
c0d02892:	f000 f81a 	bl	c0d028ca <try_context_set>
            os_sched_exit(-1);
c0d02896:	2000      	movs	r0, #0
c0d02898:	43c0      	mvns	r0, r0
c0d0289a:	f001 fbab 	bl	c0d03ff4 <os_sched_exit>
        }
        FINALLY_L(exit) {
c0d0289e:	f000 f981 	bl	c0d02ba4 <try_context_get>
c0d028a2:	a901      	add	r1, sp, #4
c0d028a4:	4288      	cmp	r0, r1
c0d028a6:	d103      	bne.n	c0d028b0 <app_exit+0x34>
c0d028a8:	f000 f97e 	bl	c0d02ba8 <try_context_get_previous>
c0d028ac:	f000 f80d 	bl	c0d028ca <try_context_set>
c0d028b0:	a801      	add	r0, sp, #4

        }
    }
    END_TRY_L(exit);
c0d028b2:	8d00      	ldrh	r0, [r0, #40]	; 0x28
c0d028b4:	2800      	cmp	r0, #0
c0d028b6:	d101      	bne.n	c0d028bc <app_exit+0x40>
}
c0d028b8:	b00c      	add	sp, #48	; 0x30
c0d028ba:	bd10      	pop	{r4, pc}
        }
        FINALLY_L(exit) {

        }
    }
    END_TRY_L(exit);
c0d028bc:	f000 f96d 	bl	c0d02b9a <os_longjmp>
c0d028c0:	0000ffff 	.word	0x0000ffff

c0d028c4 <os_boot>:
  //                ^ platform register
  return (try_context_t*) current_ctx->jmp_buf[5];
}

void try_context_set(try_context_t* ctx) {
  __asm volatile ("mov r9, %0"::"r"(ctx));
c0d028c4:	2000      	movs	r0, #0
c0d028c6:	4681      	mov	r9, r0

void os_boot(void) {
  // TODO patch entry point when romming (f)
  // set the default try context to nothing
  try_context_set(NULL);
}
c0d028c8:	4770      	bx	lr

c0d028ca <try_context_set>:
  //                ^ platform register
  return (try_context_t*) current_ctx->jmp_buf[5];
}

void try_context_set(try_context_t* ctx) {
  __asm volatile ("mov r9, %0"::"r"(ctx));
c0d028ca:	4681      	mov	r9, r0
}
c0d028cc:	4770      	bx	lr
	...

c0d028d0 <io_usb_hid_receive>:
volatile unsigned int   G_io_usb_hid_channel;
volatile unsigned int   G_io_usb_hid_remaining_length;
volatile unsigned int   G_io_usb_hid_sequence_number;
volatile unsigned char* G_io_usb_hid_current_buffer;

io_usb_hid_receive_status_t io_usb_hid_receive (io_send_t sndfct, unsigned char* buffer, unsigned short l) {
c0d028d0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d028d2:	b081      	sub	sp, #4
c0d028d4:	9200      	str	r2, [sp, #0]
c0d028d6:	460f      	mov	r7, r1
c0d028d8:	4605      	mov	r5, r0
  // avoid over/under flows
  if (buffer != G_io_usb_ep_buffer) {
c0d028da:	4b48      	ldr	r3, [pc, #288]	; (c0d029fc <io_usb_hid_receive+0x12c>)
c0d028dc:	429f      	cmp	r7, r3
c0d028de:	d00f      	beq.n	c0d02900 <io_usb_hid_receive+0x30>
}

void os_memset(void * dst, unsigned char c, unsigned int length) {
#define DSTCHAR ((unsigned char *)dst)
  while(length--) {
    DSTCHAR[length] = c;
c0d028e0:	4c46      	ldr	r4, [pc, #280]	; (c0d029fc <io_usb_hid_receive+0x12c>)
c0d028e2:	2640      	movs	r6, #64	; 0x40
c0d028e4:	4620      	mov	r0, r4
c0d028e6:	4631      	mov	r1, r6
c0d028e8:	f004 fad2 	bl	c0d06e90 <__aeabi_memclr>
c0d028ec:	9800      	ldr	r0, [sp, #0]

io_usb_hid_receive_status_t io_usb_hid_receive (io_send_t sndfct, unsigned char* buffer, unsigned short l) {
  // avoid over/under flows
  if (buffer != G_io_usb_ep_buffer) {
    os_memset(G_io_usb_ep_buffer, 0, sizeof(G_io_usb_ep_buffer));
    os_memmove(G_io_usb_ep_buffer, buffer, MIN(l, sizeof(G_io_usb_ep_buffer)));
c0d028ee:	2840      	cmp	r0, #64	; 0x40
c0d028f0:	4602      	mov	r2, r0
c0d028f2:	d300      	bcc.n	c0d028f6 <io_usb_hid_receive+0x26>
c0d028f4:	4632      	mov	r2, r6
c0d028f6:	4620      	mov	r0, r4
c0d028f8:	4639      	mov	r1, r7
c0d028fa:	f000 f89a 	bl	c0d02a32 <os_memmove>
c0d028fe:	4b3f      	ldr	r3, [pc, #252]	; (c0d029fc <io_usb_hid_receive+0x12c>)
c0d02900:	7898      	ldrb	r0, [r3, #2]
  }

  // process the chunk content
  switch(G_io_usb_ep_buffer[2]) {
c0d02902:	2801      	cmp	r0, #1
c0d02904:	dc0b      	bgt.n	c0d0291e <io_usb_hid_receive+0x4e>
c0d02906:	2800      	cmp	r0, #0
c0d02908:	d02b      	beq.n	c0d02962 <io_usb_hid_receive+0x92>
c0d0290a:	2801      	cmp	r0, #1
c0d0290c:	d169      	bne.n	c0d029e2 <io_usb_hid_receive+0x112>
    // await for the next chunk
    goto apdu_reset;

  case 0x01: // ALLOCATE CHANNEL
    // do not reset the current apdu reception if any
    cx_rng(G_io_usb_ep_buffer+3, 4);
c0d0290e:	1cd8      	adds	r0, r3, #3
c0d02910:	2104      	movs	r1, #4
c0d02912:	461c      	mov	r4, r3
c0d02914:	f001 fa3e 	bl	c0d03d94 <cx_rng>
    // send the response
    sndfct(G_io_usb_ep_buffer, IO_HID_EP_LENGTH);
c0d02918:	2140      	movs	r1, #64	; 0x40
c0d0291a:	4620      	mov	r0, r4
c0d0291c:	e02c      	b.n	c0d02978 <io_usb_hid_receive+0xa8>
c0d0291e:	2802      	cmp	r0, #2
c0d02920:	d028      	beq.n	c0d02974 <io_usb_hid_receive+0xa4>
c0d02922:	2805      	cmp	r0, #5
c0d02924:	d15d      	bne.n	c0d029e2 <io_usb_hid_receive+0x112>

  // process the chunk content
  switch(G_io_usb_ep_buffer[2]) {
  case 0x05:
    // ensure sequence idx is 0 for the first chunk ! 
    if ((unsigned int)U2BE(G_io_usb_ep_buffer, 3) != (unsigned int)G_io_usb_hid_sequence_number) {
c0d02926:	7918      	ldrb	r0, [r3, #4]
c0d02928:	78d9      	ldrb	r1, [r3, #3]
c0d0292a:	0209      	lsls	r1, r1, #8
c0d0292c:	4301      	orrs	r1, r0
c0d0292e:	4a34      	ldr	r2, [pc, #208]	; (c0d02a00 <io_usb_hid_receive+0x130>)
c0d02930:	6810      	ldr	r0, [r2, #0]
c0d02932:	2400      	movs	r4, #0
c0d02934:	4281      	cmp	r1, r0
c0d02936:	d15a      	bne.n	c0d029ee <io_usb_hid_receive+0x11e>
c0d02938:	4e32      	ldr	r6, [pc, #200]	; (c0d02a04 <io_usb_hid_receive+0x134>)
      // ignore packet
      goto apdu_reset;
    }
    // cid, tag, seq
    l -= 2+1+2;
c0d0293a:	9800      	ldr	r0, [sp, #0]
c0d0293c:	1980      	adds	r0, r0, r6
c0d0293e:	1f07      	subs	r7, r0, #4
    
    // append the received chunk to the current command apdu
    if (G_io_usb_hid_sequence_number == 0) {
c0d02940:	6810      	ldr	r0, [r2, #0]
c0d02942:	2800      	cmp	r0, #0
c0d02944:	d01b      	beq.n	c0d0297e <io_usb_hid_receive+0xae>
c0d02946:	4614      	mov	r4, r2
      // copy data
      os_memmove((void*)G_io_usb_hid_current_buffer, G_io_usb_ep_buffer+7, l);
    }
    else {
      // check for invalid length encoding (more data in chunk that announced in the total apdu)
      if (l > G_io_usb_hid_remaining_length) {
c0d02948:	4639      	mov	r1, r7
c0d0294a:	4031      	ands	r1, r6
c0d0294c:	482e      	ldr	r0, [pc, #184]	; (c0d02a08 <io_usb_hid_receive+0x138>)
c0d0294e:	6802      	ldr	r2, [r0, #0]
c0d02950:	4291      	cmp	r1, r2
c0d02952:	d900      	bls.n	c0d02956 <io_usb_hid_receive+0x86>
        l = G_io_usb_hid_remaining_length;
c0d02954:	6807      	ldr	r7, [r0, #0]
      }

      /// This is a following chunk
      // append content
      os_memmove((void*)G_io_usb_hid_current_buffer, G_io_usb_ep_buffer+5, l);
c0d02956:	463a      	mov	r2, r7
c0d02958:	4032      	ands	r2, r6
c0d0295a:	482c      	ldr	r0, [pc, #176]	; (c0d02a0c <io_usb_hid_receive+0x13c>)
c0d0295c:	6800      	ldr	r0, [r0, #0]
c0d0295e:	1d59      	adds	r1, r3, #5
c0d02960:	e031      	b.n	c0d029c6 <io_usb_hid_receive+0xf6>
c0d02962:	2400      	movs	r4, #0
}

void os_memset(void * dst, unsigned char c, unsigned int length) {
#define DSTCHAR ((unsigned char *)dst)
  while(length--) {
    DSTCHAR[length] = c;
c0d02964:	719c      	strb	r4, [r3, #6]
c0d02966:	715c      	strb	r4, [r3, #5]
c0d02968:	711c      	strb	r4, [r3, #4]
c0d0296a:	70dc      	strb	r4, [r3, #3]

  case 0x00: // get version ID
    // do not reset the current apdu reception if any
    os_memset(G_io_usb_ep_buffer+3, 0, 4); // PROTOCOL VERSION is 0
    // send the response
    sndfct(G_io_usb_ep_buffer, IO_HID_EP_LENGTH);
c0d0296c:	2140      	movs	r1, #64	; 0x40
c0d0296e:	4618      	mov	r0, r3
c0d02970:	47a8      	blx	r5
c0d02972:	e03c      	b.n	c0d029ee <io_usb_hid_receive+0x11e>
    goto apdu_reset;

  case 0x02: // ECHO|PING
    // do not reset the current apdu reception if any
    // send the response
    sndfct(G_io_usb_ep_buffer, IO_HID_EP_LENGTH);
c0d02974:	4821      	ldr	r0, [pc, #132]	; (c0d029fc <io_usb_hid_receive+0x12c>)
c0d02976:	2140      	movs	r1, #64	; 0x40
c0d02978:	47a8      	blx	r5
c0d0297a:	2400      	movs	r4, #0
c0d0297c:	e037      	b.n	c0d029ee <io_usb_hid_receive+0x11e>
    
    // append the received chunk to the current command apdu
    if (G_io_usb_hid_sequence_number == 0) {
      /// This is the apdu first chunk
      // total apdu size to receive
      G_io_usb_hid_total_length = U2BE(G_io_usb_ep_buffer, 5); //(G_io_usb_ep_buffer[5]<<8)+(G_io_usb_ep_buffer[6]&0xFF);
c0d0297e:	7998      	ldrb	r0, [r3, #6]
c0d02980:	7959      	ldrb	r1, [r3, #5]
c0d02982:	0209      	lsls	r1, r1, #8
c0d02984:	4301      	orrs	r1, r0
c0d02986:	4822      	ldr	r0, [pc, #136]	; (c0d02a10 <io_usb_hid_receive+0x140>)
c0d02988:	6001      	str	r1, [r0, #0]
      // check for invalid length encoding (more data in chunk that announced in the total apdu)
      if (G_io_usb_hid_total_length > sizeof(G_io_apdu_buffer)) {
c0d0298a:	6801      	ldr	r1, [r0, #0]
c0d0298c:	0849      	lsrs	r1, r1, #1
c0d0298e:	29a8      	cmp	r1, #168	; 0xa8
c0d02990:	d82d      	bhi.n	c0d029ee <io_usb_hid_receive+0x11e>
c0d02992:	4614      	mov	r4, r2
        goto apdu_reset;
      }
      // seq and total length
      l -= 2;
      // compute remaining size to receive
      G_io_usb_hid_remaining_length = G_io_usb_hid_total_length;
c0d02994:	6801      	ldr	r1, [r0, #0]
c0d02996:	481c      	ldr	r0, [pc, #112]	; (c0d02a08 <io_usb_hid_receive+0x138>)
c0d02998:	6001      	str	r1, [r0, #0]
      G_io_usb_hid_current_buffer = G_io_apdu_buffer;
c0d0299a:	491c      	ldr	r1, [pc, #112]	; (c0d02a0c <io_usb_hid_receive+0x13c>)
c0d0299c:	4a1d      	ldr	r2, [pc, #116]	; (c0d02a14 <io_usb_hid_receive+0x144>)
c0d0299e:	600a      	str	r2, [r1, #0]

      // retain the channel id to use for the reply
      G_io_usb_hid_channel = U2BE(G_io_usb_ep_buffer, 0);
c0d029a0:	7859      	ldrb	r1, [r3, #1]
c0d029a2:	781a      	ldrb	r2, [r3, #0]
c0d029a4:	0212      	lsls	r2, r2, #8
c0d029a6:	430a      	orrs	r2, r1
c0d029a8:	491b      	ldr	r1, [pc, #108]	; (c0d02a18 <io_usb_hid_receive+0x148>)
c0d029aa:	600a      	str	r2, [r1, #0]
      // check for invalid length encoding (more data in chunk that announced in the total apdu)
      if (G_io_usb_hid_total_length > sizeof(G_io_apdu_buffer)) {
        goto apdu_reset;
      }
      // seq and total length
      l -= 2;
c0d029ac:	491b      	ldr	r1, [pc, #108]	; (c0d02a1c <io_usb_hid_receive+0x14c>)
c0d029ae:	9a00      	ldr	r2, [sp, #0]
c0d029b0:	1857      	adds	r7, r2, r1
      G_io_usb_hid_current_buffer = G_io_apdu_buffer;

      // retain the channel id to use for the reply
      G_io_usb_hid_channel = U2BE(G_io_usb_ep_buffer, 0);

      if (l > G_io_usb_hid_remaining_length) {
c0d029b2:	4639      	mov	r1, r7
c0d029b4:	4031      	ands	r1, r6
c0d029b6:	6802      	ldr	r2, [r0, #0]
c0d029b8:	4291      	cmp	r1, r2
c0d029ba:	d900      	bls.n	c0d029be <io_usb_hid_receive+0xee>
        l = G_io_usb_hid_remaining_length;
c0d029bc:	6807      	ldr	r7, [r0, #0]
      }
      // copy data
      os_memmove((void*)G_io_usb_hid_current_buffer, G_io_usb_ep_buffer+7, l);
c0d029be:	463a      	mov	r2, r7
c0d029c0:	4032      	ands	r2, r6
c0d029c2:	1dd9      	adds	r1, r3, #7
c0d029c4:	4813      	ldr	r0, [pc, #76]	; (c0d02a14 <io_usb_hid_receive+0x144>)
c0d029c6:	f000 f834 	bl	c0d02a32 <os_memmove>
      /// This is a following chunk
      // append content
      os_memmove((void*)G_io_usb_hid_current_buffer, G_io_usb_ep_buffer+5, l);
    }
    // factorize (f)
    G_io_usb_hid_current_buffer += l;
c0d029ca:	4037      	ands	r7, r6
c0d029cc:	480f      	ldr	r0, [pc, #60]	; (c0d02a0c <io_usb_hid_receive+0x13c>)
c0d029ce:	6801      	ldr	r1, [r0, #0]
c0d029d0:	19c9      	adds	r1, r1, r7
c0d029d2:	6001      	str	r1, [r0, #0]
    G_io_usb_hid_remaining_length -= l;
c0d029d4:	480c      	ldr	r0, [pc, #48]	; (c0d02a08 <io_usb_hid_receive+0x138>)
c0d029d6:	6801      	ldr	r1, [r0, #0]
c0d029d8:	1bc9      	subs	r1, r1, r7
c0d029da:	6001      	str	r1, [r0, #0]
    G_io_usb_hid_sequence_number++;
c0d029dc:	6820      	ldr	r0, [r4, #0]
c0d029de:	1c40      	adds	r0, r0, #1
c0d029e0:	6020      	str	r0, [r4, #0]
    // await for the next chunk
    goto apdu_reset;
  }

  // if more data to be received, notify it
  if (G_io_usb_hid_remaining_length) {
c0d029e2:	4809      	ldr	r0, [pc, #36]	; (c0d02a08 <io_usb_hid_receive+0x138>)
c0d029e4:	6801      	ldr	r1, [r0, #0]
c0d029e6:	2001      	movs	r0, #1
c0d029e8:	2402      	movs	r4, #2
c0d029ea:	2900      	cmp	r1, #0
c0d029ec:	d103      	bne.n	c0d029f6 <io_usb_hid_receive+0x126>
  io_usb_hid_init();
  return IO_USB_APDU_RESET;
}

void io_usb_hid_init(void) {
  G_io_usb_hid_sequence_number = 0; 
c0d029ee:	4804      	ldr	r0, [pc, #16]	; (c0d02a00 <io_usb_hid_receive+0x130>)
c0d029f0:	2100      	movs	r1, #0
c0d029f2:	6001      	str	r1, [r0, #0]
c0d029f4:	4620      	mov	r0, r4
  return IO_USB_APDU_RECEIVED;

apdu_reset:
  io_usb_hid_init();
  return IO_USB_APDU_RESET;
}
c0d029f6:	b2c0      	uxtb	r0, r0
c0d029f8:	b001      	add	sp, #4
c0d029fa:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d029fc:	20001f5c 	.word	0x20001f5c
c0d02a00:	20001d40 	.word	0x20001d40
c0d02a04:	0000ffff 	.word	0x0000ffff
c0d02a08:	20001d48 	.word	0x20001d48
c0d02a0c:	20001ea0 	.word	0x20001ea0
c0d02a10:	20001d44 	.word	0x20001d44
c0d02a14:	20001d4c 	.word	0x20001d4c
c0d02a18:	20001ea4 	.word	0x20001ea4
c0d02a1c:	0001fff9 	.word	0x0001fff9

c0d02a20 <os_memset>:
    }
  }
#undef DSTCHAR
}

void os_memset(void * dst, unsigned char c, unsigned int length) {
c0d02a20:	b580      	push	{r7, lr}
c0d02a22:	460b      	mov	r3, r1
#define DSTCHAR ((unsigned char *)dst)
  while(length--) {
c0d02a24:	2a00      	cmp	r2, #0
c0d02a26:	d003      	beq.n	c0d02a30 <os_memset+0x10>
    DSTCHAR[length] = c;
c0d02a28:	4611      	mov	r1, r2
c0d02a2a:	461a      	mov	r2, r3
c0d02a2c:	f004 fa3a 	bl	c0d06ea4 <__aeabi_memset>
  }
#undef DSTCHAR
}
c0d02a30:	bd80      	pop	{r7, pc}

c0d02a32 <os_memmove>:
  }
}

#endif // HAVE_USB_APDU

REENTRANT(void os_memmove(void * dst, const void WIDE * src, unsigned int length)) {
c0d02a32:	b5b0      	push	{r4, r5, r7, lr}
#define DSTCHAR ((unsigned char *)dst)
#define SRCCHAR ((unsigned char WIDE *)src)
  if (dst > src) {
c0d02a34:	4288      	cmp	r0, r1
c0d02a36:	d90d      	bls.n	c0d02a54 <os_memmove+0x22>
    while(length--) {
c0d02a38:	2a00      	cmp	r2, #0
c0d02a3a:	d014      	beq.n	c0d02a66 <os_memmove+0x34>
c0d02a3c:	1e49      	subs	r1, r1, #1
c0d02a3e:	4252      	negs	r2, r2
c0d02a40:	1e40      	subs	r0, r0, #1
c0d02a42:	2300      	movs	r3, #0
c0d02a44:	43db      	mvns	r3, r3
      DSTCHAR[length] = SRCCHAR[length];
c0d02a46:	461c      	mov	r4, r3
c0d02a48:	4354      	muls	r4, r2
c0d02a4a:	5d0d      	ldrb	r5, [r1, r4]
c0d02a4c:	5505      	strb	r5, [r0, r4]

REENTRANT(void os_memmove(void * dst, const void WIDE * src, unsigned int length)) {
#define DSTCHAR ((unsigned char *)dst)
#define SRCCHAR ((unsigned char WIDE *)src)
  if (dst > src) {
    while(length--) {
c0d02a4e:	1c52      	adds	r2, r2, #1
c0d02a50:	d1f9      	bne.n	c0d02a46 <os_memmove+0x14>
c0d02a52:	e008      	b.n	c0d02a66 <os_memmove+0x34>
      DSTCHAR[length] = SRCCHAR[length];
    }
  }
  else {
    unsigned short l = 0;
    while (length--) {
c0d02a54:	2a00      	cmp	r2, #0
c0d02a56:	d006      	beq.n	c0d02a66 <os_memmove+0x34>
c0d02a58:	2300      	movs	r3, #0
      DSTCHAR[l] = SRCCHAR[l];
c0d02a5a:	b29c      	uxth	r4, r3
c0d02a5c:	5d0d      	ldrb	r5, [r1, r4]
c0d02a5e:	5505      	strb	r5, [r0, r4]
      l++;
c0d02a60:	1c5b      	adds	r3, r3, #1
      DSTCHAR[length] = SRCCHAR[length];
    }
  }
  else {
    unsigned short l = 0;
    while (length--) {
c0d02a62:	1e52      	subs	r2, r2, #1
c0d02a64:	d1f9      	bne.n	c0d02a5a <os_memmove+0x28>
      DSTCHAR[l] = SRCCHAR[l];
      l++;
    }
  }
#undef DSTCHAR
}
c0d02a66:	bdb0      	pop	{r4, r5, r7, pc}

c0d02a68 <io_usb_hid_init>:
  io_usb_hid_init();
  return IO_USB_APDU_RESET;
}

void io_usb_hid_init(void) {
  G_io_usb_hid_sequence_number = 0; 
c0d02a68:	4801      	ldr	r0, [pc, #4]	; (c0d02a70 <io_usb_hid_init+0x8>)
c0d02a6a:	2100      	movs	r1, #0
c0d02a6c:	6001      	str	r1, [r0, #0]
  //G_io_usb_hid_remaining_length = 0; // not really needed
  //G_io_usb_hid_total_length = 0; // not really needed
  //G_io_usb_hid_current_buffer = G_io_apdu_buffer; // not really needed
}
c0d02a6e:	4770      	bx	lr
c0d02a70:	20001d40 	.word	0x20001d40

c0d02a74 <io_usb_hid_sent>:

/**
 * sent the next io_usb_hid transport chunk (rx on the host, tx on the device)
 */
void io_usb_hid_sent(io_send_t sndfct) {
c0d02a74:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d02a76:	b081      	sub	sp, #4
  unsigned int l;

  // only prepare next chunk if some data to be sent remain
  if (G_io_usb_hid_remaining_length) {
c0d02a78:	4f29      	ldr	r7, [pc, #164]	; (c0d02b20 <io_usb_hid_sent+0xac>)
c0d02a7a:	6839      	ldr	r1, [r7, #0]
c0d02a7c:	2900      	cmp	r1, #0
c0d02a7e:	d026      	beq.n	c0d02ace <io_usb_hid_sent+0x5a>
c0d02a80:	9000      	str	r0, [sp, #0]
}

void os_memset(void * dst, unsigned char c, unsigned int length) {
#define DSTCHAR ((unsigned char *)dst)
  while(length--) {
    DSTCHAR[length] = c;
c0d02a82:	4c28      	ldr	r4, [pc, #160]	; (c0d02b24 <io_usb_hid_sent+0xb0>)
c0d02a84:	1d66      	adds	r6, r4, #5
c0d02a86:	2539      	movs	r5, #57	; 0x39
c0d02a88:	4630      	mov	r0, r6
c0d02a8a:	4629      	mov	r1, r5
c0d02a8c:	f004 fa00 	bl	c0d06e90 <__aeabi_memclr>
  if (G_io_usb_hid_remaining_length) {
    // fill the chunk
    os_memset(G_io_usb_ep_buffer, 0, IO_HID_EP_LENGTH-2);

    // keep the channel identifier
    G_io_usb_ep_buffer[0] = (G_io_usb_hid_channel>>8)&0xFF;
c0d02a90:	4825      	ldr	r0, [pc, #148]	; (c0d02b28 <io_usb_hid_sent+0xb4>)
c0d02a92:	6801      	ldr	r1, [r0, #0]
c0d02a94:	0a09      	lsrs	r1, r1, #8
c0d02a96:	7021      	strb	r1, [r4, #0]
    G_io_usb_ep_buffer[1] = G_io_usb_hid_channel&0xFF;
c0d02a98:	6800      	ldr	r0, [r0, #0]
c0d02a9a:	7060      	strb	r0, [r4, #1]
c0d02a9c:	2005      	movs	r0, #5
    G_io_usb_ep_buffer[2] = 0x05;
c0d02a9e:	70a0      	strb	r0, [r4, #2]
    G_io_usb_ep_buffer[3] = G_io_usb_hid_sequence_number>>8;
c0d02aa0:	4a22      	ldr	r2, [pc, #136]	; (c0d02b2c <io_usb_hid_sent+0xb8>)
c0d02aa2:	6810      	ldr	r0, [r2, #0]
c0d02aa4:	0a00      	lsrs	r0, r0, #8
c0d02aa6:	70e0      	strb	r0, [r4, #3]
    G_io_usb_ep_buffer[4] = G_io_usb_hid_sequence_number;
c0d02aa8:	6810      	ldr	r0, [r2, #0]
c0d02aaa:	7120      	strb	r0, [r4, #4]

    if (G_io_usb_hid_sequence_number == 0) {
c0d02aac:	6811      	ldr	r1, [r2, #0]
c0d02aae:	6838      	ldr	r0, [r7, #0]
c0d02ab0:	2900      	cmp	r1, #0
c0d02ab2:	d014      	beq.n	c0d02ade <io_usb_hid_sent+0x6a>
c0d02ab4:	4614      	mov	r4, r2
c0d02ab6:	253b      	movs	r5, #59	; 0x3b
      G_io_usb_hid_current_buffer += l;
      G_io_usb_hid_remaining_length -= l;
      l += 7;
    }
    else {
      l = ((G_io_usb_hid_remaining_length>IO_HID_EP_LENGTH-5) ? IO_HID_EP_LENGTH-5 : G_io_usb_hid_remaining_length);
c0d02ab8:	283b      	cmp	r0, #59	; 0x3b
c0d02aba:	d800      	bhi.n	c0d02abe <io_usb_hid_sent+0x4a>
c0d02abc:	683d      	ldr	r5, [r7, #0]
      os_memmove(G_io_usb_ep_buffer+5, (const void*)G_io_usb_hid_current_buffer, l);
c0d02abe:	481c      	ldr	r0, [pc, #112]	; (c0d02b30 <io_usb_hid_sent+0xbc>)
c0d02ac0:	6801      	ldr	r1, [r0, #0]
c0d02ac2:	4630      	mov	r0, r6
c0d02ac4:	462a      	mov	r2, r5
c0d02ac6:	f7ff ffb4 	bl	c0d02a32 <os_memmove>
c0d02aca:	9a00      	ldr	r2, [sp, #0]
c0d02acc:	e018      	b.n	c0d02b00 <io_usb_hid_sent+0x8c>
    // always pad :)
    sndfct(G_io_usb_ep_buffer, sizeof(G_io_usb_ep_buffer));
  }
  // cleanup when everything has been sent (ack for the last sent usb in packet)
  else {
    G_io_usb_hid_sequence_number = 0; 
c0d02ace:	4817      	ldr	r0, [pc, #92]	; (c0d02b2c <io_usb_hid_sent+0xb8>)
c0d02ad0:	2100      	movs	r1, #0
c0d02ad2:	6001      	str	r1, [r0, #0]
    G_io_usb_hid_current_buffer = NULL;
c0d02ad4:	4816      	ldr	r0, [pc, #88]	; (c0d02b30 <io_usb_hid_sent+0xbc>)
c0d02ad6:	6001      	str	r1, [r0, #0]

    // we sent the whole response
    G_io_apdu_state = APDU_IDLE;
c0d02ad8:	4816      	ldr	r0, [pc, #88]	; (c0d02b34 <io_usb_hid_sent+0xc0>)
c0d02ada:	7001      	strb	r1, [r0, #0]
c0d02adc:	e01d      	b.n	c0d02b1a <io_usb_hid_sent+0xa6>
c0d02ade:	4616      	mov	r6, r2
    G_io_usb_ep_buffer[2] = 0x05;
    G_io_usb_ep_buffer[3] = G_io_usb_hid_sequence_number>>8;
    G_io_usb_ep_buffer[4] = G_io_usb_hid_sequence_number;

    if (G_io_usb_hid_sequence_number == 0) {
      l = ((G_io_usb_hid_remaining_length>IO_HID_EP_LENGTH-7) ? IO_HID_EP_LENGTH-7 : G_io_usb_hid_remaining_length);
c0d02ae0:	2839      	cmp	r0, #57	; 0x39
c0d02ae2:	d800      	bhi.n	c0d02ae6 <io_usb_hid_sent+0x72>
c0d02ae4:	683d      	ldr	r5, [r7, #0]
      G_io_usb_ep_buffer[5] = G_io_usb_hid_remaining_length>>8;
c0d02ae6:	6838      	ldr	r0, [r7, #0]
c0d02ae8:	0a00      	lsrs	r0, r0, #8
c0d02aea:	7160      	strb	r0, [r4, #5]
      G_io_usb_ep_buffer[6] = G_io_usb_hid_remaining_length;
c0d02aec:	6838      	ldr	r0, [r7, #0]
c0d02aee:	71a0      	strb	r0, [r4, #6]
      os_memmove(G_io_usb_ep_buffer+7, (const void*)G_io_usb_hid_current_buffer, l);
c0d02af0:	480f      	ldr	r0, [pc, #60]	; (c0d02b30 <io_usb_hid_sent+0xbc>)
c0d02af2:	6801      	ldr	r1, [r0, #0]
c0d02af4:	1de0      	adds	r0, r4, #7
c0d02af6:	462a      	mov	r2, r5
c0d02af8:	f7ff ff9b 	bl	c0d02a32 <os_memmove>
c0d02afc:	9a00      	ldr	r2, [sp, #0]
c0d02afe:	4634      	mov	r4, r6
c0d02b00:	480b      	ldr	r0, [pc, #44]	; (c0d02b30 <io_usb_hid_sent+0xbc>)
c0d02b02:	6801      	ldr	r1, [r0, #0]
c0d02b04:	1949      	adds	r1, r1, r5
c0d02b06:	6001      	str	r1, [r0, #0]
c0d02b08:	6838      	ldr	r0, [r7, #0]
c0d02b0a:	1b40      	subs	r0, r0, r5
c0d02b0c:	6038      	str	r0, [r7, #0]
      G_io_usb_hid_current_buffer += l;
      G_io_usb_hid_remaining_length -= l;
      l += 5;
    }
    // prepare next chunk numbering
    G_io_usb_hid_sequence_number++;
c0d02b0e:	6820      	ldr	r0, [r4, #0]
c0d02b10:	1c40      	adds	r0, r0, #1
c0d02b12:	6020      	str	r0, [r4, #0]
    // send the chunk
    // always pad :)
    sndfct(G_io_usb_ep_buffer, sizeof(G_io_usb_ep_buffer));
c0d02b14:	4803      	ldr	r0, [pc, #12]	; (c0d02b24 <io_usb_hid_sent+0xb0>)
c0d02b16:	2140      	movs	r1, #64	; 0x40
c0d02b18:	4790      	blx	r2
    G_io_usb_hid_current_buffer = NULL;

    // we sent the whole response
    G_io_apdu_state = APDU_IDLE;
  }
}
c0d02b1a:	b001      	add	sp, #4
c0d02b1c:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d02b1e:	46c0      	nop			; (mov r8, r8)
c0d02b20:	20001d48 	.word	0x20001d48
c0d02b24:	20001f5c 	.word	0x20001f5c
c0d02b28:	20001ea4 	.word	0x20001ea4
c0d02b2c:	20001d40 	.word	0x20001d40
c0d02b30:	20001ea0 	.word	0x20001ea0
c0d02b34:	20001ebc 	.word	0x20001ebc

c0d02b38 <io_usb_hid_send>:

void io_usb_hid_send(io_send_t sndfct, unsigned short sndlength) {
c0d02b38:	b580      	push	{r7, lr}
  // perform send
  if (sndlength) {
c0d02b3a:	2900      	cmp	r1, #0
c0d02b3c:	d00b      	beq.n	c0d02b56 <io_usb_hid_send+0x1e>
    G_io_usb_hid_sequence_number = 0; 
c0d02b3e:	4a06      	ldr	r2, [pc, #24]	; (c0d02b58 <io_usb_hid_send+0x20>)
c0d02b40:	2300      	movs	r3, #0
c0d02b42:	6013      	str	r3, [r2, #0]
    G_io_usb_hid_current_buffer = G_io_apdu_buffer;
c0d02b44:	4a05      	ldr	r2, [pc, #20]	; (c0d02b5c <io_usb_hid_send+0x24>)
c0d02b46:	4b06      	ldr	r3, [pc, #24]	; (c0d02b60 <io_usb_hid_send+0x28>)
c0d02b48:	6013      	str	r3, [r2, #0]
    G_io_usb_hid_remaining_length = sndlength;
c0d02b4a:	4a06      	ldr	r2, [pc, #24]	; (c0d02b64 <io_usb_hid_send+0x2c>)
c0d02b4c:	6011      	str	r1, [r2, #0]
    G_io_usb_hid_total_length = sndlength;
c0d02b4e:	4a06      	ldr	r2, [pc, #24]	; (c0d02b68 <io_usb_hid_send+0x30>)
c0d02b50:	6011      	str	r1, [r2, #0]
    io_usb_hid_sent(sndfct);
c0d02b52:	f7ff ff8f 	bl	c0d02a74 <io_usb_hid_sent>
  }
}
c0d02b56:	bd80      	pop	{r7, pc}
c0d02b58:	20001d40 	.word	0x20001d40
c0d02b5c:	20001ea0 	.word	0x20001ea0
c0d02b60:	20001d4c 	.word	0x20001d4c
c0d02b64:	20001d48 	.word	0x20001d48
c0d02b68:	20001d44 	.word	0x20001d44

c0d02b6c <os_memcmp>:
    DSTCHAR[length] = c;
  }
#undef DSTCHAR
}

char os_memcmp(const void WIDE * buf1, const void WIDE * buf2, unsigned int length) {
c0d02b6c:	b570      	push	{r4, r5, r6, lr}
#define BUF1 ((unsigned char const WIDE *)buf1)
#define BUF2 ((unsigned char const WIDE *)buf2)
  while(length--) {
c0d02b6e:	1e43      	subs	r3, r0, #1
c0d02b70:	1e49      	subs	r1, r1, #1
c0d02b72:	4252      	negs	r2, r2
c0d02b74:	2000      	movs	r0, #0
c0d02b76:	43c4      	mvns	r4, r0
c0d02b78:	2a00      	cmp	r2, #0
c0d02b7a:	d00c      	beq.n	c0d02b96 <os_memcmp+0x2a>
    if (BUF1[length] != BUF2[length]) {
c0d02b7c:	4626      	mov	r6, r4
c0d02b7e:	4356      	muls	r6, r2
c0d02b80:	5d8d      	ldrb	r5, [r1, r6]
c0d02b82:	5d9e      	ldrb	r6, [r3, r6]
c0d02b84:	1c52      	adds	r2, r2, #1
c0d02b86:	42ae      	cmp	r6, r5
c0d02b88:	d0f6      	beq.n	c0d02b78 <os_memcmp+0xc>
      return (BUF1[length] > BUF2[length])? 1:-1;
c0d02b8a:	2000      	movs	r0, #0
c0d02b8c:	43c1      	mvns	r1, r0
c0d02b8e:	2001      	movs	r0, #1
c0d02b90:	42ae      	cmp	r6, r5
c0d02b92:	d800      	bhi.n	c0d02b96 <os_memcmp+0x2a>
c0d02b94:	4608      	mov	r0, r1
  }
  return 0;
#undef BUF1
#undef BUF2

}
c0d02b96:	b2c0      	uxtb	r0, r0
c0d02b98:	bd70      	pop	{r4, r5, r6, pc}

c0d02b9a <os_longjmp>:
void try_context_set(try_context_t* ctx) {
  __asm volatile ("mov r9, %0"::"r"(ctx));
}

#ifndef HAVE_BOLOS
void os_longjmp(unsigned int exception) {
c0d02b9a:	b580      	push	{r7, lr}
c0d02b9c:	4601      	mov	r1, r0
  return xoracc;
}

try_context_t* try_context_get(void) {
  try_context_t* current_ctx;
  __asm volatile ("mov %0, r9":"=r"(current_ctx));
c0d02b9e:	4648      	mov	r0, r9
  __asm volatile ("mov r9, %0"::"r"(ctx));
}

#ifndef HAVE_BOLOS
void os_longjmp(unsigned int exception) {
  longjmp(try_context_get()->jmp_buf, exception);
c0d02ba0:	f004 fa18 	bl	c0d06fd4 <longjmp>

c0d02ba4 <try_context_get>:
  return xoracc;
}

try_context_t* try_context_get(void) {
  try_context_t* current_ctx;
  __asm volatile ("mov %0, r9":"=r"(current_ctx));
c0d02ba4:	4648      	mov	r0, r9
  return current_ctx;
c0d02ba6:	4770      	bx	lr

c0d02ba8 <try_context_get_previous>:
}

try_context_t* try_context_get_previous(void) {
c0d02ba8:	2000      	movs	r0, #0
  try_context_t* current_ctx;
  __asm volatile ("mov %0, r9":"=r"(current_ctx));
c0d02baa:	4649      	mov	r1, r9

  // first context reached ?
  if (current_ctx == NULL) {
c0d02bac:	2900      	cmp	r1, #0
c0d02bae:	d000      	beq.n	c0d02bb2 <try_context_get_previous+0xa>
  }

  // return r9 content saved on the current context. It links to the previous context.
  // r4 r5 r6 r7 r8 r9 r10 r11 sp lr
  //                ^ platform register
  return (try_context_t*) current_ctx->jmp_buf[5];
c0d02bb0:	6948      	ldr	r0, [r1, #20]
}
c0d02bb2:	4770      	bx	lr

c0d02bb4 <io_seproxyhal_general_status>:

#ifndef IO_RAPDU_TRANSMIT_TIMEOUT_MS 
#define IO_RAPDU_TRANSMIT_TIMEOUT_MS 2000UL
#endif // IO_RAPDU_TRANSMIT_TIMEOUT_MS

void io_seproxyhal_general_status(void) {
c0d02bb4:	b580      	push	{r7, lr}
  // avoid troubles
  if (io_seproxyhal_spi_is_status_sent()) {
c0d02bb6:	f001 faa3 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d02bba:	2800      	cmp	r0, #0
c0d02bbc:	d10b      	bne.n	c0d02bd6 <io_seproxyhal_general_status+0x22>
    return;
  }
  // send the general status
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_GENERAL_STATUS;
c0d02bbe:	4806      	ldr	r0, [pc, #24]	; (c0d02bd8 <io_seproxyhal_general_status+0x24>)
c0d02bc0:	2160      	movs	r1, #96	; 0x60
c0d02bc2:	7001      	strb	r1, [r0, #0]
  G_io_seproxyhal_spi_buffer[1] = 0;
c0d02bc4:	2100      	movs	r1, #0
c0d02bc6:	7041      	strb	r1, [r0, #1]
  G_io_seproxyhal_spi_buffer[2] = 2;
c0d02bc8:	2202      	movs	r2, #2
c0d02bca:	7082      	strb	r2, [r0, #2]
  G_io_seproxyhal_spi_buffer[3] = SEPROXYHAL_TAG_GENERAL_STATUS_LAST_COMMAND>>8;
c0d02bcc:	70c1      	strb	r1, [r0, #3]
  G_io_seproxyhal_spi_buffer[4] = SEPROXYHAL_TAG_GENERAL_STATUS_LAST_COMMAND;
c0d02bce:	7101      	strb	r1, [r0, #4]
  io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 5);
c0d02bd0:	2105      	movs	r1, #5
c0d02bd2:	f001 fa7f 	bl	c0d040d4 <io_seproxyhal_spi_send>
}
c0d02bd6:	bd80      	pop	{r7, pc}
c0d02bd8:	20001cc0 	.word	0x20001cc0

c0d02bdc <io_seproxyhal_handle_usb_event>:
} G_io_usb_ep_timeouts[IO_USB_MAX_ENDPOINTS];
#include "usbd_def.h"
#include "usbd_core.h"
extern USBD_HandleTypeDef USBD_Device;

void io_seproxyhal_handle_usb_event(void) {
c0d02bdc:	b510      	push	{r4, lr}
  switch(G_io_seproxyhal_spi_buffer[3]) {
c0d02bde:	4819      	ldr	r0, [pc, #100]	; (c0d02c44 <io_seproxyhal_handle_usb_event+0x68>)
c0d02be0:	78c0      	ldrb	r0, [r0, #3]
c0d02be2:	2803      	cmp	r0, #3
c0d02be4:	dc07      	bgt.n	c0d02bf6 <io_seproxyhal_handle_usb_event+0x1a>
c0d02be6:	2801      	cmp	r0, #1
c0d02be8:	d00d      	beq.n	c0d02c06 <io_seproxyhal_handle_usb_event+0x2a>
c0d02bea:	2802      	cmp	r0, #2
c0d02bec:	d126      	bne.n	c0d02c3c <io_seproxyhal_handle_usb_event+0x60>
      }
      os_memset(G_io_usb_ep_xfer_len, 0, sizeof(G_io_usb_ep_xfer_len));
      os_memset(G_io_usb_ep_timeouts, 0, sizeof(G_io_usb_ep_timeouts));
      break;
    case SEPROXYHAL_TAG_USB_EVENT_SOF:
      USBD_LL_SOF(&USBD_Device);
c0d02bee:	4816      	ldr	r0, [pc, #88]	; (c0d02c48 <io_seproxyhal_handle_usb_event+0x6c>)
c0d02bf0:	f003 fb2a 	bl	c0d06248 <USBD_LL_SOF>
      break;
    case SEPROXYHAL_TAG_USB_EVENT_RESUMED:
      USBD_LL_Resume(&USBD_Device);
      break;
  }
}
c0d02bf4:	bd10      	pop	{r4, pc}
c0d02bf6:	2804      	cmp	r0, #4
c0d02bf8:	d01d      	beq.n	c0d02c36 <io_seproxyhal_handle_usb_event+0x5a>
c0d02bfa:	2808      	cmp	r0, #8
c0d02bfc:	d11e      	bne.n	c0d02c3c <io_seproxyhal_handle_usb_event+0x60>
      break;
    case SEPROXYHAL_TAG_USB_EVENT_SUSPENDED:
      USBD_LL_Suspend(&USBD_Device);
      break;
    case SEPROXYHAL_TAG_USB_EVENT_RESUMED:
      USBD_LL_Resume(&USBD_Device);
c0d02bfe:	4812      	ldr	r0, [pc, #72]	; (c0d02c48 <io_seproxyhal_handle_usb_event+0x6c>)
c0d02c00:	f003 fb20 	bl	c0d06244 <USBD_LL_Resume>
      break;
  }
}
c0d02c04:	bd10      	pop	{r4, pc}
extern USBD_HandleTypeDef USBD_Device;

void io_seproxyhal_handle_usb_event(void) {
  switch(G_io_seproxyhal_spi_buffer[3]) {
    case SEPROXYHAL_TAG_USB_EVENT_RESET:
      USBD_LL_SetSpeed(&USBD_Device, USBD_SPEED_FULL);  
c0d02c06:	4c10      	ldr	r4, [pc, #64]	; (c0d02c48 <io_seproxyhal_handle_usb_event+0x6c>)
c0d02c08:	2101      	movs	r1, #1
c0d02c0a:	4620      	mov	r0, r4
c0d02c0c:	f003 fb15 	bl	c0d0623a <USBD_LL_SetSpeed>
      USBD_LL_Reset(&USBD_Device);
c0d02c10:	4620      	mov	r0, r4
c0d02c12:	f003 faf2 	bl	c0d061fa <USBD_LL_Reset>
      // ongoing APDU detected, throw a reset, even if not the media. to avoid potential troubles.
      if (G_io_apdu_media != IO_APDU_MEDIA_NONE) {
c0d02c16:	480d      	ldr	r0, [pc, #52]	; (c0d02c4c <io_seproxyhal_handle_usb_event+0x70>)
c0d02c18:	7800      	ldrb	r0, [r0, #0]
c0d02c1a:	2800      	cmp	r0, #0
c0d02c1c:	d10f      	bne.n	c0d02c3e <io_seproxyhal_handle_usb_event+0x62>
        THROW(EXCEPTION_IO_RESET);
      }
      os_memset(G_io_usb_ep_xfer_len, 0, sizeof(G_io_usb_ep_xfer_len));
c0d02c1e:	480c      	ldr	r0, [pc, #48]	; (c0d02c50 <io_seproxyhal_handle_usb_event+0x74>)
c0d02c20:	2400      	movs	r4, #0
c0d02c22:	2206      	movs	r2, #6
c0d02c24:	4621      	mov	r1, r4
c0d02c26:	f7ff fefb 	bl	c0d02a20 <os_memset>
      os_memset(G_io_usb_ep_timeouts, 0, sizeof(G_io_usb_ep_timeouts));
c0d02c2a:	480a      	ldr	r0, [pc, #40]	; (c0d02c54 <io_seproxyhal_handle_usb_event+0x78>)
c0d02c2c:	220c      	movs	r2, #12
c0d02c2e:	4621      	mov	r1, r4
c0d02c30:	f7ff fef6 	bl	c0d02a20 <os_memset>
      break;
    case SEPROXYHAL_TAG_USB_EVENT_RESUMED:
      USBD_LL_Resume(&USBD_Device);
      break;
  }
}
c0d02c34:	bd10      	pop	{r4, pc}
      break;
    case SEPROXYHAL_TAG_USB_EVENT_SOF:
      USBD_LL_SOF(&USBD_Device);
      break;
    case SEPROXYHAL_TAG_USB_EVENT_SUSPENDED:
      USBD_LL_Suspend(&USBD_Device);
c0d02c36:	4804      	ldr	r0, [pc, #16]	; (c0d02c48 <io_seproxyhal_handle_usb_event+0x6c>)
c0d02c38:	f003 fb02 	bl	c0d06240 <USBD_LL_Suspend>
      break;
    case SEPROXYHAL_TAG_USB_EVENT_RESUMED:
      USBD_LL_Resume(&USBD_Device);
      break;
  }
}
c0d02c3c:	bd10      	pop	{r4, pc}
    case SEPROXYHAL_TAG_USB_EVENT_RESET:
      USBD_LL_SetSpeed(&USBD_Device, USBD_SPEED_FULL);  
      USBD_LL_Reset(&USBD_Device);
      // ongoing APDU detected, throw a reset, even if not the media. to avoid potential troubles.
      if (G_io_apdu_media != IO_APDU_MEDIA_NONE) {
        THROW(EXCEPTION_IO_RESET);
c0d02c3e:	2010      	movs	r0, #16
c0d02c40:	f7ff ffab 	bl	c0d02b9a <os_longjmp>
c0d02c44:	20001cc0 	.word	0x20001cc0
c0d02c48:	20001fa4 	.word	0x20001fa4
c0d02c4c:	20001ea8 	.word	0x20001ea8
c0d02c50:	20001ea9 	.word	0x20001ea9
c0d02c54:	20001eb0 	.word	0x20001eb0

c0d02c58 <io_seproxyhal_get_ep_rx_size>:
      break;
  }
}

uint16_t io_seproxyhal_get_ep_rx_size(uint8_t epnum) {
  return G_io_usb_ep_xfer_len[epnum&0x7F];
c0d02c58:	217f      	movs	r1, #127	; 0x7f
c0d02c5a:	4001      	ands	r1, r0
c0d02c5c:	4801      	ldr	r0, [pc, #4]	; (c0d02c64 <io_seproxyhal_get_ep_rx_size+0xc>)
c0d02c5e:	5c40      	ldrb	r0, [r0, r1]
c0d02c60:	4770      	bx	lr
c0d02c62:	46c0      	nop			; (mov r8, r8)
c0d02c64:	20001ea9 	.word	0x20001ea9

c0d02c68 <io_seproxyhal_handle_usb_ep_xfer_event>:
}

void io_seproxyhal_handle_usb_ep_xfer_event(void) {
c0d02c68:	b510      	push	{r4, lr}
  switch(G_io_seproxyhal_spi_buffer[4]) {
c0d02c6a:	4815      	ldr	r0, [pc, #84]	; (c0d02cc0 <io_seproxyhal_handle_usb_ep_xfer_event+0x58>)
c0d02c6c:	7901      	ldrb	r1, [r0, #4]
c0d02c6e:	2904      	cmp	r1, #4
c0d02c70:	d017      	beq.n	c0d02ca2 <io_seproxyhal_handle_usb_ep_xfer_event+0x3a>
c0d02c72:	2902      	cmp	r1, #2
c0d02c74:	d006      	beq.n	c0d02c84 <io_seproxyhal_handle_usb_ep_xfer_event+0x1c>
c0d02c76:	2901      	cmp	r1, #1
c0d02c78:	d120      	bne.n	c0d02cbc <io_seproxyhal_handle_usb_ep_xfer_event+0x54>
    /* This event is received when a new SETUP token had been received on a control endpoint */
    case SEPROXYHAL_TAG_USB_EP_XFER_SETUP:
      // assume length of setup packet, and that it is on endpoint 0
      USBD_LL_SetupStage(&USBD_Device, &G_io_seproxyhal_spi_buffer[6]);
c0d02c7a:	1d81      	adds	r1, r0, #6
c0d02c7c:	4812      	ldr	r0, [pc, #72]	; (c0d02cc8 <io_seproxyhal_handle_usb_ep_xfer_event+0x60>)
c0d02c7e:	f003 f9be 	bl	c0d05ffe <USBD_LL_SetupStage>
        // prepare reception
        USBD_LL_DataOutStage(&USBD_Device, G_io_seproxyhal_spi_buffer[3]&0x7F, &G_io_seproxyhal_spi_buffer[6]);
      }
      break;
  }
}
c0d02c82:	bd10      	pop	{r4, pc}
      USBD_LL_SetupStage(&USBD_Device, &G_io_seproxyhal_spi_buffer[6]);
      break;

    /* This event is received after the prepare data packet has been flushed to the usb host */
    case SEPROXYHAL_TAG_USB_EP_XFER_IN:
      if ((G_io_seproxyhal_spi_buffer[3]&0x7F) < IO_USB_MAX_ENDPOINTS) {
c0d02c84:	78c2      	ldrb	r2, [r0, #3]
c0d02c86:	217f      	movs	r1, #127	; 0x7f
c0d02c88:	4011      	ands	r1, r2
c0d02c8a:	2905      	cmp	r1, #5
c0d02c8c:	d816      	bhi.n	c0d02cbc <io_seproxyhal_handle_usb_ep_xfer_event+0x54>
c0d02c8e:	b2c9      	uxtb	r1, r1
        // discard ep timeout as we received the sent packet confirmation
        G_io_usb_ep_timeouts[G_io_seproxyhal_spi_buffer[3]&0x7F].timeout = 0;
c0d02c90:	004a      	lsls	r2, r1, #1
c0d02c92:	4b0e      	ldr	r3, [pc, #56]	; (c0d02ccc <io_seproxyhal_handle_usb_ep_xfer_event+0x64>)
c0d02c94:	2400      	movs	r4, #0
c0d02c96:	529c      	strh	r4, [r3, r2]
        // propagate sending ack of the data
        USBD_LL_DataInStage(&USBD_Device, G_io_seproxyhal_spi_buffer[3]&0x7F, &G_io_seproxyhal_spi_buffer[6]);
c0d02c98:	1d82      	adds	r2, r0, #6
c0d02c9a:	480b      	ldr	r0, [pc, #44]	; (c0d02cc8 <io_seproxyhal_handle_usb_ep_xfer_event+0x60>)
c0d02c9c:	f003 fa37 	bl	c0d0610e <USBD_LL_DataInStage>
        // prepare reception
        USBD_LL_DataOutStage(&USBD_Device, G_io_seproxyhal_spi_buffer[3]&0x7F, &G_io_seproxyhal_spi_buffer[6]);
      }
      break;
  }
}
c0d02ca0:	bd10      	pop	{r4, pc}
      }
      break;

    /* This event is received when a new DATA token is received on an endpoint */
    case SEPROXYHAL_TAG_USB_EP_XFER_OUT:
      if ((G_io_seproxyhal_spi_buffer[3]&0x7F) < IO_USB_MAX_ENDPOINTS) {
c0d02ca2:	78c2      	ldrb	r2, [r0, #3]
c0d02ca4:	217f      	movs	r1, #127	; 0x7f
c0d02ca6:	4011      	ands	r1, r2
c0d02ca8:	2905      	cmp	r1, #5
c0d02caa:	d807      	bhi.n	c0d02cbc <io_seproxyhal_handle_usb_ep_xfer_event+0x54>
        // saved just in case it is needed ...
        G_io_usb_ep_xfer_len[G_io_seproxyhal_spi_buffer[3]&0x7F] = G_io_seproxyhal_spi_buffer[5];
c0d02cac:	7942      	ldrb	r2, [r0, #5]
      }
      break;

    /* This event is received when a new DATA token is received on an endpoint */
    case SEPROXYHAL_TAG_USB_EP_XFER_OUT:
      if ((G_io_seproxyhal_spi_buffer[3]&0x7F) < IO_USB_MAX_ENDPOINTS) {
c0d02cae:	b2c9      	uxtb	r1, r1
        // saved just in case it is needed ...
        G_io_usb_ep_xfer_len[G_io_seproxyhal_spi_buffer[3]&0x7F] = G_io_seproxyhal_spi_buffer[5];
c0d02cb0:	4b04      	ldr	r3, [pc, #16]	; (c0d02cc4 <io_seproxyhal_handle_usb_ep_xfer_event+0x5c>)
c0d02cb2:	545a      	strb	r2, [r3, r1]
        // prepare reception
        USBD_LL_DataOutStage(&USBD_Device, G_io_seproxyhal_spi_buffer[3]&0x7F, &G_io_seproxyhal_spi_buffer[6]);
c0d02cb4:	1d82      	adds	r2, r0, #6
c0d02cb6:	4804      	ldr	r0, [pc, #16]	; (c0d02cc8 <io_seproxyhal_handle_usb_ep_xfer_event+0x60>)
c0d02cb8:	f003 f9cf 	bl	c0d0605a <USBD_LL_DataOutStage>
      }
      break;
  }
}
c0d02cbc:	bd10      	pop	{r4, pc}
c0d02cbe:	46c0      	nop			; (mov r8, r8)
c0d02cc0:	20001cc0 	.word	0x20001cc0
c0d02cc4:	20001ea9 	.word	0x20001ea9
c0d02cc8:	20001fa4 	.word	0x20001fa4
c0d02ccc:	20001eb0 	.word	0x20001eb0

c0d02cd0 <io_usb_send_ep>:
#endif // HAVE_L4_USBLIB

// TODO, refactor this using the USB DataIn event like for the U2F tunnel
// TODO add a blocking parameter, for HID KBD sending, or use a USB busy flag per channel to know if 
// the transfer has been processed or not. and move on to the next transfer on the same endpoint
void io_usb_send_ep(unsigned int ep, unsigned char* buffer, unsigned short length, unsigned int timeout) {
c0d02cd0:	b570      	push	{r4, r5, r6, lr}
c0d02cd2:	4615      	mov	r5, r2
c0d02cd4:	460e      	mov	r6, r1
c0d02cd6:	4604      	mov	r4, r0
  if (timeout) {
    timeout++;
  }

  // won't send if overflowing seproxyhal buffer format
  if (length > 255) {
c0d02cd8:	2dff      	cmp	r5, #255	; 0xff
c0d02cda:	d81a      	bhi.n	c0d02d12 <io_usb_send_ep+0x42>
    return;
  }
  
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0d02cdc:	480d      	ldr	r0, [pc, #52]	; (c0d02d14 <io_usb_send_ep+0x44>)
c0d02cde:	2150      	movs	r1, #80	; 0x50
c0d02ce0:	7001      	strb	r1, [r0, #0]
  G_io_seproxyhal_spi_buffer[1] = (3+length)>>8;
c0d02ce2:	1ce9      	adds	r1, r5, #3
c0d02ce4:	0a0a      	lsrs	r2, r1, #8
c0d02ce6:	7042      	strb	r2, [r0, #1]
  G_io_seproxyhal_spi_buffer[2] = (3+length);
c0d02ce8:	7081      	strb	r1, [r0, #2]
  G_io_seproxyhal_spi_buffer[3] = ep|0x80;
c0d02cea:	2180      	movs	r1, #128	; 0x80
c0d02cec:	4321      	orrs	r1, r4
c0d02cee:	70c1      	strb	r1, [r0, #3]
  G_io_seproxyhal_spi_buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN;
c0d02cf0:	2120      	movs	r1, #32
c0d02cf2:	7101      	strb	r1, [r0, #4]
  G_io_seproxyhal_spi_buffer[5] = length;
c0d02cf4:	7145      	strb	r5, [r0, #5]
  io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 6);
c0d02cf6:	2106      	movs	r1, #6
c0d02cf8:	f001 f9ec 	bl	c0d040d4 <io_seproxyhal_spi_send>
  io_seproxyhal_spi_send(buffer, length);
c0d02cfc:	4630      	mov	r0, r6
c0d02cfe:	4629      	mov	r1, r5
c0d02d00:	f001 f9e8 	bl	c0d040d4 <io_seproxyhal_spi_send>
  // setup timeout of the endpoint
  G_io_usb_ep_timeouts[ep&0x7F].timeout = IO_RAPDU_TRANSMIT_TIMEOUT_MS;
c0d02d04:	207f      	movs	r0, #127	; 0x7f
c0d02d06:	4020      	ands	r0, r4
c0d02d08:	0040      	lsls	r0, r0, #1
c0d02d0a:	217d      	movs	r1, #125	; 0x7d
c0d02d0c:	0109      	lsls	r1, r1, #4
c0d02d0e:	4a02      	ldr	r2, [pc, #8]	; (c0d02d18 <io_usb_send_ep+0x48>)
c0d02d10:	5211      	strh	r1, [r2, r0]

}
c0d02d12:	bd70      	pop	{r4, r5, r6, pc}
c0d02d14:	20001cc0 	.word	0x20001cc0
c0d02d18:	20001eb0 	.word	0x20001eb0

c0d02d1c <io_usb_send_apdu_data>:

void io_usb_send_apdu_data(unsigned char* buffer, unsigned short length) {
c0d02d1c:	b580      	push	{r7, lr}
c0d02d1e:	460a      	mov	r2, r1
c0d02d20:	4601      	mov	r1, r0
  // wait for 20 events before hanging up and timeout (~2 seconds of timeout)
  io_usb_send_ep(0x82, buffer, length, 20);
c0d02d22:	2082      	movs	r0, #130	; 0x82
c0d02d24:	2314      	movs	r3, #20
c0d02d26:	f7ff ffd3 	bl	c0d02cd0 <io_usb_send_ep>
}
c0d02d2a:	bd80      	pop	{r7, pc}

c0d02d2c <io_usb_send_apdu_data_ep0x83>:

#ifdef HAVE_WEBUSB
void io_usb_send_apdu_data_ep0x83(unsigned char* buffer, unsigned short length) {
c0d02d2c:	b580      	push	{r7, lr}
c0d02d2e:	460a      	mov	r2, r1
c0d02d30:	4601      	mov	r1, r0
  // wait for 20 events before hanging up and timeout (~2 seconds of timeout)
  io_usb_send_ep(0x83, buffer, length, 20);
c0d02d32:	2083      	movs	r0, #131	; 0x83
c0d02d34:	2314      	movs	r3, #20
c0d02d36:	f7ff ffcb 	bl	c0d02cd0 <io_usb_send_ep>
}
c0d02d3a:	bd80      	pop	{r7, pc}

c0d02d3c <io_seproxyhal_handle_capdu_event>:

}
#endif


void io_seproxyhal_handle_capdu_event(void) {
c0d02d3c:	b580      	push	{r7, lr}
  if(G_io_apdu_state == APDU_IDLE) 
c0d02d3e:	480d      	ldr	r0, [pc, #52]	; (c0d02d74 <io_seproxyhal_handle_capdu_event+0x38>)
c0d02d40:	7801      	ldrb	r1, [r0, #0]
c0d02d42:	2900      	cmp	r1, #0
c0d02d44:	d115      	bne.n	c0d02d72 <io_seproxyhal_handle_capdu_event+0x36>
  {
    G_io_apdu_media = IO_APDU_MEDIA_RAW; // for application code
c0d02d46:	490c      	ldr	r1, [pc, #48]	; (c0d02d78 <io_seproxyhal_handle_capdu_event+0x3c>)
c0d02d48:	2206      	movs	r2, #6
c0d02d4a:	700a      	strb	r2, [r1, #0]
    G_io_apdu_state = APDU_RAW; // for next call to io_exchange
c0d02d4c:	210a      	movs	r1, #10
c0d02d4e:	7001      	strb	r1, [r0, #0]
    G_io_apdu_length = MIN(U2BE(G_io_seproxyhal_spi_buffer, 1), sizeof(G_io_apdu_buffer)); 
c0d02d50:	480a      	ldr	r0, [pc, #40]	; (c0d02d7c <io_seproxyhal_handle_capdu_event+0x40>)
c0d02d52:	7882      	ldrb	r2, [r0, #2]
c0d02d54:	7841      	ldrb	r1, [r0, #1]
c0d02d56:	0209      	lsls	r1, r1, #8
c0d02d58:	4311      	orrs	r1, r2
c0d02d5a:	22ff      	movs	r2, #255	; 0xff
c0d02d5c:	3252      	adds	r2, #82	; 0x52
c0d02d5e:	4291      	cmp	r1, r2
c0d02d60:	d300      	bcc.n	c0d02d64 <io_seproxyhal_handle_capdu_event+0x28>
c0d02d62:	4611      	mov	r1, r2
c0d02d64:	4a06      	ldr	r2, [pc, #24]	; (c0d02d80 <io_seproxyhal_handle_capdu_event+0x44>)
c0d02d66:	8011      	strh	r1, [r2, #0]
    // copy apdu to apdu buffer
    os_memmove(G_io_apdu_buffer, G_io_seproxyhal_spi_buffer+3, G_io_apdu_length);
c0d02d68:	8812      	ldrh	r2, [r2, #0]
c0d02d6a:	1cc1      	adds	r1, r0, #3
c0d02d6c:	4805      	ldr	r0, [pc, #20]	; (c0d02d84 <io_seproxyhal_handle_capdu_event+0x48>)
c0d02d6e:	f7ff fe60 	bl	c0d02a32 <os_memmove>
  }
}
c0d02d72:	bd80      	pop	{r7, pc}
c0d02d74:	20001ebc 	.word	0x20001ebc
c0d02d78:	20001ea8 	.word	0x20001ea8
c0d02d7c:	20001cc0 	.word	0x20001cc0
c0d02d80:	20001ebe 	.word	0x20001ebe
c0d02d84:	20001d4c 	.word	0x20001d4c

c0d02d88 <io_seproxyhal_handle_event>:

unsigned int io_seproxyhal_handle_event(void) {
c0d02d88:	b5b0      	push	{r4, r5, r7, lr}
  unsigned int rx_len = U2BE(G_io_seproxyhal_spi_buffer, 1);
c0d02d8a:	481e      	ldr	r0, [pc, #120]	; (c0d02e04 <io_seproxyhal_handle_event+0x7c>)
c0d02d8c:	7882      	ldrb	r2, [r0, #2]
c0d02d8e:	7841      	ldrb	r1, [r0, #1]
c0d02d90:	0209      	lsls	r1, r1, #8
c0d02d92:	4311      	orrs	r1, r2
c0d02d94:	7800      	ldrb	r0, [r0, #0]

  switch(G_io_seproxyhal_spi_buffer[0]) {
c0d02d96:	280f      	cmp	r0, #15
c0d02d98:	dc09      	bgt.n	c0d02dae <io_seproxyhal_handle_event+0x26>
c0d02d9a:	280e      	cmp	r0, #14
c0d02d9c:	d00e      	beq.n	c0d02dbc <io_seproxyhal_handle_event+0x34>
c0d02d9e:	280f      	cmp	r0, #15
c0d02da0:	d11f      	bne.n	c0d02de2 <io_seproxyhal_handle_event+0x5a>
c0d02da2:	2000      	movs	r0, #0
  #ifdef HAVE_IO_USB
    case SEPROXYHAL_TAG_USB_EVENT:
      if (rx_len != 1) {
c0d02da4:	2901      	cmp	r1, #1
c0d02da6:	d126      	bne.n	c0d02df6 <io_seproxyhal_handle_event+0x6e>
        return 0;
      }
      io_seproxyhal_handle_usb_event();
c0d02da8:	f7ff ff18 	bl	c0d02bdc <io_seproxyhal_handle_usb_event>
c0d02dac:	e022      	b.n	c0d02df4 <io_seproxyhal_handle_event+0x6c>
c0d02dae:	2810      	cmp	r0, #16
c0d02db0:	d01b      	beq.n	c0d02dea <io_seproxyhal_handle_event+0x62>
c0d02db2:	2816      	cmp	r0, #22
c0d02db4:	d115      	bne.n	c0d02de2 <io_seproxyhal_handle_event+0x5a>
      }
      return 1;
  #endif // HAVE_BLE

    case SEPROXYHAL_TAG_CAPDU_EVENT:
      io_seproxyhal_handle_capdu_event();
c0d02db6:	f7ff ffc1 	bl	c0d02d3c <io_seproxyhal_handle_capdu_event>
c0d02dba:	e01b      	b.n	c0d02df4 <io_seproxyhal_handle_event+0x6c>
c0d02dbc:	2000      	movs	r0, #0
c0d02dbe:	4912      	ldr	r1, [pc, #72]	; (c0d02e08 <io_seproxyhal_handle_event+0x80>)
      // process ticker events to timeout the IO transfers, and forward to the user io_event function too
#ifdef HAVE_IO_USB
      {
        unsigned int i = IO_USB_MAX_ENDPOINTS;
        while(i--) {
          if (G_io_usb_ep_timeouts[i].timeout) {
c0d02dc0:	1a0a      	subs	r2, r1, r0
c0d02dc2:	8953      	ldrh	r3, [r2, #10]
c0d02dc4:	2b00      	cmp	r3, #0
c0d02dc6:	d009      	beq.n	c0d02ddc <io_seproxyhal_handle_event+0x54>
            G_io_usb_ep_timeouts[i].timeout-=MIN(G_io_usb_ep_timeouts[i].timeout, 100);
c0d02dc8:	2464      	movs	r4, #100	; 0x64
c0d02dca:	2b64      	cmp	r3, #100	; 0x64
c0d02dcc:	461d      	mov	r5, r3
c0d02dce:	d300      	bcc.n	c0d02dd2 <io_seproxyhal_handle_event+0x4a>
c0d02dd0:	4625      	mov	r5, r4
c0d02dd2:	1b5b      	subs	r3, r3, r5
c0d02dd4:	8153      	strh	r3, [r2, #10]
c0d02dd6:	4a0d      	ldr	r2, [pc, #52]	; (c0d02e0c <io_seproxyhal_handle_event+0x84>)
            if (!G_io_usb_ep_timeouts[i].timeout) {
c0d02dd8:	4213      	tst	r3, r2
c0d02dda:	d00d      	beq.n	c0d02df8 <io_seproxyhal_handle_event+0x70>
    case SEPROXYHAL_TAG_TICKER_EVENT:
      // process ticker events to timeout the IO transfers, and forward to the user io_event function too
#ifdef HAVE_IO_USB
      {
        unsigned int i = IO_USB_MAX_ENDPOINTS;
        while(i--) {
c0d02ddc:	1c80      	adds	r0, r0, #2
c0d02dde:	280c      	cmp	r0, #12
c0d02de0:	d1ee      	bne.n	c0d02dc0 <io_seproxyhal_handle_event+0x38>
        }
      }
#endif // HAVE_IO_USB
      // no break is intentional
    default:
      return io_event(CHANNEL_SPI);
c0d02de2:	2002      	movs	r0, #2
c0d02de4:	f7ff fa76 	bl	c0d022d4 <io_event>
  }
  // defaultly return as not processed
  return 0;
}
c0d02de8:	bdb0      	pop	{r4, r5, r7, pc}
c0d02dea:	2000      	movs	r0, #0
      }
      io_seproxyhal_handle_usb_event();
      return 1;

    case SEPROXYHAL_TAG_USB_EP_XFER_EVENT:
      if (rx_len < 3) {
c0d02dec:	2903      	cmp	r1, #3
c0d02dee:	d302      	bcc.n	c0d02df6 <io_seproxyhal_handle_event+0x6e>
        // error !
        return 0;
      }
      io_seproxyhal_handle_usb_ep_xfer_event();
c0d02df0:	f7ff ff3a 	bl	c0d02c68 <io_seproxyhal_handle_usb_ep_xfer_event>
c0d02df4:	2001      	movs	r0, #1
    default:
      return io_event(CHANNEL_SPI);
  }
  // defaultly return as not processed
  return 0;
}
c0d02df6:	bdb0      	pop	{r4, r5, r7, pc}
        while(i--) {
          if (G_io_usb_ep_timeouts[i].timeout) {
            G_io_usb_ep_timeouts[i].timeout-=MIN(G_io_usb_ep_timeouts[i].timeout, 100);
            if (!G_io_usb_ep_timeouts[i].timeout) {
              // timeout !
              G_io_apdu_state = APDU_IDLE;
c0d02df8:	4805      	ldr	r0, [pc, #20]	; (c0d02e10 <io_seproxyhal_handle_event+0x88>)
c0d02dfa:	2100      	movs	r1, #0
c0d02dfc:	7001      	strb	r1, [r0, #0]
              THROW(EXCEPTION_IO_RESET);
c0d02dfe:	2010      	movs	r0, #16
c0d02e00:	f7ff fecb 	bl	c0d02b9a <os_longjmp>
c0d02e04:	20001cc0 	.word	0x20001cc0
c0d02e08:	20001eb0 	.word	0x20001eb0
c0d02e0c:	0000ffff 	.word	0x0000ffff
c0d02e10:	20001ebc 	.word	0x20001ebc

c0d02e14 <io_seproxyhal_init>:
#ifdef HAVE_BOLOS_APP_STACK_CANARY
#define APP_STACK_CANARY_MAGIC 0xDEAD0031
extern unsigned int app_stack_canary;
#endif // HAVE_BOLOS_APP_STACK_CANARY

void io_seproxyhal_init(void) {
c0d02e14:	b510      	push	{r4, lr}
  // Enforce OS compatibility
  check_api_level(CX_COMPAT_APILEVEL);
c0d02e16:	2009      	movs	r0, #9
c0d02e18:	f000 ff7c 	bl	c0d03d14 <check_api_level>

#ifdef HAVE_BOLOS_APP_STACK_CANARY
  app_stack_canary = APP_STACK_CANARY_MAGIC;
#endif // HAVE_BOLOS_APP_STACK_CANARY  

  G_io_apdu_state = APDU_IDLE;
c0d02e1c:	4807      	ldr	r0, [pc, #28]	; (c0d02e3c <io_seproxyhal_init+0x28>)
c0d02e1e:	2400      	movs	r4, #0
c0d02e20:	7004      	strb	r4, [r0, #0]
  G_io_apdu_length = 0;
c0d02e22:	4807      	ldr	r0, [pc, #28]	; (c0d02e40 <io_seproxyhal_init+0x2c>)
c0d02e24:	8004      	strh	r4, [r0, #0]
  G_io_apdu_media = IO_APDU_MEDIA_NONE;
c0d02e26:	4807      	ldr	r0, [pc, #28]	; (c0d02e44 <io_seproxyhal_init+0x30>)
c0d02e28:	7004      	strb	r4, [r0, #0]
  debug_apdus_offset = 0;
  #endif // DEBUG_APDU


  #ifdef HAVE_USB_APDU
  io_usb_hid_init();
c0d02e2a:	f7ff fe1d 	bl	c0d02a68 <io_usb_hid_init>
  io_seproxyhal_init_button();
}

void io_seproxyhal_init_ux(void) {
  // initialize the touch part
  G_bagl_last_touched_not_released_component = NULL;
c0d02e2e:	4806      	ldr	r0, [pc, #24]	; (c0d02e48 <io_seproxyhal_init+0x34>)
c0d02e30:	6004      	str	r4, [r0, #0]
}

void io_seproxyhal_init_button(void) {
  // no button push so far
  G_button_mask = 0;
c0d02e32:	4806      	ldr	r0, [pc, #24]	; (c0d02e4c <io_seproxyhal_init+0x38>)
c0d02e34:	6004      	str	r4, [r0, #0]
  G_button_same_mask_counter = 0;
c0d02e36:	4806      	ldr	r0, [pc, #24]	; (c0d02e50 <io_seproxyhal_init+0x3c>)
c0d02e38:	6004      	str	r4, [r0, #0]
  io_usb_hid_init();
  #endif // HAVE_USB_APDU

  io_seproxyhal_init_ux();
  io_seproxyhal_init_button();
}
c0d02e3a:	bd10      	pop	{r4, pc}
c0d02e3c:	20001ebc 	.word	0x20001ebc
c0d02e40:	20001ebe 	.word	0x20001ebe
c0d02e44:	20001ea8 	.word	0x20001ea8
c0d02e48:	20001ec0 	.word	0x20001ec0
c0d02e4c:	20001ec4 	.word	0x20001ec4
c0d02e50:	20001ec8 	.word	0x20001ec8

c0d02e54 <io_seproxyhal_init_ux>:

void io_seproxyhal_init_ux(void) {
  // initialize the touch part
  G_bagl_last_touched_not_released_component = NULL;
c0d02e54:	4801      	ldr	r0, [pc, #4]	; (c0d02e5c <io_seproxyhal_init_ux+0x8>)
c0d02e56:	2100      	movs	r1, #0
c0d02e58:	6001      	str	r1, [r0, #0]
}
c0d02e5a:	4770      	bx	lr
c0d02e5c:	20001ec0 	.word	0x20001ec0

c0d02e60 <io_seproxyhal_init_button>:

void io_seproxyhal_init_button(void) {
  // no button push so far
  G_button_mask = 0;
c0d02e60:	4802      	ldr	r0, [pc, #8]	; (c0d02e6c <io_seproxyhal_init_button+0xc>)
c0d02e62:	2100      	movs	r1, #0
c0d02e64:	6001      	str	r1, [r0, #0]
  G_button_same_mask_counter = 0;
c0d02e66:	4802      	ldr	r0, [pc, #8]	; (c0d02e70 <io_seproxyhal_init_button+0x10>)
c0d02e68:	6001      	str	r1, [r0, #0]
}
c0d02e6a:	4770      	bx	lr
c0d02e6c:	20001ec4 	.word	0x20001ec4
c0d02e70:	20001ec8 	.word	0x20001ec8

c0d02e74 <io_seproxyhal_touch_out>:

#ifdef HAVE_BAGL

unsigned int io_seproxyhal_touch_out(const bagl_element_t* element, bagl_element_callback_t before_display) {
c0d02e74:	b5b0      	push	{r4, r5, r7, lr}
c0d02e76:	460d      	mov	r5, r1
c0d02e78:	4604      	mov	r4, r0
  const bagl_element_t* el;
  if (element->out != NULL) {
c0d02e7a:	6b20      	ldr	r0, [r4, #48]	; 0x30
c0d02e7c:	2800      	cmp	r0, #0
c0d02e7e:	d00c      	beq.n	c0d02e9a <io_seproxyhal_touch_out+0x26>
    el = (const bagl_element_t*)PIC(((bagl_element_callback_t)PIC(element->out))(element));
c0d02e80:	f000 ff30 	bl	c0d03ce4 <pic>
c0d02e84:	4601      	mov	r1, r0
c0d02e86:	4620      	mov	r0, r4
c0d02e88:	4788      	blx	r1
c0d02e8a:	f000 ff2b 	bl	c0d03ce4 <pic>
c0d02e8e:	2100      	movs	r1, #0
    // backward compatible with samples and such
    if (! el) {
c0d02e90:	2800      	cmp	r0, #0
c0d02e92:	d010      	beq.n	c0d02eb6 <io_seproxyhal_touch_out+0x42>
c0d02e94:	2801      	cmp	r0, #1
c0d02e96:	d000      	beq.n	c0d02e9a <io_seproxyhal_touch_out+0x26>
c0d02e98:	4604      	mov	r4, r0
      element = el;
    }
  }

  // out function might have triggered a draw of its own during a display callback
  if (before_display) {
c0d02e9a:	2d00      	cmp	r5, #0
c0d02e9c:	d007      	beq.n	c0d02eae <io_seproxyhal_touch_out+0x3a>
    el = before_display(element);
c0d02e9e:	4620      	mov	r0, r4
c0d02ea0:	47a8      	blx	r5
c0d02ea2:	2100      	movs	r1, #0
    if (!el) {
c0d02ea4:	2800      	cmp	r0, #0
c0d02ea6:	d006      	beq.n	c0d02eb6 <io_seproxyhal_touch_out+0x42>
c0d02ea8:	2801      	cmp	r0, #1
c0d02eaa:	d000      	beq.n	c0d02eae <io_seproxyhal_touch_out+0x3a>
c0d02eac:	4604      	mov	r4, r0
    if ((unsigned int)el != 1) {
      element = el;
    }
  }

  io_seproxyhal_display(element);
c0d02eae:	4620      	mov	r0, r4
c0d02eb0:	f7fe fdb6 	bl	c0d01a20 <io_seproxyhal_display>
c0d02eb4:	2101      	movs	r1, #1
  return 1;
}
c0d02eb6:	4608      	mov	r0, r1
c0d02eb8:	bdb0      	pop	{r4, r5, r7, pc}

c0d02eba <io_seproxyhal_touch_over>:

unsigned int io_seproxyhal_touch_over(const bagl_element_t* element, bagl_element_callback_t before_display) {
c0d02eba:	b5b0      	push	{r4, r5, r7, lr}
c0d02ebc:	b08e      	sub	sp, #56	; 0x38
c0d02ebe:	460d      	mov	r5, r1
c0d02ec0:	4604      	mov	r4, r0
  bagl_element_t e;
  const bagl_element_t* el;
  if (element->over != NULL) {
c0d02ec2:	6b60      	ldr	r0, [r4, #52]	; 0x34
c0d02ec4:	2800      	cmp	r0, #0
c0d02ec6:	d00c      	beq.n	c0d02ee2 <io_seproxyhal_touch_over+0x28>
    el = (const bagl_element_t*)PIC(((bagl_element_callback_t)PIC(element->over))(element));
c0d02ec8:	f000 ff0c 	bl	c0d03ce4 <pic>
c0d02ecc:	4601      	mov	r1, r0
c0d02ece:	4620      	mov	r0, r4
c0d02ed0:	4788      	blx	r1
c0d02ed2:	f000 ff07 	bl	c0d03ce4 <pic>
c0d02ed6:	2100      	movs	r1, #0
    // backward compatible with samples and such
    if (!el) {
c0d02ed8:	2800      	cmp	r0, #0
c0d02eda:	d01b      	beq.n	c0d02f14 <io_seproxyhal_touch_over+0x5a>
c0d02edc:	2801      	cmp	r0, #1
c0d02ede:	d000      	beq.n	c0d02ee2 <io_seproxyhal_touch_over+0x28>
c0d02ee0:	4604      	mov	r4, r0
      element = el;
    }
  }

  // over function might have triggered a draw of its own during a display callback
  if (before_display) {
c0d02ee2:	2d00      	cmp	r5, #0
c0d02ee4:	d008      	beq.n	c0d02ef8 <io_seproxyhal_touch_over+0x3e>
    el = before_display(element);
c0d02ee6:	4620      	mov	r0, r4
c0d02ee8:	47a8      	blx	r5
c0d02eea:	466c      	mov	r4, sp
c0d02eec:	2100      	movs	r1, #0
    element = &e;
    if (!el) {
c0d02eee:	2800      	cmp	r0, #0
c0d02ef0:	d010      	beq.n	c0d02f14 <io_seproxyhal_touch_over+0x5a>
c0d02ef2:	2801      	cmp	r0, #1
c0d02ef4:	d000      	beq.n	c0d02ef8 <io_seproxyhal_touch_over+0x3e>
c0d02ef6:	4604      	mov	r4, r0
c0d02ef8:	466d      	mov	r5, sp
      element = el;
    }
  }

  // swap colors
  os_memmove(&e, (void*)element, sizeof(bagl_element_t));
c0d02efa:	2238      	movs	r2, #56	; 0x38
c0d02efc:	4628      	mov	r0, r5
c0d02efe:	4621      	mov	r1, r4
c0d02f00:	f7ff fd97 	bl	c0d02a32 <os_memmove>
  e.component.fgcolor = element->overfgcolor;
c0d02f04:	6a60      	ldr	r0, [r4, #36]	; 0x24
c0d02f06:	9004      	str	r0, [sp, #16]
  e.component.bgcolor = element->overbgcolor;
c0d02f08:	6aa0      	ldr	r0, [r4, #40]	; 0x28
c0d02f0a:	9005      	str	r0, [sp, #20]

  io_seproxyhal_display(&e);
c0d02f0c:	4628      	mov	r0, r5
c0d02f0e:	f7fe fd87 	bl	c0d01a20 <io_seproxyhal_display>
c0d02f12:	2101      	movs	r1, #1
  return 1;
}
c0d02f14:	4608      	mov	r0, r1
c0d02f16:	b00e      	add	sp, #56	; 0x38
c0d02f18:	bdb0      	pop	{r4, r5, r7, pc}

c0d02f1a <io_seproxyhal_touch_tap>:

unsigned int io_seproxyhal_touch_tap(const bagl_element_t* element, bagl_element_callback_t before_display) {
c0d02f1a:	b5b0      	push	{r4, r5, r7, lr}
c0d02f1c:	460d      	mov	r5, r1
c0d02f1e:	4604      	mov	r4, r0
  const bagl_element_t* el;
  if (element->tap != NULL) {
c0d02f20:	6ae0      	ldr	r0, [r4, #44]	; 0x2c
c0d02f22:	2800      	cmp	r0, #0
c0d02f24:	d00c      	beq.n	c0d02f40 <io_seproxyhal_touch_tap+0x26>
    el = (const bagl_element_t*)PIC(((bagl_element_callback_t)PIC(element->tap))(element));
c0d02f26:	f000 fedd 	bl	c0d03ce4 <pic>
c0d02f2a:	4601      	mov	r1, r0
c0d02f2c:	4620      	mov	r0, r4
c0d02f2e:	4788      	blx	r1
c0d02f30:	f000 fed8 	bl	c0d03ce4 <pic>
c0d02f34:	2100      	movs	r1, #0
    // backward compatible with samples and such
    if (!el) {
c0d02f36:	2800      	cmp	r0, #0
c0d02f38:	d010      	beq.n	c0d02f5c <io_seproxyhal_touch_tap+0x42>
c0d02f3a:	2801      	cmp	r0, #1
c0d02f3c:	d000      	beq.n	c0d02f40 <io_seproxyhal_touch_tap+0x26>
c0d02f3e:	4604      	mov	r4, r0
      element = el;
    }
  }

  // tap function might have triggered a draw of its own during a display callback
  if (before_display) {
c0d02f40:	2d00      	cmp	r5, #0
c0d02f42:	d007      	beq.n	c0d02f54 <io_seproxyhal_touch_tap+0x3a>
    el = before_display(element);
c0d02f44:	4620      	mov	r0, r4
c0d02f46:	47a8      	blx	r5
c0d02f48:	2100      	movs	r1, #0
    if (!el) {
c0d02f4a:	2800      	cmp	r0, #0
c0d02f4c:	d006      	beq.n	c0d02f5c <io_seproxyhal_touch_tap+0x42>
c0d02f4e:	2801      	cmp	r0, #1
c0d02f50:	d000      	beq.n	c0d02f54 <io_seproxyhal_touch_tap+0x3a>
c0d02f52:	4604      	mov	r4, r0
    }
    if ((unsigned int)el != 1) {
      element = el;
    }
  }
  io_seproxyhal_display(element);
c0d02f54:	4620      	mov	r0, r4
c0d02f56:	f7fe fd63 	bl	c0d01a20 <io_seproxyhal_display>
c0d02f5a:	2101      	movs	r1, #1
  return 1;
}
c0d02f5c:	4608      	mov	r0, r1
c0d02f5e:	bdb0      	pop	{r4, r5, r7, pc}

c0d02f60 <io_seproxyhal_touch_element_callback>:
  io_seproxyhal_touch_element_callback(elements, element_count, x, y, event_kind, NULL);  
}

// browse all elements and until an element has changed state, continue browsing
// return if processed or not
void io_seproxyhal_touch_element_callback(const bagl_element_t* elements, unsigned short element_count, unsigned short x, unsigned short y, unsigned char event_kind, bagl_element_callback_t before_display) {
c0d02f60:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d02f62:	b087      	sub	sp, #28
c0d02f64:	9302      	str	r3, [sp, #8]
c0d02f66:	9203      	str	r2, [sp, #12]
c0d02f68:	9105      	str	r1, [sp, #20]
  unsigned char comp_idx;
  unsigned char last_touched_not_released_component_was_in_current_array = 0;

  // find the first empty entry
  for (comp_idx=0; comp_idx < element_count; comp_idx++) {
c0d02f6a:	2900      	cmp	r1, #0
c0d02f6c:	d077      	beq.n	c0d0305e <io_seproxyhal_touch_element_callback+0xfe>
c0d02f6e:	9004      	str	r0, [sp, #16]
c0d02f70:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d02f72:	9001      	str	r0, [sp, #4]
c0d02f74:	980c      	ldr	r0, [sp, #48]	; 0x30
c0d02f76:	9000      	str	r0, [sp, #0]
c0d02f78:	2500      	movs	r5, #0
c0d02f7a:	4b3c      	ldr	r3, [pc, #240]	; (c0d0306c <io_seproxyhal_touch_element_callback+0x10c>)
c0d02f7c:	9506      	str	r5, [sp, #24]
c0d02f7e:	462f      	mov	r7, r5
c0d02f80:	461e      	mov	r6, r3
    // process all components matching the x/y/w/h (no break) => fishy for the released out of zone
    // continue processing only if a status has not been sent
    if (io_seproxyhal_spi_is_status_sent()) {
c0d02f82:	f001 f8bd 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d02f86:	2800      	cmp	r0, #0
c0d02f88:	d155      	bne.n	c0d03036 <io_seproxyhal_touch_element_callback+0xd6>
      // continue instead of return to process all elemnts and therefore discard last touched element
      break;
    }

    // only perform out callback when element was in the current array, else, leave it be
    if (&elements[comp_idx] == G_bagl_last_touched_not_released_component) {
c0d02f8a:	2038      	movs	r0, #56	; 0x38
c0d02f8c:	4368      	muls	r0, r5
c0d02f8e:	9c04      	ldr	r4, [sp, #16]
c0d02f90:	1825      	adds	r5, r4, r0
c0d02f92:	4633      	mov	r3, r6
c0d02f94:	681a      	ldr	r2, [r3, #0]
c0d02f96:	2101      	movs	r1, #1
c0d02f98:	4295      	cmp	r5, r2
c0d02f9a:	d000      	beq.n	c0d02f9e <io_seproxyhal_touch_element_callback+0x3e>
c0d02f9c:	9906      	ldr	r1, [sp, #24]
c0d02f9e:	9106      	str	r1, [sp, #24]
      last_touched_not_released_component_was_in_current_array = 1;
    }

    // the first component drawn with a 
    if ((elements[comp_idx].component.type & BAGL_FLAG_TOUCHABLE) 
c0d02fa0:	5620      	ldrsb	r0, [r4, r0]
        && elements[comp_idx].component.x-elements[comp_idx].touch_area_brim <= x && x<elements[comp_idx].component.x+elements[comp_idx].component.width+elements[comp_idx].touch_area_brim
c0d02fa2:	2800      	cmp	r0, #0
c0d02fa4:	da41      	bge.n	c0d0302a <io_seproxyhal_touch_element_callback+0xca>
c0d02fa6:	2020      	movs	r0, #32
c0d02fa8:	5c28      	ldrb	r0, [r5, r0]
c0d02faa:	2102      	movs	r1, #2
c0d02fac:	5e69      	ldrsh	r1, [r5, r1]
c0d02fae:	1a0a      	subs	r2, r1, r0
c0d02fb0:	9c03      	ldr	r4, [sp, #12]
c0d02fb2:	42a2      	cmp	r2, r4
c0d02fb4:	dc39      	bgt.n	c0d0302a <io_seproxyhal_touch_element_callback+0xca>
c0d02fb6:	1841      	adds	r1, r0, r1
c0d02fb8:	88ea      	ldrh	r2, [r5, #6]
c0d02fba:	1889      	adds	r1, r1, r2
        && elements[comp_idx].component.y-elements[comp_idx].touch_area_brim <= y && y<elements[comp_idx].component.y+elements[comp_idx].component.height+elements[comp_idx].touch_area_brim) {
c0d02fbc:	9a03      	ldr	r2, [sp, #12]
c0d02fbe:	428a      	cmp	r2, r1
c0d02fc0:	da33      	bge.n	c0d0302a <io_seproxyhal_touch_element_callback+0xca>
c0d02fc2:	2104      	movs	r1, #4
c0d02fc4:	5e6c      	ldrsh	r4, [r5, r1]
c0d02fc6:	1a22      	subs	r2, r4, r0
c0d02fc8:	9902      	ldr	r1, [sp, #8]
c0d02fca:	428a      	cmp	r2, r1
c0d02fcc:	dc2d      	bgt.n	c0d0302a <io_seproxyhal_touch_element_callback+0xca>
c0d02fce:	1820      	adds	r0, r4, r0
c0d02fd0:	8929      	ldrh	r1, [r5, #8]
c0d02fd2:	1840      	adds	r0, r0, r1
    if (&elements[comp_idx] == G_bagl_last_touched_not_released_component) {
      last_touched_not_released_component_was_in_current_array = 1;
    }

    // the first component drawn with a 
    if ((elements[comp_idx].component.type & BAGL_FLAG_TOUCHABLE) 
c0d02fd4:	9902      	ldr	r1, [sp, #8]
c0d02fd6:	4281      	cmp	r1, r0
c0d02fd8:	da27      	bge.n	c0d0302a <io_seproxyhal_touch_element_callback+0xca>
        && elements[comp_idx].component.x-elements[comp_idx].touch_area_brim <= x && x<elements[comp_idx].component.x+elements[comp_idx].component.width+elements[comp_idx].touch_area_brim
        && elements[comp_idx].component.y-elements[comp_idx].touch_area_brim <= y && y<elements[comp_idx].component.y+elements[comp_idx].component.height+elements[comp_idx].touch_area_brim) {

      // outing the previous over'ed component
      if (&elements[comp_idx] != G_bagl_last_touched_not_released_component 
c0d02fda:	6818      	ldr	r0, [r3, #0]
              && G_bagl_last_touched_not_released_component != NULL) {
c0d02fdc:	4285      	cmp	r5, r0
c0d02fde:	d010      	beq.n	c0d03002 <io_seproxyhal_touch_element_callback+0xa2>
c0d02fe0:	6818      	ldr	r0, [r3, #0]
    if ((elements[comp_idx].component.type & BAGL_FLAG_TOUCHABLE) 
        && elements[comp_idx].component.x-elements[comp_idx].touch_area_brim <= x && x<elements[comp_idx].component.x+elements[comp_idx].component.width+elements[comp_idx].touch_area_brim
        && elements[comp_idx].component.y-elements[comp_idx].touch_area_brim <= y && y<elements[comp_idx].component.y+elements[comp_idx].component.height+elements[comp_idx].touch_area_brim) {

      // outing the previous over'ed component
      if (&elements[comp_idx] != G_bagl_last_touched_not_released_component 
c0d02fe2:	2800      	cmp	r0, #0
c0d02fe4:	d00d      	beq.n	c0d03002 <io_seproxyhal_touch_element_callback+0xa2>
              && G_bagl_last_touched_not_released_component != NULL) {
        // only out the previous element if the newly matching will be displayed 
        if (!before_display || before_display(&elements[comp_idx])) {
c0d02fe6:	9801      	ldr	r0, [sp, #4]
c0d02fe8:	2800      	cmp	r0, #0
c0d02fea:	d005      	beq.n	c0d02ff8 <io_seproxyhal_touch_element_callback+0x98>
c0d02fec:	4628      	mov	r0, r5
c0d02fee:	9901      	ldr	r1, [sp, #4]
c0d02ff0:	4788      	blx	r1
c0d02ff2:	4633      	mov	r3, r6
c0d02ff4:	2800      	cmp	r0, #0
c0d02ff6:	d018      	beq.n	c0d0302a <io_seproxyhal_touch_element_callback+0xca>
          if (io_seproxyhal_touch_out(G_bagl_last_touched_not_released_component, before_display)) {
c0d02ff8:	6818      	ldr	r0, [r3, #0]
c0d02ffa:	9901      	ldr	r1, [sp, #4]
c0d02ffc:	f7ff ff3a 	bl	c0d02e74 <io_seproxyhal_touch_out>
c0d03000:	e008      	b.n	c0d03014 <io_seproxyhal_touch_element_callback+0xb4>
c0d03002:	9800      	ldr	r0, [sp, #0]
        continue;
      }
      */
      
      // callback the hal to notify the component impacted by the user input
      else if (event_kind == SEPROXYHAL_TAG_FINGER_EVENT_RELEASE) {
c0d03004:	2801      	cmp	r0, #1
c0d03006:	d009      	beq.n	c0d0301c <io_seproxyhal_touch_element_callback+0xbc>
c0d03008:	2802      	cmp	r0, #2
c0d0300a:	d10e      	bne.n	c0d0302a <io_seproxyhal_touch_element_callback+0xca>
        if (io_seproxyhal_touch_tap(&elements[comp_idx], before_display)) {
c0d0300c:	4628      	mov	r0, r5
c0d0300e:	9901      	ldr	r1, [sp, #4]
c0d03010:	f7ff ff83 	bl	c0d02f1a <io_seproxyhal_touch_tap>
c0d03014:	4633      	mov	r3, r6
c0d03016:	2800      	cmp	r0, #0
c0d03018:	d007      	beq.n	c0d0302a <io_seproxyhal_touch_element_callback+0xca>
c0d0301a:	e022      	b.n	c0d03062 <io_seproxyhal_touch_element_callback+0x102>
          return;
        }
      }
      else if (event_kind == SEPROXYHAL_TAG_FINGER_EVENT_TOUCH) {
        // ask for overing
        if (io_seproxyhal_touch_over(&elements[comp_idx], before_display)) {
c0d0301c:	4628      	mov	r0, r5
c0d0301e:	9901      	ldr	r1, [sp, #4]
c0d03020:	f7ff ff4b 	bl	c0d02eba <io_seproxyhal_touch_over>
c0d03024:	4633      	mov	r3, r6
c0d03026:	2800      	cmp	r0, #0
c0d03028:	d11e      	bne.n	c0d03068 <io_seproxyhal_touch_element_callback+0x108>
void io_seproxyhal_touch_element_callback(const bagl_element_t* elements, unsigned short element_count, unsigned short x, unsigned short y, unsigned char event_kind, bagl_element_callback_t before_display) {
  unsigned char comp_idx;
  unsigned char last_touched_not_released_component_was_in_current_array = 0;

  // find the first empty entry
  for (comp_idx=0; comp_idx < element_count; comp_idx++) {
c0d0302a:	1c7f      	adds	r7, r7, #1
c0d0302c:	b2fd      	uxtb	r5, r7
c0d0302e:	9805      	ldr	r0, [sp, #20]
c0d03030:	4285      	cmp	r5, r0
c0d03032:	d3a5      	bcc.n	c0d02f80 <io_seproxyhal_touch_element_callback+0x20>
c0d03034:	e000      	b.n	c0d03038 <io_seproxyhal_touch_element_callback+0xd8>
c0d03036:	4633      	mov	r3, r6
    }
  }

  // if overing out of component or over another component, the out event is sent after the over event of the previous component
  if(last_touched_not_released_component_was_in_current_array 
    && G_bagl_last_touched_not_released_component != NULL) {
c0d03038:	9806      	ldr	r0, [sp, #24]
c0d0303a:	0600      	lsls	r0, r0, #24
c0d0303c:	d00f      	beq.n	c0d0305e <io_seproxyhal_touch_element_callback+0xfe>
c0d0303e:	6818      	ldr	r0, [r3, #0]
      }
    }
  }

  // if overing out of component or over another component, the out event is sent after the over event of the previous component
  if(last_touched_not_released_component_was_in_current_array 
c0d03040:	2800      	cmp	r0, #0
c0d03042:	d00c      	beq.n	c0d0305e <io_seproxyhal_touch_element_callback+0xfe>
    && G_bagl_last_touched_not_released_component != NULL) {

    // we won't be able to notify the out, don't do it, in case a diplay refused the dra of the relased element and the position matched another element of the array (in autocomplete for example)
    if (io_seproxyhal_spi_is_status_sent()) {
c0d03044:	f001 f85c 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d03048:	4631      	mov	r1, r6
c0d0304a:	2800      	cmp	r0, #0
c0d0304c:	d107      	bne.n	c0d0305e <io_seproxyhal_touch_element_callback+0xfe>
      return;
    }
    
    if (io_seproxyhal_touch_out(G_bagl_last_touched_not_released_component, before_display)) {
c0d0304e:	6808      	ldr	r0, [r1, #0]
c0d03050:	9901      	ldr	r1, [sp, #4]
c0d03052:	f7ff ff0f 	bl	c0d02e74 <io_seproxyhal_touch_out>
c0d03056:	2800      	cmp	r0, #0
c0d03058:	d001      	beq.n	c0d0305e <io_seproxyhal_touch_element_callback+0xfe>
      // ok component out has been emitted
      G_bagl_last_touched_not_released_component = NULL;
c0d0305a:	2000      	movs	r0, #0
c0d0305c:	6030      	str	r0, [r6, #0]
    }
  }

  // not processed
}
c0d0305e:	b007      	add	sp, #28
c0d03060:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d03062:	2000      	movs	r0, #0
c0d03064:	6018      	str	r0, [r3, #0]
c0d03066:	e7fa      	b.n	c0d0305e <io_seproxyhal_touch_element_callback+0xfe>
      }
      else if (event_kind == SEPROXYHAL_TAG_FINGER_EVENT_TOUCH) {
        // ask for overing
        if (io_seproxyhal_touch_over(&elements[comp_idx], before_display)) {
          // remember the last touched component
          G_bagl_last_touched_not_released_component = (bagl_element_t*)&elements[comp_idx];
c0d03068:	601d      	str	r5, [r3, #0]
c0d0306a:	e7f8      	b.n	c0d0305e <io_seproxyhal_touch_element_callback+0xfe>
c0d0306c:	20001ec0 	.word	0x20001ec0

c0d03070 <io_seproxyhal_display_icon>:
  // remaining length of bitmap bits to be displayed
  return len;
}
#endif // SEPROXYHAL_TAG_SCREEN_DISPLAY_RAW_STATUS

void io_seproxyhal_display_icon(bagl_component_t* icon_component, bagl_icon_details_t* icon_details) {
c0d03070:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d03072:	b089      	sub	sp, #36	; 0x24
c0d03074:	460c      	mov	r4, r1
c0d03076:	4601      	mov	r1, r0
c0d03078:	ad02      	add	r5, sp, #8
c0d0307a:	221c      	movs	r2, #28
  bagl_component_t icon_component_mod;
  // ensure not being out of bounds in the icon component agianst the declared icon real size
  os_memmove(&icon_component_mod, icon_component, sizeof(bagl_component_t));
c0d0307c:	4628      	mov	r0, r5
c0d0307e:	9201      	str	r2, [sp, #4]
c0d03080:	f7ff fcd7 	bl	c0d02a32 <os_memmove>
  icon_component_mod.width = icon_details->width;
c0d03084:	6821      	ldr	r1, [r4, #0]
c0d03086:	80e9      	strh	r1, [r5, #6]
  icon_component_mod.height = icon_details->height;
c0d03088:	6862      	ldr	r2, [r4, #4]
c0d0308a:	812a      	strh	r2, [r5, #8]
  // component type = ICON, provided bitmap
  // => bitmap transmitted


  // color index size
  unsigned int h = (1<<(icon_details->bpp))*sizeof(unsigned int); 
c0d0308c:	68a0      	ldr	r0, [r4, #8]
  unsigned int w = ((icon_component->width*icon_component->height*icon_details->bpp)/8)+((icon_component->width*icon_component->height*icon_details->bpp)%8?1:0);
  unsigned short length = sizeof(bagl_component_t)
                          +1 /* bpp */
                          +h /* color index */
                          +w; /* image bitmap size */
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS;
c0d0308e:	4f1a      	ldr	r7, [pc, #104]	; (c0d030f8 <io_seproxyhal_display_icon+0x88>)
c0d03090:	2365      	movs	r3, #101	; 0x65
c0d03092:	703b      	strb	r3, [r7, #0]


  // color index size
  unsigned int h = (1<<(icon_details->bpp))*sizeof(unsigned int); 
  // bitmap size
  unsigned int w = ((icon_component->width*icon_component->height*icon_details->bpp)/8)+((icon_component->width*icon_component->height*icon_details->bpp)%8?1:0);
c0d03094:	b292      	uxth	r2, r2
c0d03096:	4342      	muls	r2, r0
c0d03098:	b28b      	uxth	r3, r1
c0d0309a:	4353      	muls	r3, r2
c0d0309c:	08d9      	lsrs	r1, r3, #3
c0d0309e:	1c4e      	adds	r6, r1, #1
c0d030a0:	2207      	movs	r2, #7
c0d030a2:	4213      	tst	r3, r2
c0d030a4:	d100      	bne.n	c0d030a8 <io_seproxyhal_display_icon+0x38>
c0d030a6:	460e      	mov	r6, r1
c0d030a8:	4631      	mov	r1, r6
c0d030aa:	9100      	str	r1, [sp, #0]
c0d030ac:	2604      	movs	r6, #4
  // component type = ICON, provided bitmap
  // => bitmap transmitted


  // color index size
  unsigned int h = (1<<(icon_details->bpp))*sizeof(unsigned int); 
c0d030ae:	4086      	lsls	r6, r0
  // bitmap size
  unsigned int w = ((icon_component->width*icon_component->height*icon_details->bpp)/8)+((icon_component->width*icon_component->height*icon_details->bpp)%8?1:0);
  unsigned short length = sizeof(bagl_component_t)
                          +1 /* bpp */
                          +h /* color index */
c0d030b0:	1870      	adds	r0, r6, r1
                          +w; /* image bitmap size */
c0d030b2:	301d      	adds	r0, #29
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS;
  G_io_seproxyhal_spi_buffer[1] = length>>8;
c0d030b4:	0a01      	lsrs	r1, r0, #8
c0d030b6:	7079      	strb	r1, [r7, #1]
  G_io_seproxyhal_spi_buffer[2] = length;
c0d030b8:	70b8      	strb	r0, [r7, #2]
c0d030ba:	2103      	movs	r1, #3
  io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 3);
c0d030bc:	4638      	mov	r0, r7
c0d030be:	f001 f809 	bl	c0d040d4 <io_seproxyhal_spi_send>
  io_seproxyhal_spi_send((unsigned char*)icon_component, sizeof(bagl_component_t));
c0d030c2:	4628      	mov	r0, r5
c0d030c4:	9901      	ldr	r1, [sp, #4]
c0d030c6:	f001 f805 	bl	c0d040d4 <io_seproxyhal_spi_send>
  G_io_seproxyhal_spi_buffer[0] = icon_details->bpp;
c0d030ca:	68a0      	ldr	r0, [r4, #8]
c0d030cc:	7038      	strb	r0, [r7, #0]
c0d030ce:	2101      	movs	r1, #1
  io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 1);
c0d030d0:	4638      	mov	r0, r7
c0d030d2:	f000 ffff 	bl	c0d040d4 <io_seproxyhal_spi_send>
  io_seproxyhal_spi_send((unsigned char*)PIC(icon_details->colors), h);
c0d030d6:	68e0      	ldr	r0, [r4, #12]
c0d030d8:	f000 fe04 	bl	c0d03ce4 <pic>
c0d030dc:	b2b1      	uxth	r1, r6
c0d030de:	f000 fff9 	bl	c0d040d4 <io_seproxyhal_spi_send>
  io_seproxyhal_spi_send((unsigned char*)PIC(icon_details->bitmap), w);
c0d030e2:	9800      	ldr	r0, [sp, #0]
c0d030e4:	b285      	uxth	r5, r0
c0d030e6:	6920      	ldr	r0, [r4, #16]
c0d030e8:	f000 fdfc 	bl	c0d03ce4 <pic>
c0d030ec:	4629      	mov	r1, r5
c0d030ee:	f000 fff1 	bl	c0d040d4 <io_seproxyhal_spi_send>
#endif // !SEPROXYHAL_TAG_SCREEN_DISPLAY_RAW_STATUS
}
c0d030f2:	b009      	add	sp, #36	; 0x24
c0d030f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d030f6:	46c0      	nop			; (mov r8, r8)
c0d030f8:	20001cc0 	.word	0x20001cc0

c0d030fc <io_seproxyhal_display_default>:

void io_seproxyhal_display_default(const bagl_element_t * element) {
c0d030fc:	b570      	push	{r4, r5, r6, lr}
c0d030fe:	4604      	mov	r4, r0
  // process automagically address from rom and from ram
  unsigned int type = (element->component.type & ~(BAGL_FLAG_TOUCHABLE));
c0d03100:	7820      	ldrb	r0, [r4, #0]
c0d03102:	267f      	movs	r6, #127	; 0x7f
c0d03104:	4006      	ands	r6, r0

  // avoid sending another status :), fixes a lot of bugs in the end
  if (io_seproxyhal_spi_is_status_sent()) {
c0d03106:	f000 fffb 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d0310a:	2800      	cmp	r0, #0
c0d0310c:	d130      	bne.n	c0d03170 <io_seproxyhal_display_default+0x74>
c0d0310e:	2e00      	cmp	r6, #0
c0d03110:	d02e      	beq.n	c0d03170 <io_seproxyhal_display_default+0x74>
    return;
  }

  if (type != BAGL_NONE) {
    if (element->text != NULL) {
c0d03112:	69e0      	ldr	r0, [r4, #28]
c0d03114:	2800      	cmp	r0, #0
c0d03116:	d01d      	beq.n	c0d03154 <io_seproxyhal_display_default+0x58>
      unsigned int text_adr = PIC((unsigned int)element->text);
c0d03118:	f000 fde4 	bl	c0d03ce4 <pic>
c0d0311c:	4605      	mov	r5, r0
      // consider an icon details descriptor is pointed by the context
      if (type == BAGL_ICON && element->component.icon_id == 0) {
c0d0311e:	2e05      	cmp	r6, #5
c0d03120:	d102      	bne.n	c0d03128 <io_seproxyhal_display_default+0x2c>
c0d03122:	7ea0      	ldrb	r0, [r4, #26]
c0d03124:	2800      	cmp	r0, #0
c0d03126:	d024      	beq.n	c0d03172 <io_seproxyhal_display_default+0x76>
        io_seproxyhal_display_icon((bagl_component_t*)&element->component, (bagl_icon_details_t*)text_adr);
      }
      else {
        unsigned short length = sizeof(bagl_component_t)+strlen((const char*)text_adr);
c0d03128:	4628      	mov	r0, r5
c0d0312a:	f003 ff61 	bl	c0d06ff0 <strlen>
c0d0312e:	4606      	mov	r6, r0
        G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS;
c0d03130:	4812      	ldr	r0, [pc, #72]	; (c0d0317c <io_seproxyhal_display_default+0x80>)
c0d03132:	2165      	movs	r1, #101	; 0x65
c0d03134:	7001      	strb	r1, [r0, #0]
      // consider an icon details descriptor is pointed by the context
      if (type == BAGL_ICON && element->component.icon_id == 0) {
        io_seproxyhal_display_icon((bagl_component_t*)&element->component, (bagl_icon_details_t*)text_adr);
      }
      else {
        unsigned short length = sizeof(bagl_component_t)+strlen((const char*)text_adr);
c0d03136:	4631      	mov	r1, r6
c0d03138:	311c      	adds	r1, #28
        G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS;
        G_io_seproxyhal_spi_buffer[1] = length>>8;
c0d0313a:	0a0a      	lsrs	r2, r1, #8
c0d0313c:	7042      	strb	r2, [r0, #1]
        G_io_seproxyhal_spi_buffer[2] = length;
c0d0313e:	7081      	strb	r1, [r0, #2]
        io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 3);
c0d03140:	2103      	movs	r1, #3
c0d03142:	f000 ffc7 	bl	c0d040d4 <io_seproxyhal_spi_send>
c0d03146:	211c      	movs	r1, #28
        io_seproxyhal_spi_send((unsigned char*)&element->component, sizeof(bagl_component_t));
c0d03148:	4620      	mov	r0, r4
c0d0314a:	f000 ffc3 	bl	c0d040d4 <io_seproxyhal_spi_send>
        io_seproxyhal_spi_send((unsigned char*)text_adr, length-sizeof(bagl_component_t));
c0d0314e:	b2b1      	uxth	r1, r6
c0d03150:	4628      	mov	r0, r5
c0d03152:	e00b      	b.n	c0d0316c <io_seproxyhal_display_default+0x70>
      }
    }
    else {
      unsigned short length = sizeof(bagl_component_t);
      G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_SCREEN_DISPLAY_STATUS;
c0d03154:	4809      	ldr	r0, [pc, #36]	; (c0d0317c <io_seproxyhal_display_default+0x80>)
c0d03156:	2165      	movs	r1, #101	; 0x65
c0d03158:	7001      	strb	r1, [r0, #0]
      G_io_seproxyhal_spi_buffer[1] = length>>8;
c0d0315a:	2100      	movs	r1, #0
c0d0315c:	7041      	strb	r1, [r0, #1]
c0d0315e:	251c      	movs	r5, #28
      G_io_seproxyhal_spi_buffer[2] = length;
c0d03160:	7085      	strb	r5, [r0, #2]
      io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 3);
c0d03162:	2103      	movs	r1, #3
c0d03164:	f000 ffb6 	bl	c0d040d4 <io_seproxyhal_spi_send>
      io_seproxyhal_spi_send((unsigned char*)&element->component, sizeof(bagl_component_t));
c0d03168:	4620      	mov	r0, r4
c0d0316a:	4629      	mov	r1, r5
c0d0316c:	f000 ffb2 	bl	c0d040d4 <io_seproxyhal_spi_send>
    }
  }
}
c0d03170:	bd70      	pop	{r4, r5, r6, pc}
  if (type != BAGL_NONE) {
    if (element->text != NULL) {
      unsigned int text_adr = PIC((unsigned int)element->text);
      // consider an icon details descriptor is pointed by the context
      if (type == BAGL_ICON && element->component.icon_id == 0) {
        io_seproxyhal_display_icon((bagl_component_t*)&element->component, (bagl_icon_details_t*)text_adr);
c0d03172:	4620      	mov	r0, r4
c0d03174:	4629      	mov	r1, r5
c0d03176:	f7ff ff7b 	bl	c0d03070 <io_seproxyhal_display_icon>
      G_io_seproxyhal_spi_buffer[2] = length;
      io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 3);
      io_seproxyhal_spi_send((unsigned char*)&element->component, sizeof(bagl_component_t));
    }
  }
}
c0d0317a:	bd70      	pop	{r4, r5, r6, pc}
c0d0317c:	20001cc0 	.word	0x20001cc0

c0d03180 <bagl_label_roundtrip_duration_ms>:

unsigned int bagl_label_roundtrip_duration_ms(const bagl_element_t* e, unsigned int average_char_width) {
c0d03180:	b580      	push	{r7, lr}
c0d03182:	460a      	mov	r2, r1
  return bagl_label_roundtrip_duration_ms_buf(e, e->text, average_char_width);
c0d03184:	69c1      	ldr	r1, [r0, #28]
c0d03186:	f000 f801 	bl	c0d0318c <bagl_label_roundtrip_duration_ms_buf>
c0d0318a:	bd80      	pop	{r7, pc}

c0d0318c <bagl_label_roundtrip_duration_ms_buf>:
}

unsigned int bagl_label_roundtrip_duration_ms_buf(const bagl_element_t* e, const char* str, unsigned int average_char_width) {
c0d0318c:	b570      	push	{r4, r5, r6, lr}
c0d0318e:	4616      	mov	r6, r2
c0d03190:	4604      	mov	r4, r0
c0d03192:	2500      	movs	r5, #0
  // not a scrollable label
  if (e == NULL || (e->component.type != BAGL_LABEL && e->component.type != BAGL_LABELINE)) {
c0d03194:	2c00      	cmp	r4, #0
c0d03196:	d01c      	beq.n	c0d031d2 <bagl_label_roundtrip_duration_ms_buf+0x46>
c0d03198:	7820      	ldrb	r0, [r4, #0]
c0d0319a:	2807      	cmp	r0, #7
c0d0319c:	d001      	beq.n	c0d031a2 <bagl_label_roundtrip_duration_ms_buf+0x16>
c0d0319e:	2802      	cmp	r0, #2
c0d031a0:	d117      	bne.n	c0d031d2 <bagl_label_roundtrip_duration_ms_buf+0x46>
    return 0;
  }
  
  unsigned int text_adr = PIC((unsigned int)str);
c0d031a2:	4608      	mov	r0, r1
c0d031a4:	f000 fd9e 	bl	c0d03ce4 <pic>
  unsigned int textlen = 0;
  
  // no delay, no text to display
  if (!text_adr) {
c0d031a8:	2800      	cmp	r0, #0
c0d031aa:	d012      	beq.n	c0d031d2 <bagl_label_roundtrip_duration_ms_buf+0x46>
    return 0;
  }
  textlen = strlen((const char*)text_adr);
c0d031ac:	f003 ff20 	bl	c0d06ff0 <strlen>
  
  // no delay, all text fits
  textlen = textlen * average_char_width;
c0d031b0:	4346      	muls	r6, r0
  if (textlen <= e->component.width) {
c0d031b2:	88e0      	ldrh	r0, [r4, #6]
c0d031b4:	4286      	cmp	r6, r0
c0d031b6:	d90c      	bls.n	c0d031d2 <bagl_label_roundtrip_duration_ms_buf+0x46>
    return 0; 
  }
  
  // compute scrolled text length
  return 2*(textlen - e->component.width)*1000/e->component.icon_id + 2*(e->component.stroke & ~(0x80))*100;
c0d031b8:	1a31      	subs	r1, r6, r0
c0d031ba:	207d      	movs	r0, #125	; 0x7d
c0d031bc:	0100      	lsls	r0, r0, #4
c0d031be:	4348      	muls	r0, r1
c0d031c0:	7ea1      	ldrb	r1, [r4, #26]
c0d031c2:	f003 fdad 	bl	c0d06d20 <__aeabi_uidiv>
c0d031c6:	7aa1      	ldrb	r1, [r4, #10]
c0d031c8:	0049      	lsls	r1, r1, #1
c0d031ca:	b2c9      	uxtb	r1, r1
c0d031cc:	2264      	movs	r2, #100	; 0x64
c0d031ce:	434a      	muls	r2, r1
c0d031d0:	1815      	adds	r5, r2, r0
}
c0d031d2:	4628      	mov	r0, r5
c0d031d4:	bd70      	pop	{r4, r5, r6, pc}
	...

c0d031d8 <io_seproxyhal_button_push>:
  G_io_seproxyhal_spi_buffer[3] = (backlight_percentage?0x80:0)|(flags & 0x7F); // power on
  G_io_seproxyhal_spi_buffer[4] = backlight_percentage;
  io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 5);
}

void io_seproxyhal_button_push(button_push_callback_t button_callback, unsigned int new_button_mask) {
c0d031d8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d031da:	b081      	sub	sp, #4
c0d031dc:	4604      	mov	r4, r0
  if (button_callback) {
c0d031de:	2c00      	cmp	r4, #0
c0d031e0:	d02b      	beq.n	c0d0323a <io_seproxyhal_button_push+0x62>
    unsigned int button_mask;
    unsigned int button_same_mask_counter;
    // enable speeded up long push
    if (new_button_mask == G_button_mask) {
c0d031e2:	4817      	ldr	r0, [pc, #92]	; (c0d03240 <io_seproxyhal_button_push+0x68>)
c0d031e4:	6802      	ldr	r2, [r0, #0]
c0d031e6:	428a      	cmp	r2, r1
c0d031e8:	d103      	bne.n	c0d031f2 <io_seproxyhal_button_push+0x1a>
      // each 100ms ~
      G_button_same_mask_counter++;
c0d031ea:	4a16      	ldr	r2, [pc, #88]	; (c0d03244 <io_seproxyhal_button_push+0x6c>)
c0d031ec:	6813      	ldr	r3, [r2, #0]
c0d031ee:	1c5b      	adds	r3, r3, #1
c0d031f0:	6013      	str	r3, [r2, #0]
    }

    // append the button mask
    button_mask = G_button_mask | new_button_mask;
c0d031f2:	6806      	ldr	r6, [r0, #0]
c0d031f4:	430e      	orrs	r6, r1

    // pre reset variable due to os_sched_exit
    button_same_mask_counter = G_button_same_mask_counter;
c0d031f6:	4a13      	ldr	r2, [pc, #76]	; (c0d03244 <io_seproxyhal_button_push+0x6c>)
c0d031f8:	6815      	ldr	r5, [r2, #0]
c0d031fa:	4f13      	ldr	r7, [pc, #76]	; (c0d03248 <io_seproxyhal_button_push+0x70>)

    // reset button mask
    if (new_button_mask == 0) {
c0d031fc:	2900      	cmp	r1, #0
c0d031fe:	d001      	beq.n	c0d03204 <io_seproxyhal_button_push+0x2c>

      // notify button released event
      button_mask |= BUTTON_EVT_RELEASED;
    }
    else {
      G_button_mask = button_mask;
c0d03200:	6006      	str	r6, [r0, #0]
c0d03202:	e004      	b.n	c0d0320e <io_seproxyhal_button_push+0x36>
c0d03204:	2300      	movs	r3, #0
    button_same_mask_counter = G_button_same_mask_counter;

    // reset button mask
    if (new_button_mask == 0) {
      // reset next state when button are released
      G_button_mask = 0;
c0d03206:	6003      	str	r3, [r0, #0]
      G_button_same_mask_counter=0;
c0d03208:	6013      	str	r3, [r2, #0]

      // notify button released event
      button_mask |= BUTTON_EVT_RELEASED;
c0d0320a:	1c7b      	adds	r3, r7, #1
c0d0320c:	431e      	orrs	r6, r3
    else {
      G_button_mask = button_mask;
    }

    // reset counter when button mask changes
    if (new_button_mask != G_button_mask) {
c0d0320e:	6800      	ldr	r0, [r0, #0]
c0d03210:	4288      	cmp	r0, r1
c0d03212:	d001      	beq.n	c0d03218 <io_seproxyhal_button_push+0x40>
      G_button_same_mask_counter=0;
c0d03214:	2000      	movs	r0, #0
c0d03216:	6010      	str	r0, [r2, #0]
    }

    if (button_same_mask_counter >= BUTTON_FAST_THRESHOLD_CS) {
c0d03218:	2d08      	cmp	r5, #8
c0d0321a:	d30b      	bcc.n	c0d03234 <io_seproxyhal_button_push+0x5c>
      // fast bit when pressing and timing is right
      if ((button_same_mask_counter%BUTTON_FAST_ACTION_CS) == 0) {
c0d0321c:	2103      	movs	r1, #3
c0d0321e:	4628      	mov	r0, r5
c0d03220:	f003 fe04 	bl	c0d06e2c <__aeabi_uidivmod>
        button_mask |= BUTTON_EVT_FAST;
c0d03224:	2001      	movs	r0, #1
c0d03226:	0780      	lsls	r0, r0, #30
c0d03228:	4330      	orrs	r0, r6
      G_button_same_mask_counter=0;
    }

    if (button_same_mask_counter >= BUTTON_FAST_THRESHOLD_CS) {
      // fast bit when pressing and timing is right
      if ((button_same_mask_counter%BUTTON_FAST_ACTION_CS) == 0) {
c0d0322a:	2900      	cmp	r1, #0
c0d0322c:	d000      	beq.n	c0d03230 <io_seproxyhal_button_push+0x58>
c0d0322e:	4630      	mov	r0, r6
      }
      */

      // discard the release event after a fastskip has been detected, to avoid strange at release behavior
      // and also to enable user to cancel an operation by starting triggering the fast skip
      button_mask &= ~BUTTON_EVT_RELEASED;
c0d03230:	4038      	ands	r0, r7
c0d03232:	e000      	b.n	c0d03236 <io_seproxyhal_button_push+0x5e>
c0d03234:	4630      	mov	r0, r6
    }

    // indicate if button have been released
    button_callback(button_mask, button_same_mask_counter);
c0d03236:	4629      	mov	r1, r5
c0d03238:	47a0      	blx	r4
  }
}
c0d0323a:	b001      	add	sp, #4
c0d0323c:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0323e:	46c0      	nop			; (mov r8, r8)
c0d03240:	20001ec4 	.word	0x20001ec4
c0d03244:	20001ec8 	.word	0x20001ec8
c0d03248:	7fffffff 	.word	0x7fffffff

c0d0324c <os_io_seproxyhal_get_app_name_and_version>:
#ifdef HAVE_IO_U2F
u2f_service_t G_io_u2f;
#endif // HAVE_IO_U2F

unsigned int os_io_seproxyhal_get_app_name_and_version(void) __attribute__((weak));
unsigned int os_io_seproxyhal_get_app_name_and_version(void) {
c0d0324c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0324e:	b081      	sub	sp, #4
  unsigned int tx_len, len;
  // build the get app name and version reply
  tx_len = 0;
  G_io_apdu_buffer[tx_len++] = 1; // format ID
c0d03250:	4e0f      	ldr	r6, [pc, #60]	; (c0d03290 <os_io_seproxyhal_get_app_name_and_version+0x44>)
c0d03252:	2401      	movs	r4, #1
c0d03254:	7034      	strb	r4, [r6, #0]

  // append app name
  len = os_registry_get_current_app_tag(BOLOS_TAG_APPNAME, G_io_apdu_buffer+tx_len+1, sizeof(G_io_apdu_buffer)-tx_len);
c0d03256:	1cb1      	adds	r1, r6, #2
c0d03258:	27ff      	movs	r7, #255	; 0xff
c0d0325a:	3750      	adds	r7, #80	; 0x50
c0d0325c:	1c7a      	adds	r2, r7, #1
c0d0325e:	4620      	mov	r0, r4
c0d03260:	f000 ff20 	bl	c0d040a4 <os_registry_get_current_app_tag>
c0d03264:	4605      	mov	r5, r0
  G_io_apdu_buffer[tx_len++] = len;
c0d03266:	7075      	strb	r5, [r6, #1]
  tx_len += len;
  // append app version
  len = os_registry_get_current_app_tag(BOLOS_TAG_APPVERSION, G_io_apdu_buffer+tx_len+1, sizeof(G_io_apdu_buffer)-tx_len);
c0d03268:	1b7a      	subs	r2, r7, r5
unsigned int os_io_seproxyhal_get_app_name_and_version(void) __attribute__((weak));
unsigned int os_io_seproxyhal_get_app_name_and_version(void) {
  unsigned int tx_len, len;
  // build the get app name and version reply
  tx_len = 0;
  G_io_apdu_buffer[tx_len++] = 1; // format ID
c0d0326a:	1977      	adds	r7, r6, r5
  // append app name
  len = os_registry_get_current_app_tag(BOLOS_TAG_APPNAME, G_io_apdu_buffer+tx_len+1, sizeof(G_io_apdu_buffer)-tx_len);
  G_io_apdu_buffer[tx_len++] = len;
  tx_len += len;
  // append app version
  len = os_registry_get_current_app_tag(BOLOS_TAG_APPVERSION, G_io_apdu_buffer+tx_len+1, sizeof(G_io_apdu_buffer)-tx_len);
c0d0326c:	1cf9      	adds	r1, r7, #3
c0d0326e:	2002      	movs	r0, #2
c0d03270:	f000 ff18 	bl	c0d040a4 <os_registry_get_current_app_tag>
  G_io_apdu_buffer[tx_len++] = len;
c0d03274:	70b8      	strb	r0, [r7, #2]
c0d03276:	182d      	adds	r5, r5, r0
unsigned int os_io_seproxyhal_get_app_name_and_version(void) __attribute__((weak));
unsigned int os_io_seproxyhal_get_app_name_and_version(void) {
  unsigned int tx_len, len;
  // build the get app name and version reply
  tx_len = 0;
  G_io_apdu_buffer[tx_len++] = 1; // format ID
c0d03278:	1976      	adds	r6, r6, r5
  // append app version
  len = os_registry_get_current_app_tag(BOLOS_TAG_APPVERSION, G_io_apdu_buffer+tx_len+1, sizeof(G_io_apdu_buffer)-tx_len);
  G_io_apdu_buffer[tx_len++] = len;
  tx_len += len;
  // return OS flags to notify of platform's global state (pin lock etc)
  G_io_apdu_buffer[tx_len++] = 1; // flags length
c0d0327a:	70f4      	strb	r4, [r6, #3]
  G_io_apdu_buffer[tx_len++] = os_flags();
c0d0327c:	f000 fefc 	bl	c0d04078 <os_flags>
c0d03280:	7130      	strb	r0, [r6, #4]

  // status words
  G_io_apdu_buffer[tx_len++] = 0x90;
c0d03282:	2090      	movs	r0, #144	; 0x90
c0d03284:	7170      	strb	r0, [r6, #5]
  G_io_apdu_buffer[tx_len++] = 0x00;
c0d03286:	2000      	movs	r0, #0
c0d03288:	71b0      	strb	r0, [r6, #6]
c0d0328a:	1de8      	adds	r0, r5, #7
  return tx_len;
c0d0328c:	b001      	add	sp, #4
c0d0328e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d03290:	20001d4c 	.word	0x20001d4c

c0d03294 <io_exchange>:
}


unsigned short io_exchange(unsigned char channel, unsigned short tx_len) {
c0d03294:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d03296:	b087      	sub	sp, #28
c0d03298:	4602      	mov	r2, r0
  }
  after_debug:
#endif // DEBUG_APDU

reply_apdu:
  switch(channel&~(IO_FLAGS)) {
c0d0329a:	2007      	movs	r0, #7
c0d0329c:	4202      	tst	r2, r0
c0d0329e:	d006      	beq.n	c0d032ae <io_exchange+0x1a>
c0d032a0:	4616      	mov	r6, r2
      }
    }
    break;

  default:
    return io_exchange_al(channel, tx_len);
c0d032a2:	b2f0      	uxtb	r0, r6
c0d032a4:	f7fe f8ca 	bl	c0d0143c <io_exchange_al>
  }
}
c0d032a8:	b280      	uxth	r0, r0
c0d032aa:	b007      	add	sp, #28
c0d032ac:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d032ae:	9003      	str	r0, [sp, #12]
c0d032b0:	487f      	ldr	r0, [pc, #508]	; (c0d034b0 <io_exchange+0x21c>)
          goto reply_apdu; 
        }
        // exit app after replied
        else if (os_memcmp(G_io_apdu_buffer, "\xB0\xA7\x00\x00", 4) == 0) {
          tx_len = 0;
          G_io_apdu_buffer[tx_len++] = 0x90;
c0d032b2:	9001      	str	r0, [sp, #4]
c0d032b4:	2083      	movs	r0, #131	; 0x83
c0d032b6:	9004      	str	r0, [sp, #16]
c0d032b8:	4c7e      	ldr	r4, [pc, #504]	; (c0d034b4 <io_exchange+0x220>)
c0d032ba:	4d80      	ldr	r5, [pc, #512]	; (c0d034bc <io_exchange+0x228>)
c0d032bc:	4616      	mov	r6, r2
c0d032be:	e011      	b.n	c0d032e4 <io_exchange+0x50>
c0d032c0:	9804      	ldr	r0, [sp, #16]
c0d032c2:	300d      	adds	r0, #13
c0d032c4:	497e      	ldr	r1, [pc, #504]	; (c0d034c0 <io_exchange+0x22c>)
c0d032c6:	7008      	strb	r0, [r1, #0]
          G_io_apdu_buffer[tx_len++] = 0x00;
c0d032c8:	704f      	strb	r7, [r1, #1]
c0d032ca:	9a06      	ldr	r2, [sp, #24]
          // exit app after replied
          channel |= IO_RESET_AFTER_REPLIED;
c0d032cc:	4316      	orrs	r6, r2
c0d032ce:	2102      	movs	r1, #2
  }
  after_debug:
#endif // DEBUG_APDU

reply_apdu:
  switch(channel&~(IO_FLAGS)) {
c0d032d0:	9803      	ldr	r0, [sp, #12]
c0d032d2:	4202      	tst	r2, r0
c0d032d4:	4632      	mov	r2, r6
c0d032d6:	d005      	beq.n	c0d032e4 <io_exchange+0x50>
c0d032d8:	e7e3      	b.n	c0d032a2 <io_exchange+0xe>
      // an apdu has been received asynchroneously, return it
      if (G_io_apdu_state != APDU_IDLE && G_io_apdu_length > 0) {
        // handle reserved apdus
        // get name and version
        if (os_memcmp(G_io_apdu_buffer, "\xB0\x01\x00\x00", 4) == 0) {
          tx_len = os_io_seproxyhal_get_app_name_and_version();
c0d032da:	f7ff ffb7 	bl	c0d0324c <os_io_seproxyhal_get_app_name_and_version>
c0d032de:	4601      	mov	r1, r0
c0d032e0:	463a      	mov	r2, r7
c0d032e2:	463e      	mov	r6, r7
reply_apdu:
  switch(channel&~(IO_FLAGS)) {
  case CHANNEL_APDU:
    // TODO work up the spi state machine over the HAL proxy until an APDU is available

    if (tx_len && !(channel&IO_ASYNCH_REPLY)) {
c0d032e4:	2310      	movs	r3, #16
c0d032e6:	4013      	ands	r3, r2
c0d032e8:	b28f      	uxth	r7, r1
c0d032ea:	2f00      	cmp	r7, #0
c0d032ec:	9206      	str	r2, [sp, #24]
c0d032ee:	d100      	bne.n	c0d032f2 <io_exchange+0x5e>
c0d032f0:	e091      	b.n	c0d03416 <io_exchange+0x182>
c0d032f2:	2b00      	cmp	r3, #0
c0d032f4:	d000      	beq.n	c0d032f8 <io_exchange+0x64>
c0d032f6:	e08e      	b.n	c0d03416 <io_exchange+0x182>
c0d032f8:	7820      	ldrb	r0, [r4, #0]
      // until the whole RAPDU is transmitted, send chunks using the current mode for communication
      for (;;) {
        switch(G_io_apdu_state) {
c0d032fa:	2809      	cmp	r0, #9
c0d032fc:	9305      	str	r3, [sp, #20]
c0d032fe:	dc3c      	bgt.n	c0d0337a <io_exchange+0xe6>
c0d03300:	2807      	cmp	r0, #7
c0d03302:	d041      	beq.n	c0d03388 <io_exchange+0xf4>
c0d03304:	2809      	cmp	r0, #9
c0d03306:	d15b      	bne.n	c0d033c0 <io_exchange+0x12c>
c0d03308:	2100      	movs	r1, #0
c0d0330a:	4e6b      	ldr	r6, [pc, #428]	; (c0d034b8 <io_exchange+0x224>)
          // case to handle U2F channels. u2f apdu to be dispatched in the upper layers
          case APDU_U2F:
            // prepare reply, the remaining segments will be pumped during USB/BLE events handling while waiting for the next APDU

            // the reply has been prepared by the application, stop sending anti timeouts
            u2f_message_set_autoreply_wait_user_presence(&G_io_u2f, false);
c0d0330c:	4630      	mov	r0, r6
c0d0330e:	9102      	str	r1, [sp, #8]
c0d03310:	f001 fbca 	bl	c0d04aa8 <u2f_message_set_autoreply_wait_user_presence>

            // continue processing currently received command until completely received.
            while(!u2f_message_repliable(&G_io_u2f)) {
c0d03314:	4630      	mov	r0, r6
c0d03316:	f001 fbda 	bl	c0d04ace <u2f_message_repliable>
c0d0331a:	2800      	cmp	r0, #0
c0d0331c:	d10d      	bne.n	c0d0333a <io_exchange+0xa6>
              io_seproxyhal_general_status();
c0d0331e:	f7ff fc49 	bl	c0d02bb4 <io_seproxyhal_general_status>
              io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d03322:	2180      	movs	r1, #128	; 0x80
c0d03324:	2200      	movs	r2, #0
c0d03326:	4628      	mov	r0, r5
c0d03328:	f000 ff00 	bl	c0d0412c <io_seproxyhal_spi_recv>
              // if packet is not well formed, then too bad ...
              io_seproxyhal_handle_event();
c0d0332c:	f7ff fd2c 	bl	c0d02d88 <io_seproxyhal_handle_event>

            // the reply has been prepared by the application, stop sending anti timeouts
            u2f_message_set_autoreply_wait_user_presence(&G_io_u2f, false);

            // continue processing currently received command until completely received.
            while(!u2f_message_repliable(&G_io_u2f)) {
c0d03330:	4630      	mov	r0, r6
c0d03332:	f001 fbcc 	bl	c0d04ace <u2f_message_repliable>
c0d03336:	2801      	cmp	r0, #1
c0d03338:	d1f1      	bne.n	c0d0331e <io_exchange+0x8a>
              // if packet is not well formed, then too bad ...
              io_seproxyhal_handle_event();
            }          

            // user presence + counter + rapdu + sw must fit the apdu buffer
            if (1U+ 4U+ tx_len +2U > sizeof(G_io_apdu_buffer)) {
c0d0333a:	1dfe      	adds	r6, r7, #7
c0d0333c:	0870      	lsrs	r0, r6, #1
c0d0333e:	28a9      	cmp	r0, #169	; 0xa9
c0d03340:	d300      	bcc.n	c0d03344 <io_exchange+0xb0>
c0d03342:	e0b1      	b.n	c0d034a8 <io_exchange+0x214>
              THROW(INVALID_PARAMETER);
            }

            // u2F tunnel needs the status words to be included in the signature response BLOB, do it now.
            // always return 9000 in the signature to avoid error @ transport level in u2f layers. 
            G_io_apdu_buffer[tx_len] = 0x90; //G_io_apdu_buffer[tx_len-2];
c0d03344:	9804      	ldr	r0, [sp, #16]
c0d03346:	300d      	adds	r0, #13
c0d03348:	495d      	ldr	r1, [pc, #372]	; (c0d034c0 <io_exchange+0x22c>)
c0d0334a:	55c8      	strb	r0, [r1, r7]
c0d0334c:	19c8      	adds	r0, r1, r7
            G_io_apdu_buffer[tx_len+1] = 0x00; //G_io_apdu_buffer[tx_len-1];
c0d0334e:	9a02      	ldr	r2, [sp, #8]
c0d03350:	7042      	strb	r2, [r0, #1]
            tx_len += 2;
            os_memmove(G_io_apdu_buffer+5, G_io_apdu_buffer, tx_len);
c0d03352:	9801      	ldr	r0, [sp, #4]
c0d03354:	1d00      	adds	r0, r0, #4

            // u2F tunnel needs the status words to be included in the signature response BLOB, do it now.
            // always return 9000 in the signature to avoid error @ transport level in u2f layers. 
            G_io_apdu_buffer[tx_len] = 0x90; //G_io_apdu_buffer[tx_len-2];
            G_io_apdu_buffer[tx_len+1] = 0x00; //G_io_apdu_buffer[tx_len-1];
            tx_len += 2;
c0d03356:	1cba      	adds	r2, r7, #2
            os_memmove(G_io_apdu_buffer+5, G_io_apdu_buffer, tx_len);
c0d03358:	4002      	ands	r2, r0
c0d0335a:	1d48      	adds	r0, r1, #5
c0d0335c:	460f      	mov	r7, r1
c0d0335e:	f7ff fb68 	bl	c0d02a32 <os_memmove>
c0d03362:	2205      	movs	r2, #5
            // zeroize user presence and counter
            os_memset(G_io_apdu_buffer, 0, 5);
c0d03364:	4638      	mov	r0, r7
c0d03366:	9902      	ldr	r1, [sp, #8]
c0d03368:	f7ff fb5a 	bl	c0d02a20 <os_memset>
            u2f_message_reply(&G_io_u2f, U2F_CMD_MSG, G_io_apdu_buffer, tx_len+5);
c0d0336c:	b2b3      	uxth	r3, r6
c0d0336e:	4852      	ldr	r0, [pc, #328]	; (c0d034b8 <io_exchange+0x224>)
c0d03370:	9904      	ldr	r1, [sp, #16]
c0d03372:	463a      	mov	r2, r7
c0d03374:	f001 fbc3 	bl	c0d04afe <u2f_message_reply>
c0d03378:	e034      	b.n	c0d033e4 <io_exchange+0x150>
c0d0337a:	280a      	cmp	r0, #10
c0d0337c:	d00a      	beq.n	c0d03394 <io_exchange+0x100>
c0d0337e:	280b      	cmp	r0, #11
c0d03380:	d120      	bne.n	c0d033c4 <io_exchange+0x130>
            io_usb_ccid_reply(G_io_apdu_buffer, tx_len);
            goto break_send;
#endif // HAVE_USB_CLASS_CCID
#ifdef HAVE_WEBUSB
          case APDU_USB_WEBUSB:
            io_usb_hid_send(io_usb_send_apdu_data_ep0x83, tx_len);
c0d03382:	4858      	ldr	r0, [pc, #352]	; (c0d034e4 <io_exchange+0x250>)
c0d03384:	4478      	add	r0, pc
c0d03386:	e001      	b.n	c0d0338c <io_exchange+0xf8>
            goto break_send;

#ifdef HAVE_USB_APDU
          case APDU_USB_HID:
            // only send, don't perform synchronous reception of the next command (will be done later by the seproxyhal packet processing)
            io_usb_hid_send(io_usb_send_apdu_data, tx_len);
c0d03388:	4855      	ldr	r0, [pc, #340]	; (c0d034e0 <io_exchange+0x24c>)
c0d0338a:	4478      	add	r0, pc
c0d0338c:	4639      	mov	r1, r7
c0d0338e:	f7ff fbd3 	bl	c0d02b38 <io_usb_hid_send>
c0d03392:	e027      	b.n	c0d033e4 <io_exchange+0x150>
            LOG("invalid state for APDU reply\n");
            THROW(INVALID_STATE);
            break;

          case APDU_RAW:
            if (tx_len > sizeof(G_io_apdu_buffer)) {
c0d03394:	484b      	ldr	r0, [pc, #300]	; (c0d034c4 <io_exchange+0x230>)
c0d03396:	4008      	ands	r0, r1
c0d03398:	0840      	lsrs	r0, r0, #1
c0d0339a:	28a9      	cmp	r0, #169	; 0xa9
c0d0339c:	d300      	bcc.n	c0d033a0 <io_exchange+0x10c>
c0d0339e:	e083      	b.n	c0d034a8 <io_exchange+0x214>
              THROW(INVALID_PARAMETER);
            }
            // reply the RAW APDU over SEPROXYHAL protocol
            G_io_seproxyhal_spi_buffer[0]  = SEPROXYHAL_TAG_RAPDU;
c0d033a0:	2053      	movs	r0, #83	; 0x53
c0d033a2:	7028      	strb	r0, [r5, #0]
            G_io_seproxyhal_spi_buffer[1]  = (tx_len)>>8;
c0d033a4:	0a38      	lsrs	r0, r7, #8
c0d033a6:	7068      	strb	r0, [r5, #1]
            G_io_seproxyhal_spi_buffer[2]  = (tx_len);
c0d033a8:	70a9      	strb	r1, [r5, #2]
            io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 3);
c0d033aa:	2103      	movs	r1, #3
c0d033ac:	4628      	mov	r0, r5
c0d033ae:	f000 fe91 	bl	c0d040d4 <io_seproxyhal_spi_send>
            io_seproxyhal_spi_send(G_io_apdu_buffer, tx_len);
c0d033b2:	4843      	ldr	r0, [pc, #268]	; (c0d034c0 <io_exchange+0x22c>)
c0d033b4:	4639      	mov	r1, r7
c0d033b6:	f000 fe8d 	bl	c0d040d4 <io_seproxyhal_spi_send>

            // isngle packet reply, mark immediate idle
            G_io_apdu_state = APDU_IDLE;
c0d033ba:	2000      	movs	r0, #0
c0d033bc:	7020      	strb	r0, [r4, #0]
c0d033be:	e011      	b.n	c0d033e4 <io_exchange+0x150>
c0d033c0:	2800      	cmp	r0, #0
c0d033c2:	d06e      	beq.n	c0d034a2 <io_exchange+0x20e>
      // until the whole RAPDU is transmitted, send chunks using the current mode for communication
      for (;;) {
        switch(G_io_apdu_state) {
          default: 
            // delegate to the hal in case of not generic transport mode (or asynch)
            if (io_exchange_al(channel, tx_len) == 0) {
c0d033c4:	b2f0      	uxtb	r0, r6
c0d033c6:	4639      	mov	r1, r7
c0d033c8:	f7fe f838 	bl	c0d0143c <io_exchange_al>
c0d033cc:	2800      	cmp	r0, #0
c0d033ce:	d009      	beq.n	c0d033e4 <io_exchange+0x150>
c0d033d0:	e067      	b.n	c0d034a2 <io_exchange+0x20e>
        // wait end of reply transmission
        while (G_io_apdu_state != APDU_IDLE) {
#ifdef HAVE_TINY_COROUTINE
          tcr_yield();
#else // HAVE_TINY_COROUTINE
          io_seproxyhal_general_status();
c0d033d2:	f7ff fbef 	bl	c0d02bb4 <io_seproxyhal_general_status>
          io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d033d6:	2180      	movs	r1, #128	; 0x80
c0d033d8:	2200      	movs	r2, #0
c0d033da:	4628      	mov	r0, r5
c0d033dc:	f000 fea6 	bl	c0d0412c <io_seproxyhal_spi_recv>
          // if packet is not well formed, then too bad ...
          io_seproxyhal_handle_event();
c0d033e0:	f7ff fcd2 	bl	c0d02d88 <io_seproxyhal_handle_event>
c0d033e4:	7820      	ldrb	r0, [r4, #0]
c0d033e6:	2800      	cmp	r0, #0
c0d033e8:	d1f3      	bne.n	c0d033d2 <io_exchange+0x13e>
c0d033ea:	2000      	movs	r0, #0
#endif // HAVE_TINY_COROUTINE
        }

        // reset apdu state
        G_io_apdu_state = APDU_IDLE;
c0d033ec:	7020      	strb	r0, [r4, #0]
        G_io_apdu_media = IO_APDU_MEDIA_NONE;
c0d033ee:	4936      	ldr	r1, [pc, #216]	; (c0d034c8 <io_exchange+0x234>)
c0d033f0:	7008      	strb	r0, [r1, #0]

        G_io_apdu_length = 0;
c0d033f2:	4936      	ldr	r1, [pc, #216]	; (c0d034cc <io_exchange+0x238>)
c0d033f4:	8008      	strh	r0, [r1, #0]

        // continue sending commands, don't issue status yet
        if (channel & IO_RETURN_AFTER_TX) {
c0d033f6:	9906      	ldr	r1, [sp, #24]
c0d033f8:	0689      	lsls	r1, r1, #26
c0d033fa:	d500      	bpl.n	c0d033fe <io_exchange+0x16a>
c0d033fc:	e754      	b.n	c0d032a8 <io_exchange+0x14>
          return 0;
        }
        // acknowledge the write request (general status OK) and no more command to follow (wait until another APDU container is received to continue unwrapping)
        io_seproxyhal_general_status();
c0d033fe:	f7ff fbd9 	bl	c0d02bb4 <io_seproxyhal_general_status>
c0d03402:	9a06      	ldr	r2, [sp, #24]
        break;
      }

      // perform reset after io exchange
      if (channel & IO_RESET_AFTER_REPLIED) {
c0d03404:	0610      	lsls	r0, r2, #24
c0d03406:	9b05      	ldr	r3, [sp, #20]
c0d03408:	d505      	bpl.n	c0d03416 <io_exchange+0x182>
        os_sched_exit(1);
c0d0340a:	2001      	movs	r0, #1
c0d0340c:	461e      	mov	r6, r3
c0d0340e:	f000 fdf1 	bl	c0d03ff4 <os_sched_exit>
c0d03412:	4633      	mov	r3, r6
c0d03414:	9a06      	ldr	r2, [sp, #24]
        //reset();
      }
    }

#ifndef HAVE_TINY_COROUTINE
    if (!(channel&IO_ASYNCH_REPLY)) {
c0d03416:	2b00      	cmp	r3, #0
c0d03418:	d105      	bne.n	c0d03426 <io_exchange+0x192>
      
      // already received the data of the apdu when received the whole apdu
      if ((channel & (CHANNEL_APDU|IO_RECEIVE_DATA)) == (CHANNEL_APDU|IO_RECEIVE_DATA)) {
c0d0341a:	0650      	lsls	r0, r2, #25
c0d0341c:	d43c      	bmi.n	c0d03498 <io_exchange+0x204>
        // return apdu data - header
        return G_io_apdu_length-5;
      }

      // reply has ended, proceed to next apdu reception (reset status only after asynch reply)
      G_io_apdu_state = APDU_IDLE;
c0d0341e:	2000      	movs	r0, #0
c0d03420:	7020      	strb	r0, [r4, #0]
      G_io_apdu_media = IO_APDU_MEDIA_NONE;
c0d03422:	4929      	ldr	r1, [pc, #164]	; (c0d034c8 <io_exchange+0x234>)
c0d03424:	7008      	strb	r0, [r1, #0]
    }
#endif // HAVE_TINY_COROUTINE

    // reset the received apdu length
    G_io_apdu_length = 0;
c0d03426:	2000      	movs	r0, #0
c0d03428:	4928      	ldr	r1, [pc, #160]	; (c0d034cc <io_exchange+0x238>)
c0d0342a:	8008      	strh	r0, [r1, #0]
#ifdef HAVE_TINY_COROUTINE
      // give back hand to the seph task which interprets all incoming events first
      tcr_yield();
#else // HAVE_TINY_COROUTINE

      if (!io_seproxyhal_spi_is_status_sent()) {
c0d0342c:	f000 fe68 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d03430:	2800      	cmp	r0, #0
c0d03432:	d101      	bne.n	c0d03438 <io_exchange+0x1a4>
        io_seproxyhal_general_status();
c0d03434:	f7ff fbbe 	bl	c0d02bb4 <io_seproxyhal_general_status>
      }
      // wait until a SPI packet is available
      // NOTE: on ST31, dual wait ISO & RF (ISO instead of SPI)
      rx_len = io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);
c0d03438:	2680      	movs	r6, #128	; 0x80
c0d0343a:	2700      	movs	r7, #0
c0d0343c:	4628      	mov	r0, r5
c0d0343e:	4631      	mov	r1, r6
c0d03440:	463a      	mov	r2, r7
c0d03442:	f000 fe73 	bl	c0d0412c <io_seproxyhal_spi_recv>

      // can't process split TLV, continue
      if (rx_len < 3 && rx_len-3 != U2(G_io_seproxyhal_spi_buffer[1],G_io_seproxyhal_spi_buffer[2])) {
c0d03446:	2802      	cmp	r0, #2
c0d03448:	d806      	bhi.n	c0d03458 <io_exchange+0x1c4>
c0d0344a:	78a9      	ldrb	r1, [r5, #2]
c0d0344c:	786a      	ldrb	r2, [r5, #1]
c0d0344e:	0212      	lsls	r2, r2, #8
c0d03450:	430a      	orrs	r2, r1
c0d03452:	1ec0      	subs	r0, r0, #3
c0d03454:	4290      	cmp	r0, r2
c0d03456:	d109      	bne.n	c0d0346c <io_exchange+0x1d8>
        G_io_apdu_state = APDU_IDLE;
        G_io_apdu_length = 0;
        continue;
      }

        io_seproxyhal_handle_event();
c0d03458:	f7ff fc96 	bl	c0d02d88 <io_seproxyhal_handle_event>
#endif // HAVE_TINY_COROUTINE

      // an apdu has been received asynchroneously, return it
      if (G_io_apdu_state != APDU_IDLE && G_io_apdu_length > 0) {
c0d0345c:	7820      	ldrb	r0, [r4, #0]
c0d0345e:	2800      	cmp	r0, #0
c0d03460:	d0e4      	beq.n	c0d0342c <io_exchange+0x198>
c0d03462:	481a      	ldr	r0, [pc, #104]	; (c0d034cc <io_exchange+0x238>)
c0d03464:	8800      	ldrh	r0, [r0, #0]
c0d03466:	2800      	cmp	r0, #0
c0d03468:	d0e0      	beq.n	c0d0342c <io_exchange+0x198>
c0d0346a:	e002      	b.n	c0d03472 <io_exchange+0x1de>
c0d0346c:	2000      	movs	r0, #0
      rx_len = io_seproxyhal_spi_recv(G_io_seproxyhal_spi_buffer, sizeof(G_io_seproxyhal_spi_buffer), 0);

      // can't process split TLV, continue
      if (rx_len < 3 && rx_len-3 != U2(G_io_seproxyhal_spi_buffer[1],G_io_seproxyhal_spi_buffer[2])) {
        LOG("invalid TLV format\n");
        G_io_apdu_state = APDU_IDLE;
c0d0346e:	7020      	strb	r0, [r4, #0]
c0d03470:	e7da      	b.n	c0d03428 <io_exchange+0x194>

      // an apdu has been received asynchroneously, return it
      if (G_io_apdu_state != APDU_IDLE && G_io_apdu_length > 0) {
        // handle reserved apdus
        // get name and version
        if (os_memcmp(G_io_apdu_buffer, "\xB0\x01\x00\x00", 4) == 0) {
c0d03472:	2204      	movs	r2, #4
c0d03474:	4812      	ldr	r0, [pc, #72]	; (c0d034c0 <io_exchange+0x22c>)
c0d03476:	a116      	add	r1, pc, #88	; (adr r1, c0d034d0 <io_exchange+0x23c>)
c0d03478:	f7ff fb78 	bl	c0d02b6c <os_memcmp>
c0d0347c:	2800      	cmp	r0, #0
c0d0347e:	d100      	bne.n	c0d03482 <io_exchange+0x1ee>
c0d03480:	e72b      	b.n	c0d032da <io_exchange+0x46>
          // disable 'return after tx' and 'asynch reply' flags
          channel &= ~IO_FLAGS;
          goto reply_apdu; 
        }
        // exit app after replied
        else if (os_memcmp(G_io_apdu_buffer, "\xB0\xA7\x00\x00", 4) == 0) {
c0d03482:	2204      	movs	r2, #4
c0d03484:	480e      	ldr	r0, [pc, #56]	; (c0d034c0 <io_exchange+0x22c>)
c0d03486:	a114      	add	r1, pc, #80	; (adr r1, c0d034d8 <io_exchange+0x244>)
c0d03488:	f7ff fb70 	bl	c0d02b6c <os_memcmp>
c0d0348c:	2800      	cmp	r0, #0
c0d0348e:	d100      	bne.n	c0d03492 <io_exchange+0x1fe>
c0d03490:	e716      	b.n	c0d032c0 <io_exchange+0x2c>
          // disable 'return after tx' and 'asynch reply' flags
          channel &= ~IO_FLAGS;
          goto reply_apdu; 
        }
#endif // HAVE_BOLOS_WITH_VIRGIN_ATTESTATION
        return G_io_apdu_length;
c0d03492:	480e      	ldr	r0, [pc, #56]	; (c0d034cc <io_exchange+0x238>)
c0d03494:	8800      	ldrh	r0, [r0, #0]
c0d03496:	e707      	b.n	c0d032a8 <io_exchange+0x14>
    if (!(channel&IO_ASYNCH_REPLY)) {
      
      // already received the data of the apdu when received the whole apdu
      if ((channel & (CHANNEL_APDU|IO_RECEIVE_DATA)) == (CHANNEL_APDU|IO_RECEIVE_DATA)) {
        // return apdu data - header
        return G_io_apdu_length-5;
c0d03498:	480c      	ldr	r0, [pc, #48]	; (c0d034cc <io_exchange+0x238>)
c0d0349a:	8800      	ldrh	r0, [r0, #0]
c0d0349c:	9901      	ldr	r1, [sp, #4]
c0d0349e:	1840      	adds	r0, r0, r1
c0d034a0:	e702      	b.n	c0d032a8 <io_exchange+0x14>
            if (io_exchange_al(channel, tx_len) == 0) {
              goto break_send;
            }
          case APDU_IDLE:
            LOG("invalid state for APDU reply\n");
            THROW(INVALID_STATE);
c0d034a2:	2009      	movs	r0, #9
c0d034a4:	f7ff fb79 	bl	c0d02b9a <os_longjmp>
c0d034a8:	2002      	movs	r0, #2
c0d034aa:	f7ff fb76 	bl	c0d02b9a <os_longjmp>
c0d034ae:	46c0      	nop			; (mov r8, r8)
c0d034b0:	0000fffb 	.word	0x0000fffb
c0d034b4:	20001ebc 	.word	0x20001ebc
c0d034b8:	20001ecc 	.word	0x20001ecc
c0d034bc:	20001cc0 	.word	0x20001cc0
c0d034c0:	20001d4c 	.word	0x20001d4c
c0d034c4:	0000fffe 	.word	0x0000fffe
c0d034c8:	20001ea8 	.word	0x20001ea8
c0d034cc:	20001ebe 	.word	0x20001ebe
c0d034d0:	000001b0 	.word	0x000001b0
c0d034d4:	00000000 	.word	0x00000000
c0d034d8:	0000a7b0 	.word	0x0000a7b0
c0d034dc:	00000000 	.word	0x00000000
c0d034e0:	fffff98f 	.word	0xfffff98f
c0d034e4:	fffff9a5 	.word	0xfffff9a5

c0d034e8 <ux_menu_element_preprocessor>:
    return ux_menu.menu_iterator(entry_idx);
  } 
  return &ux_menu.menu_entries[entry_idx];
} 

const bagl_element_t* ux_menu_element_preprocessor(const bagl_element_t* element) {
c0d034e8:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d034ea:	b081      	sub	sp, #4
c0d034ec:	4607      	mov	r7, r0
  //todo avoid center alignment when text_x or icon_x AND text_x are not 0
  os_memmove(&ux_menu.tmp_element, element, sizeof(bagl_element_t));
c0d034ee:	4c5f      	ldr	r4, [pc, #380]	; (c0d0366c <ux_menu_element_preprocessor+0x184>)
c0d034f0:	4625      	mov	r5, r4
c0d034f2:	3514      	adds	r5, #20
c0d034f4:	2238      	movs	r2, #56	; 0x38
c0d034f6:	4628      	mov	r0, r5
c0d034f8:	4639      	mov	r1, r7
c0d034fa:	f7ff fa9a 	bl	c0d02a32 <os_memmove>
  {{BAGL_LABELINE                       , 0x22,  14,  26, 100,  12, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, NULL, 0, 0, 0, NULL, NULL, NULL },

};

const ux_menu_entry_t* ux_menu_get_entry (unsigned int entry_idx) {
  if (ux_menu.menu_iterator) {
c0d034fe:	6921      	ldr	r1, [r4, #16]
const bagl_element_t* ux_menu_element_preprocessor(const bagl_element_t* element) {
  //todo avoid center alignment when text_x or icon_x AND text_x are not 0
  os_memmove(&ux_menu.tmp_element, element, sizeof(bagl_element_t));

  // ask the current entry first, to setup other entries
  const ux_menu_entry_t* current_entry = ux_menu_get_entry(ux_menu.current_entry);
c0d03500:	68a0      	ldr	r0, [r4, #8]
  {{BAGL_LABELINE                       , 0x22,  14,  26, 100,  12, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, NULL, 0, 0, 0, NULL, NULL, NULL },

};

const ux_menu_entry_t* ux_menu_get_entry (unsigned int entry_idx) {
  if (ux_menu.menu_iterator) {
c0d03502:	2900      	cmp	r1, #0
c0d03504:	d003      	beq.n	c0d0350e <ux_menu_element_preprocessor+0x26>
    return ux_menu.menu_iterator(entry_idx);
c0d03506:	4788      	blx	r1
c0d03508:	4603      	mov	r3, r0
c0d0350a:	68a0      	ldr	r0, [r4, #8]
c0d0350c:	e003      	b.n	c0d03516 <ux_menu_element_preprocessor+0x2e>
  } 
  return &ux_menu.menu_entries[entry_idx];
c0d0350e:	211c      	movs	r1, #28
c0d03510:	4341      	muls	r1, r0
c0d03512:	6822      	ldr	r2, [r4, #0]
c0d03514:	1853      	adds	r3, r2, r1
c0d03516:	2600      	movs	r6, #0

  // ask the current entry first, to setup other entries
  const ux_menu_entry_t* current_entry = ux_menu_get_entry(ux_menu.current_entry);

  const ux_menu_entry_t* previous_entry = NULL;
  if (ux_menu.current_entry) {
c0d03518:	2800      	cmp	r0, #0
c0d0351a:	d010      	beq.n	c0d0353e <ux_menu_element_preprocessor+0x56>
  {{BAGL_LABELINE                       , 0x22,  14,  26, 100,  12, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, NULL, 0, 0, 0, NULL, NULL, NULL },

};

const ux_menu_entry_t* ux_menu_get_entry (unsigned int entry_idx) {
  if (ux_menu.menu_iterator) {
c0d0351c:	6922      	ldr	r2, [r4, #16]
  // ask the current entry first, to setup other entries
  const ux_menu_entry_t* current_entry = ux_menu_get_entry(ux_menu.current_entry);

  const ux_menu_entry_t* previous_entry = NULL;
  if (ux_menu.current_entry) {
    previous_entry = ux_menu_get_entry(ux_menu.current_entry-1);
c0d0351e:	1e41      	subs	r1, r0, #1
  {{BAGL_LABELINE                       , 0x22,  14,  26, 100,  12, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, NULL, 0, 0, 0, NULL, NULL, NULL },

};

const ux_menu_entry_t* ux_menu_get_entry (unsigned int entry_idx) {
  if (ux_menu.menu_iterator) {
c0d03520:	2a00      	cmp	r2, #0
c0d03522:	d00f      	beq.n	c0d03544 <ux_menu_element_preprocessor+0x5c>
    return ux_menu.menu_iterator(entry_idx);
c0d03524:	4608      	mov	r0, r1
c0d03526:	9700      	str	r7, [sp, #0]
c0d03528:	4637      	mov	r7, r6
c0d0352a:	462e      	mov	r6, r5
c0d0352c:	461d      	mov	r5, r3
c0d0352e:	4790      	blx	r2
c0d03530:	462b      	mov	r3, r5
c0d03532:	4635      	mov	r5, r6
c0d03534:	463e      	mov	r6, r7
c0d03536:	9f00      	ldr	r7, [sp, #0]
c0d03538:	4602      	mov	r2, r0
c0d0353a:	68a0      	ldr	r0, [r4, #8]
c0d0353c:	e006      	b.n	c0d0354c <ux_menu_element_preprocessor+0x64>
  const ux_menu_entry_t* previous_entry = NULL;
  if (ux_menu.current_entry) {
    previous_entry = ux_menu_get_entry(ux_menu.current_entry-1);
  }
  const ux_menu_entry_t* next_entry = NULL;
  if (ux_menu.current_entry < ux_menu.menu_entries_count-1) {
c0d0353e:	4630      	mov	r0, r6
c0d03540:	4632      	mov	r2, r6
c0d03542:	e003      	b.n	c0d0354c <ux_menu_element_preprocessor+0x64>

const ux_menu_entry_t* ux_menu_get_entry (unsigned int entry_idx) {
  if (ux_menu.menu_iterator) {
    return ux_menu.menu_iterator(entry_idx);
  } 
  return &ux_menu.menu_entries[entry_idx];
c0d03544:	221c      	movs	r2, #28
c0d03546:	434a      	muls	r2, r1
c0d03548:	6821      	ldr	r1, [r4, #0]
c0d0354a:	188a      	adds	r2, r1, r2
  const ux_menu_entry_t* previous_entry = NULL;
  if (ux_menu.current_entry) {
    previous_entry = ux_menu_get_entry(ux_menu.current_entry-1);
  }
  const ux_menu_entry_t* next_entry = NULL;
  if (ux_menu.current_entry < ux_menu.menu_entries_count-1) {
c0d0354c:	6861      	ldr	r1, [r4, #4]
c0d0354e:	1e49      	subs	r1, r1, #1
c0d03550:	4288      	cmp	r0, r1
c0d03552:	d210      	bcs.n	c0d03576 <ux_menu_element_preprocessor+0x8e>
  {{BAGL_LABELINE                       , 0x22,  14,  26, 100,  12, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, NULL, 0, 0, 0, NULL, NULL, NULL },

};

const ux_menu_entry_t* ux_menu_get_entry (unsigned int entry_idx) {
  if (ux_menu.menu_iterator) {
c0d03554:	6921      	ldr	r1, [r4, #16]
  if (ux_menu.current_entry) {
    previous_entry = ux_menu_get_entry(ux_menu.current_entry-1);
  }
  const ux_menu_entry_t* next_entry = NULL;
  if (ux_menu.current_entry < ux_menu.menu_entries_count-1) {
    next_entry = ux_menu_get_entry(ux_menu.current_entry+1);
c0d03556:	1c40      	adds	r0, r0, #1
  {{BAGL_LABELINE                       , 0x22,  14,  26, 100,  12, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, NULL, 0, 0, 0, NULL, NULL, NULL },

};

const ux_menu_entry_t* ux_menu_get_entry (unsigned int entry_idx) {
  if (ux_menu.menu_iterator) {
c0d03558:	2900      	cmp	r1, #0
c0d0355a:	d008      	beq.n	c0d0356e <ux_menu_element_preprocessor+0x86>
c0d0355c:	9500      	str	r5, [sp, #0]
c0d0355e:	461d      	mov	r5, r3
c0d03560:	4616      	mov	r6, r2
    return ux_menu.menu_iterator(entry_idx);
c0d03562:	4788      	blx	r1
c0d03564:	4632      	mov	r2, r6
c0d03566:	462b      	mov	r3, r5
c0d03568:	9d00      	ldr	r5, [sp, #0]
c0d0356a:	4606      	mov	r6, r0
c0d0356c:	e003      	b.n	c0d03576 <ux_menu_element_preprocessor+0x8e>
  } 
  return &ux_menu.menu_entries[entry_idx];
c0d0356e:	211c      	movs	r1, #28
c0d03570:	4341      	muls	r1, r0
c0d03572:	6820      	ldr	r0, [r4, #0]
c0d03574:	1846      	adds	r6, r0, r1
c0d03576:	7878      	ldrb	r0, [r7, #1]
  const ux_menu_entry_t* next_entry = NULL;
  if (ux_menu.current_entry < ux_menu.menu_entries_count-1) {
    next_entry = ux_menu_get_entry(ux_menu.current_entry+1);
  }

  switch(element->component.userid) {
c0d03578:	2840      	cmp	r0, #64	; 0x40
c0d0357a:	dc0a      	bgt.n	c0d03592 <ux_menu_element_preprocessor+0xaa>
c0d0357c:	2820      	cmp	r0, #32
c0d0357e:	dc22      	bgt.n	c0d035c6 <ux_menu_element_preprocessor+0xde>
c0d03580:	2810      	cmp	r0, #16
c0d03582:	d034      	beq.n	c0d035ee <ux_menu_element_preprocessor+0x106>
c0d03584:	2820      	cmp	r0, #32
c0d03586:	d167      	bne.n	c0d03658 <ux_menu_element_preprocessor+0x170>
      if (current_entry->icon_x) {
        ux_menu.tmp_element.component.x = current_entry->icon_x;
      }
      break;
    case 0x20:
      if (current_entry->line2 != NULL) {
c0d03588:	6959      	ldr	r1, [r3, #20]
c0d0358a:	2000      	movs	r0, #0
c0d0358c:	2900      	cmp	r1, #0
c0d0358e:	d16b      	bne.n	c0d03668 <ux_menu_element_preprocessor+0x180>
c0d03590:	e051      	b.n	c0d03636 <ux_menu_element_preprocessor+0x14e>
c0d03592:	2880      	cmp	r0, #128	; 0x80
c0d03594:	dc22      	bgt.n	c0d035dc <ux_menu_element_preprocessor+0xf4>
c0d03596:	2841      	cmp	r0, #65	; 0x41
c0d03598:	d033      	beq.n	c0d03602 <ux_menu_element_preprocessor+0x11a>
c0d0359a:	2842      	cmp	r0, #66	; 0x42
c0d0359c:	d15c      	bne.n	c0d03658 <ux_menu_element_preprocessor+0x170>
      }
      ux_menu.tmp_element.text = previous_entry->line1;
      break;
    // next setting name
    case 0x42:
      if (current_entry->line2 != NULL 
c0d0359e:	6959      	ldr	r1, [r3, #20]
c0d035a0:	2000      	movs	r0, #0
        || current_entry->icon != NULL
c0d035a2:	2900      	cmp	r1, #0
c0d035a4:	d160      	bne.n	c0d03668 <ux_menu_element_preprocessor+0x180>
c0d035a6:	68d9      	ldr	r1, [r3, #12]
        || ux_menu.current_entry == ux_menu.menu_entries_count-1
c0d035a8:	2900      	cmp	r1, #0
c0d035aa:	d15d      	bne.n	c0d03668 <ux_menu_element_preprocessor+0x180>
c0d035ac:	6862      	ldr	r2, [r4, #4]
c0d035ae:	1e51      	subs	r1, r2, #1
        || ux_menu.menu_entries_count == 1
c0d035b0:	2a01      	cmp	r2, #1
c0d035b2:	d059      	beq.n	c0d03668 <ux_menu_element_preprocessor+0x180>
      break;
    // next setting name
    case 0x42:
      if (current_entry->line2 != NULL 
        || current_entry->icon != NULL
        || ux_menu.current_entry == ux_menu.menu_entries_count-1
c0d035b4:	68a2      	ldr	r2, [r4, #8]
c0d035b6:	428a      	cmp	r2, r1
c0d035b8:	d056      	beq.n	c0d03668 <ux_menu_element_preprocessor+0x180>
        || ux_menu.menu_entries_count == 1
        || next_entry->icon != NULL) {
c0d035ba:	68f1      	ldr	r1, [r6, #12]
      }
      ux_menu.tmp_element.text = previous_entry->line1;
      break;
    // next setting name
    case 0x42:
      if (current_entry->line2 != NULL 
c0d035bc:	2900      	cmp	r1, #0
c0d035be:	d153      	bne.n	c0d03668 <ux_menu_element_preprocessor+0x180>
        || ux_menu.current_entry == ux_menu.menu_entries_count-1
        || ux_menu.menu_entries_count == 1
        || next_entry->icon != NULL) {
        return NULL;
      }
      ux_menu.tmp_element.text = next_entry->line1;
c0d035c0:	6930      	ldr	r0, [r6, #16]
c0d035c2:	6320      	str	r0, [r4, #48]	; 0x30
c0d035c4:	e048      	b.n	c0d03658 <ux_menu_element_preprocessor+0x170>
c0d035c6:	2821      	cmp	r0, #33	; 0x21
c0d035c8:	d031      	beq.n	c0d0362e <ux_menu_element_preprocessor+0x146>
c0d035ca:	2822      	cmp	r0, #34	; 0x22
c0d035cc:	d144      	bne.n	c0d03658 <ux_menu_element_preprocessor+0x170>
        return NULL;
      }
      ux_menu.tmp_element.text = current_entry->line1;
      goto adjust_text_x;
    case 0x22:
      if (current_entry->line2 == NULL) {
c0d035ce:	4619      	mov	r1, r3
c0d035d0:	3114      	adds	r1, #20
c0d035d2:	695a      	ldr	r2, [r3, #20]
c0d035d4:	2000      	movs	r0, #0
c0d035d6:	2a00      	cmp	r2, #0
c0d035d8:	d12f      	bne.n	c0d0363a <ux_menu_element_preprocessor+0x152>
c0d035da:	e045      	b.n	c0d03668 <ux_menu_element_preprocessor+0x180>
c0d035dc:	2882      	cmp	r0, #130	; 0x82
c0d035de:	d035      	beq.n	c0d0364c <ux_menu_element_preprocessor+0x164>
c0d035e0:	2881      	cmp	r0, #129	; 0x81
c0d035e2:	d139      	bne.n	c0d03658 <ux_menu_element_preprocessor+0x170>
    next_entry = ux_menu_get_entry(ux_menu.current_entry+1);
  }

  switch(element->component.userid) {
    case 0x81:
      if (ux_menu.current_entry == 0) {
c0d035e4:	68a1      	ldr	r1, [r4, #8]
c0d035e6:	2000      	movs	r0, #0
c0d035e8:	2900      	cmp	r1, #0
c0d035ea:	d135      	bne.n	c0d03658 <ux_menu_element_preprocessor+0x170>
c0d035ec:	e03c      	b.n	c0d03668 <ux_menu_element_preprocessor+0x180>
        return NULL;
      }
      ux_menu.tmp_element.text = next_entry->line1;
      break;
    case 0x10:
      if (current_entry->icon == NULL) {
c0d035ee:	68d9      	ldr	r1, [r3, #12]
c0d035f0:	2000      	movs	r0, #0
c0d035f2:	2900      	cmp	r1, #0
c0d035f4:	d038      	beq.n	c0d03668 <ux_menu_element_preprocessor+0x180>
        return NULL;
      }
      ux_menu.tmp_element.text = (const char*)current_entry->icon;
c0d035f6:	6321      	str	r1, [r4, #48]	; 0x30
      if (current_entry->icon_x) {
c0d035f8:	7e58      	ldrb	r0, [r3, #25]
c0d035fa:	2800      	cmp	r0, #0
c0d035fc:	d02c      	beq.n	c0d03658 <ux_menu_element_preprocessor+0x170>
        ux_menu.tmp_element.component.x = current_entry->icon_x;
c0d035fe:	82e0      	strh	r0, [r4, #22]
c0d03600:	e02a      	b.n	c0d03658 <ux_menu_element_preprocessor+0x170>
        return NULL;
      }
      break;
    // previous setting name
    case 0x41:
      if (current_entry->line2 != NULL 
c0d03602:	6959      	ldr	r1, [r3, #20]
c0d03604:	2000      	movs	r0, #0
        || current_entry->icon != NULL
c0d03606:	2900      	cmp	r1, #0
c0d03608:	d12e      	bne.n	c0d03668 <ux_menu_element_preprocessor+0x180>
c0d0360a:	68d9      	ldr	r1, [r3, #12]
        || ux_menu.current_entry == 0
c0d0360c:	2900      	cmp	r1, #0
c0d0360e:	d12b      	bne.n	c0d03668 <ux_menu_element_preprocessor+0x180>
c0d03610:	68a1      	ldr	r1, [r4, #8]
c0d03612:	2900      	cmp	r1, #0
c0d03614:	d028      	beq.n	c0d03668 <ux_menu_element_preprocessor+0x180>
        || ux_menu.menu_entries_count == 1 
c0d03616:	6861      	ldr	r1, [r4, #4]
c0d03618:	2901      	cmp	r1, #1
c0d0361a:	d025      	beq.n	c0d03668 <ux_menu_element_preprocessor+0x180>
        || previous_entry->icon != NULL
c0d0361c:	68d1      	ldr	r1, [r2, #12]
        || previous_entry->line2 != NULL) {
c0d0361e:	2900      	cmp	r1, #0
c0d03620:	d122      	bne.n	c0d03668 <ux_menu_element_preprocessor+0x180>
c0d03622:	6951      	ldr	r1, [r2, #20]
        return NULL;
      }
      break;
    // previous setting name
    case 0x41:
      if (current_entry->line2 != NULL 
c0d03624:	2900      	cmp	r1, #0
c0d03626:	d11f      	bne.n	c0d03668 <ux_menu_element_preprocessor+0x180>
        || ux_menu.menu_entries_count == 1 
        || previous_entry->icon != NULL
        || previous_entry->line2 != NULL) {
        return 0;
      }
      ux_menu.tmp_element.text = previous_entry->line1;
c0d03628:	6910      	ldr	r0, [r2, #16]
c0d0362a:	6320      	str	r0, [r4, #48]	; 0x30
c0d0362c:	e014      	b.n	c0d03658 <ux_menu_element_preprocessor+0x170>
        return NULL;
      }
      ux_menu.tmp_element.text = current_entry->line1;
      goto adjust_text_x;
    case 0x21:
      if (current_entry->line2 == NULL) {
c0d0362e:	6959      	ldr	r1, [r3, #20]
c0d03630:	2000      	movs	r0, #0
c0d03632:	2900      	cmp	r1, #0
c0d03634:	d018      	beq.n	c0d03668 <ux_menu_element_preprocessor+0x180>
c0d03636:	4619      	mov	r1, r3
c0d03638:	3110      	adds	r1, #16
c0d0363a:	6808      	ldr	r0, [r1, #0]
c0d0363c:	6320      	str	r0, [r4, #48]	; 0x30
      if (current_entry->line2 == NULL) {
        return NULL;
      }
      ux_menu.tmp_element.text = current_entry->line2;
    adjust_text_x:
      if (current_entry->text_x) {
c0d0363e:	7e18      	ldrb	r0, [r3, #24]
c0d03640:	2800      	cmp	r0, #0
c0d03642:	d009      	beq.n	c0d03658 <ux_menu_element_preprocessor+0x170>
        ux_menu.tmp_element.component.x = current_entry->text_x;
c0d03644:	82e0      	strh	r0, [r4, #22]
        // discard the 'center' flag
        ux_menu.tmp_element.component.font_id = BAGL_FONT_OPEN_SANS_EXTRABOLD_11px;
c0d03646:	2008      	movs	r0, #8
c0d03648:	85a0      	strh	r0, [r4, #44]	; 0x2c
c0d0364a:	e005      	b.n	c0d03658 <ux_menu_element_preprocessor+0x170>
      if (ux_menu.current_entry == 0) {
        return NULL;
      }
      break;
    case 0x82:
      if (ux_menu.current_entry == ux_menu.menu_entries_count-1) {
c0d0364c:	6860      	ldr	r0, [r4, #4]
c0d0364e:	68a1      	ldr	r1, [r4, #8]
c0d03650:	1e42      	subs	r2, r0, #1
c0d03652:	2000      	movs	r0, #0
c0d03654:	4291      	cmp	r1, r2
c0d03656:	d007      	beq.n	c0d03668 <ux_menu_element_preprocessor+0x180>
        ux_menu.tmp_element.component.font_id = BAGL_FONT_OPEN_SANS_EXTRABOLD_11px;
      }
      break;
  }
  // ensure prepro agrees to the element to be displayed
  if (ux_menu.menu_entry_preprocessor) {
c0d03658:	68e2      	ldr	r2, [r4, #12]
c0d0365a:	2a00      	cmp	r2, #0
c0d0365c:	4628      	mov	r0, r5
c0d0365e:	d003      	beq.n	c0d03668 <ux_menu_element_preprocessor+0x180>
    // menu is denied by the menu entry preprocessor
    return ux_menu.menu_entry_preprocessor(current_entry, &ux_menu.tmp_element);
c0d03660:	3414      	adds	r4, #20
c0d03662:	4618      	mov	r0, r3
c0d03664:	4621      	mov	r1, r4
c0d03666:	4790      	blx	r2
  }

  return &ux_menu.tmp_element;
}
c0d03668:	b001      	add	sp, #4
c0d0366a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0366c:	20001f10 	.word	0x20001f10

c0d03670 <ux_menu_elements_button>:

unsigned int ux_menu_elements_button (unsigned int button_mask, unsigned int button_mask_counter) {
c0d03670:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d03672:	b081      	sub	sp, #4
c0d03674:	4605      	mov	r5, r0
  UNUSED(button_mask_counter);

  const ux_menu_entry_t* current_entry = ux_menu_get_entry(ux_menu.current_entry);
c0d03676:	4f3d      	ldr	r7, [pc, #244]	; (c0d0376c <ux_menu_elements_button+0xfc>)
  {{BAGL_LABELINE                       , 0x22,  14,  26, 100,  12, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, NULL, 0, 0, 0, NULL, NULL, NULL },

};

const ux_menu_entry_t* ux_menu_get_entry (unsigned int entry_idx) {
  if (ux_menu.menu_iterator) {
c0d03678:	6939      	ldr	r1, [r7, #16]
}

unsigned int ux_menu_elements_button (unsigned int button_mask, unsigned int button_mask_counter) {
  UNUSED(button_mask_counter);

  const ux_menu_entry_t* current_entry = ux_menu_get_entry(ux_menu.current_entry);
c0d0367a:	68b8      	ldr	r0, [r7, #8]
  {{BAGL_LABELINE                       , 0x22,  14,  26, 100,  12, 0, 0, 0        , 0xFFFFFF, 0x000000, BAGL_FONT_OPEN_SANS_EXTRABOLD_11px|BAGL_FONT_ALIGNMENT_CENTER, 0  }, NULL, 0, 0, 0, NULL, NULL, NULL },

};

const ux_menu_entry_t* ux_menu_get_entry (unsigned int entry_idx) {
  if (ux_menu.menu_iterator) {
c0d0367c:	2900      	cmp	r1, #0
c0d0367e:	d002      	beq.n	c0d03686 <ux_menu_elements_button+0x16>
    return ux_menu.menu_iterator(entry_idx);
c0d03680:	4788      	blx	r1
c0d03682:	4606      	mov	r6, r0
c0d03684:	e003      	b.n	c0d0368e <ux_menu_elements_button+0x1e>
  } 
  return &ux_menu.menu_entries[entry_idx];
c0d03686:	211c      	movs	r1, #28
c0d03688:	4341      	muls	r1, r0
c0d0368a:	6838      	ldr	r0, [r7, #0]
c0d0368c:	1846      	adds	r6, r0, r1
c0d0368e:	2401      	movs	r4, #1
unsigned int ux_menu_elements_button (unsigned int button_mask, unsigned int button_mask_counter) {
  UNUSED(button_mask_counter);

  const ux_menu_entry_t* current_entry = ux_menu_get_entry(ux_menu.current_entry);

  switch (button_mask) {
c0d03690:	4837      	ldr	r0, [pc, #220]	; (c0d03770 <ux_menu_elements_button+0x100>)
c0d03692:	4285      	cmp	r5, r0
c0d03694:	dd14      	ble.n	c0d036c0 <ux_menu_elements_button+0x50>
c0d03696:	4837      	ldr	r0, [pc, #220]	; (c0d03774 <ux_menu_elements_button+0x104>)
c0d03698:	4285      	cmp	r5, r0
c0d0369a:	d017      	beq.n	c0d036cc <ux_menu_elements_button+0x5c>
c0d0369c:	4836      	ldr	r0, [pc, #216]	; (c0d03778 <ux_menu_elements_button+0x108>)
c0d0369e:	4285      	cmp	r5, r0
c0d036a0:	d01c      	beq.n	c0d036dc <ux_menu_elements_button+0x6c>
c0d036a2:	4836      	ldr	r0, [pc, #216]	; (c0d0377c <ux_menu_elements_button+0x10c>)
c0d036a4:	4285      	cmp	r5, r0
c0d036a6:	d15e      	bne.n	c0d03766 <ux_menu_elements_button+0xf6>
    // enter menu or exit menu
    case BUTTON_EVT_RELEASED|BUTTON_LEFT|BUTTON_RIGHT:
      // menu is priority 1
      if (current_entry->menu) {
c0d036a8:	6830      	ldr	r0, [r6, #0]
c0d036aa:	2800      	cmp	r0, #0
c0d036ac:	d052      	beq.n	c0d03754 <ux_menu_elements_button+0xe4>
        // use userid as the pointer to current entry in the parent menu
        UX_MENU_DISPLAY(current_entry->userid, (const ux_menu_entry_t*)PIC(current_entry->menu), ux_menu.menu_entry_preprocessor);
c0d036ae:	68b4      	ldr	r4, [r6, #8]
c0d036b0:	f000 fb18 	bl	c0d03ce4 <pic>
c0d036b4:	4601      	mov	r1, r0
c0d036b6:	68fa      	ldr	r2, [r7, #12]
c0d036b8:	4620      	mov	r0, r4
c0d036ba:	f000 f86d 	bl	c0d03798 <ux_menu_display>
c0d036be:	e051      	b.n	c0d03764 <ux_menu_elements_button+0xf4>
c0d036c0:	482f      	ldr	r0, [pc, #188]	; (c0d03780 <ux_menu_elements_button+0x110>)
c0d036c2:	4285      	cmp	r5, r0
c0d036c4:	d00a      	beq.n	c0d036dc <ux_menu_elements_button+0x6c>
c0d036c6:	482a      	ldr	r0, [pc, #168]	; (c0d03770 <ux_menu_elements_button+0x100>)
c0d036c8:	4285      	cmp	r5, r0
c0d036ca:	d14c      	bne.n	c0d03766 <ux_menu_elements_button+0xf6>
      goto redraw;

    case BUTTON_EVT_FAST|BUTTON_RIGHT:
    case BUTTON_EVT_RELEASED|BUTTON_RIGHT:
      // entry 0 is the number of entries in the menu list
      if (ux_menu.current_entry >= ux_menu.menu_entries_count-1) {
c0d036cc:	6879      	ldr	r1, [r7, #4]
c0d036ce:	68b8      	ldr	r0, [r7, #8]
c0d036d0:	1e4a      	subs	r2, r1, #1
c0d036d2:	2400      	movs	r4, #0
c0d036d4:	2101      	movs	r1, #1
c0d036d6:	4290      	cmp	r0, r2
c0d036d8:	d305      	bcc.n	c0d036e6 <ux_menu_elements_button+0x76>
c0d036da:	e044      	b.n	c0d03766 <ux_menu_elements_button+0xf6>
c0d036dc:	2400      	movs	r4, #0
c0d036de:	43e1      	mvns	r1, r4
      break;

    case BUTTON_EVT_FAST|BUTTON_LEFT:
    case BUTTON_EVT_RELEASED|BUTTON_LEFT:
      // entry 0 is the number of entries in the menu list
      if (ux_menu.current_entry == 0) {
c0d036e0:	68b8      	ldr	r0, [r7, #8]
c0d036e2:	2800      	cmp	r0, #0
c0d036e4:	d03f      	beq.n	c0d03766 <ux_menu_elements_button+0xf6>
c0d036e6:	1840      	adds	r0, r0, r1
c0d036e8:	60b8      	str	r0, [r7, #8]
  io_seproxyhal_init_button();
}

void io_seproxyhal_init_ux(void) {
  // initialize the touch part
  G_bagl_last_touched_not_released_component = NULL;
c0d036ea:	4826      	ldr	r0, [pc, #152]	; (c0d03784 <ux_menu_elements_button+0x114>)
c0d036ec:	2400      	movs	r4, #0
c0d036ee:	6004      	str	r4, [r0, #0]
}

void io_seproxyhal_init_button(void) {
  // no button push so far
  G_button_mask = 0;
c0d036f0:	4825      	ldr	r0, [pc, #148]	; (c0d03788 <ux_menu_elements_button+0x118>)
c0d036f2:	6004      	str	r4, [r0, #0]
  G_button_same_mask_counter = 0;
c0d036f4:	4825      	ldr	r0, [pc, #148]	; (c0d0378c <ux_menu_elements_button+0x11c>)
c0d036f6:	6004      	str	r4, [r0, #0]
      ux_menu.current_entry++;
    redraw:
#ifdef HAVE_BOLOS_UX
      screen_display_init(0);
#else
      UX_REDISPLAY();
c0d036f8:	4d25      	ldr	r5, [pc, #148]	; (c0d03790 <ux_menu_elements_button+0x120>)
c0d036fa:	60ac      	str	r4, [r5, #8]
c0d036fc:	6828      	ldr	r0, [r5, #0]
c0d036fe:	2800      	cmp	r0, #0
c0d03700:	d031      	beq.n	c0d03766 <ux_menu_elements_button+0xf6>
c0d03702:	69e8      	ldr	r0, [r5, #28]
c0d03704:	4923      	ldr	r1, [pc, #140]	; (c0d03794 <ux_menu_elements_button+0x124>)
c0d03706:	4288      	cmp	r0, r1
c0d03708:	d02d      	beq.n	c0d03766 <ux_menu_elements_button+0xf6>
c0d0370a:	2800      	cmp	r0, #0
c0d0370c:	d02b      	beq.n	c0d03766 <ux_menu_elements_button+0xf6>
c0d0370e:	2400      	movs	r4, #0
c0d03710:	4620      	mov	r0, r4
c0d03712:	6869      	ldr	r1, [r5, #4]
c0d03714:	4288      	cmp	r0, r1
c0d03716:	d226      	bcs.n	c0d03766 <ux_menu_elements_button+0xf6>
c0d03718:	f000 fcf2 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d0371c:	2800      	cmp	r0, #0
c0d0371e:	d122      	bne.n	c0d03766 <ux_menu_elements_button+0xf6>
c0d03720:	68a8      	ldr	r0, [r5, #8]
c0d03722:	68e9      	ldr	r1, [r5, #12]
c0d03724:	2638      	movs	r6, #56	; 0x38
c0d03726:	4370      	muls	r0, r6
c0d03728:	682a      	ldr	r2, [r5, #0]
c0d0372a:	1810      	adds	r0, r2, r0
c0d0372c:	2900      	cmp	r1, #0
c0d0372e:	d002      	beq.n	c0d03736 <ux_menu_elements_button+0xc6>
c0d03730:	4788      	blx	r1
c0d03732:	2800      	cmp	r0, #0
c0d03734:	d007      	beq.n	c0d03746 <ux_menu_elements_button+0xd6>
c0d03736:	2801      	cmp	r0, #1
c0d03738:	d103      	bne.n	c0d03742 <ux_menu_elements_button+0xd2>
c0d0373a:	68a8      	ldr	r0, [r5, #8]
c0d0373c:	4346      	muls	r6, r0
c0d0373e:	6828      	ldr	r0, [r5, #0]
c0d03740:	1980      	adds	r0, r0, r6
c0d03742:	f7fe f96d 	bl	c0d01a20 <io_seproxyhal_display>
c0d03746:	68a8      	ldr	r0, [r5, #8]
c0d03748:	1c40      	adds	r0, r0, #1
c0d0374a:	60a8      	str	r0, [r5, #8]
c0d0374c:	6829      	ldr	r1, [r5, #0]
c0d0374e:	2900      	cmp	r1, #0
c0d03750:	d1df      	bne.n	c0d03712 <ux_menu_elements_button+0xa2>
c0d03752:	e008      	b.n	c0d03766 <ux_menu_elements_button+0xf6>
        // use userid as the pointer to current entry in the parent menu
        UX_MENU_DISPLAY(current_entry->userid, (const ux_menu_entry_t*)PIC(current_entry->menu), ux_menu.menu_entry_preprocessor);
        return 0;
      }
      // else callback
      else if (current_entry->callback) {
c0d03754:	6870      	ldr	r0, [r6, #4]
c0d03756:	2800      	cmp	r0, #0
c0d03758:	d005      	beq.n	c0d03766 <ux_menu_elements_button+0xf6>
        ((ux_menu_callback_t)PIC(current_entry->callback))(current_entry->userid);
c0d0375a:	f000 fac3 	bl	c0d03ce4 <pic>
c0d0375e:	4601      	mov	r1, r0
c0d03760:	68b0      	ldr	r0, [r6, #8]
c0d03762:	4788      	blx	r1
c0d03764:	2400      	movs	r4, #0
      UX_REDISPLAY();
#endif
      return 0;
  }
  return 1;
}
c0d03766:	4620      	mov	r0, r4
c0d03768:	b001      	add	sp, #4
c0d0376a:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0376c:	20001f10 	.word	0x20001f10
c0d03770:	80000002 	.word	0x80000002
c0d03774:	40000002 	.word	0x40000002
c0d03778:	40000001 	.word	0x40000001
c0d0377c:	80000003 	.word	0x80000003
c0d03780:	80000001 	.word	0x80000001
c0d03784:	20001ec0 	.word	0x20001ec0
c0d03788:	20001ec4 	.word	0x20001ec4
c0d0378c:	20001ec8 	.word	0x20001ec8
c0d03790:	20001898 	.word	0x20001898
c0d03794:	b0105044 	.word	0xb0105044

c0d03798 <ux_menu_display>:

const ux_menu_entry_t UX_MENU_END_ENTRY = UX_MENU_END;

void ux_menu_display(unsigned int current_entry, 
                     const ux_menu_entry_t* menu_entries,
                     ux_menu_preprocessor_t menu_entry_preprocessor) {
c0d03798:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0379a:	b083      	sub	sp, #12
c0d0379c:	9202      	str	r2, [sp, #8]
c0d0379e:	460d      	mov	r5, r1
c0d037a0:	9001      	str	r0, [sp, #4]
  // reset to first entry
  ux_menu.menu_entries_count = 0;
c0d037a2:	4e39      	ldr	r6, [pc, #228]	; (c0d03888 <ux_menu_display+0xf0>)
c0d037a4:	2000      	movs	r0, #0
c0d037a6:	9000      	str	r0, [sp, #0]
c0d037a8:	6070      	str	r0, [r6, #4]

  // count entries
  if (menu_entries) {
c0d037aa:	2d00      	cmp	r5, #0
c0d037ac:	d015      	beq.n	c0d037da <ux_menu_display+0x42>
    for(;;) {
      if (os_memcmp(&menu_entries[ux_menu.menu_entries_count], &UX_MENU_END_ENTRY, sizeof(ux_menu_entry_t)) == 0) {
c0d037ae:	493c      	ldr	r1, [pc, #240]	; (c0d038a0 <ux_menu_display+0x108>)
c0d037b0:	4479      	add	r1, pc
c0d037b2:	271c      	movs	r7, #28
c0d037b4:	4628      	mov	r0, r5
c0d037b6:	463a      	mov	r2, r7
c0d037b8:	f7ff f9d8 	bl	c0d02b6c <os_memcmp>
c0d037bc:	2800      	cmp	r0, #0
c0d037be:	d00c      	beq.n	c0d037da <ux_menu_display+0x42>
c0d037c0:	4c38      	ldr	r4, [pc, #224]	; (c0d038a4 <ux_menu_display+0x10c>)
c0d037c2:	447c      	add	r4, pc
        break;
      }
      ux_menu.menu_entries_count++;
c0d037c4:	6870      	ldr	r0, [r6, #4]
c0d037c6:	1c40      	adds	r0, r0, #1
c0d037c8:	6070      	str	r0, [r6, #4]
  ux_menu.menu_entries_count = 0;

  // count entries
  if (menu_entries) {
    for(;;) {
      if (os_memcmp(&menu_entries[ux_menu.menu_entries_count], &UX_MENU_END_ENTRY, sizeof(ux_menu_entry_t)) == 0) {
c0d037ca:	4378      	muls	r0, r7
c0d037cc:	1828      	adds	r0, r5, r0
c0d037ce:	4621      	mov	r1, r4
c0d037d0:	463a      	mov	r2, r7
c0d037d2:	f7ff f9cb 	bl	c0d02b6c <os_memcmp>
c0d037d6:	2800      	cmp	r0, #0
c0d037d8:	d1f4      	bne.n	c0d037c4 <ux_menu_display+0x2c>
c0d037da:	9901      	ldr	r1, [sp, #4]
      }
      ux_menu.menu_entries_count++;
    }
  }

  if (current_entry != UX_MENU_UNCHANGED_ENTRY) {
c0d037dc:	4608      	mov	r0, r1
c0d037de:	3001      	adds	r0, #1
c0d037e0:	d005      	beq.n	c0d037ee <ux_menu_display+0x56>
    ux_menu.current_entry = current_entry;
    if (ux_menu.current_entry > ux_menu.menu_entries_count) {
c0d037e2:	6870      	ldr	r0, [r6, #4]
c0d037e4:	4288      	cmp	r0, r1
c0d037e6:	9800      	ldr	r0, [sp, #0]
c0d037e8:	d300      	bcc.n	c0d037ec <ux_menu_display+0x54>
c0d037ea:	4608      	mov	r0, r1
      ux_menu.current_entry = 0;
c0d037ec:	60b0      	str	r0, [r6, #8]
    }
  }
  ux_menu.menu_entries = menu_entries;
c0d037ee:	6035      	str	r5, [r6, #0]
c0d037f0:	2500      	movs	r5, #0
  ux_menu.menu_entry_preprocessor = menu_entry_preprocessor;
c0d037f2:	9802      	ldr	r0, [sp, #8]
c0d037f4:	60f0      	str	r0, [r6, #12]
  ux_menu.menu_iterator = NULL;
c0d037f6:	6135      	str	r5, [r6, #16]
  G_bolos_ux_context.screen_stack[0].button_push_callback = ux_menu_elements_button;

  screen_display_init(0);
#else
  // display the menu current entry
  UX_DISPLAY(ux_menu_elements, ux_menu_element_preprocessor);
c0d037f8:	4c24      	ldr	r4, [pc, #144]	; (c0d0388c <ux_menu_display+0xf4>)
c0d037fa:	482b      	ldr	r0, [pc, #172]	; (c0d038a8 <ux_menu_display+0x110>)
c0d037fc:	4478      	add	r0, pc
c0d037fe:	6020      	str	r0, [r4, #0]
c0d03800:	2009      	movs	r0, #9
c0d03802:	6060      	str	r0, [r4, #4]
c0d03804:	4829      	ldr	r0, [pc, #164]	; (c0d038ac <ux_menu_display+0x114>)
c0d03806:	4478      	add	r0, pc
c0d03808:	6120      	str	r0, [r4, #16]
c0d0380a:	4829      	ldr	r0, [pc, #164]	; (c0d038b0 <ux_menu_display+0x118>)
c0d0380c:	4478      	add	r0, pc
c0d0380e:	60e0      	str	r0, [r4, #12]
c0d03810:	2003      	movs	r0, #3
c0d03812:	7620      	strb	r0, [r4, #24]
c0d03814:	61e5      	str	r5, [r4, #28]
c0d03816:	4620      	mov	r0, r4
c0d03818:	3018      	adds	r0, #24
c0d0381a:	f000 fc01 	bl	c0d04020 <os_ux>
c0d0381e:	61e0      	str	r0, [r4, #28]
c0d03820:	f000 f848 	bl	c0d038b4 <ux_check_status_default>
  io_seproxyhal_init_button();
}

void io_seproxyhal_init_ux(void) {
  // initialize the touch part
  G_bagl_last_touched_not_released_component = NULL;
c0d03824:	481a      	ldr	r0, [pc, #104]	; (c0d03890 <ux_menu_display+0xf8>)
c0d03826:	6005      	str	r5, [r0, #0]
}

void io_seproxyhal_init_button(void) {
  // no button push so far
  G_button_mask = 0;
c0d03828:	481a      	ldr	r0, [pc, #104]	; (c0d03894 <ux_menu_display+0xfc>)
c0d0382a:	6005      	str	r5, [r0, #0]
  G_button_same_mask_counter = 0;
c0d0382c:	481a      	ldr	r0, [pc, #104]	; (c0d03898 <ux_menu_display+0x100>)
c0d0382e:	6005      	str	r5, [r0, #0]
  G_bolos_ux_context.screen_stack[0].button_push_callback = ux_menu_elements_button;

  screen_display_init(0);
#else
  // display the menu current entry
  UX_DISPLAY(ux_menu_elements, ux_menu_element_preprocessor);
c0d03830:	60a5      	str	r5, [r4, #8]
c0d03832:	6820      	ldr	r0, [r4, #0]
c0d03834:	2800      	cmp	r0, #0
c0d03836:	d024      	beq.n	c0d03882 <ux_menu_display+0xea>
c0d03838:	69e0      	ldr	r0, [r4, #28]
c0d0383a:	4918      	ldr	r1, [pc, #96]	; (c0d0389c <ux_menu_display+0x104>)
c0d0383c:	4288      	cmp	r0, r1
c0d0383e:	d11e      	bne.n	c0d0387e <ux_menu_display+0xe6>
c0d03840:	e01f      	b.n	c0d03882 <ux_menu_display+0xea>
c0d03842:	6860      	ldr	r0, [r4, #4]
c0d03844:	4285      	cmp	r5, r0
c0d03846:	d21c      	bcs.n	c0d03882 <ux_menu_display+0xea>
c0d03848:	f000 fc5a 	bl	c0d04100 <io_seproxyhal_spi_is_status_sent>
c0d0384c:	2800      	cmp	r0, #0
c0d0384e:	d118      	bne.n	c0d03882 <ux_menu_display+0xea>
c0d03850:	68a0      	ldr	r0, [r4, #8]
c0d03852:	68e1      	ldr	r1, [r4, #12]
c0d03854:	2538      	movs	r5, #56	; 0x38
c0d03856:	4368      	muls	r0, r5
c0d03858:	6822      	ldr	r2, [r4, #0]
c0d0385a:	1810      	adds	r0, r2, r0
c0d0385c:	2900      	cmp	r1, #0
c0d0385e:	d002      	beq.n	c0d03866 <ux_menu_display+0xce>
c0d03860:	4788      	blx	r1
c0d03862:	2800      	cmp	r0, #0
c0d03864:	d007      	beq.n	c0d03876 <ux_menu_display+0xde>
c0d03866:	2801      	cmp	r0, #1
c0d03868:	d103      	bne.n	c0d03872 <ux_menu_display+0xda>
c0d0386a:	68a0      	ldr	r0, [r4, #8]
c0d0386c:	4345      	muls	r5, r0
c0d0386e:	6820      	ldr	r0, [r4, #0]
c0d03870:	1940      	adds	r0, r0, r5
c0d03872:	f7fe f8d5 	bl	c0d01a20 <io_seproxyhal_display>
c0d03876:	68a0      	ldr	r0, [r4, #8]
c0d03878:	1c45      	adds	r5, r0, #1
c0d0387a:	60a5      	str	r5, [r4, #8]
c0d0387c:	6820      	ldr	r0, [r4, #0]
c0d0387e:	2800      	cmp	r0, #0
c0d03880:	d1df      	bne.n	c0d03842 <ux_menu_display+0xaa>
#endif
}
c0d03882:	b003      	add	sp, #12
c0d03884:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d03886:	46c0      	nop			; (mov r8, r8)
c0d03888:	20001f10 	.word	0x20001f10
c0d0388c:	20001898 	.word	0x20001898
c0d03890:	20001ec0 	.word	0x20001ec0
c0d03894:	20001ec4 	.word	0x20001ec4
c0d03898:	20001ec8 	.word	0x20001ec8
c0d0389c:	b0105044 	.word	0xb0105044
c0d038a0:	000047d0 	.word	0x000047d0
c0d038a4:	000047be 	.word	0x000047be
c0d038a8:	0000458c 	.word	0x0000458c
c0d038ac:	fffffe67 	.word	0xfffffe67
c0d038b0:	fffffcd9 	.word	0xfffffcd9

c0d038b4 <ux_check_status_default>:
}

void ux_check_status_default(unsigned int status) {
  // nothing to be done here by default.
  UNUSED(status);
}
c0d038b4:	4770      	bx	lr
	...

c0d038b8 <snprintf>:
#endif // HAVE_PRINTF

#ifdef HAVE_SPRINTF
//unsigned int snprintf(unsigned char * str, unsigned int str_size, const char* format, ...)
int snprintf(char * str, size_t str_size, const char * format, ...)
 {
c0d038b8:	b081      	sub	sp, #4
c0d038ba:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d038bc:	b090      	sub	sp, #64	; 0x40
c0d038be:	4616      	mov	r6, r2
c0d038c0:	460c      	mov	r4, r1
c0d038c2:	900a      	str	r0, [sp, #40]	; 0x28
c0d038c4:	9315      	str	r3, [sp, #84]	; 0x54
    char cStrlenSet;
    
    //
    // Check the arguments.
    //
    if(format == 0 || str == 0 ||str_size < 2) {
c0d038c6:	2c02      	cmp	r4, #2
c0d038c8:	d200      	bcs.n	c0d038cc <snprintf+0x14>
c0d038ca:	e1f0      	b.n	c0d03cae <snprintf+0x3f6>
c0d038cc:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d038ce:	2800      	cmp	r0, #0
c0d038d0:	d100      	bne.n	c0d038d4 <snprintf+0x1c>
c0d038d2:	e1ec      	b.n	c0d03cae <snprintf+0x3f6>
c0d038d4:	2e00      	cmp	r6, #0
c0d038d6:	d100      	bne.n	c0d038da <snprintf+0x22>
c0d038d8:	e1e9      	b.n	c0d03cae <snprintf+0x3f6>
c0d038da:	2100      	movs	r1, #0
      return 0;
    }

    // ensure terminating string with a \0
    os_memset(str, 0, str_size);
c0d038dc:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d038de:	9107      	str	r1, [sp, #28]
c0d038e0:	4622      	mov	r2, r4
c0d038e2:	f7ff f89d 	bl	c0d02a20 <os_memset>
c0d038e6:	a815      	add	r0, sp, #84	; 0x54


    //
    // Start the varargs processing.
    //
    va_start(vaArgP, format);
c0d038e8:	900b      	str	r0, [sp, #44]	; 0x2c

    //
    // Loop while there are more characters in the string.
    //
    while(*format)
c0d038ea:	7830      	ldrb	r0, [r6, #0]
c0d038ec:	2800      	cmp	r0, #0
c0d038ee:	d100      	bne.n	c0d038f2 <snprintf+0x3a>
c0d038f0:	e1dd      	b.n	c0d03cae <snprintf+0x3f6>
c0d038f2:	9907      	ldr	r1, [sp, #28]
c0d038f4:	43c9      	mvns	r1, r1
      return 0;
    }

    // ensure terminating string with a \0
    os_memset(str, 0, str_size);
    str_size--;
c0d038f6:	1e65      	subs	r5, r4, #1
c0d038f8:	9105      	str	r1, [sp, #20]
c0d038fa:	e1bd      	b.n	c0d03c78 <snprintf+0x3c0>
        }

        //
        // Skip the portion of the string that was written.
        //
        format += ulIdx;
c0d038fc:	1930      	adds	r0, r6, r4

        //
        // See if the next character is a %.
        //
        if(*format == '%')
c0d038fe:	5d31      	ldrb	r1, [r6, r4]
c0d03900:	2925      	cmp	r1, #37	; 0x25
c0d03902:	d10b      	bne.n	c0d0391c <snprintf+0x64>
c0d03904:	9303      	str	r3, [sp, #12]
c0d03906:	9202      	str	r2, [sp, #8]
        {
            //
            // Skip the %.
            //
            format++;
c0d03908:	1c43      	adds	r3, r0, #1
c0d0390a:	2000      	movs	r0, #0
c0d0390c:	2120      	movs	r1, #32
c0d0390e:	9108      	str	r1, [sp, #32]
c0d03910:	210a      	movs	r1, #10
c0d03912:	9101      	str	r1, [sp, #4]
c0d03914:	9000      	str	r0, [sp, #0]
c0d03916:	9004      	str	r0, [sp, #16]
c0d03918:	9009      	str	r0, [sp, #36]	; 0x24
c0d0391a:	e056      	b.n	c0d039ca <snprintf+0x112>
c0d0391c:	4606      	mov	r6, r0
c0d0391e:	920a      	str	r2, [sp, #40]	; 0x28
c0d03920:	e11e      	b.n	c0d03b60 <snprintf+0x2a8>
c0d03922:	4633      	mov	r3, r6
c0d03924:	4608      	mov	r0, r1
c0d03926:	e04b      	b.n	c0d039c0 <snprintf+0x108>
c0d03928:	2b47      	cmp	r3, #71	; 0x47
c0d0392a:	dc13      	bgt.n	c0d03954 <snprintf+0x9c>
c0d0392c:	4619      	mov	r1, r3
c0d0392e:	3930      	subs	r1, #48	; 0x30
c0d03930:	290a      	cmp	r1, #10
c0d03932:	d234      	bcs.n	c0d0399e <snprintf+0xe6>
                {
                    //
                    // If this is a zero, and it is the first digit, then the
                    // fill character is a zero instead of a space.
                    //
                    if((format[-1] == '0') && (ulCount == 0))
c0d03934:	2b30      	cmp	r3, #48	; 0x30
c0d03936:	9908      	ldr	r1, [sp, #32]
c0d03938:	d100      	bne.n	c0d0393c <snprintf+0x84>
c0d0393a:	4619      	mov	r1, r3
c0d0393c:	9d09      	ldr	r5, [sp, #36]	; 0x24
c0d0393e:	2d00      	cmp	r5, #0
c0d03940:	d000      	beq.n	c0d03944 <snprintf+0x8c>
c0d03942:	9908      	ldr	r1, [sp, #32]
                    }

                    //
                    // Update the digit count.
                    //
                    ulCount *= 10;
c0d03944:	220a      	movs	r2, #10
c0d03946:	436a      	muls	r2, r5
                    ulCount += format[-1] - '0';
c0d03948:	18d2      	adds	r2, r2, r3
c0d0394a:	3a30      	subs	r2, #48	; 0x30
c0d0394c:	9209      	str	r2, [sp, #36]	; 0x24
c0d0394e:	4633      	mov	r3, r6
c0d03950:	9108      	str	r1, [sp, #32]
c0d03952:	e03a      	b.n	c0d039ca <snprintf+0x112>
c0d03954:	2b67      	cmp	r3, #103	; 0x67
c0d03956:	dd04      	ble.n	c0d03962 <snprintf+0xaa>
c0d03958:	2b72      	cmp	r3, #114	; 0x72
c0d0395a:	dd09      	ble.n	c0d03970 <snprintf+0xb8>
c0d0395c:	2b73      	cmp	r3, #115	; 0x73
c0d0395e:	d146      	bne.n	c0d039ee <snprintf+0x136>
c0d03960:	e00a      	b.n	c0d03978 <snprintf+0xc0>
c0d03962:	2b62      	cmp	r3, #98	; 0x62
c0d03964:	dc48      	bgt.n	c0d039f8 <snprintf+0x140>
c0d03966:	2b48      	cmp	r3, #72	; 0x48
c0d03968:	d155      	bne.n	c0d03a16 <snprintf+0x15e>
c0d0396a:	2201      	movs	r2, #1
c0d0396c:	9204      	str	r2, [sp, #16]
c0d0396e:	e001      	b.n	c0d03974 <snprintf+0xbc>
c0d03970:	2b68      	cmp	r3, #104	; 0x68
c0d03972:	d156      	bne.n	c0d03a22 <snprintf+0x16a>
c0d03974:	2210      	movs	r2, #16
c0d03976:	9201      	str	r2, [sp, #4]
                case_s:
                {
                    //
                    // Get the string pointer from the varargs.
                    //
                    pcStr = va_arg(vaArgP, char *);
c0d03978:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
c0d0397a:	1d13      	adds	r3, r2, #4
c0d0397c:	930b      	str	r3, [sp, #44]	; 0x2c
c0d0397e:	2303      	movs	r3, #3
c0d03980:	4018      	ands	r0, r3
c0d03982:	1c4d      	adds	r5, r1, #1
c0d03984:	6811      	ldr	r1, [r2, #0]

                    //
                    // Determine the length of the string. (if not specified using .*)
                    //
                    switch(cStrlenSet) {
c0d03986:	2801      	cmp	r0, #1
c0d03988:	d100      	bne.n	c0d0398c <snprintf+0xd4>
c0d0398a:	e0ce      	b.n	c0d03b2a <snprintf+0x272>
c0d0398c:	2802      	cmp	r0, #2
c0d0398e:	d100      	bne.n	c0d03992 <snprintf+0xda>
c0d03990:	e0d0      	b.n	c0d03b34 <snprintf+0x27c>
c0d03992:	2803      	cmp	r0, #3
c0d03994:	4633      	mov	r3, r6
c0d03996:	4628      	mov	r0, r5
c0d03998:	9d06      	ldr	r5, [sp, #24]
c0d0399a:	d016      	beq.n	c0d039ca <snprintf+0x112>
c0d0399c:	e0e7      	b.n	c0d03b6e <snprintf+0x2b6>
c0d0399e:	2b2e      	cmp	r3, #46	; 0x2e
c0d039a0:	d000      	beq.n	c0d039a4 <snprintf+0xec>
c0d039a2:	e0ca      	b.n	c0d03b3a <snprintf+0x282>
                // special %.*H or %.*h format to print a given length of hex digits (case: H UPPER, h lower)
                //
                case '.':
                {
                  // ensure next char is '*' and next one is 's'/'h'/'H'
                  if (format[0] == '*' && (format[1] == 's' || format[1] == 'H' || format[1] == 'h')) {
c0d039a4:	7830      	ldrb	r0, [r6, #0]
c0d039a6:	282a      	cmp	r0, #42	; 0x2a
c0d039a8:	d000      	beq.n	c0d039ac <snprintf+0xf4>
c0d039aa:	e0c6      	b.n	c0d03b3a <snprintf+0x282>
c0d039ac:	7871      	ldrb	r1, [r6, #1]
c0d039ae:	1c73      	adds	r3, r6, #1
c0d039b0:	2001      	movs	r0, #1
c0d039b2:	2948      	cmp	r1, #72	; 0x48
c0d039b4:	d004      	beq.n	c0d039c0 <snprintf+0x108>
c0d039b6:	2968      	cmp	r1, #104	; 0x68
c0d039b8:	d002      	beq.n	c0d039c0 <snprintf+0x108>
c0d039ba:	2973      	cmp	r1, #115	; 0x73
c0d039bc:	d000      	beq.n	c0d039c0 <snprintf+0x108>
c0d039be:	e0bc      	b.n	c0d03b3a <snprintf+0x282>
c0d039c0:	990b      	ldr	r1, [sp, #44]	; 0x2c
c0d039c2:	1d0a      	adds	r2, r1, #4
c0d039c4:	920b      	str	r2, [sp, #44]	; 0x2c
c0d039c6:	6809      	ldr	r1, [r1, #0]
int snprintf(char * str, size_t str_size, const char * format, ...)
 {
    unsigned int ulIdx, ulValue, ulPos, ulCount, ulBase, ulNeg, ulStrlen, ulCap;
    char *pcStr, pcBuf[16], cFill;
    va_list vaArgP;
    char cStrlenSet;
c0d039c8:	9100      	str	r1, [sp, #0]
c0d039ca:	2102      	movs	r1, #2
c0d039cc:	461e      	mov	r6, r3
again:

            //
            // Determine how to handle the next character.
            //
            switch(*format++)
c0d039ce:	7833      	ldrb	r3, [r6, #0]
c0d039d0:	1c76      	adds	r6, r6, #1
c0d039d2:	2200      	movs	r2, #0
c0d039d4:	2b2d      	cmp	r3, #45	; 0x2d
c0d039d6:	dca7      	bgt.n	c0d03928 <snprintf+0x70>
c0d039d8:	4610      	mov	r0, r2
c0d039da:	d0f8      	beq.n	c0d039ce <snprintf+0x116>
c0d039dc:	2b25      	cmp	r3, #37	; 0x25
c0d039de:	d02a      	beq.n	c0d03a36 <snprintf+0x17e>
c0d039e0:	2b2a      	cmp	r3, #42	; 0x2a
c0d039e2:	d000      	beq.n	c0d039e6 <snprintf+0x12e>
c0d039e4:	e0a9      	b.n	c0d03b3a <snprintf+0x282>
                  goto error;
                }
                
                case '*':
                {
                  if (*format == 's' ) {                    
c0d039e6:	7830      	ldrb	r0, [r6, #0]
c0d039e8:	2873      	cmp	r0, #115	; 0x73
c0d039ea:	d09a      	beq.n	c0d03922 <snprintf+0x6a>
c0d039ec:	e0a5      	b.n	c0d03b3a <snprintf+0x282>
c0d039ee:	2b75      	cmp	r3, #117	; 0x75
c0d039f0:	d023      	beq.n	c0d03a3a <snprintf+0x182>
c0d039f2:	2b78      	cmp	r3, #120	; 0x78
c0d039f4:	d018      	beq.n	c0d03a28 <snprintf+0x170>
c0d039f6:	e0a0      	b.n	c0d03b3a <snprintf+0x282>
c0d039f8:	2b63      	cmp	r3, #99	; 0x63
c0d039fa:	d100      	bne.n	c0d039fe <snprintf+0x146>
c0d039fc:	e08b      	b.n	c0d03b16 <snprintf+0x25e>
c0d039fe:	2b64      	cmp	r3, #100	; 0x64
c0d03a00:	d000      	beq.n	c0d03a04 <snprintf+0x14c>
c0d03a02:	e09a      	b.n	c0d03b3a <snprintf+0x282>
                case 'd':
                {
                    //
                    // Get the value from the varargs.
                    //
                    ulValue = va_arg(vaArgP, unsigned long);
c0d03a04:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d03a06:	1d01      	adds	r1, r0, #4
c0d03a08:	910b      	str	r1, [sp, #44]	; 0x2c
c0d03a0a:	6800      	ldr	r0, [r0, #0]
c0d03a0c:	17c1      	asrs	r1, r0, #31
c0d03a0e:	1842      	adds	r2, r0, r1
c0d03a10:	404a      	eors	r2, r1

                    //
                    // If the value is negative, make it positive and indicate
                    // that a minus sign is needed.
                    //
                    if((long)ulValue < 0)
c0d03a12:	0fc0      	lsrs	r0, r0, #31
c0d03a14:	e016      	b.n	c0d03a44 <snprintf+0x18c>
c0d03a16:	2b58      	cmp	r3, #88	; 0x58
c0d03a18:	d000      	beq.n	c0d03a1c <snprintf+0x164>
c0d03a1a:	e08e      	b.n	c0d03b3a <snprintf+0x282>
c0d03a1c:	2001      	movs	r0, #1

#ifdef HAVE_SPRINTF
//unsigned int snprintf(unsigned char * str, unsigned int str_size, const char* format, ...)
int snprintf(char * str, size_t str_size, const char * format, ...)
 {
    unsigned int ulIdx, ulValue, ulPos, ulCount, ulBase, ulNeg, ulStrlen, ulCap;
c0d03a1e:	9004      	str	r0, [sp, #16]
c0d03a20:	e002      	b.n	c0d03a28 <snprintf+0x170>
c0d03a22:	2b70      	cmp	r3, #112	; 0x70
c0d03a24:	d000      	beq.n	c0d03a28 <snprintf+0x170>
c0d03a26:	e088      	b.n	c0d03b3a <snprintf+0x282>
                case 'p':
                {
                    //
                    // Get the value from the varargs.
                    //
                    ulValue = va_arg(vaArgP, unsigned long);
c0d03a28:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d03a2a:	1d01      	adds	r1, r0, #4
c0d03a2c:	910b      	str	r1, [sp, #44]	; 0x2c
c0d03a2e:	6802      	ldr	r2, [r0, #0]
c0d03a30:	2000      	movs	r0, #0
c0d03a32:	2510      	movs	r5, #16
c0d03a34:	e007      	b.n	c0d03a46 <snprintf+0x18e>
                case '%':
                {
                    //
                    // Simply write a single %.
                    //
                    str[0] = '%';
c0d03a36:	2025      	movs	r0, #37	; 0x25
c0d03a38:	e071      	b.n	c0d03b1e <snprintf+0x266>
                case 'u':
                {
                    //
                    // Get the value from the varargs.
                    //
                    ulValue = va_arg(vaArgP, unsigned long);
c0d03a3a:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d03a3c:	1d01      	adds	r1, r0, #4
c0d03a3e:	910b      	str	r1, [sp, #44]	; 0x2c
c0d03a40:	6802      	ldr	r2, [r0, #0]
c0d03a42:	2000      	movs	r0, #0
c0d03a44:	250a      	movs	r5, #10
c0d03a46:	9006      	str	r0, [sp, #24]
c0d03a48:	2701      	movs	r7, #1
c0d03a4a:	920a      	str	r2, [sp, #40]	; 0x28
                    // Determine the number of digits in the string version of
                    // the value.
                    //
convert:
                    for(ulIdx = 1;
                        (((ulIdx * ulBase) <= ulValue) &&
c0d03a4c:	4295      	cmp	r5, r2
c0d03a4e:	d812      	bhi.n	c0d03a76 <snprintf+0x1be>
c0d03a50:	2401      	movs	r4, #1
c0d03a52:	4628      	mov	r0, r5
c0d03a54:	4607      	mov	r7, r0
                         (((ulIdx * ulBase) / ulBase) == ulIdx));
c0d03a56:	4629      	mov	r1, r5
c0d03a58:	f003 f962 	bl	c0d06d20 <__aeabi_uidiv>
                    //
                    // Determine the number of digits in the string version of
                    // the value.
                    //
convert:
                    for(ulIdx = 1;
c0d03a5c:	42a0      	cmp	r0, r4
c0d03a5e:	d109      	bne.n	c0d03a74 <snprintf+0x1bc>
                        (((ulIdx * ulBase) <= ulValue) &&
c0d03a60:	4628      	mov	r0, r5
c0d03a62:	4378      	muls	r0, r7
                         (((ulIdx * ulBase) / ulBase) == ulIdx));
                        ulIdx *= ulBase, ulCount--)
c0d03a64:	9909      	ldr	r1, [sp, #36]	; 0x24
c0d03a66:	1e49      	subs	r1, r1, #1
                    // Determine the number of digits in the string version of
                    // the value.
                    //
convert:
                    for(ulIdx = 1;
                        (((ulIdx * ulBase) <= ulValue) &&
c0d03a68:	9109      	str	r1, [sp, #36]	; 0x24
c0d03a6a:	990a      	ldr	r1, [sp, #40]	; 0x28
c0d03a6c:	4288      	cmp	r0, r1
c0d03a6e:	463c      	mov	r4, r7
c0d03a70:	d9f0      	bls.n	c0d03a54 <snprintf+0x19c>
c0d03a72:	e000      	b.n	c0d03a76 <snprintf+0x1be>
c0d03a74:	4627      	mov	r7, r4

                    //
                    // If the value is negative, reduce the count of padding
                    // characters needed.
                    //
                    if(ulNeg)
c0d03a76:	2400      	movs	r4, #0
c0d03a78:	43e1      	mvns	r1, r4
c0d03a7a:	9b06      	ldr	r3, [sp, #24]
c0d03a7c:	2b00      	cmp	r3, #0
c0d03a7e:	d100      	bne.n	c0d03a82 <snprintf+0x1ca>
c0d03a80:	4619      	mov	r1, r3
c0d03a82:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d03a84:	9101      	str	r1, [sp, #4]
c0d03a86:	1840      	adds	r0, r0, r1

                    //
                    // If the value is negative and the value is padded with
                    // zeros, then place the minus sign before the padding.
                    //
                    if(ulNeg && (cFill == '0'))
c0d03a88:	9908      	ldr	r1, [sp, #32]
c0d03a8a:	b2ca      	uxtb	r2, r1
c0d03a8c:	2a30      	cmp	r2, #48	; 0x30
c0d03a8e:	d106      	bne.n	c0d03a9e <snprintf+0x1e6>
c0d03a90:	2b00      	cmp	r3, #0
c0d03a92:	d004      	beq.n	c0d03a9e <snprintf+0x1e6>
c0d03a94:	a90c      	add	r1, sp, #48	; 0x30
                    {
                        //
                        // Place the minus sign in the output buffer.
                        //
                        pcBuf[ulPos++] = '-';
c0d03a96:	232d      	movs	r3, #45	; 0x2d
c0d03a98:	700b      	strb	r3, [r1, #0]
c0d03a9a:	2300      	movs	r3, #0
c0d03a9c:	2401      	movs	r4, #1

                    //
                    // Provide additional padding at the beginning of the
                    // string conversion if needed.
                    //
                    if((ulCount > 1) && (ulCount < 16))
c0d03a9e:	1e81      	subs	r1, r0, #2
c0d03aa0:	290d      	cmp	r1, #13
c0d03aa2:	d80c      	bhi.n	c0d03abe <snprintf+0x206>
c0d03aa4:	1e41      	subs	r1, r0, #1
c0d03aa6:	d00a      	beq.n	c0d03abe <snprintf+0x206>
c0d03aa8:	a80c      	add	r0, sp, #48	; 0x30
                    {
                        for(ulCount--; ulCount; ulCount--)
                        {
                            pcBuf[ulPos++] = cFill;
c0d03aaa:	4320      	orrs	r0, r4
c0d03aac:	9306      	str	r3, [sp, #24]
c0d03aae:	f003 f9f9 	bl	c0d06ea4 <__aeabi_memset>
c0d03ab2:	9b06      	ldr	r3, [sp, #24]
c0d03ab4:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d03ab6:	1900      	adds	r0, r0, r4
c0d03ab8:	9901      	ldr	r1, [sp, #4]
c0d03aba:	1840      	adds	r0, r0, r1
c0d03abc:	1e44      	subs	r4, r0, #1

                    //
                    // If the value is negative, then place the minus sign
                    // before the number.
                    //
                    if(ulNeg)
c0d03abe:	2b00      	cmp	r3, #0
c0d03ac0:	d003      	beq.n	c0d03aca <snprintf+0x212>
c0d03ac2:	a80c      	add	r0, sp, #48	; 0x30
                    {
                        //
                        // Place the minus sign in the output buffer.
                        //
                        pcBuf[ulPos++] = '-';
c0d03ac4:	212d      	movs	r1, #45	; 0x2d
c0d03ac6:	5501      	strb	r1, [r0, r4]
c0d03ac8:	1c64      	adds	r4, r4, #1
c0d03aca:	9804      	ldr	r0, [sp, #16]
                    }

                    //
                    // Convert the value into a string.
                    //
                    for(; ulIdx; ulIdx /= ulBase)
c0d03acc:	2f00      	cmp	r7, #0
c0d03ace:	d018      	beq.n	c0d03b02 <snprintf+0x24a>
c0d03ad0:	2800      	cmp	r0, #0
c0d03ad2:	d001      	beq.n	c0d03ad8 <snprintf+0x220>
c0d03ad4:	a079      	add	r0, pc, #484	; (adr r0, c0d03cbc <g_pcHex_cap>)
c0d03ad6:	e000      	b.n	c0d03ada <snprintf+0x222>
c0d03ad8:	a07c      	add	r0, pc, #496	; (adr r0, c0d03ccc <g_pcHex>)
c0d03ada:	9009      	str	r0, [sp, #36]	; 0x24
c0d03adc:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d03ade:	4639      	mov	r1, r7
c0d03ae0:	f003 f91e 	bl	c0d06d20 <__aeabi_uidiv>
c0d03ae4:	4629      	mov	r1, r5
c0d03ae6:	f003 f9a1 	bl	c0d06e2c <__aeabi_uidivmod>
c0d03aea:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d03aec:	5c40      	ldrb	r0, [r0, r1]
c0d03aee:	a90c      	add	r1, sp, #48	; 0x30
c0d03af0:	5508      	strb	r0, [r1, r4]
c0d03af2:	4638      	mov	r0, r7
c0d03af4:	4629      	mov	r1, r5
c0d03af6:	f003 f913 	bl	c0d06d20 <__aeabi_uidiv>
c0d03afa:	1c64      	adds	r4, r4, #1
c0d03afc:	42bd      	cmp	r5, r7
c0d03afe:	4607      	mov	r7, r0
c0d03b00:	d9ec      	bls.n	c0d03adc <snprintf+0x224>
c0d03b02:	9b03      	ldr	r3, [sp, #12]
                    }

                    //
                    // Write the string.
                    //
                    ulPos = MIN(ulPos, str_size);
c0d03b04:	429c      	cmp	r4, r3
c0d03b06:	d300      	bcc.n	c0d03b0a <snprintf+0x252>
c0d03b08:	461c      	mov	r4, r3
c0d03b0a:	a90c      	add	r1, sp, #48	; 0x30
c0d03b0c:	9d02      	ldr	r5, [sp, #8]
                    os_memmove(str, pcBuf, ulPos);
c0d03b0e:	4628      	mov	r0, r5
c0d03b10:	4622      	mov	r2, r4
c0d03b12:	461f      	mov	r7, r3
c0d03b14:	e01b      	b.n	c0d03b4e <snprintf+0x296>
                case 'c':
                {
                    //
                    // Get the value from the varargs.
                    //
                    ulValue = va_arg(vaArgP, unsigned long);
c0d03b16:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d03b18:	1d01      	adds	r1, r0, #4
c0d03b1a:	910b      	str	r1, [sp, #44]	; 0x2c
c0d03b1c:	6800      	ldr	r0, [r0, #0]
c0d03b1e:	9902      	ldr	r1, [sp, #8]
c0d03b20:	7008      	strb	r0, [r1, #0]
c0d03b22:	9803      	ldr	r0, [sp, #12]
c0d03b24:	1e40      	subs	r0, r0, #1
c0d03b26:	1c49      	adds	r1, r1, #1
c0d03b28:	e015      	b.n	c0d03b56 <snprintf+0x29e>
c0d03b2a:	9c00      	ldr	r4, [sp, #0]
c0d03b2c:	9a05      	ldr	r2, [sp, #20]
c0d03b2e:	9b03      	ldr	r3, [sp, #12]
c0d03b30:	9d06      	ldr	r5, [sp, #24]
c0d03b32:	e024      	b.n	c0d03b7e <snprintf+0x2c6>
                        break;
                        
                      // printout prepad
                      case 2:
                        // if string is empty, then, ' ' padding
                        if (pcStr[0] == '\0') {
c0d03b34:	7808      	ldrb	r0, [r1, #0]
c0d03b36:	2800      	cmp	r0, #0
c0d03b38:	d075      	beq.n	c0d03c26 <snprintf+0x36e>
                default:
                {
                    //
                    // Indicate an error.
                    //
                    ulPos = MIN(strlen("ERROR"), str_size);
c0d03b3a:	2005      	movs	r0, #5
c0d03b3c:	9f03      	ldr	r7, [sp, #12]
c0d03b3e:	2f05      	cmp	r7, #5
c0d03b40:	463c      	mov	r4, r7
c0d03b42:	d300      	bcc.n	c0d03b46 <snprintf+0x28e>
c0d03b44:	4604      	mov	r4, r0
c0d03b46:	9d02      	ldr	r5, [sp, #8]
                    os_memmove(str, "ERROR", ulPos);
c0d03b48:	4628      	mov	r0, r5
c0d03b4a:	a164      	add	r1, pc, #400	; (adr r1, c0d03cdc <g_pcHex+0x10>)
c0d03b4c:	4622      	mov	r2, r4
c0d03b4e:	f7fe ff70 	bl	c0d02a32 <os_memmove>
c0d03b52:	1b38      	subs	r0, r7, r4
c0d03b54:	1929      	adds	r1, r5, r4
c0d03b56:	910a      	str	r1, [sp, #40]	; 0x28
c0d03b58:	4603      	mov	r3, r0
c0d03b5a:	2800      	cmp	r0, #0
c0d03b5c:	d100      	bne.n	c0d03b60 <snprintf+0x2a8>
c0d03b5e:	e0a6      	b.n	c0d03cae <snprintf+0x3f6>
    va_start(vaArgP, format);

    //
    // Loop while there are more characters in the string.
    //
    while(*format)
c0d03b60:	7830      	ldrb	r0, [r6, #0]
c0d03b62:	2800      	cmp	r0, #0
c0d03b64:	9905      	ldr	r1, [sp, #20]
c0d03b66:	461d      	mov	r5, r3
c0d03b68:	d000      	beq.n	c0d03b6c <snprintf+0x2b4>
c0d03b6a:	e085      	b.n	c0d03c78 <snprintf+0x3c0>
c0d03b6c:	e09f      	b.n	c0d03cae <snprintf+0x3f6>
c0d03b6e:	9a05      	ldr	r2, [sp, #20]
c0d03b70:	4614      	mov	r4, r2
c0d03b72:	9b03      	ldr	r3, [sp, #12]
                    // Determine the length of the string. (if not specified using .*)
                    //
                    switch(cStrlenSet) {
                      // compute length with strlen
                      case 0:
                        for(ulIdx = 0; pcStr[ulIdx] != '\0'; ulIdx++)
c0d03b74:	1908      	adds	r0, r1, r4
c0d03b76:	7840      	ldrb	r0, [r0, #1]
c0d03b78:	1c64      	adds	r4, r4, #1
c0d03b7a:	2800      	cmp	r0, #0
c0d03b7c:	d1fa      	bne.n	c0d03b74 <snprintf+0x2bc>
                    }

                    //
                    // Write the string.
                    //
                    switch(ulBase) {
c0d03b7e:	9801      	ldr	r0, [sp, #4]
c0d03b80:	2810      	cmp	r0, #16
c0d03b82:	9802      	ldr	r0, [sp, #8]
c0d03b84:	d144      	bne.n	c0d03c10 <snprintf+0x358>
                            return 0;
                        }
                        break;
                      case 16: {
                        unsigned char nibble1, nibble2;
                        for (ulCount = 0; ulCount < ulIdx; ulCount++) {
c0d03b86:	2c00      	cmp	r4, #0
c0d03b88:	d074      	beq.n	c0d03c74 <snprintf+0x3bc>
c0d03b8a:	9108      	str	r1, [sp, #32]
                          nibble1 = (pcStr[ulCount]>>4)&0xF;
c0d03b8c:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d03b8e:	1883      	adds	r3, r0, r2
c0d03b90:	1b50      	subs	r0, r2, r5
c0d03b92:	4287      	cmp	r7, r0
c0d03b94:	4639      	mov	r1, r7
c0d03b96:	d800      	bhi.n	c0d03b9a <snprintf+0x2e2>
c0d03b98:	4601      	mov	r1, r0
c0d03b9a:	9103      	str	r1, [sp, #12]
c0d03b9c:	434a      	muls	r2, r1
c0d03b9e:	9202      	str	r2, [sp, #8]
c0d03ba0:	1c50      	adds	r0, r2, #1
c0d03ba2:	9001      	str	r0, [sp, #4]
c0d03ba4:	2000      	movs	r0, #0
c0d03ba6:	462a      	mov	r2, r5
c0d03ba8:	930a      	str	r3, [sp, #40]	; 0x28
c0d03baa:	9902      	ldr	r1, [sp, #8]
c0d03bac:	185b      	adds	r3, r3, r1
c0d03bae:	9009      	str	r0, [sp, #36]	; 0x24
c0d03bb0:	9908      	ldr	r1, [sp, #32]
c0d03bb2:	5c08      	ldrb	r0, [r1, r0]
                          nibble2 = pcStr[ulCount]&0xF;
c0d03bb4:	250f      	movs	r5, #15
c0d03bb6:	4005      	ands	r5, r0
                        }
                        break;
                      case 16: {
                        unsigned char nibble1, nibble2;
                        for (ulCount = 0; ulCount < ulIdx; ulCount++) {
                          nibble1 = (pcStr[ulCount]>>4)&0xF;
c0d03bb8:	0900      	lsrs	r0, r0, #4
c0d03bba:	9903      	ldr	r1, [sp, #12]
c0d03bbc:	1889      	adds	r1, r1, r2
c0d03bbe:	1c49      	adds	r1, r1, #1
                          nibble2 = pcStr[ulCount]&0xF;
                          if (str_size < 2) {
c0d03bc0:	2902      	cmp	r1, #2
c0d03bc2:	d374      	bcc.n	c0d03cae <snprintf+0x3f6>
c0d03bc4:	9904      	ldr	r1, [sp, #16]
                              return 0;
                          }
                          switch(ulCap) {
c0d03bc6:	2901      	cmp	r1, #1
c0d03bc8:	d003      	beq.n	c0d03bd2 <snprintf+0x31a>
c0d03bca:	2900      	cmp	r1, #0
c0d03bcc:	d108      	bne.n	c0d03be0 <snprintf+0x328>
c0d03bce:	a13f      	add	r1, pc, #252	; (adr r1, c0d03ccc <g_pcHex>)
c0d03bd0:	e000      	b.n	c0d03bd4 <snprintf+0x31c>
c0d03bd2:	a13a      	add	r1, pc, #232	; (adr r1, c0d03cbc <g_pcHex_cap>)
c0d03bd4:	b2c0      	uxtb	r0, r0
c0d03bd6:	5c08      	ldrb	r0, [r1, r0]
c0d03bd8:	7018      	strb	r0, [r3, #0]
c0d03bda:	b2e8      	uxtb	r0, r5
c0d03bdc:	5c08      	ldrb	r0, [r1, r0]
c0d03bde:	7058      	strb	r0, [r3, #1]
                                str[1] = g_pcHex_cap[nibble2];
                              break;
                          }
                          str+= 2;
                          str_size -= 2;
                          if (str_size == 0) {
c0d03be0:	9801      	ldr	r0, [sp, #4]
c0d03be2:	4290      	cmp	r0, r2
c0d03be4:	d063      	beq.n	c0d03cae <snprintf+0x3f6>
                            return 0;
                        }
                        break;
                      case 16: {
                        unsigned char nibble1, nibble2;
                        for (ulCount = 0; ulCount < ulIdx; ulCount++) {
c0d03be6:	1e92      	subs	r2, r2, #2
c0d03be8:	9b0a      	ldr	r3, [sp, #40]	; 0x28
c0d03bea:	1c9b      	adds	r3, r3, #2
c0d03bec:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d03bee:	1c40      	adds	r0, r0, #1
c0d03bf0:	42a0      	cmp	r0, r4
c0d03bf2:	d3d9      	bcc.n	c0d03ba8 <snprintf+0x2f0>
c0d03bf4:	9009      	str	r0, [sp, #36]	; 0x24
c0d03bf6:	9905      	ldr	r1, [sp, #20]
 
#endif // HAVE_PRINTF

#ifdef HAVE_SPRINTF
//unsigned int snprintf(unsigned char * str, unsigned int str_size, const char* format, ...)
int snprintf(char * str, size_t str_size, const char * format, ...)
c0d03bf8:	9806      	ldr	r0, [sp, #24]
c0d03bfa:	1a08      	subs	r0, r1, r0
c0d03bfc:	4287      	cmp	r7, r0
c0d03bfe:	d800      	bhi.n	c0d03c02 <snprintf+0x34a>
c0d03c00:	4607      	mov	r7, r0
c0d03c02:	4608      	mov	r0, r1
c0d03c04:	4378      	muls	r0, r7
c0d03c06:	1818      	adds	r0, r3, r0
c0d03c08:	900a      	str	r0, [sp, #40]	; 0x28
c0d03c0a:	18b8      	adds	r0, r7, r2
c0d03c0c:	1c43      	adds	r3, r0, #1
c0d03c0e:	e01c      	b.n	c0d03c4a <snprintf+0x392>
                    //
                    // Write the string.
                    //
                    switch(ulBase) {
                      default:
                        ulIdx = MIN(ulIdx, str_size);
c0d03c10:	429c      	cmp	r4, r3
c0d03c12:	d300      	bcc.n	c0d03c16 <snprintf+0x35e>
c0d03c14:	461c      	mov	r4, r3
                        os_memmove(str, pcStr, ulIdx);
c0d03c16:	4622      	mov	r2, r4
c0d03c18:	4605      	mov	r5, r0
c0d03c1a:	461f      	mov	r7, r3
c0d03c1c:	f7fe ff09 	bl	c0d02a32 <os_memmove>
                        str+= ulIdx;
                        str_size -= ulIdx;
c0d03c20:	1b38      	subs	r0, r7, r4
                    //
                    switch(ulBase) {
                      default:
                        ulIdx = MIN(ulIdx, str_size);
                        os_memmove(str, pcStr, ulIdx);
                        str+= ulIdx;
c0d03c22:	1929      	adds	r1, r5, r4
c0d03c24:	e00d      	b.n	c0d03c42 <snprintf+0x38a>
c0d03c26:	9b03      	ldr	r3, [sp, #12]
c0d03c28:	9f00      	ldr	r7, [sp, #0]
                      case 2:
                        // if string is empty, then, ' ' padding
                        if (pcStr[0] == '\0') {
                        
                          // padd ulStrlen white space
                          ulStrlen = MIN(ulStrlen, str_size);
c0d03c2a:	429f      	cmp	r7, r3
c0d03c2c:	d300      	bcc.n	c0d03c30 <snprintf+0x378>
c0d03c2e:	461f      	mov	r7, r3
                          os_memset(str, ' ', ulStrlen);
c0d03c30:	2120      	movs	r1, #32
c0d03c32:	9d02      	ldr	r5, [sp, #8]
c0d03c34:	4628      	mov	r0, r5
c0d03c36:	463a      	mov	r2, r7
c0d03c38:	f7fe fef2 	bl	c0d02a20 <os_memset>
                          str+= ulStrlen;
                          str_size -= ulStrlen;
c0d03c3c:	9803      	ldr	r0, [sp, #12]
c0d03c3e:	1bc0      	subs	r0, r0, r7
                        if (pcStr[0] == '\0') {
                        
                          // padd ulStrlen white space
                          ulStrlen = MIN(ulStrlen, str_size);
                          os_memset(str, ' ', ulStrlen);
                          str+= ulStrlen;
c0d03c40:	19e9      	adds	r1, r5, r7
c0d03c42:	910a      	str	r1, [sp, #40]	; 0x28
c0d03c44:	4603      	mov	r3, r0
c0d03c46:	2800      	cmp	r0, #0
c0d03c48:	d031      	beq.n	c0d03cae <snprintf+0x3f6>
c0d03c4a:	9809      	ldr	r0, [sp, #36]	; 0x24

s_pad:
                    //
                    // Write any required padding spaces
                    //
                    if(ulCount > ulIdx)
c0d03c4c:	42a0      	cmp	r0, r4
c0d03c4e:	d987      	bls.n	c0d03b60 <snprintf+0x2a8>
                    {
                        ulCount -= ulIdx;
c0d03c50:	1b04      	subs	r4, r0, r4
c0d03c52:	461d      	mov	r5, r3
                        ulCount = MIN(ulCount, str_size);
c0d03c54:	42ac      	cmp	r4, r5
c0d03c56:	d300      	bcc.n	c0d03c5a <snprintf+0x3a2>
c0d03c58:	462c      	mov	r4, r5
                        os_memset(str, ' ', ulCount);
c0d03c5a:	2120      	movs	r1, #32
c0d03c5c:	9f0a      	ldr	r7, [sp, #40]	; 0x28
c0d03c5e:	4638      	mov	r0, r7
c0d03c60:	4622      	mov	r2, r4
c0d03c62:	f7fe fedd 	bl	c0d02a20 <os_memset>
                        str+= ulCount;
                        str_size -= ulCount;
c0d03c66:	1b2d      	subs	r5, r5, r4
                    if(ulCount > ulIdx)
                    {
                        ulCount -= ulIdx;
                        ulCount = MIN(ulCount, str_size);
                        os_memset(str, ' ', ulCount);
                        str+= ulCount;
c0d03c68:	193f      	adds	r7, r7, r4
c0d03c6a:	970a      	str	r7, [sp, #40]	; 0x28
c0d03c6c:	462b      	mov	r3, r5
                        str_size -= ulCount;
                        if (str_size == 0) {
c0d03c6e:	2d00      	cmp	r5, #0
c0d03c70:	d01d      	beq.n	c0d03cae <snprintf+0x3f6>
c0d03c72:	e775      	b.n	c0d03b60 <snprintf+0x2a8>
c0d03c74:	900a      	str	r0, [sp, #40]	; 0x28
c0d03c76:	e773      	b.n	c0d03b60 <snprintf+0x2a8>
    while(*format)
    {
        //
        // Find the first non-% character, or the end of the string.
        //
        for(ulIdx = 0; (format[ulIdx] != '%') && (format[ulIdx] != '\0');
c0d03c78:	460f      	mov	r7, r1
c0d03c7a:	9c07      	ldr	r4, [sp, #28]
c0d03c7c:	e003      	b.n	c0d03c86 <snprintf+0x3ce>
c0d03c7e:	1930      	adds	r0, r6, r4
c0d03c80:	7840      	ldrb	r0, [r0, #1]
c0d03c82:	1e7f      	subs	r7, r7, #1
            ulIdx++)
c0d03c84:	1c64      	adds	r4, r4, #1
c0d03c86:	b2c0      	uxtb	r0, r0
    while(*format)
    {
        //
        // Find the first non-% character, or the end of the string.
        //
        for(ulIdx = 0; (format[ulIdx] != '%') && (format[ulIdx] != '\0');
c0d03c88:	2800      	cmp	r0, #0
c0d03c8a:	d001      	beq.n	c0d03c90 <snprintf+0x3d8>
c0d03c8c:	2825      	cmp	r0, #37	; 0x25
c0d03c8e:	d1f6      	bne.n	c0d03c7e <snprintf+0x3c6>
        }

        //
        // Write this portion of the string.
        //
        ulIdx = MIN(ulIdx, str_size);
c0d03c90:	42ac      	cmp	r4, r5
c0d03c92:	d300      	bcc.n	c0d03c96 <snprintf+0x3de>
c0d03c94:	462c      	mov	r4, r5
        os_memmove(str, format, ulIdx);
c0d03c96:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d03c98:	4631      	mov	r1, r6
c0d03c9a:	4622      	mov	r2, r4
c0d03c9c:	f7fe fec9 	bl	c0d02a32 <os_memmove>
c0d03ca0:	9506      	str	r5, [sp, #24]
        str+= ulIdx;
        str_size -= ulIdx;
c0d03ca2:	1b2b      	subs	r3, r5, r4
        //
        // Write this portion of the string.
        //
        ulIdx = MIN(ulIdx, str_size);
        os_memmove(str, format, ulIdx);
        str+= ulIdx;
c0d03ca4:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d03ca6:	1902      	adds	r2, r0, r4
        str_size -= ulIdx;
        if (str_size == 0) {
c0d03ca8:	2b00      	cmp	r3, #0
c0d03caa:	d000      	beq.n	c0d03cae <snprintf+0x3f6>
c0d03cac:	e626      	b.n	c0d038fc <snprintf+0x44>
    // End the varargs processing.
    //
    va_end(vaArgP);

    return 0;
}
c0d03cae:	2000      	movs	r0, #0
c0d03cb0:	b010      	add	sp, #64	; 0x40
c0d03cb2:	bcf0      	pop	{r4, r5, r6, r7}
c0d03cb4:	bc02      	pop	{r1}
c0d03cb6:	b001      	add	sp, #4
c0d03cb8:	4708      	bx	r1
c0d03cba:	46c0      	nop			; (mov r8, r8)

c0d03cbc <g_pcHex_cap>:
c0d03cbc:	33323130 	.word	0x33323130
c0d03cc0:	37363534 	.word	0x37363534
c0d03cc4:	42413938 	.word	0x42413938
c0d03cc8:	46454443 	.word	0x46454443

c0d03ccc <g_pcHex>:
c0d03ccc:	33323130 	.word	0x33323130
c0d03cd0:	37363534 	.word	0x37363534
c0d03cd4:	62613938 	.word	0x62613938
c0d03cd8:	66656463 	.word	0x66656463
c0d03cdc:	4f525245 	.word	0x4f525245
c0d03ce0:	00000052 	.word	0x00000052

c0d03ce4 <pic>:

// only apply PIC conversion if link_address is in linked code (over 0xC0D00000 in our example)
// this way, PIC call are armless if the address is not meant to be converted
extern unsigned int _nvram;
extern unsigned int _envram;
unsigned int pic(unsigned int link_address) {
c0d03ce4:	b580      	push	{r7, lr}
//  screen_printf(" %08X", link_address);
	if (link_address >= ((unsigned int)&_nvram) && link_address < ((unsigned int)&_envram)) {
c0d03ce6:	4904      	ldr	r1, [pc, #16]	; (c0d03cf8 <pic+0x14>)
c0d03ce8:	4288      	cmp	r0, r1
c0d03cea:	d304      	bcc.n	c0d03cf6 <pic+0x12>
c0d03cec:	4903      	ldr	r1, [pc, #12]	; (c0d03cfc <pic+0x18>)
c0d03cee:	4288      	cmp	r0, r1
c0d03cf0:	d201      	bcs.n	c0d03cf6 <pic+0x12>
		link_address = pic_internal(link_address);
c0d03cf2:	f000 f805 	bl	c0d03d00 <pic_internal>
//    screen_printf(" -> %08X\n", link_address);
  }
	return link_address;
c0d03cf6:	bd80      	pop	{r7, pc}
c0d03cf8:	c0d00000 	.word	0xc0d00000
c0d03cfc:	c0d10900 	.word	0xc0d10900

c0d03d00 <pic_internal>:

unsigned int pic_internal(unsigned int link_address) __attribute__((naked));
unsigned int pic_internal(unsigned int link_address) 
{
  // compute the delta offset between LinkMemAddr & ExecMemAddr
  __asm volatile ("mov r2, pc\n");          // r2 = 0x109004
c0d03d00:	467a      	mov	r2, pc
  __asm volatile ("ldr r1, =pic_internal\n");        // r1 = 0xC0D00001
c0d03d02:	4902      	ldr	r1, [pc, #8]	; (c0d03d0c <pic_internal+0xc>)
  __asm volatile ("adds r1, r1, #3\n");     // r1 = 0xC0D00004
c0d03d04:	1cc9      	adds	r1, r1, #3
  __asm volatile ("subs r1, r1, r2\n");     // r1 = 0xC0BF7000 (delta between load and exec address)
c0d03d06:	1a89      	subs	r1, r1, r2

  // adjust value of the given parameter
  __asm volatile ("subs r0, r0, r1\n");     // r0 = 0xC0D0C244 => r0 = 0x115244
c0d03d08:	1a40      	subs	r0, r0, r1
  __asm volatile ("bx lr\n");
c0d03d0a:	4770      	bx	lr
c0d03d0c:	c0d03d01 	.word	0xc0d03d01

c0d03d10 <SVC_Call>:
  // avoid a separate asm file, but avoid any intrusion from the compiler
  unsigned int SVC_Call(unsigned int syscall_id, unsigned int * parameters) __attribute__ ((naked));
  //                    r0                       r1
  unsigned int SVC_Call(unsigned int syscall_id, unsigned int * parameters) {
    // delegate svc
    asm volatile("svc #1":::"r0","r1");
c0d03d10:	df01      	svc	1
    // directly return R0 value
    asm volatile("bx  lr");
c0d03d12:	4770      	bx	lr

c0d03d14 <check_api_level>:
  }
  void check_api_level ( unsigned int apiLevel ) 
{
c0d03d14:	b580      	push	{r7, lr}
c0d03d16:	b082      	sub	sp, #8
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+1];
  parameters[0] = (unsigned int)apiLevel;
c0d03d18:	9000      	str	r0, [sp, #0]
  retid = SVC_Call(SYSCALL_check_api_level_ID_IN, parameters);
c0d03d1a:	4807      	ldr	r0, [pc, #28]	; (c0d03d38 <check_api_level+0x24>)
c0d03d1c:	4669      	mov	r1, sp
c0d03d1e:	f7ff fff7 	bl	c0d03d10 <SVC_Call>
c0d03d22:	aa01      	add	r2, sp, #4
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d03d24:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_check_api_level_ID_OUT) {
c0d03d26:	4905      	ldr	r1, [pc, #20]	; (c0d03d3c <check_api_level+0x28>)
c0d03d28:	4288      	cmp	r0, r1
c0d03d2a:	d101      	bne.n	c0d03d30 <check_api_level+0x1c>
    THROW(EXCEPTION_SECURITY);
  }
}
c0d03d2c:	b002      	add	sp, #8
c0d03d2e:	bd80      	pop	{r7, pc}
  unsigned int parameters [0+1];
  parameters[0] = (unsigned int)apiLevel;
  retid = SVC_Call(SYSCALL_check_api_level_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_check_api_level_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d03d30:	2004      	movs	r0, #4
c0d03d32:	f7fe ff32 	bl	c0d02b9a <os_longjmp>
c0d03d36:	46c0      	nop			; (mov r8, r8)
c0d03d38:	60000137 	.word	0x60000137
c0d03d3c:	900001c6 	.word	0x900001c6

c0d03d40 <reset>:
  }
}

void reset ( void ) 
{
c0d03d40:	b580      	push	{r7, lr}
c0d03d42:	b082      	sub	sp, #8
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0];
  retid = SVC_Call(SYSCALL_reset_ID_IN, parameters);
c0d03d44:	4806      	ldr	r0, [pc, #24]	; (c0d03d60 <reset+0x20>)
c0d03d46:	a901      	add	r1, sp, #4
c0d03d48:	f7ff ffe2 	bl	c0d03d10 <SVC_Call>
c0d03d4c:	466a      	mov	r2, sp
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d03d4e:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_reset_ID_OUT) {
c0d03d50:	4904      	ldr	r1, [pc, #16]	; (c0d03d64 <reset+0x24>)
c0d03d52:	4288      	cmp	r0, r1
c0d03d54:	d101      	bne.n	c0d03d5a <reset+0x1a>
    THROW(EXCEPTION_SECURITY);
  }
}
c0d03d56:	b002      	add	sp, #8
c0d03d58:	bd80      	pop	{r7, pc}
  unsigned int retid;
  unsigned int parameters [0];
  retid = SVC_Call(SYSCALL_reset_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_reset_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d03d5a:	2004      	movs	r0, #4
c0d03d5c:	f7fe ff1d 	bl	c0d02b9a <os_longjmp>
c0d03d60:	60000200 	.word	0x60000200
c0d03d64:	900002f1 	.word	0x900002f1

c0d03d68 <nvm_write>:
  }
}

void nvm_write ( void * dst_adr, void * src_adr, unsigned int src_len ) 
{
c0d03d68:	b580      	push	{r7, lr}
c0d03d6a:	b084      	sub	sp, #16
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+3];
  parameters[0] = (unsigned int)dst_adr;
c0d03d6c:	ab00      	add	r3, sp, #0
c0d03d6e:	c307      	stmia	r3!, {r0, r1, r2}
  parameters[1] = (unsigned int)src_adr;
  parameters[2] = (unsigned int)src_len;
  retid = SVC_Call(SYSCALL_nvm_write_ID_IN, parameters);
c0d03d70:	4806      	ldr	r0, [pc, #24]	; (c0d03d8c <nvm_write+0x24>)
c0d03d72:	4669      	mov	r1, sp
c0d03d74:	f7ff ffcc 	bl	c0d03d10 <SVC_Call>
c0d03d78:	aa03      	add	r2, sp, #12
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d03d7a:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_nvm_write_ID_OUT) {
c0d03d7c:	4904      	ldr	r1, [pc, #16]	; (c0d03d90 <nvm_write+0x28>)
c0d03d7e:	4288      	cmp	r0, r1
c0d03d80:	d101      	bne.n	c0d03d86 <nvm_write+0x1e>
    THROW(EXCEPTION_SECURITY);
  }
}
c0d03d82:	b004      	add	sp, #16
c0d03d84:	bd80      	pop	{r7, pc}
  parameters[1] = (unsigned int)src_adr;
  parameters[2] = (unsigned int)src_len;
  retid = SVC_Call(SYSCALL_nvm_write_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_nvm_write_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d03d86:	2004      	movs	r0, #4
c0d03d88:	f7fe ff07 	bl	c0d02b9a <os_longjmp>
c0d03d8c:	6000037f 	.word	0x6000037f
c0d03d90:	900003bc 	.word	0x900003bc

c0d03d94 <cx_rng>:
  }
  return (unsigned char)ret;
}

unsigned char * cx_rng ( unsigned char * buffer, unsigned int len ) 
{
c0d03d94:	b580      	push	{r7, lr}
c0d03d96:	b084      	sub	sp, #16
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+2];
  parameters[0] = (unsigned int)buffer;
c0d03d98:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)len;
c0d03d9a:	9102      	str	r1, [sp, #8]
  retid = SVC_Call(SYSCALL_cx_rng_ID_IN, parameters);
c0d03d9c:	4807      	ldr	r0, [pc, #28]	; (c0d03dbc <cx_rng+0x28>)
c0d03d9e:	a901      	add	r1, sp, #4
c0d03da0:	f7ff ffb6 	bl	c0d03d10 <SVC_Call>
c0d03da4:	aa03      	add	r2, sp, #12
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d03da6:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_cx_rng_ID_OUT) {
c0d03da8:	4905      	ldr	r1, [pc, #20]	; (c0d03dc0 <cx_rng+0x2c>)
c0d03daa:	4288      	cmp	r0, r1
c0d03dac:	d102      	bne.n	c0d03db4 <cx_rng+0x20>
    THROW(EXCEPTION_SECURITY);
  }
  return (unsigned char *)ret;
c0d03dae:	9803      	ldr	r0, [sp, #12]
c0d03db0:	b004      	add	sp, #16
c0d03db2:	bd80      	pop	{r7, pc}
  parameters[0] = (unsigned int)buffer;
  parameters[1] = (unsigned int)len;
  retid = SVC_Call(SYSCALL_cx_rng_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_cx_rng_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d03db4:	2004      	movs	r0, #4
c0d03db6:	f7fe fef0 	bl	c0d02b9a <os_longjmp>
c0d03dba:	46c0      	nop			; (mov r8, r8)
c0d03dbc:	6000052c 	.word	0x6000052c
c0d03dc0:	90000567 	.word	0x90000567

c0d03dc4 <cx_hash>:
  }
  return (int)ret;
}

int cx_hash ( cx_hash_t * hash, int mode, const unsigned char * in, unsigned int len, unsigned char * out, unsigned int out_len ) 
{
c0d03dc4:	b580      	push	{r7, lr}
c0d03dc6:	b088      	sub	sp, #32
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+6];
  parameters[0] = (unsigned int)hash;
c0d03dc8:	af01      	add	r7, sp, #4
c0d03dca:	c70f      	stmia	r7!, {r0, r1, r2, r3}
c0d03dcc:	980a      	ldr	r0, [sp, #40]	; 0x28
  parameters[1] = (unsigned int)mode;
  parameters[2] = (unsigned int)in;
  parameters[3] = (unsigned int)len;
  parameters[4] = (unsigned int)out;
c0d03dce:	9005      	str	r0, [sp, #20]
c0d03dd0:	980b      	ldr	r0, [sp, #44]	; 0x2c
  parameters[5] = (unsigned int)out_len;
c0d03dd2:	9006      	str	r0, [sp, #24]
  retid = SVC_Call(SYSCALL_cx_hash_ID_IN, parameters);
c0d03dd4:	4807      	ldr	r0, [pc, #28]	; (c0d03df4 <cx_hash+0x30>)
c0d03dd6:	a901      	add	r1, sp, #4
c0d03dd8:	f7ff ff9a 	bl	c0d03d10 <SVC_Call>
c0d03ddc:	aa07      	add	r2, sp, #28
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d03dde:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_cx_hash_ID_OUT) {
c0d03de0:	4905      	ldr	r1, [pc, #20]	; (c0d03df8 <cx_hash+0x34>)
c0d03de2:	4288      	cmp	r0, r1
c0d03de4:	d102      	bne.n	c0d03dec <cx_hash+0x28>
    THROW(EXCEPTION_SECURITY);
  }
  return (int)ret;
c0d03de6:	9807      	ldr	r0, [sp, #28]
c0d03de8:	b008      	add	sp, #32
c0d03dea:	bd80      	pop	{r7, pc}
  parameters[4] = (unsigned int)out;
  parameters[5] = (unsigned int)out_len;
  retid = SVC_Call(SYSCALL_cx_hash_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_cx_hash_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d03dec:	2004      	movs	r0, #4
c0d03dee:	f7fe fed4 	bl	c0d02b9a <os_longjmp>
c0d03df2:	46c0      	nop			; (mov r8, r8)
c0d03df4:	6000073b 	.word	0x6000073b
c0d03df8:	900007ad 	.word	0x900007ad

c0d03dfc <cx_sha256_init>:
  }
  return (int)ret;
}

int cx_sha256_init ( cx_sha256_t * hash ) 
{
c0d03dfc:	b580      	push	{r7, lr}
c0d03dfe:	b082      	sub	sp, #8
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+1];
  parameters[0] = (unsigned int)hash;
c0d03e00:	9000      	str	r0, [sp, #0]
  retid = SVC_Call(SYSCALL_cx_sha256_init_ID_IN, parameters);
c0d03e02:	4807      	ldr	r0, [pc, #28]	; (c0d03e20 <cx_sha256_init+0x24>)
c0d03e04:	4669      	mov	r1, sp
c0d03e06:	f7ff ff83 	bl	c0d03d10 <SVC_Call>
c0d03e0a:	aa01      	add	r2, sp, #4
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d03e0c:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_cx_sha256_init_ID_OUT) {
c0d03e0e:	4905      	ldr	r1, [pc, #20]	; (c0d03e24 <cx_sha256_init+0x28>)
c0d03e10:	4288      	cmp	r0, r1
c0d03e12:	d102      	bne.n	c0d03e1a <cx_sha256_init+0x1e>
    THROW(EXCEPTION_SECURITY);
  }
  return (int)ret;
c0d03e14:	9801      	ldr	r0, [sp, #4]
c0d03e16:	b002      	add	sp, #8
c0d03e18:	bd80      	pop	{r7, pc}
  unsigned int parameters [0+1];
  parameters[0] = (unsigned int)hash;
  retid = SVC_Call(SYSCALL_cx_sha256_init_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_cx_sha256_init_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d03e1a:	2004      	movs	r0, #4
c0d03e1c:	f7fe febd 	bl	c0d02b9a <os_longjmp>
c0d03e20:	60000adb 	.word	0x60000adb
c0d03e24:	90000a64 	.word	0x90000a64

c0d03e28 <cx_hash_sha256>:
  }
  return (int)ret;
}

int cx_hash_sha256 ( const unsigned char * in, unsigned int len, unsigned char * out, unsigned int out_len ) 
{
c0d03e28:	b580      	push	{r7, lr}
c0d03e2a:	b086      	sub	sp, #24
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+4];
  parameters[0] = (unsigned int)in;
c0d03e2c:	af01      	add	r7, sp, #4
c0d03e2e:	c70f      	stmia	r7!, {r0, r1, r2, r3}
  parameters[1] = (unsigned int)len;
  parameters[2] = (unsigned int)out;
  parameters[3] = (unsigned int)out_len;
  retid = SVC_Call(SYSCALL_cx_hash_sha256_ID_IN, parameters);
c0d03e30:	4807      	ldr	r0, [pc, #28]	; (c0d03e50 <cx_hash_sha256+0x28>)
c0d03e32:	a901      	add	r1, sp, #4
c0d03e34:	f7ff ff6c 	bl	c0d03d10 <SVC_Call>
c0d03e38:	aa05      	add	r2, sp, #20
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d03e3a:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_cx_hash_sha256_ID_OUT) {
c0d03e3c:	4905      	ldr	r1, [pc, #20]	; (c0d03e54 <cx_hash_sha256+0x2c>)
c0d03e3e:	4288      	cmp	r0, r1
c0d03e40:	d102      	bne.n	c0d03e48 <cx_hash_sha256+0x20>
    THROW(EXCEPTION_SECURITY);
  }
  return (int)ret;
c0d03e42:	9805      	ldr	r0, [sp, #20]
c0d03e44:	b006      	add	sp, #24
c0d03e46:	bd80      	pop	{r7, pc}
  parameters[2] = (unsigned int)out;
  parameters[3] = (unsigned int)out_len;
  retid = SVC_Call(SYSCALL_cx_hash_sha256_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_cx_hash_sha256_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d03e48:	2004      	movs	r0, #4
c0d03e4a:	f7fe fea6 	bl	c0d02b9a <os_longjmp>
c0d03e4e:	46c0      	nop			; (mov r8, r8)
c0d03e50:	60000b2c 	.word	0x60000b2c
c0d03e54:	90000ba0 	.word	0x90000ba0

c0d03e58 <cx_keccak_init>:
  }
  return (int)ret;
}

int cx_keccak_init ( cx_sha3_t * hash, unsigned int size ) 
{
c0d03e58:	b580      	push	{r7, lr}
c0d03e5a:	b084      	sub	sp, #16
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+2];
  parameters[0] = (unsigned int)hash;
c0d03e5c:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)size;
c0d03e5e:	9102      	str	r1, [sp, #8]
  retid = SVC_Call(SYSCALL_cx_keccak_init_ID_IN, parameters);
c0d03e60:	4807      	ldr	r0, [pc, #28]	; (c0d03e80 <cx_keccak_init+0x28>)
c0d03e62:	a901      	add	r1, sp, #4
c0d03e64:	f7ff ff54 	bl	c0d03d10 <SVC_Call>
c0d03e68:	aa03      	add	r2, sp, #12
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d03e6a:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_cx_keccak_init_ID_OUT) {
c0d03e6c:	4905      	ldr	r1, [pc, #20]	; (c0d03e84 <cx_keccak_init+0x2c>)
c0d03e6e:	4288      	cmp	r0, r1
c0d03e70:	d102      	bne.n	c0d03e78 <cx_keccak_init+0x20>
    THROW(EXCEPTION_SECURITY);
  }
  return (int)ret;
c0d03e72:	9803      	ldr	r0, [sp, #12]
c0d03e74:	b004      	add	sp, #16
c0d03e76:	bd80      	pop	{r7, pc}
  parameters[0] = (unsigned int)hash;
  parameters[1] = (unsigned int)size;
  retid = SVC_Call(SYSCALL_cx_keccak_init_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_cx_keccak_init_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d03e78:	2004      	movs	r0, #4
c0d03e7a:	f7fe fe8e 	bl	c0d02b9a <os_longjmp>
c0d03e7e:	46c0      	nop			; (mov r8, r8)
c0d03e80:	600010cf 	.word	0x600010cf
c0d03e84:	900010d8 	.word	0x900010d8

c0d03e88 <cx_ecfp_init_public_key>:
  }
  return (int)ret;
}

int cx_ecfp_init_public_key ( cx_curve_t curve, const unsigned char * rawkey, unsigned int key_len, cx_ecfp_public_key_t * key ) 
{
c0d03e88:	b580      	push	{r7, lr}
c0d03e8a:	b086      	sub	sp, #24
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+4];
  parameters[0] = (unsigned int)curve;
c0d03e8c:	af01      	add	r7, sp, #4
c0d03e8e:	c70f      	stmia	r7!, {r0, r1, r2, r3}
  parameters[1] = (unsigned int)rawkey;
  parameters[2] = (unsigned int)key_len;
  parameters[3] = (unsigned int)key;
  retid = SVC_Call(SYSCALL_cx_ecfp_init_public_key_ID_IN, parameters);
c0d03e90:	4807      	ldr	r0, [pc, #28]	; (c0d03eb0 <cx_ecfp_init_public_key+0x28>)
c0d03e92:	a901      	add	r1, sp, #4
c0d03e94:	f7ff ff3c 	bl	c0d03d10 <SVC_Call>
c0d03e98:	aa05      	add	r2, sp, #20
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d03e9a:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_cx_ecfp_init_public_key_ID_OUT) {
c0d03e9c:	4905      	ldr	r1, [pc, #20]	; (c0d03eb4 <cx_ecfp_init_public_key+0x2c>)
c0d03e9e:	4288      	cmp	r0, r1
c0d03ea0:	d102      	bne.n	c0d03ea8 <cx_ecfp_init_public_key+0x20>
    THROW(EXCEPTION_SECURITY);
  }
  return (int)ret;
c0d03ea2:	9805      	ldr	r0, [sp, #20]
c0d03ea4:	b006      	add	sp, #24
c0d03ea6:	bd80      	pop	{r7, pc}
  parameters[2] = (unsigned int)key_len;
  parameters[3] = (unsigned int)key;
  retid = SVC_Call(SYSCALL_cx_ecfp_init_public_key_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_cx_ecfp_init_public_key_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d03ea8:	2004      	movs	r0, #4
c0d03eaa:	f7fe fe76 	bl	c0d02b9a <os_longjmp>
c0d03eae:	46c0      	nop			; (mov r8, r8)
c0d03eb0:	60002ded 	.word	0x60002ded
c0d03eb4:	90002d49 	.word	0x90002d49

c0d03eb8 <cx_ecfp_init_private_key>:
  }
  return (int)ret;
}

int cx_ecfp_init_private_key ( cx_curve_t curve, const unsigned char * rawkey, unsigned int key_len, cx_ecfp_private_key_t * pvkey ) 
{
c0d03eb8:	b580      	push	{r7, lr}
c0d03eba:	b086      	sub	sp, #24
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+4];
  parameters[0] = (unsigned int)curve;
c0d03ebc:	af01      	add	r7, sp, #4
c0d03ebe:	c70f      	stmia	r7!, {r0, r1, r2, r3}
  parameters[1] = (unsigned int)rawkey;
  parameters[2] = (unsigned int)key_len;
  parameters[3] = (unsigned int)pvkey;
  retid = SVC_Call(SYSCALL_cx_ecfp_init_private_key_ID_IN, parameters);
c0d03ec0:	4807      	ldr	r0, [pc, #28]	; (c0d03ee0 <cx_ecfp_init_private_key+0x28>)
c0d03ec2:	a901      	add	r1, sp, #4
c0d03ec4:	f7ff ff24 	bl	c0d03d10 <SVC_Call>
c0d03ec8:	aa05      	add	r2, sp, #20
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d03eca:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_cx_ecfp_init_private_key_ID_OUT) {
c0d03ecc:	4905      	ldr	r1, [pc, #20]	; (c0d03ee4 <cx_ecfp_init_private_key+0x2c>)
c0d03ece:	4288      	cmp	r0, r1
c0d03ed0:	d102      	bne.n	c0d03ed8 <cx_ecfp_init_private_key+0x20>
    THROW(EXCEPTION_SECURITY);
  }
  return (int)ret;
c0d03ed2:	9805      	ldr	r0, [sp, #20]
c0d03ed4:	b006      	add	sp, #24
c0d03ed6:	bd80      	pop	{r7, pc}
  parameters[2] = (unsigned int)key_len;
  parameters[3] = (unsigned int)pvkey;
  retid = SVC_Call(SYSCALL_cx_ecfp_init_private_key_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_cx_ecfp_init_private_key_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d03ed8:	2004      	movs	r0, #4
c0d03eda:	f7fe fe5e 	bl	c0d02b9a <os_longjmp>
c0d03ede:	46c0      	nop			; (mov r8, r8)
c0d03ee0:	60002eea 	.word	0x60002eea
c0d03ee4:	90002e63 	.word	0x90002e63

c0d03ee8 <cx_ecfp_generate_pair>:
  }
  return (int)ret;
}

int cx_ecfp_generate_pair ( cx_curve_t curve, cx_ecfp_public_key_t * pubkey, cx_ecfp_private_key_t * privkey, int keepprivate ) 
{
c0d03ee8:	b580      	push	{r7, lr}
c0d03eea:	b086      	sub	sp, #24
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+4];
  parameters[0] = (unsigned int)curve;
c0d03eec:	af01      	add	r7, sp, #4
c0d03eee:	c70f      	stmia	r7!, {r0, r1, r2, r3}
  parameters[1] = (unsigned int)pubkey;
  parameters[2] = (unsigned int)privkey;
  parameters[3] = (unsigned int)keepprivate;
  retid = SVC_Call(SYSCALL_cx_ecfp_generate_pair_ID_IN, parameters);
c0d03ef0:	4807      	ldr	r0, [pc, #28]	; (c0d03f10 <cx_ecfp_generate_pair+0x28>)
c0d03ef2:	a901      	add	r1, sp, #4
c0d03ef4:	f7ff ff0c 	bl	c0d03d10 <SVC_Call>
c0d03ef8:	aa05      	add	r2, sp, #20
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d03efa:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_cx_ecfp_generate_pair_ID_OUT) {
c0d03efc:	4905      	ldr	r1, [pc, #20]	; (c0d03f14 <cx_ecfp_generate_pair+0x2c>)
c0d03efe:	4288      	cmp	r0, r1
c0d03f00:	d102      	bne.n	c0d03f08 <cx_ecfp_generate_pair+0x20>
    THROW(EXCEPTION_SECURITY);
  }
  return (int)ret;
c0d03f02:	9805      	ldr	r0, [sp, #20]
c0d03f04:	b006      	add	sp, #24
c0d03f06:	bd80      	pop	{r7, pc}
  parameters[2] = (unsigned int)privkey;
  parameters[3] = (unsigned int)keepprivate;
  retid = SVC_Call(SYSCALL_cx_ecfp_generate_pair_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_cx_ecfp_generate_pair_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d03f08:	2004      	movs	r0, #4
c0d03f0a:	f7fe fe46 	bl	c0d02b9a <os_longjmp>
c0d03f0e:	46c0      	nop			; (mov r8, r8)
c0d03f10:	60002f2e 	.word	0x60002f2e
c0d03f14:	90002f74 	.word	0x90002f74

c0d03f18 <cx_ecdsa_sign>:
  }
  return (int)ret;
}

int cx_ecdsa_sign ( const cx_ecfp_private_key_t * pvkey, int mode, cx_md_t hashID, const unsigned char * hash, unsigned int hash_len, unsigned char * sig, unsigned int sig_len, unsigned int * info ) 
{
c0d03f18:	b580      	push	{r7, lr}
c0d03f1a:	b08a      	sub	sp, #40	; 0x28
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+8];
  parameters[0] = (unsigned int)pvkey;
c0d03f1c:	af01      	add	r7, sp, #4
c0d03f1e:	c70f      	stmia	r7!, {r0, r1, r2, r3}
c0d03f20:	980c      	ldr	r0, [sp, #48]	; 0x30
  parameters[1] = (unsigned int)mode;
  parameters[2] = (unsigned int)hashID;
  parameters[3] = (unsigned int)hash;
  parameters[4] = (unsigned int)hash_len;
c0d03f22:	9005      	str	r0, [sp, #20]
c0d03f24:	980d      	ldr	r0, [sp, #52]	; 0x34
  parameters[5] = (unsigned int)sig;
c0d03f26:	9006      	str	r0, [sp, #24]
c0d03f28:	980e      	ldr	r0, [sp, #56]	; 0x38
  parameters[6] = (unsigned int)sig_len;
c0d03f2a:	9007      	str	r0, [sp, #28]
c0d03f2c:	980f      	ldr	r0, [sp, #60]	; 0x3c
  parameters[7] = (unsigned int)info;
c0d03f2e:	9008      	str	r0, [sp, #32]
  retid = SVC_Call(SYSCALL_cx_ecdsa_sign_ID_IN, parameters);
c0d03f30:	4807      	ldr	r0, [pc, #28]	; (c0d03f50 <cx_ecdsa_sign+0x38>)
c0d03f32:	a901      	add	r1, sp, #4
c0d03f34:	f7ff feec 	bl	c0d03d10 <SVC_Call>
c0d03f38:	aa09      	add	r2, sp, #36	; 0x24
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d03f3a:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_cx_ecdsa_sign_ID_OUT) {
c0d03f3c:	4905      	ldr	r1, [pc, #20]	; (c0d03f54 <cx_ecdsa_sign+0x3c>)
c0d03f3e:	4288      	cmp	r0, r1
c0d03f40:	d102      	bne.n	c0d03f48 <cx_ecdsa_sign+0x30>
    THROW(EXCEPTION_SECURITY);
  }
  return (int)ret;
c0d03f42:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d03f44:	b00a      	add	sp, #40	; 0x28
c0d03f46:	bd80      	pop	{r7, pc}
  parameters[6] = (unsigned int)sig_len;
  parameters[7] = (unsigned int)info;
  retid = SVC_Call(SYSCALL_cx_ecdsa_sign_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_cx_ecdsa_sign_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d03f48:	2004      	movs	r0, #4
c0d03f4a:	f7fe fe26 	bl	c0d02b9a <os_longjmp>
c0d03f4e:	46c0      	nop			; (mov r8, r8)
c0d03f50:	600038f3 	.word	0x600038f3
c0d03f54:	90003876 	.word	0x90003876

c0d03f58 <cx_ecdsa_verify>:
  }
  return (int)ret;
}

int cx_ecdsa_verify ( const cx_ecfp_public_key_t * pukey, int mode, cx_md_t hashID, const unsigned char * hash, unsigned int hash_len, const unsigned char * sig, unsigned int sig_len ) 
{
c0d03f58:	b580      	push	{r7, lr}
c0d03f5a:	b088      	sub	sp, #32
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+7];
  parameters[0] = (unsigned int)pukey;
c0d03f5c:	af00      	add	r7, sp, #0
c0d03f5e:	c70f      	stmia	r7!, {r0, r1, r2, r3}
c0d03f60:	980a      	ldr	r0, [sp, #40]	; 0x28
  parameters[1] = (unsigned int)mode;
  parameters[2] = (unsigned int)hashID;
  parameters[3] = (unsigned int)hash;
  parameters[4] = (unsigned int)hash_len;
c0d03f62:	9004      	str	r0, [sp, #16]
c0d03f64:	980b      	ldr	r0, [sp, #44]	; 0x2c
  parameters[5] = (unsigned int)sig;
c0d03f66:	9005      	str	r0, [sp, #20]
c0d03f68:	980c      	ldr	r0, [sp, #48]	; 0x30
  parameters[6] = (unsigned int)sig_len;
c0d03f6a:	9006      	str	r0, [sp, #24]
  retid = SVC_Call(SYSCALL_cx_ecdsa_verify_ID_IN, parameters);
c0d03f6c:	4807      	ldr	r0, [pc, #28]	; (c0d03f8c <cx_ecdsa_verify+0x34>)
c0d03f6e:	4669      	mov	r1, sp
c0d03f70:	f7ff fece 	bl	c0d03d10 <SVC_Call>
c0d03f74:	aa07      	add	r2, sp, #28
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d03f76:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_cx_ecdsa_verify_ID_OUT) {
c0d03f78:	4905      	ldr	r1, [pc, #20]	; (c0d03f90 <cx_ecdsa_verify+0x38>)
c0d03f7a:	4288      	cmp	r0, r1
c0d03f7c:	d102      	bne.n	c0d03f84 <cx_ecdsa_verify+0x2c>
    THROW(EXCEPTION_SECURITY);
  }
  return (int)ret;
c0d03f7e:	9807      	ldr	r0, [sp, #28]
c0d03f80:	b008      	add	sp, #32
c0d03f82:	bd80      	pop	{r7, pc}
  parameters[5] = (unsigned int)sig;
  parameters[6] = (unsigned int)sig_len;
  retid = SVC_Call(SYSCALL_cx_ecdsa_verify_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_cx_ecdsa_verify_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d03f84:	2004      	movs	r0, #4
c0d03f86:	f7fe fe08 	bl	c0d02b9a <os_longjmp>
c0d03f8a:	46c0      	nop			; (mov r8, r8)
c0d03f8c:	600039f1 	.word	0x600039f1
c0d03f90:	900039e7 	.word	0x900039e7

c0d03f94 <cx_crc16_update>:
  }
  return (unsigned short)ret;
}

unsigned short cx_crc16_update ( unsigned short crc, const void * buffer, unsigned int len ) 
{
c0d03f94:	b580      	push	{r7, lr}
c0d03f96:	b084      	sub	sp, #16
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+3];
  parameters[0] = (unsigned int)crc;
c0d03f98:	ab00      	add	r3, sp, #0
c0d03f9a:	c307      	stmia	r3!, {r0, r1, r2}
  parameters[1] = (unsigned int)buffer;
  parameters[2] = (unsigned int)len;
  retid = SVC_Call(SYSCALL_cx_crc16_update_ID_IN, parameters);
c0d03f9c:	4807      	ldr	r0, [pc, #28]	; (c0d03fbc <cx_crc16_update+0x28>)
c0d03f9e:	4669      	mov	r1, sp
c0d03fa0:	f7ff feb6 	bl	c0d03d10 <SVC_Call>
c0d03fa4:	aa03      	add	r2, sp, #12
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d03fa6:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_cx_crc16_update_ID_OUT) {
c0d03fa8:	4905      	ldr	r1, [pc, #20]	; (c0d03fc0 <cx_crc16_update+0x2c>)
c0d03faa:	4288      	cmp	r0, r1
c0d03fac:	d103      	bne.n	c0d03fb6 <cx_crc16_update+0x22>
c0d03fae:	a803      	add	r0, sp, #12
    THROW(EXCEPTION_SECURITY);
  }
  return (unsigned short)ret;
c0d03fb0:	8800      	ldrh	r0, [r0, #0]
c0d03fb2:	b004      	add	sp, #16
c0d03fb4:	bd80      	pop	{r7, pc}
  parameters[1] = (unsigned int)buffer;
  parameters[2] = (unsigned int)len;
  retid = SVC_Call(SYSCALL_cx_crc16_update_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_cx_crc16_update_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d03fb6:	2004      	movs	r0, #4
c0d03fb8:	f7fe fdef 	bl	c0d02b9a <os_longjmp>
c0d03fbc:	60003c9e 	.word	0x60003c9e
c0d03fc0:	90003cb9 	.word	0x90003cb9

c0d03fc4 <os_perso_derive_node_bip32>:
  }
  return (unsigned int)ret;
}

void os_perso_derive_node_bip32 ( cx_curve_t curve, const unsigned int * path, unsigned int pathLength, unsigned char * privateKey, unsigned char * chain ) 
{
c0d03fc4:	b580      	push	{r7, lr}
c0d03fc6:	b086      	sub	sp, #24
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+5];
  parameters[0] = (unsigned int)curve;
c0d03fc8:	af00      	add	r7, sp, #0
c0d03fca:	c70f      	stmia	r7!, {r0, r1, r2, r3}
c0d03fcc:	9808      	ldr	r0, [sp, #32]
  parameters[1] = (unsigned int)path;
  parameters[2] = (unsigned int)pathLength;
  parameters[3] = (unsigned int)privateKey;
  parameters[4] = (unsigned int)chain;
c0d03fce:	9004      	str	r0, [sp, #16]
  retid = SVC_Call(SYSCALL_os_perso_derive_node_bip32_ID_IN, parameters);
c0d03fd0:	4806      	ldr	r0, [pc, #24]	; (c0d03fec <os_perso_derive_node_bip32+0x28>)
c0d03fd2:	4669      	mov	r1, sp
c0d03fd4:	f7ff fe9c 	bl	c0d03d10 <SVC_Call>
c0d03fd8:	aa05      	add	r2, sp, #20
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d03fda:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_os_perso_derive_node_bip32_ID_OUT) {
c0d03fdc:	4904      	ldr	r1, [pc, #16]	; (c0d03ff0 <os_perso_derive_node_bip32+0x2c>)
c0d03fde:	4288      	cmp	r0, r1
c0d03fe0:	d101      	bne.n	c0d03fe6 <os_perso_derive_node_bip32+0x22>
    THROW(EXCEPTION_SECURITY);
  }
}
c0d03fe2:	b006      	add	sp, #24
c0d03fe4:	bd80      	pop	{r7, pc}
  parameters[3] = (unsigned int)privateKey;
  parameters[4] = (unsigned int)chain;
  retid = SVC_Call(SYSCALL_os_perso_derive_node_bip32_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_os_perso_derive_node_bip32_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d03fe6:	2004      	movs	r0, #4
c0d03fe8:	f7fe fdd7 	bl	c0d02b9a <os_longjmp>
c0d03fec:	600053ba 	.word	0x600053ba
c0d03ff0:	9000531e 	.word	0x9000531e

c0d03ff4 <os_sched_exit>:
  }
  return (unsigned int)ret;
}

void os_sched_exit ( unsigned int exit_code ) 
{
c0d03ff4:	b580      	push	{r7, lr}
c0d03ff6:	b082      	sub	sp, #8
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+1];
  parameters[0] = (unsigned int)exit_code;
c0d03ff8:	9000      	str	r0, [sp, #0]
  retid = SVC_Call(SYSCALL_os_sched_exit_ID_IN, parameters);
c0d03ffa:	4807      	ldr	r0, [pc, #28]	; (c0d04018 <os_sched_exit+0x24>)
c0d03ffc:	4669      	mov	r1, sp
c0d03ffe:	f7ff fe87 	bl	c0d03d10 <SVC_Call>
c0d04002:	aa01      	add	r2, sp, #4
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d04004:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_os_sched_exit_ID_OUT) {
c0d04006:	4905      	ldr	r1, [pc, #20]	; (c0d0401c <os_sched_exit+0x28>)
c0d04008:	4288      	cmp	r0, r1
c0d0400a:	d101      	bne.n	c0d04010 <os_sched_exit+0x1c>
    THROW(EXCEPTION_SECURITY);
  }
}
c0d0400c:	b002      	add	sp, #8
c0d0400e:	bd80      	pop	{r7, pc}
  unsigned int parameters [0+1];
  parameters[0] = (unsigned int)exit_code;
  retid = SVC_Call(SYSCALL_os_sched_exit_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_os_sched_exit_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d04010:	2004      	movs	r0, #4
c0d04012:	f7fe fdc2 	bl	c0d02b9a <os_longjmp>
c0d04016:	46c0      	nop			; (mov r8, r8)
c0d04018:	600062e1 	.word	0x600062e1
c0d0401c:	9000626f 	.word	0x9000626f

c0d04020 <os_ux>:
    THROW(EXCEPTION_SECURITY);
  }
}

unsigned int os_ux ( bolos_ux_params_t * params ) 
{
c0d04020:	b580      	push	{r7, lr}
c0d04022:	b082      	sub	sp, #8
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+1];
  parameters[0] = (unsigned int)params;
c0d04024:	9000      	str	r0, [sp, #0]
  retid = SVC_Call(SYSCALL_os_ux_ID_IN, parameters);
c0d04026:	4807      	ldr	r0, [pc, #28]	; (c0d04044 <os_ux+0x24>)
c0d04028:	4669      	mov	r1, sp
c0d0402a:	f7ff fe71 	bl	c0d03d10 <SVC_Call>
c0d0402e:	aa01      	add	r2, sp, #4
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d04030:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_os_ux_ID_OUT) {
c0d04032:	4905      	ldr	r1, [pc, #20]	; (c0d04048 <os_ux+0x28>)
c0d04034:	4288      	cmp	r0, r1
c0d04036:	d102      	bne.n	c0d0403e <os_ux+0x1e>
    THROW(EXCEPTION_SECURITY);
  }
  return (unsigned int)ret;
c0d04038:	9801      	ldr	r0, [sp, #4]
c0d0403a:	b002      	add	sp, #8
c0d0403c:	bd80      	pop	{r7, pc}
  unsigned int parameters [0+1];
  parameters[0] = (unsigned int)params;
  retid = SVC_Call(SYSCALL_os_ux_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_os_ux_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d0403e:	2004      	movs	r0, #4
c0d04040:	f7fe fdab 	bl	c0d02b9a <os_longjmp>
c0d04044:	60006458 	.word	0x60006458
c0d04048:	9000641f 	.word	0x9000641f

c0d0404c <os_lib_throw>:
    THROW(EXCEPTION_SECURITY);
  }
}

void os_lib_throw ( unsigned int exception ) 
{
c0d0404c:	b580      	push	{r7, lr}
c0d0404e:	b082      	sub	sp, #8
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+1];
  parameters[0] = (unsigned int)exception;
c0d04050:	9000      	str	r0, [sp, #0]
  retid = SVC_Call(SYSCALL_os_lib_throw_ID_IN, parameters);
c0d04052:	4807      	ldr	r0, [pc, #28]	; (c0d04070 <os_lib_throw+0x24>)
c0d04054:	4669      	mov	r1, sp
c0d04056:	f7ff fe5b 	bl	c0d03d10 <SVC_Call>
c0d0405a:	aa01      	add	r2, sp, #4
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d0405c:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_os_lib_throw_ID_OUT) {
c0d0405e:	4905      	ldr	r1, [pc, #20]	; (c0d04074 <os_lib_throw+0x28>)
c0d04060:	4288      	cmp	r0, r1
c0d04062:	d101      	bne.n	c0d04068 <os_lib_throw+0x1c>
    THROW(EXCEPTION_SECURITY);
  }
}
c0d04064:	b002      	add	sp, #8
c0d04066:	bd80      	pop	{r7, pc}
  unsigned int parameters [0+1];
  parameters[0] = (unsigned int)exception;
  retid = SVC_Call(SYSCALL_os_lib_throw_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_os_lib_throw_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d04068:	2004      	movs	r0, #4
c0d0406a:	f7fe fd96 	bl	c0d02b9a <os_longjmp>
c0d0406e:	46c0      	nop			; (mov r8, r8)
c0d04070:	60006745 	.word	0x60006745
c0d04074:	90006787 	.word	0x90006787

c0d04078 <os_flags>:
  }
}

unsigned int os_flags ( void ) 
{
c0d04078:	b580      	push	{r7, lr}
c0d0407a:	b082      	sub	sp, #8
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0];
  retid = SVC_Call(SYSCALL_os_flags_ID_IN, parameters);
c0d0407c:	4807      	ldr	r0, [pc, #28]	; (c0d0409c <os_flags+0x24>)
c0d0407e:	a901      	add	r1, sp, #4
c0d04080:	f7ff fe46 	bl	c0d03d10 <SVC_Call>
c0d04084:	466a      	mov	r2, sp
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d04086:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_os_flags_ID_OUT) {
c0d04088:	4905      	ldr	r1, [pc, #20]	; (c0d040a0 <os_flags+0x28>)
c0d0408a:	4288      	cmp	r0, r1
c0d0408c:	d102      	bne.n	c0d04094 <os_flags+0x1c>
    THROW(EXCEPTION_SECURITY);
  }
  return (unsigned int)ret;
c0d0408e:	9800      	ldr	r0, [sp, #0]
c0d04090:	b002      	add	sp, #8
c0d04092:	bd80      	pop	{r7, pc}
  unsigned int retid;
  unsigned int parameters [0];
  retid = SVC_Call(SYSCALL_os_flags_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_os_flags_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d04094:	2004      	movs	r0, #4
c0d04096:	f7fe fd80 	bl	c0d02b9a <os_longjmp>
c0d0409a:	46c0      	nop			; (mov r8, r8)
c0d0409c:	6000686e 	.word	0x6000686e
c0d040a0:	9000687f 	.word	0x9000687f

c0d040a4 <os_registry_get_current_app_tag>:
  }
  return (unsigned int)ret;
}

unsigned int os_registry_get_current_app_tag ( unsigned int tag, unsigned char * buffer, unsigned int maxlen ) 
{
c0d040a4:	b580      	push	{r7, lr}
c0d040a6:	b084      	sub	sp, #16
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+3];
  parameters[0] = (unsigned int)tag;
c0d040a8:	ab00      	add	r3, sp, #0
c0d040aa:	c307      	stmia	r3!, {r0, r1, r2}
  parameters[1] = (unsigned int)buffer;
  parameters[2] = (unsigned int)maxlen;
  retid = SVC_Call(SYSCALL_os_registry_get_current_app_tag_ID_IN, parameters);
c0d040ac:	4807      	ldr	r0, [pc, #28]	; (c0d040cc <os_registry_get_current_app_tag+0x28>)
c0d040ae:	4669      	mov	r1, sp
c0d040b0:	f7ff fe2e 	bl	c0d03d10 <SVC_Call>
c0d040b4:	aa03      	add	r2, sp, #12
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d040b6:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_os_registry_get_current_app_tag_ID_OUT) {
c0d040b8:	4905      	ldr	r1, [pc, #20]	; (c0d040d0 <os_registry_get_current_app_tag+0x2c>)
c0d040ba:	4288      	cmp	r0, r1
c0d040bc:	d102      	bne.n	c0d040c4 <os_registry_get_current_app_tag+0x20>
    THROW(EXCEPTION_SECURITY);
  }
  return (unsigned int)ret;
c0d040be:	9803      	ldr	r0, [sp, #12]
c0d040c0:	b004      	add	sp, #16
c0d040c2:	bd80      	pop	{r7, pc}
  parameters[1] = (unsigned int)buffer;
  parameters[2] = (unsigned int)maxlen;
  retid = SVC_Call(SYSCALL_os_registry_get_current_app_tag_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_os_registry_get_current_app_tag_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d040c4:	2004      	movs	r0, #4
c0d040c6:	f7fe fd68 	bl	c0d02b9a <os_longjmp>
c0d040ca:	46c0      	nop			; (mov r8, r8)
c0d040cc:	600070d4 	.word	0x600070d4
c0d040d0:	90007087 	.word	0x90007087

c0d040d4 <io_seproxyhal_spi_send>:
  }
  return (unsigned int)ret;
}

void io_seproxyhal_spi_send ( const unsigned char * buffer, unsigned short length ) 
{
c0d040d4:	b580      	push	{r7, lr}
c0d040d6:	b084      	sub	sp, #16
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+2];
  parameters[0] = (unsigned int)buffer;
c0d040d8:	9001      	str	r0, [sp, #4]
  parameters[1] = (unsigned int)length;
c0d040da:	9102      	str	r1, [sp, #8]
  retid = SVC_Call(SYSCALL_io_seproxyhal_spi_send_ID_IN, parameters);
c0d040dc:	4806      	ldr	r0, [pc, #24]	; (c0d040f8 <io_seproxyhal_spi_send+0x24>)
c0d040de:	a901      	add	r1, sp, #4
c0d040e0:	f7ff fe16 	bl	c0d03d10 <SVC_Call>
c0d040e4:	aa03      	add	r2, sp, #12
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d040e6:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_io_seproxyhal_spi_send_ID_OUT) {
c0d040e8:	4904      	ldr	r1, [pc, #16]	; (c0d040fc <io_seproxyhal_spi_send+0x28>)
c0d040ea:	4288      	cmp	r0, r1
c0d040ec:	d101      	bne.n	c0d040f2 <io_seproxyhal_spi_send+0x1e>
    THROW(EXCEPTION_SECURITY);
  }
}
c0d040ee:	b004      	add	sp, #16
c0d040f0:	bd80      	pop	{r7, pc}
  parameters[0] = (unsigned int)buffer;
  parameters[1] = (unsigned int)length;
  retid = SVC_Call(SYSCALL_io_seproxyhal_spi_send_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_io_seproxyhal_spi_send_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d040f2:	2004      	movs	r0, #4
c0d040f4:	f7fe fd51 	bl	c0d02b9a <os_longjmp>
c0d040f8:	6000721c 	.word	0x6000721c
c0d040fc:	900072f3 	.word	0x900072f3

c0d04100 <io_seproxyhal_spi_is_status_sent>:
  }
}

unsigned int io_seproxyhal_spi_is_status_sent ( void ) 
{
c0d04100:	b580      	push	{r7, lr}
c0d04102:	b082      	sub	sp, #8
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0];
  retid = SVC_Call(SYSCALL_io_seproxyhal_spi_is_status_sent_ID_IN, parameters);
c0d04104:	4807      	ldr	r0, [pc, #28]	; (c0d04124 <io_seproxyhal_spi_is_status_sent+0x24>)
c0d04106:	a901      	add	r1, sp, #4
c0d04108:	f7ff fe02 	bl	c0d03d10 <SVC_Call>
c0d0410c:	466a      	mov	r2, sp
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d0410e:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_io_seproxyhal_spi_is_status_sent_ID_OUT) {
c0d04110:	4905      	ldr	r1, [pc, #20]	; (c0d04128 <io_seproxyhal_spi_is_status_sent+0x28>)
c0d04112:	4288      	cmp	r0, r1
c0d04114:	d102      	bne.n	c0d0411c <io_seproxyhal_spi_is_status_sent+0x1c>
    THROW(EXCEPTION_SECURITY);
  }
  return (unsigned int)ret;
c0d04116:	9800      	ldr	r0, [sp, #0]
c0d04118:	b002      	add	sp, #8
c0d0411a:	bd80      	pop	{r7, pc}
  unsigned int retid;
  unsigned int parameters [0];
  retid = SVC_Call(SYSCALL_io_seproxyhal_spi_is_status_sent_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_io_seproxyhal_spi_is_status_sent_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d0411c:	2004      	movs	r0, #4
c0d0411e:	f7fe fd3c 	bl	c0d02b9a <os_longjmp>
c0d04122:	46c0      	nop			; (mov r8, r8)
c0d04124:	600073cf 	.word	0x600073cf
c0d04128:	9000737f 	.word	0x9000737f

c0d0412c <io_seproxyhal_spi_recv>:
  }
  return (unsigned int)ret;
}

unsigned short io_seproxyhal_spi_recv ( unsigned char * buffer, unsigned short maxlength, unsigned int flags ) 
{
c0d0412c:	b580      	push	{r7, lr}
c0d0412e:	b084      	sub	sp, #16
  unsigned int ret;
  unsigned int retid;
  unsigned int parameters [0+3];
  parameters[0] = (unsigned int)buffer;
c0d04130:	ab00      	add	r3, sp, #0
c0d04132:	c307      	stmia	r3!, {r0, r1, r2}
  parameters[1] = (unsigned int)maxlength;
  parameters[2] = (unsigned int)flags;
  retid = SVC_Call(SYSCALL_io_seproxyhal_spi_recv_ID_IN, parameters);
c0d04134:	4807      	ldr	r0, [pc, #28]	; (c0d04154 <io_seproxyhal_spi_recv+0x28>)
c0d04136:	4669      	mov	r1, sp
c0d04138:	f7ff fdea 	bl	c0d03d10 <SVC_Call>
c0d0413c:	aa03      	add	r2, sp, #12
  asm volatile("str r1, %0":"=m"(ret)::"r1");
c0d0413e:	6011      	str	r1, [r2, #0]
  if (retid != SYSCALL_io_seproxyhal_spi_recv_ID_OUT) {
c0d04140:	4905      	ldr	r1, [pc, #20]	; (c0d04158 <io_seproxyhal_spi_recv+0x2c>)
c0d04142:	4288      	cmp	r0, r1
c0d04144:	d103      	bne.n	c0d0414e <io_seproxyhal_spi_recv+0x22>
c0d04146:	a803      	add	r0, sp, #12
    THROW(EXCEPTION_SECURITY);
  }
  return (unsigned short)ret;
c0d04148:	8800      	ldrh	r0, [r0, #0]
c0d0414a:	b004      	add	sp, #16
c0d0414c:	bd80      	pop	{r7, pc}
  parameters[1] = (unsigned int)maxlength;
  parameters[2] = (unsigned int)flags;
  retid = SVC_Call(SYSCALL_io_seproxyhal_spi_recv_ID_IN, parameters);
  asm volatile("str r1, %0":"=m"(ret)::"r1");
  if (retid != SYSCALL_io_seproxyhal_spi_recv_ID_OUT) {
    THROW(EXCEPTION_SECURITY);
c0d0414e:	2004      	movs	r0, #4
c0d04150:	f7fe fd23 	bl	c0d02b9a <os_longjmp>
c0d04154:	600074d1 	.word	0x600074d1
c0d04158:	9000742b 	.word	0x9000742b

c0d0415c <u2f_apdu_sign>:

    u2f_message_reply(service, U2F_CMD_MSG, (uint8_t *)SW_INTERNAL, sizeof(SW_INTERNAL));
}

void u2f_apdu_sign(u2f_service_t *service, uint8_t p1, uint8_t p2,
                     uint8_t *buffer, uint16_t length) {
c0d0415c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0415e:	b085      	sub	sp, #20
    UNUSED(p2);
    uint8_t keyHandleLength;
    uint8_t i;

    // can't process the apdu if another one is already scheduled in
    if (G_io_apdu_state != APDU_IDLE) {
c0d04160:	4a34      	ldr	r2, [pc, #208]	; (c0d04234 <u2f_apdu_sign+0xd8>)
c0d04162:	7812      	ldrb	r2, [r2, #0]
    for (i = 0; i < keyHandleLength; i++) {
        buffer[U2F_HANDLE_SIGN_HEADER_SIZE + i] ^= U2F_PROXY_MAGIC[i % (sizeof(U2F_PROXY_MAGIC)-1)];
    }
    // Check that it looks like an APDU
    if (length != U2F_HANDLE_SIGN_HEADER_SIZE + 5 + buffer[U2F_HANDLE_SIGN_HEADER_SIZE + 4]) {
        u2f_message_reply(service, U2F_CMD_MSG,
c0d04164:	2483      	movs	r4, #131	; 0x83
    UNUSED(p2);
    uint8_t keyHandleLength;
    uint8_t i;

    // can't process the apdu if another one is already scheduled in
    if (G_io_apdu_state != APDU_IDLE) {
c0d04166:	2a00      	cmp	r2, #0
c0d04168:	d002      	beq.n	c0d04170 <u2f_apdu_sign+0x14>
        u2f_message_reply(service, U2F_CMD_MSG,
c0d0416a:	4a3b      	ldr	r2, [pc, #236]	; (c0d04258 <u2f_apdu_sign+0xfc>)
c0d0416c:	447a      	add	r2, pc
c0d0416e:	e009      	b.n	c0d04184 <u2f_apdu_sign+0x28>
c0d04170:	9a0a      	ldr	r2, [sp, #40]	; 0x28
                  (uint8_t *)SW_BUSY,
                  sizeof(SW_BUSY));
        return;        
    }

    if (length < U2F_HANDLE_SIGN_HEADER_SIZE + 5 /*at least an apdu header*/) {
c0d04172:	2a45      	cmp	r2, #69	; 0x45
c0d04174:	d802      	bhi.n	c0d0417c <u2f_apdu_sign+0x20>
        u2f_message_reply(service, U2F_CMD_MSG,
c0d04176:	4a39      	ldr	r2, [pc, #228]	; (c0d0425c <u2f_apdu_sign+0x100>)
c0d04178:	447a      	add	r2, pc
c0d0417a:	e003      	b.n	c0d04184 <u2f_apdu_sign+0x28>
                  sizeof(SW_WRONG_LENGTH));
        return;
    }
    
    // Confirm immediately if it's just a validation call
    if (p1 == P1_SIGN_CHECK_ONLY) {
c0d0417c:	2907      	cmp	r1, #7
c0d0417e:	d107      	bne.n	c0d04190 <u2f_apdu_sign+0x34>
        u2f_message_reply(service, U2F_CMD_MSG,
c0d04180:	4a37      	ldr	r2, [pc, #220]	; (c0d04260 <u2f_apdu_sign+0x104>)
c0d04182:	447a      	add	r2, pc
c0d04184:	2302      	movs	r3, #2
c0d04186:	4621      	mov	r1, r4
c0d04188:	f000 fcb9 	bl	c0d04afe <u2f_message_reply>
    app_dispatch();
    if ((btchip_context_D.io_flags & IO_ASYNCH_REPLY) == 0) {
        u2f_proxy_response(service, btchip_context_D.outLength);
    }
    */
}
c0d0418c:	b005      	add	sp, #20
c0d0418e:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d04190:	9202      	str	r2, [sp, #8]
c0d04192:	9401      	str	r4, [sp, #4]
c0d04194:	9003      	str	r0, [sp, #12]
                  sizeof(SW_PROOF_OF_PRESENCE_REQUIRED));
        return;
    }

    // Unwrap magic
    keyHandleLength = buffer[U2F_HANDLE_SIGN_HEADER_SIZE-1];
c0d04196:	2040      	movs	r0, #64	; 0x40
c0d04198:	9304      	str	r3, [sp, #16]
c0d0419a:	5c1f      	ldrb	r7, [r3, r0]
    
    // reply to the "get magic" question of the host
    if (keyHandleLength == 5) {
c0d0419c:	2f00      	cmp	r7, #0
c0d0419e:	d018      	beq.n	c0d041d2 <u2f_apdu_sign+0x76>
c0d041a0:	2f05      	cmp	r7, #5
c0d041a2:	9e04      	ldr	r6, [sp, #16]
c0d041a4:	d107      	bne.n	c0d041b6 <u2f_apdu_sign+0x5a>
        // GET U2F PROXY PARAMETERS
        // this apdu is not subject to proxy magic masking
        // APDU is F1 D0 00 00 00 to get the magic proxy
        // RAPDU: <>
        if (os_memcmp(buffer+U2F_HANDLE_SIGN_HEADER_SIZE, "\xF1\xD0\x00\x00\x00", 5) == 0 ) {
c0d041a6:	4630      	mov	r0, r6
c0d041a8:	3041      	adds	r0, #65	; 0x41
c0d041aa:	a123      	add	r1, pc, #140	; (adr r1, c0d04238 <u2f_apdu_sign+0xdc>)
c0d041ac:	2205      	movs	r2, #5
c0d041ae:	f7fe fcdd 	bl	c0d02b6c <os_memcmp>
c0d041b2:	2800      	cmp	r0, #0
c0d041b4:	d02c      	beq.n	c0d04210 <u2f_apdu_sign+0xb4>
        }
    }
    

    for (i = 0; i < keyHandleLength; i++) {
        buffer[U2F_HANDLE_SIGN_HEADER_SIZE + i] ^= U2F_PROXY_MAGIC[i % (sizeof(U2F_PROXY_MAGIC)-1)];
c0d041b6:	3641      	adds	r6, #65	; 0x41
c0d041b8:	2400      	movs	r4, #0
c0d041ba:	a522      	add	r5, pc, #136	; (adr r5, c0d04244 <u2f_apdu_sign+0xe8>)
c0d041bc:	b2e0      	uxtb	r0, r4
c0d041be:	2103      	movs	r1, #3
c0d041c0:	f002 fe34 	bl	c0d06e2c <__aeabi_uidivmod>
c0d041c4:	5d30      	ldrb	r0, [r6, r4]
c0d041c6:	5c69      	ldrb	r1, [r5, r1]
c0d041c8:	4041      	eors	r1, r0
c0d041ca:	5531      	strb	r1, [r6, r4]
            return;
        }
    }
    

    for (i = 0; i < keyHandleLength; i++) {
c0d041cc:	1c64      	adds	r4, r4, #1
c0d041ce:	42a7      	cmp	r7, r4
c0d041d0:	d1f4      	bne.n	c0d041bc <u2f_apdu_sign+0x60>
        buffer[U2F_HANDLE_SIGN_HEADER_SIZE + i] ^= U2F_PROXY_MAGIC[i % (sizeof(U2F_PROXY_MAGIC)-1)];
    }
    // Check that it looks like an APDU
    if (length != U2F_HANDLE_SIGN_HEADER_SIZE + 5 + buffer[U2F_HANDLE_SIGN_HEADER_SIZE + 4]) {
c0d041d2:	2045      	movs	r0, #69	; 0x45
c0d041d4:	9904      	ldr	r1, [sp, #16]
c0d041d6:	5c08      	ldrb	r0, [r1, r0]
c0d041d8:	3046      	adds	r0, #70	; 0x46
c0d041da:	9a02      	ldr	r2, [sp, #8]
c0d041dc:	4282      	cmp	r2, r0
c0d041de:	d111      	bne.n	c0d04204 <u2f_apdu_sign+0xa8>
                  sizeof(SW_BAD_KEY_HANDLE));
        return;
    }

    // make the apdu available to higher layers
    os_memmove(G_io_apdu_buffer, buffer + U2F_HANDLE_SIGN_HEADER_SIZE, keyHandleLength);
c0d041e0:	3141      	adds	r1, #65	; 0x41
c0d041e2:	4817      	ldr	r0, [pc, #92]	; (c0d04240 <u2f_apdu_sign+0xe4>)
c0d041e4:	463a      	mov	r2, r7
c0d041e6:	f7fe fc24 	bl	c0d02a32 <os_memmove>
    G_io_apdu_length = keyHandleLength;
c0d041ea:	4819      	ldr	r0, [pc, #100]	; (c0d04250 <u2f_apdu_sign+0xf4>)
c0d041ec:	8007      	strh	r7, [r0, #0]
    G_io_apdu_media = IO_APDU_MEDIA_U2F; // the effective transport is managed by the U2F layer
c0d041ee:	4819      	ldr	r0, [pc, #100]	; (c0d04254 <u2f_apdu_sign+0xf8>)
c0d041f0:	2107      	movs	r1, #7
c0d041f2:	7001      	strb	r1, [r0, #0]
    G_io_apdu_state = APDU_U2F;
c0d041f4:	2009      	movs	r0, #9
c0d041f6:	490f      	ldr	r1, [pc, #60]	; (c0d04234 <u2f_apdu_sign+0xd8>)
c0d041f8:	7008      	strb	r0, [r1, #0]

    // prepare for asynch reply
    u2f_message_set_autoreply_wait_user_presence(service, true);
c0d041fa:	2101      	movs	r1, #1
c0d041fc:	9803      	ldr	r0, [sp, #12]
c0d041fe:	f000 fc53 	bl	c0d04aa8 <u2f_message_set_autoreply_wait_user_presence>
c0d04202:	e7c3      	b.n	c0d0418c <u2f_apdu_sign+0x30>
    for (i = 0; i < keyHandleLength; i++) {
        buffer[U2F_HANDLE_SIGN_HEADER_SIZE + i] ^= U2F_PROXY_MAGIC[i % (sizeof(U2F_PROXY_MAGIC)-1)];
    }
    // Check that it looks like an APDU
    if (length != U2F_HANDLE_SIGN_HEADER_SIZE + 5 + buffer[U2F_HANDLE_SIGN_HEADER_SIZE + 4]) {
        u2f_message_reply(service, U2F_CMD_MSG,
c0d04204:	4a17      	ldr	r2, [pc, #92]	; (c0d04264 <u2f_apdu_sign+0x108>)
c0d04206:	447a      	add	r2, pc
c0d04208:	2302      	movs	r3, #2
c0d0420a:	9803      	ldr	r0, [sp, #12]
c0d0420c:	9901      	ldr	r1, [sp, #4]
c0d0420e:	e7bb      	b.n	c0d04188 <u2f_apdu_sign+0x2c>
        // this apdu is not subject to proxy magic masking
        // APDU is F1 D0 00 00 00 to get the magic proxy
        // RAPDU: <>
        if (os_memcmp(buffer+U2F_HANDLE_SIGN_HEADER_SIZE, "\xF1\xD0\x00\x00\x00", 5) == 0 ) {
            // U2F_PROXY_MAGIC is given as a 0 terminated string
            G_io_apdu_buffer[0] = sizeof(U2F_PROXY_MAGIC)-1;
c0d04210:	4e0b      	ldr	r6, [pc, #44]	; (c0d04240 <u2f_apdu_sign+0xe4>)
c0d04212:	2203      	movs	r2, #3
c0d04214:	7032      	strb	r2, [r6, #0]
            os_memmove(G_io_apdu_buffer+1, U2F_PROXY_MAGIC, sizeof(U2F_PROXY_MAGIC)-1);
c0d04216:	1c70      	adds	r0, r6, #1
c0d04218:	a10a      	add	r1, pc, #40	; (adr r1, c0d04244 <u2f_apdu_sign+0xe8>)
c0d0421a:	f7fe fc0a 	bl	c0d02a32 <os_memmove>
            os_memmove(G_io_apdu_buffer+1+sizeof(U2F_PROXY_MAGIC)-1, "\x90\x00\x90\x00", 4);
c0d0421e:	1d30      	adds	r0, r6, #4
c0d04220:	a109      	add	r1, pc, #36	; (adr r1, c0d04248 <u2f_apdu_sign+0xec>)
c0d04222:	2204      	movs	r2, #4
c0d04224:	f7fe fc05 	bl	c0d02a32 <os_memmove>
            u2f_message_reply(service, U2F_CMD_MSG,
                              (uint8_t *)G_io_apdu_buffer,
                              G_io_apdu_buffer[0]+1+2+2);
c0d04228:	7830      	ldrb	r0, [r6, #0]
c0d0422a:	1d43      	adds	r3, r0, #5
        if (os_memcmp(buffer+U2F_HANDLE_SIGN_HEADER_SIZE, "\xF1\xD0\x00\x00\x00", 5) == 0 ) {
            // U2F_PROXY_MAGIC is given as a 0 terminated string
            G_io_apdu_buffer[0] = sizeof(U2F_PROXY_MAGIC)-1;
            os_memmove(G_io_apdu_buffer+1, U2F_PROXY_MAGIC, sizeof(U2F_PROXY_MAGIC)-1);
            os_memmove(G_io_apdu_buffer+1+sizeof(U2F_PROXY_MAGIC)-1, "\x90\x00\x90\x00", 4);
            u2f_message_reply(service, U2F_CMD_MSG,
c0d0422c:	9803      	ldr	r0, [sp, #12]
c0d0422e:	9901      	ldr	r1, [sp, #4]
c0d04230:	4632      	mov	r2, r6
c0d04232:	e7a9      	b.n	c0d04188 <u2f_apdu_sign+0x2c>
c0d04234:	20001ebc 	.word	0x20001ebc
c0d04238:	0000d0f1 	.word	0x0000d0f1
c0d0423c:	00000000 	.word	0x00000000
c0d04240:	20001d4c 	.word	0x20001d4c
c0d04244:	00773077 	.word	0x00773077
c0d04248:	00900090 	.word	0x00900090
c0d0424c:	00000000 	.word	0x00000000
c0d04250:	20001ebe 	.word	0x20001ebe
c0d04254:	20001ea8 	.word	0x20001ea8
c0d04258:	0000c4f9 	.word	0x0000c4f9
c0d0425c:	0000c4ef 	.word	0x0000c4ef
c0d04260:	0000c4e7 	.word	0x0000c4e7
c0d04264:	0000c465 	.word	0x0000c465

c0d04268 <u2f_handle_cmd_init>:
    UNUSED(length);
    u2f_message_reply(service, U2F_CMD_MSG, (uint8_t *)INFO, sizeof(INFO));
}

void u2f_handle_cmd_init(u2f_service_t *service, uint8_t *buffer,
                         uint16_t length, uint8_t *channelInit) {
c0d04268:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0426a:	b081      	sub	sp, #4
c0d0426c:	461d      	mov	r5, r3
c0d0426e:	460e      	mov	r6, r1
c0d04270:	4604      	mov	r4, r0
    // screen_printf("U2F init\n");
    uint8_t channel[4];
    (void)length;
    if (u2f_is_channel_broadcast(channelInit)) {
c0d04272:	4628      	mov	r0, r5
c0d04274:	f000 fc08 	bl	c0d04a88 <u2f_is_channel_broadcast>
c0d04278:	2801      	cmp	r0, #1
c0d0427a:	d104      	bne.n	c0d04286 <u2f_handle_cmd_init+0x1e>
c0d0427c:	4668      	mov	r0, sp
        cx_rng(channel, 4);
c0d0427e:	2104      	movs	r1, #4
c0d04280:	f7ff fd88 	bl	c0d03d94 <cx_rng>
c0d04284:	e004      	b.n	c0d04290 <u2f_handle_cmd_init+0x28>
c0d04286:	4668      	mov	r0, sp
    } else {
        os_memmove(channel, channelInit, 4);
c0d04288:	2204      	movs	r2, #4
c0d0428a:	4629      	mov	r1, r5
c0d0428c:	f7fe fbd1 	bl	c0d02a32 <os_memmove>
    }
    os_memmove(G_io_apdu_buffer, buffer, 8);
c0d04290:	4f17      	ldr	r7, [pc, #92]	; (c0d042f0 <u2f_handle_cmd_init+0x88>)
c0d04292:	2208      	movs	r2, #8
c0d04294:	4638      	mov	r0, r7
c0d04296:	4631      	mov	r1, r6
c0d04298:	f7fe fbcb 	bl	c0d02a32 <os_memmove>
    os_memmove(G_io_apdu_buffer + 8, channel, 4);
c0d0429c:	4638      	mov	r0, r7
c0d0429e:	3008      	adds	r0, #8
c0d042a0:	4669      	mov	r1, sp
c0d042a2:	2204      	movs	r2, #4
c0d042a4:	f7fe fbc5 	bl	c0d02a32 <os_memmove>
    G_io_apdu_buffer[12] = INIT_U2F_VERSION;
c0d042a8:	2002      	movs	r0, #2
c0d042aa:	7338      	strb	r0, [r7, #12]
    G_io_apdu_buffer[13] = INIT_DEVICE_VERSION_MAJOR;
c0d042ac:	2000      	movs	r0, #0
c0d042ae:	7378      	strb	r0, [r7, #13]
c0d042b0:	2101      	movs	r1, #1
    G_io_apdu_buffer[14] = INIT_DEVICE_VERSION_MINOR;
c0d042b2:	73b9      	strb	r1, [r7, #14]
    G_io_apdu_buffer[15] = INIT_BUILD_VERSION;
c0d042b4:	73f8      	strb	r0, [r7, #15]
    G_io_apdu_buffer[16] = INIT_CAPABILITIES;
c0d042b6:	7438      	strb	r0, [r7, #16]

    if (u2f_is_channel_broadcast(channelInit)) {
c0d042b8:	4628      	mov	r0, r5
c0d042ba:	f000 fbe5 	bl	c0d04a88 <u2f_is_channel_broadcast>
c0d042be:	4601      	mov	r1, r0
c0d042c0:	1d20      	adds	r0, r4, #4
        os_memset(service->channel, 0xff, 4);
c0d042c2:	2586      	movs	r5, #134	; 0x86
    G_io_apdu_buffer[13] = INIT_DEVICE_VERSION_MAJOR;
    G_io_apdu_buffer[14] = INIT_DEVICE_VERSION_MINOR;
    G_io_apdu_buffer[15] = INIT_BUILD_VERSION;
    G_io_apdu_buffer[16] = INIT_CAPABILITIES;

    if (u2f_is_channel_broadcast(channelInit)) {
c0d042c4:	2901      	cmp	r1, #1
c0d042c6:	d106      	bne.n	c0d042d6 <u2f_handle_cmd_init+0x6e>
        os_memset(service->channel, 0xff, 4);
c0d042c8:	4629      	mov	r1, r5
c0d042ca:	3179      	adds	r1, #121	; 0x79
c0d042cc:	b2c9      	uxtb	r1, r1
c0d042ce:	2204      	movs	r2, #4
c0d042d0:	f7fe fba6 	bl	c0d02a20 <os_memset>
c0d042d4:	e003      	b.n	c0d042de <u2f_handle_cmd_init+0x76>
c0d042d6:	4669      	mov	r1, sp
    } else {
        os_memmove(service->channel, channel, 4);
c0d042d8:	2204      	movs	r2, #4
c0d042da:	f7fe fbaa 	bl	c0d02a32 <os_memmove>
    }
    u2f_message_reply(service, U2F_CMD_INIT, G_io_apdu_buffer, 17);
c0d042de:	4a04      	ldr	r2, [pc, #16]	; (c0d042f0 <u2f_handle_cmd_init+0x88>)
c0d042e0:	2311      	movs	r3, #17
c0d042e2:	4620      	mov	r0, r4
c0d042e4:	4629      	mov	r1, r5
c0d042e6:	f000 fc0a 	bl	c0d04afe <u2f_message_reply>
}
c0d042ea:	b001      	add	sp, #4
c0d042ec:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d042ee:	46c0      	nop			; (mov r8, r8)
c0d042f0:	20001d4c 	.word	0x20001d4c

c0d042f4 <u2f_handle_cmd_msg>:
    // screen_printf("U2F ping\n");
    u2f_message_reply(service, U2F_CMD_PING, buffer, length);
}

void u2f_handle_cmd_msg(u2f_service_t *service, uint8_t *buffer,
                        uint16_t length) {
c0d042f4:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d042f6:	b085      	sub	sp, #20
c0d042f8:	4615      	mov	r5, r2
c0d042fa:	460c      	mov	r4, r1
c0d042fc:	9004      	str	r0, [sp, #16]
    uint8_t cla = buffer[0];
    uint8_t ins = buffer[1];
    uint8_t p1 = buffer[2];
    uint8_t p2 = buffer[3];
    // in extended length buffer[4] must be 0
    uint32_t dataLength = /*(buffer[4] << 16) |*/ (buffer[5] << 8) | (buffer[6]);
c0d042fe:	79a0      	ldrb	r0, [r4, #6]
c0d04300:	7961      	ldrb	r1, [r4, #5]
c0d04302:	020e      	lsls	r6, r1, #8
c0d04304:	4306      	orrs	r6, r0
void u2f_handle_cmd_msg(u2f_service_t *service, uint8_t *buffer,
                        uint16_t length) {
    // screen_printf("U2F msg\n");
    uint8_t cla = buffer[0];
    uint8_t ins = buffer[1];
    uint8_t p1 = buffer[2];
c0d04306:	78a0      	ldrb	r0, [r4, #2]

void u2f_handle_cmd_msg(u2f_service_t *service, uint8_t *buffer,
                        uint16_t length) {
    // screen_printf("U2F msg\n");
    uint8_t cla = buffer[0];
    uint8_t ins = buffer[1];
c0d04308:	9002      	str	r0, [sp, #8]
c0d0430a:	7861      	ldrb	r1, [r4, #1]
}

void u2f_handle_cmd_msg(u2f_service_t *service, uint8_t *buffer,
                        uint16_t length) {
    // screen_printf("U2F msg\n");
    uint8_t cla = buffer[0];
c0d0430c:	7827      	ldrb	r7, [r4, #0]
    uint8_t ins = buffer[1];
    uint8_t p1 = buffer[2];
    uint8_t p2 = buffer[3];
    // in extended length buffer[4] must be 0
    uint32_t dataLength = /*(buffer[4] << 16) |*/ (buffer[5] << 8) | (buffer[6]);
    if (dataLength == (uint16_t)(length - 9) || dataLength == (uint16_t)(length - 7)) {
c0d0430e:	3a09      	subs	r2, #9
c0d04310:	b290      	uxth	r0, r2
        u2f_apdu_get_info(service, p1, p2, buffer + 7, dataLength);
        break;

    default:
        // screen_printf("unsupported\n");
        u2f_message_reply(service, U2F_CMD_MSG,
c0d04312:	2383      	movs	r3, #131	; 0x83
c0d04314:	9303      	str	r3, [sp, #12]
c0d04316:	4b1f      	ldr	r3, [pc, #124]	; (c0d04394 <u2f_handle_cmd_msg+0xa0>)
    uint8_t ins = buffer[1];
    uint8_t p1 = buffer[2];
    uint8_t p2 = buffer[3];
    // in extended length buffer[4] must be 0
    uint32_t dataLength = /*(buffer[4] << 16) |*/ (buffer[5] << 8) | (buffer[6]);
    if (dataLength == (uint16_t)(length - 9) || dataLength == (uint16_t)(length - 7)) {
c0d04318:	4286      	cmp	r6, r0
c0d0431a:	d003      	beq.n	c0d04324 <u2f_handle_cmd_msg+0x30>
c0d0431c:	1fed      	subs	r5, r5, #7
c0d0431e:	402b      	ands	r3, r5
c0d04320:	429e      	cmp	r6, r3
c0d04322:	d11b      	bne.n	c0d0435c <u2f_handle_cmd_msg+0x68>
c0d04324:	4632      	mov	r2, r6
                  (uint8_t *)SW_WRONG_LENGTH,
                  sizeof(SW_WRONG_LENGTH));
        return;
    }

    if (cla != FIDO_CLA) {
c0d04326:	2f00      	cmp	r7, #0
c0d04328:	d008      	beq.n	c0d0433c <u2f_handle_cmd_msg+0x48>
        u2f_message_reply(service, U2F_CMD_MSG,
c0d0432a:	4a1b      	ldr	r2, [pc, #108]	; (c0d04398 <u2f_handle_cmd_msg+0xa4>)
c0d0432c:	447a      	add	r2, pc
c0d0432e:	2302      	movs	r3, #2
c0d04330:	9804      	ldr	r0, [sp, #16]
c0d04332:	9903      	ldr	r1, [sp, #12]
c0d04334:	f000 fbe3 	bl	c0d04afe <u2f_message_reply>
        u2f_message_reply(service, U2F_CMD_MSG,
                 (uint8_t *)SW_UNKNOWN_INSTRUCTION,
                 sizeof(SW_UNKNOWN_INSTRUCTION));
        return;
    }
}
c0d04338:	b005      	add	sp, #20
c0d0433a:	bdf0      	pop	{r4, r5, r6, r7, pc}
        u2f_message_reply(service, U2F_CMD_MSG,
                  (uint8_t *)SW_UNKNOWN_CLASS,
                  sizeof(SW_UNKNOWN_CLASS));
        return;
    }
    switch (ins) {
c0d0433c:	2902      	cmp	r1, #2
c0d0433e:	dc17      	bgt.n	c0d04370 <u2f_handle_cmd_msg+0x7c>
c0d04340:	2901      	cmp	r1, #1
c0d04342:	d020      	beq.n	c0d04386 <u2f_handle_cmd_msg+0x92>
c0d04344:	2902      	cmp	r1, #2
c0d04346:	d11b      	bne.n	c0d04380 <u2f_handle_cmd_msg+0x8c>
        // screen_printf("enroll\n");
        u2f_apdu_enroll(service, p1, p2, buffer + 7, dataLength);
        break;
    case FIDO_INS_SIGN:
        // screen_printf("sign\n");
        u2f_apdu_sign(service, p1, p2, buffer + 7, dataLength);
c0d04348:	b290      	uxth	r0, r2
c0d0434a:	4669      	mov	r1, sp
c0d0434c:	6008      	str	r0, [r1, #0]
c0d0434e:	1de3      	adds	r3, r4, #7
c0d04350:	2200      	movs	r2, #0
c0d04352:	9804      	ldr	r0, [sp, #16]
c0d04354:	9902      	ldr	r1, [sp, #8]
c0d04356:	f7ff ff01 	bl	c0d0415c <u2f_apdu_sign>
c0d0435a:	e7ed      	b.n	c0d04338 <u2f_handle_cmd_msg+0x44>
    if (dataLength == (uint16_t)(length - 9) || dataLength == (uint16_t)(length - 7)) {
        // Le is optional
        // nominal case from the specification
    }
    // circumvent google chrome extended length encoding done on the last byte only (module 256) but all data being transferred
    else if (dataLength == (uint16_t)(length - 9)%256) {
c0d0435c:	b2d0      	uxtb	r0, r2
c0d0435e:	4286      	cmp	r6, r0
c0d04360:	d0e1      	beq.n	c0d04326 <u2f_handle_cmd_msg+0x32>
        dataLength = length - 9;
    }
    else if (dataLength == (uint16_t)(length - 7)%256) {
c0d04362:	b2e8      	uxtb	r0, r5
c0d04364:	4286      	cmp	r6, r0
c0d04366:	462a      	mov	r2, r5
c0d04368:	d0dd      	beq.n	c0d04326 <u2f_handle_cmd_msg+0x32>
        dataLength = length - 7;
    }    
    else { 
        // invalid size
        u2f_message_reply(service, U2F_CMD_MSG,
c0d0436a:	4a0c      	ldr	r2, [pc, #48]	; (c0d0439c <u2f_handle_cmd_msg+0xa8>)
c0d0436c:	447a      	add	r2, pc
c0d0436e:	e7de      	b.n	c0d0432e <u2f_handle_cmd_msg+0x3a>
c0d04370:	2903      	cmp	r1, #3
c0d04372:	d00b      	beq.n	c0d0438c <u2f_handle_cmd_msg+0x98>
c0d04374:	29c1      	cmp	r1, #193	; 0xc1
c0d04376:	d103      	bne.n	c0d04380 <u2f_handle_cmd_msg+0x8c>
                            uint8_t *buffer, uint16_t length) {
    UNUSED(p1);
    UNUSED(p2);
    UNUSED(buffer);
    UNUSED(length);
    u2f_message_reply(service, U2F_CMD_MSG, (uint8_t *)INFO, sizeof(INFO));
c0d04378:	4a09      	ldr	r2, [pc, #36]	; (c0d043a0 <u2f_handle_cmd_msg+0xac>)
c0d0437a:	447a      	add	r2, pc
c0d0437c:	2304      	movs	r3, #4
c0d0437e:	e7d7      	b.n	c0d04330 <u2f_handle_cmd_msg+0x3c>
        u2f_apdu_get_info(service, p1, p2, buffer + 7, dataLength);
        break;

    default:
        // screen_printf("unsupported\n");
        u2f_message_reply(service, U2F_CMD_MSG,
c0d04380:	4a0a      	ldr	r2, [pc, #40]	; (c0d043ac <u2f_handle_cmd_msg+0xb8>)
c0d04382:	447a      	add	r2, pc
c0d04384:	e7d3      	b.n	c0d0432e <u2f_handle_cmd_msg+0x3a>
    UNUSED(p1);
    UNUSED(p2);
    UNUSED(buffer);
    UNUSED(length);

    u2f_message_reply(service, U2F_CMD_MSG, (uint8_t *)SW_INTERNAL, sizeof(SW_INTERNAL));
c0d04386:	4a07      	ldr	r2, [pc, #28]	; (c0d043a4 <u2f_handle_cmd_msg+0xb0>)
c0d04388:	447a      	add	r2, pc
c0d0438a:	e7d0      	b.n	c0d0432e <u2f_handle_cmd_msg+0x3a>
    // screen_printf("U2F version\n");
    UNUSED(p1);
    UNUSED(p2);
    UNUSED(buffer);
    UNUSED(length);
    u2f_message_reply(service, U2F_CMD_MSG, (uint8_t *)U2F_VERSION, sizeof(U2F_VERSION));
c0d0438c:	4a06      	ldr	r2, [pc, #24]	; (c0d043a8 <u2f_handle_cmd_msg+0xb4>)
c0d0438e:	447a      	add	r2, pc
c0d04390:	2308      	movs	r3, #8
c0d04392:	e7cd      	b.n	c0d04330 <u2f_handle_cmd_msg+0x3c>
c0d04394:	0000ffff 	.word	0x0000ffff
c0d04398:	0000c34d 	.word	0x0000c34d
c0d0439c:	0000c2fb 	.word	0x0000c2fb
c0d043a0:	0000c2fb 	.word	0x0000c2fb
c0d043a4:	0000c2db 	.word	0x0000c2db
c0d043a8:	0000c2df 	.word	0x0000c2df
c0d043ac:	0000c2f9 	.word	0x0000c2f9

c0d043b0 <u2f_message_complete>:
                 sizeof(SW_UNKNOWN_INSTRUCTION));
        return;
    }
}

void u2f_message_complete(u2f_service_t *service) {
c0d043b0:	b580      	push	{r7, lr}
    uint8_t cmd = service->transportBuffer[0];
c0d043b2:	69c1      	ldr	r1, [r0, #28]
    uint16_t length = (service->transportBuffer[1] << 8) | (service->transportBuffer[2]);
c0d043b4:	788a      	ldrb	r2, [r1, #2]
c0d043b6:	784b      	ldrb	r3, [r1, #1]
c0d043b8:	021b      	lsls	r3, r3, #8
c0d043ba:	4313      	orrs	r3, r2
        return;
    }
}

void u2f_message_complete(u2f_service_t *service) {
    uint8_t cmd = service->transportBuffer[0];
c0d043bc:	780a      	ldrb	r2, [r1, #0]
    uint16_t length = (service->transportBuffer[1] << 8) | (service->transportBuffer[2]);
    switch (cmd) {
c0d043be:	2a81      	cmp	r2, #129	; 0x81
c0d043c0:	d009      	beq.n	c0d043d6 <u2f_message_complete+0x26>
c0d043c2:	2a83      	cmp	r2, #131	; 0x83
c0d043c4:	d00c      	beq.n	c0d043e0 <u2f_message_complete+0x30>
c0d043c6:	2a86      	cmp	r2, #134	; 0x86
c0d043c8:	d10e      	bne.n	c0d043e8 <u2f_message_complete+0x38>
    case U2F_CMD_INIT:
        u2f_handle_cmd_init(service, service->transportBuffer + 3, length, service->channel);
c0d043ca:	1cc9      	adds	r1, r1, #3
c0d043cc:	1d03      	adds	r3, r0, #4
c0d043ce:	2200      	movs	r2, #0
c0d043d0:	f7ff ff4a 	bl	c0d04268 <u2f_handle_cmd_init>
        break;
    case U2F_CMD_MSG:
        u2f_handle_cmd_msg(service, service->transportBuffer + 3, length);
        break;
    }
}
c0d043d4:	bd80      	pop	{r7, pc}
    switch (cmd) {
    case U2F_CMD_INIT:
        u2f_handle_cmd_init(service, service->transportBuffer + 3, length, service->channel);
        break;
    case U2F_CMD_PING:
        u2f_handle_cmd_ping(service, service->transportBuffer + 3, length);
c0d043d6:	1cca      	adds	r2, r1, #3
}

void u2f_handle_cmd_ping(u2f_service_t *service, uint8_t *buffer,
                         uint16_t length) {
    // screen_printf("U2F ping\n");
    u2f_message_reply(service, U2F_CMD_PING, buffer, length);
c0d043d8:	2181      	movs	r1, #129	; 0x81
c0d043da:	f000 fb90 	bl	c0d04afe <u2f_message_reply>
        break;
    case U2F_CMD_MSG:
        u2f_handle_cmd_msg(service, service->transportBuffer + 3, length);
        break;
    }
}
c0d043de:	bd80      	pop	{r7, pc}
        break;
    case U2F_CMD_PING:
        u2f_handle_cmd_ping(service, service->transportBuffer + 3, length);
        break;
    case U2F_CMD_MSG:
        u2f_handle_cmd_msg(service, service->transportBuffer + 3, length);
c0d043e0:	1cc9      	adds	r1, r1, #3
c0d043e2:	461a      	mov	r2, r3
c0d043e4:	f7ff ff86 	bl	c0d042f4 <u2f_handle_cmd_msg>
        break;
    }
}
c0d043e8:	bd80      	pop	{r7, pc}
	...

c0d043ec <u2f_io_send>:
#include "u2f_processing.h"
#include "u2f_impl.h"

#include "os_io_seproxyhal.h"

void u2f_io_send(uint8_t *buffer, uint16_t length, u2f_transport_media_t media) {
c0d043ec:	b570      	push	{r4, r5, r6, lr}
c0d043ee:	460d      	mov	r5, r1
c0d043f0:	4601      	mov	r1, r0
    if (media == U2F_MEDIA_USB) {
c0d043f2:	2a01      	cmp	r2, #1
c0d043f4:	d111      	bne.n	c0d0441a <u2f_io_send+0x2e>
        os_memmove(G_io_usb_ep_buffer, buffer, length);
c0d043f6:	4c09      	ldr	r4, [pc, #36]	; (c0d0441c <u2f_io_send+0x30>)
c0d043f8:	4620      	mov	r0, r4
c0d043fa:	462a      	mov	r2, r5
c0d043fc:	f7fe fb19 	bl	c0d02a32 <os_memmove>
        // wipe the remaining to avoid :
        // 1/ data leaks
        // 2/ invalid junk
        os_memset(G_io_usb_ep_buffer+length, 0, sizeof(G_io_usb_ep_buffer)-length);
c0d04400:	1960      	adds	r0, r4, r5
c0d04402:	2640      	movs	r6, #64	; 0x40
c0d04404:	1b72      	subs	r2, r6, r5
c0d04406:	2500      	movs	r5, #0
c0d04408:	4629      	mov	r1, r5
c0d0440a:	f7fe fb09 	bl	c0d02a20 <os_memset>
    }
    switch (media) {
    case U2F_MEDIA_USB:
        io_usb_send_ep(U2F_EPIN_ADDR, G_io_usb_ep_buffer, USB_SEGMENT_SIZE, 0);
c0d0440e:	2081      	movs	r0, #129	; 0x81
c0d04410:	4621      	mov	r1, r4
c0d04412:	4632      	mov	r2, r6
c0d04414:	462b      	mov	r3, r5
c0d04416:	f7fe fc5b 	bl	c0d02cd0 <io_usb_send_ep>
#endif
    default:
        PRINTF("Request to send on unsupported media %d\n", media);
        break;
    }
}
c0d0441a:	bd70      	pop	{r4, r5, r6, pc}
c0d0441c:	20001f5c 	.word	0x20001f5c

c0d04420 <u2f_transport_init>:

/**
 * Initialize the u2f transport and provide the buffer into which to store incoming message
 */
void u2f_transport_init(u2f_service_t *service, uint8_t* message_buffer, uint16_t message_buffer_length) {
    service->transportReceiveBuffer = message_buffer;
c0d04420:	60c1      	str	r1, [r0, #12]
    service->transportReceiveBufferLength = message_buffer_length;
c0d04422:	8202      	strh	r2, [r0, #16]
c0d04424:	2200      	movs	r2, #0
#warning TODO take into account the INIT during SEGMENTED message correctly (avoid erasing the first part of the apdu buffer when doing so)

// init
void u2f_transport_reset(u2f_service_t* service) {
    service->transportState = U2F_IDLE;
    service->transportOffset = 0;
c0d04426:	82c2      	strh	r2, [r0, #22]
    service->transportMedia = 0;
    service->transportPacketIndex = 0;
c0d04428:	7682      	strb	r2, [r0, #26]
    service->fakeChannelTransportState = U2F_IDLE;
    service->fakeChannelTransportOffset = 0;
    service->fakeChannelTransportPacketIndex = 0;    
    service->sending = false;
c0d0442a:	232b      	movs	r3, #43	; 0x2b
c0d0442c:	54c2      	strb	r2, [r0, r3]
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
c0d0442e:	232a      	movs	r3, #42	; 0x2a
c0d04430:	54c2      	strb	r2, [r0, r3]

// init
void u2f_transport_reset(u2f_service_t* service) {
    service->transportState = U2F_IDLE;
    service->transportOffset = 0;
    service->transportMedia = 0;
c0d04432:	8482      	strh	r2, [r0, #36]	; 0x24
    service->fakeChannelTransportOffset = 0;
    service->fakeChannelTransportPacketIndex = 0;    
    service->sending = false;
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
    // reset the receive buffer to allow for a new message to be received again (in case transmission of a CODE buffer the previous reply)
    service->transportBuffer = service->transportReceiveBuffer;
c0d04434:	61c1      	str	r1, [r0, #28]

// init
void u2f_transport_reset(u2f_service_t* service) {
    service->transportState = U2F_IDLE;
    service->transportOffset = 0;
    service->transportMedia = 0;
c0d04436:	6202      	str	r2, [r0, #32]
 */
void u2f_transport_init(u2f_service_t *service, uint8_t* message_buffer, uint16_t message_buffer_length) {
    service->transportReceiveBuffer = message_buffer;
    service->transportReceiveBufferLength = message_buffer_length;
    u2f_transport_reset(service);
}
c0d04438:	4770      	bx	lr
	...

c0d0443c <u2f_transport_sent>:

/**
 * Function called when the previously scheduled message to be sent on the media is effectively sent.
 * And a new message can be scheduled.
 */
void u2f_transport_sent(u2f_service_t* service, u2f_transport_media_t media) {
c0d0443c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0443e:	b083      	sub	sp, #12
c0d04440:	460d      	mov	r5, r1
c0d04442:	4604      	mov	r4, r0

    // previous mark packet as sent
    if (service->sending) {
c0d04444:	202b      	movs	r0, #43	; 0x2b
c0d04446:	5c21      	ldrb	r1, [r4, r0]
c0d04448:	4620      	mov	r0, r4
c0d0444a:	302b      	adds	r0, #43	; 0x2b
c0d0444c:	2900      	cmp	r1, #0
c0d0444e:	d002      	beq.n	c0d04456 <u2f_transport_sent+0x1a>
        service->sending = false;
c0d04450:	2100      	movs	r1, #0
c0d04452:	7001      	strb	r1, [r0, #0]
c0d04454:	e067      	b.n	c0d04526 <u2f_transport_sent+0xea>
        return;
    }

    // if idle (possibly after an error), then only await for a transmission 
    if (service->transportState != U2F_SENDING_RESPONSE 
c0d04456:	2120      	movs	r1, #32
c0d04458:	5c62      	ldrb	r2, [r4, r1]
        && service->transportState != U2F_SENDING_ERROR) {
c0d0445a:	1ed2      	subs	r2, r2, #3
c0d0445c:	b2d2      	uxtb	r2, r2
        service->sending = false;
        return;
    }

    // if idle (possibly after an error), then only await for a transmission 
    if (service->transportState != U2F_SENDING_RESPONSE 
c0d0445e:	4626      	mov	r6, r4
c0d04460:	3620      	adds	r6, #32
        && service->transportState != U2F_SENDING_ERROR) {
c0d04462:	2a01      	cmp	r2, #1
c0d04464:	d85f      	bhi.n	c0d04526 <u2f_transport_sent+0xea>
        // absorb the error, transport is erroneous but that won't hurt in the end.
        // also absorb the fake channel user presence check reply ack
        //THROW(INVALID_STATE);
        return;
    }
    if (service->transportOffset < service->transportLength) {
c0d04466:	8b22      	ldrh	r2, [r4, #24]
c0d04468:	8ae3      	ldrh	r3, [r4, #22]
c0d0446a:	429a      	cmp	r2, r3
c0d0446c:	d929      	bls.n	c0d044c2 <u2f_transport_sent+0x86>
        uint16_t mtu = (media == U2F_MEDIA_USB) ? USB_SEGMENT_SIZE : BLE_SEGMENT_SIZE;
        uint16_t channelHeader =
            (media == U2F_MEDIA_USB ? 4 : 0);
c0d0446e:	2604      	movs	r6, #4
c0d04470:	2000      	movs	r0, #0
c0d04472:	2d01      	cmp	r5, #1
c0d04474:	d000      	beq.n	c0d04478 <u2f_transport_sent+0x3c>
c0d04476:	4606      	mov	r6, r0
c0d04478:	9601      	str	r6, [sp, #4]
c0d0447a:	9002      	str	r0, [sp, #8]
        uint8_t headerSize =
            (service->transportPacketIndex == 0 ? (channelHeader + 3)
c0d0447c:	7ea0      	ldrb	r0, [r4, #26]
c0d0447e:	2603      	movs	r6, #3
c0d04480:	2701      	movs	r7, #1
c0d04482:	9700      	str	r7, [sp, #0]
c0d04484:	4637      	mov	r7, r6
c0d04486:	2800      	cmp	r0, #0
c0d04488:	d000      	beq.n	c0d0448c <u2f_transport_sent+0x50>
c0d0448a:	9f00      	ldr	r7, [sp, #0]
c0d0448c:	9e01      	ldr	r6, [sp, #4]
c0d0448e:	4337      	orrs	r7, r6
                                                : (channelHeader + 1));
        uint16_t blockSize = ((service->transportLength - service->transportOffset) >
                                      (mtu - headerSize)
c0d04490:	2640      	movs	r6, #64	; 0x40
c0d04492:	2d01      	cmp	r5, #1
c0d04494:	d000      	beq.n	c0d04498 <u2f_transport_sent+0x5c>
c0d04496:	460e      	mov	r6, r1
c0d04498:	1bf6      	subs	r6, r6, r7
        uint16_t channelHeader =
            (media == U2F_MEDIA_USB ? 4 : 0);
        uint8_t headerSize =
            (service->transportPacketIndex == 0 ? (channelHeader + 3)
                                                : (channelHeader + 1));
        uint16_t blockSize = ((service->transportLength - service->transportOffset) >
c0d0449a:	1ad1      	subs	r1, r2, r3
c0d0449c:	42b1      	cmp	r1, r6
c0d0449e:	dc00      	bgt.n	c0d044a2 <u2f_transport_sent+0x66>
c0d044a0:	460e      	mov	r6, r1
                                      (mtu - headerSize)
                                  ? (mtu - headerSize)
                                  : service->transportLength - service->transportOffset);
        uint16_t dataSize = blockSize + headerSize;
c0d044a2:	19f1      	adds	r1, r6, r7
        uint16_t offset = 0;
        // Fragment
        if (media == U2F_MEDIA_USB) {
c0d044a4:	9101      	str	r1, [sp, #4]
c0d044a6:	2d01      	cmp	r5, #1
c0d044a8:	d106      	bne.n	c0d044b8 <u2f_transport_sent+0x7c>
            os_memmove(G_io_usb_ep_buffer, service->channel, 4);
c0d044aa:	1d21      	adds	r1, r4, #4
c0d044ac:	4820      	ldr	r0, [pc, #128]	; (c0d04530 <u2f_transport_sent+0xf4>)
c0d044ae:	2204      	movs	r2, #4
c0d044b0:	9202      	str	r2, [sp, #8]
c0d044b2:	f7fe fabe 	bl	c0d02a32 <os_memmove>
c0d044b6:	7ea0      	ldrb	r0, [r4, #26]
            offset += 4;
        }
        if (service->transportPacketIndex == 0) {
c0d044b8:	2800      	cmp	r0, #0
c0d044ba:	d00f      	beq.n	c0d044dc <u2f_transport_sent+0xa0>
            G_io_usb_ep_buffer[offset++] = service->sendCmd;
            G_io_usb_ep_buffer[offset++] = (service->transportLength >> 8);
            G_io_usb_ep_buffer[offset++] = (service->transportLength & 0xff);
        } else {
            G_io_usb_ep_buffer[offset++] = (service->transportPacketIndex - 1);
c0d044bc:	30ff      	adds	r0, #255	; 0xff
c0d044be:	9902      	ldr	r1, [sp, #8]
c0d044c0:	e019      	b.n	c0d044f6 <u2f_transport_sent+0xba>
c0d044c2:	d130      	bne.n	c0d04526 <u2f_transport_sent+0xea>
c0d044c4:	2100      	movs	r1, #0
#warning TODO take into account the INIT during SEGMENTED message correctly (avoid erasing the first part of the apdu buffer when doing so)

// init
void u2f_transport_reset(u2f_service_t* service) {
    service->transportState = U2F_IDLE;
    service->transportOffset = 0;
c0d044c6:	82e1      	strh	r1, [r4, #22]
    service->transportMedia = 0;
    service->transportPacketIndex = 0;
c0d044c8:	76a1      	strb	r1, [r4, #26]
    service->fakeChannelTransportState = U2F_IDLE;
    service->fakeChannelTransportOffset = 0;
    service->fakeChannelTransportPacketIndex = 0;    
    service->sending = false;
c0d044ca:	7001      	strb	r1, [r0, #0]
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
c0d044cc:	202a      	movs	r0, #42	; 0x2a
c0d044ce:	5421      	strb	r1, [r4, r0]

// init
void u2f_transport_reset(u2f_service_t* service) {
    service->transportState = U2F_IDLE;
    service->transportOffset = 0;
    service->transportMedia = 0;
c0d044d0:	80b1      	strh	r1, [r6, #4]
c0d044d2:	6031      	str	r1, [r6, #0]
    service->fakeChannelTransportOffset = 0;
    service->fakeChannelTransportPacketIndex = 0;    
    service->sending = false;
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
    // reset the receive buffer to allow for a new message to be received again (in case transmission of a CODE buffer the previous reply)
    service->transportBuffer = service->transportReceiveBuffer;
c0d044d4:	68e0      	ldr	r0, [r4, #12]
c0d044d6:	61e0      	str	r0, [r4, #28]
    }
    // last part sent
    else if (service->transportOffset == service->transportLength) {
        u2f_transport_reset(service);
        // we sent the whole response (even if we haven't yet received the ack for the last sent usb in packet)
        G_io_apdu_state = APDU_IDLE;
c0d044d8:	4814      	ldr	r0, [pc, #80]	; (c0d0452c <u2f_transport_sent+0xf0>)
c0d044da:	e7ba      	b.n	c0d04452 <u2f_transport_sent+0x16>
        if (media == U2F_MEDIA_USB) {
            os_memmove(G_io_usb_ep_buffer, service->channel, 4);
            offset += 4;
        }
        if (service->transportPacketIndex == 0) {
            G_io_usb_ep_buffer[offset++] = service->sendCmd;
c0d044dc:	2040      	movs	r0, #64	; 0x40
c0d044de:	5c20      	ldrb	r0, [r4, r0]
c0d044e0:	9b02      	ldr	r3, [sp, #8]
c0d044e2:	b299      	uxth	r1, r3
c0d044e4:	4a12      	ldr	r2, [pc, #72]	; (c0d04530 <u2f_transport_sent+0xf4>)
c0d044e6:	5450      	strb	r0, [r2, r1]
c0d044e8:	2001      	movs	r0, #1
c0d044ea:	4318      	orrs	r0, r3
            G_io_usb_ep_buffer[offset++] = (service->transportLength >> 8);
c0d044ec:	b281      	uxth	r1, r0
c0d044ee:	7e63      	ldrb	r3, [r4, #25]
c0d044f0:	5453      	strb	r3, [r2, r1]
c0d044f2:	1c41      	adds	r1, r0, #1
            G_io_usb_ep_buffer[offset++] = (service->transportLength & 0xff);
c0d044f4:	7e20      	ldrb	r0, [r4, #24]
c0d044f6:	b289      	uxth	r1, r1
c0d044f8:	4b0d      	ldr	r3, [pc, #52]	; (c0d04530 <u2f_transport_sent+0xf4>)
c0d044fa:	5458      	strb	r0, [r3, r1]
        } else {
            G_io_usb_ep_buffer[offset++] = (service->transportPacketIndex - 1);
        }
        if (service->transportBuffer != NULL) {
c0d044fc:	69e1      	ldr	r1, [r4, #28]
c0d044fe:	2900      	cmp	r1, #0
c0d04500:	d005      	beq.n	c0d0450e <u2f_transport_sent+0xd2>
                                                : (channelHeader + 1));
        uint16_t blockSize = ((service->transportLength - service->transportOffset) >
                                      (mtu - headerSize)
                                  ? (mtu - headerSize)
                                  : service->transportLength - service->transportOffset);
        uint16_t dataSize = blockSize + headerSize;
c0d04502:	b2b2      	uxth	r2, r6
            G_io_usb_ep_buffer[offset++] = (service->transportLength & 0xff);
        } else {
            G_io_usb_ep_buffer[offset++] = (service->transportPacketIndex - 1);
        }
        if (service->transportBuffer != NULL) {
            os_memmove(G_io_usb_ep_buffer + headerSize,
c0d04504:	19d8      	adds	r0, r3, r7
                       service->transportBuffer + service->transportOffset, blockSize);
c0d04506:	8ae3      	ldrh	r3, [r4, #22]
c0d04508:	18c9      	adds	r1, r1, r3
            G_io_usb_ep_buffer[offset++] = (service->transportLength & 0xff);
        } else {
            G_io_usb_ep_buffer[offset++] = (service->transportPacketIndex - 1);
        }
        if (service->transportBuffer != NULL) {
            os_memmove(G_io_usb_ep_buffer + headerSize,
c0d0450a:	f7fe fa92 	bl	c0d02a32 <os_memmove>
                       service->transportBuffer + service->transportOffset, blockSize);
        }
        service->transportOffset += blockSize;
c0d0450e:	8ae0      	ldrh	r0, [r4, #22]
c0d04510:	1980      	adds	r0, r0, r6
c0d04512:	82e0      	strh	r0, [r4, #22]
        service->transportPacketIndex++;
c0d04514:	7ea0      	ldrb	r0, [r4, #26]
c0d04516:	1c40      	adds	r0, r0, #1
c0d04518:	76a0      	strb	r0, [r4, #26]
        u2f_io_send(G_io_usb_ep_buffer, dataSize, media);
c0d0451a:	9801      	ldr	r0, [sp, #4]
c0d0451c:	b281      	uxth	r1, r0
c0d0451e:	4804      	ldr	r0, [pc, #16]	; (c0d04530 <u2f_transport_sent+0xf4>)
c0d04520:	462a      	mov	r2, r5
c0d04522:	f7ff ff63 	bl	c0d043ec <u2f_io_send>
    else if (service->transportOffset == service->transportLength) {
        u2f_transport_reset(service);
        // we sent the whole response (even if we haven't yet received the ack for the last sent usb in packet)
        G_io_apdu_state = APDU_IDLE;
    }
}
c0d04526:	b003      	add	sp, #12
c0d04528:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d0452a:	46c0      	nop			; (mov r8, r8)
c0d0452c:	20001ebc 	.word	0x20001ebc
c0d04530:	20001f5c 	.word	0x20001f5c

c0d04534 <u2f_transport_send_usb_user_presence_required>:

void u2f_transport_send_usb_user_presence_required(u2f_service_t *service) {
c0d04534:	b5b0      	push	{r4, r5, r7, lr}
    uint16_t offset = 0;
    service->sending = true;
c0d04536:	212b      	movs	r1, #43	; 0x2b
c0d04538:	2401      	movs	r4, #1
c0d0453a:	5444      	strb	r4, [r0, r1]
    os_memmove(G_io_usb_ep_buffer, service->channel, 4);
c0d0453c:	1d01      	adds	r1, r0, #4
c0d0453e:	4d0b      	ldr	r5, [pc, #44]	; (c0d0456c <u2f_transport_send_usb_user_presence_required+0x38>)
c0d04540:	2204      	movs	r2, #4
c0d04542:	4628      	mov	r0, r5
c0d04544:	f7fe fa75 	bl	c0d02a32 <os_memmove>
    offset += 4;
    G_io_usb_ep_buffer[offset++] = U2F_CMD_MSG;
    G_io_usb_ep_buffer[offset++] = 0;
    G_io_usb_ep_buffer[offset++] = 2;
    G_io_usb_ep_buffer[offset++] = 0x69;
    G_io_usb_ep_buffer[offset++] = 0x85;
c0d04548:	2083      	movs	r0, #131	; 0x83
void u2f_transport_send_usb_user_presence_required(u2f_service_t *service) {
    uint16_t offset = 0;
    service->sending = true;
    os_memmove(G_io_usb_ep_buffer, service->channel, 4);
    offset += 4;
    G_io_usb_ep_buffer[offset++] = U2F_CMD_MSG;
c0d0454a:	7128      	strb	r0, [r5, #4]
    G_io_usb_ep_buffer[offset++] = 0;
c0d0454c:	2000      	movs	r0, #0
c0d0454e:	7168      	strb	r0, [r5, #5]
    G_io_usb_ep_buffer[offset++] = 2;
c0d04550:	2002      	movs	r0, #2
c0d04552:	71a8      	strb	r0, [r5, #6]
    G_io_usb_ep_buffer[offset++] = 0x69;
c0d04554:	2069      	movs	r0, #105	; 0x69
c0d04556:	71e8      	strb	r0, [r5, #7]
    G_io_usb_ep_buffer[offset++] = 0x85;
c0d04558:	207c      	movs	r0, #124	; 0x7c
c0d0455a:	43c0      	mvns	r0, r0
c0d0455c:	1c80      	adds	r0, r0, #2
c0d0455e:	7228      	strb	r0, [r5, #8]
    u2f_io_send(G_io_usb_ep_buffer, offset, U2F_MEDIA_USB);
c0d04560:	2109      	movs	r1, #9
c0d04562:	4628      	mov	r0, r5
c0d04564:	4622      	mov	r2, r4
c0d04566:	f7ff ff41 	bl	c0d043ec <u2f_io_send>
}
c0d0456a:	bdb0      	pop	{r4, r5, r7, pc}
c0d0456c:	20001f5c 	.word	0x20001f5c

c0d04570 <u2f_transport_send_wink>:

void u2f_transport_send_wink(u2f_service_t *service) {
c0d04570:	b5b0      	push	{r4, r5, r7, lr}
    uint16_t offset = 0;
    service->sending = true;
c0d04572:	212b      	movs	r1, #43	; 0x2b
c0d04574:	2401      	movs	r4, #1
c0d04576:	5444      	strb	r4, [r0, r1]
    os_memmove(G_io_usb_ep_buffer, service->channel, 4);
c0d04578:	1d01      	adds	r1, r0, #4
c0d0457a:	4d08      	ldr	r5, [pc, #32]	; (c0d0459c <u2f_transport_send_wink+0x2c>)
c0d0457c:	2204      	movs	r2, #4
c0d0457e:	4628      	mov	r0, r5
c0d04580:	f7fe fa57 	bl	c0d02a32 <os_memmove>
    offset += 4;
    G_io_usb_ep_buffer[offset++] = U2F_CMD_WINK;
c0d04584:	2088      	movs	r0, #136	; 0x88
c0d04586:	7128      	strb	r0, [r5, #4]
    G_io_usb_ep_buffer[offset++] = 0;
c0d04588:	2000      	movs	r0, #0
c0d0458a:	7168      	strb	r0, [r5, #5]
    G_io_usb_ep_buffer[offset++] = 0;
c0d0458c:	71a8      	strb	r0, [r5, #6]
    u2f_io_send(G_io_usb_ep_buffer, offset, U2F_MEDIA_USB);
c0d0458e:	2107      	movs	r1, #7
c0d04590:	4628      	mov	r0, r5
c0d04592:	4622      	mov	r2, r4
c0d04594:	f7ff ff2a 	bl	c0d043ec <u2f_io_send>
}
c0d04598:	bdb0      	pop	{r4, r5, r7, pc}
c0d0459a:	46c0      	nop			; (mov r8, r8)
c0d0459c:	20001f5c 	.word	0x20001f5c

c0d045a0 <u2f_transport_receive_fakeChannel>:

bool u2f_transport_receive_fakeChannel(u2f_service_t *service, uint8_t *buffer, uint16_t size) {
c0d045a0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d045a2:	b085      	sub	sp, #20
c0d045a4:	4604      	mov	r4, r0
    if (service->fakeChannelTransportState == U2F_INTERNAL_ERROR) {
c0d045a6:	2025      	movs	r0, #37	; 0x25
c0d045a8:	5c23      	ldrb	r3, [r4, r0]
c0d045aa:	4627      	mov	r7, r4
c0d045ac:	3725      	adds	r7, #37	; 0x25
c0d045ae:	2000      	movs	r0, #0
c0d045b0:	2b05      	cmp	r3, #5
c0d045b2:	d019      	beq.n	c0d045e8 <u2f_transport_receive_fakeChannel+0x48>
c0d045b4:	9004      	str	r0, [sp, #16]
        return false;
    }
    if (memcmp(service->channel, buffer, 4) != 0) {
c0d045b6:	7808      	ldrb	r0, [r1, #0]
c0d045b8:	784b      	ldrb	r3, [r1, #1]
c0d045ba:	021b      	lsls	r3, r3, #8
c0d045bc:	4303      	orrs	r3, r0
c0d045be:	7888      	ldrb	r0, [r1, #2]
c0d045c0:	78ce      	ldrb	r6, [r1, #3]
c0d045c2:	0236      	lsls	r6, r6, #8
c0d045c4:	4306      	orrs	r6, r0
c0d045c6:	0430      	lsls	r0, r6, #16
c0d045c8:	4318      	orrs	r0, r3
c0d045ca:	7923      	ldrb	r3, [r4, #4]
c0d045cc:	7966      	ldrb	r6, [r4, #5]
c0d045ce:	0236      	lsls	r6, r6, #8
c0d045d0:	431e      	orrs	r6, r3
c0d045d2:	79a3      	ldrb	r3, [r4, #6]
c0d045d4:	79e5      	ldrb	r5, [r4, #7]
c0d045d6:	022d      	lsls	r5, r5, #8
c0d045d8:	431d      	orrs	r5, r3
c0d045da:	042b      	lsls	r3, r5, #16
c0d045dc:	4333      	orrs	r3, r6
c0d045de:	4283      	cmp	r3, r0
c0d045e0:	d004      	beq.n	c0d045ec <u2f_transport_receive_fakeChannel+0x4c>
            service->fakeChannelTransportState = U2F_IDLE;
        }
    }
    return true;
error:
    service->fakeChannelTransportState = U2F_INTERNAL_ERROR;
c0d045e2:	2005      	movs	r0, #5
c0d045e4:	7038      	strb	r0, [r7, #0]
c0d045e6:	9804      	ldr	r0, [sp, #16]
    return false;    
}
c0d045e8:	b005      	add	sp, #20
c0d045ea:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d045ec:	790e      	ldrb	r6, [r1, #4]
c0d045ee:	1d0d      	adds	r5, r1, #4
        return false;
    }
    if (memcmp(service->channel, buffer, 4) != 0) {
        goto error;
    }
    if (service->fakeChannelTransportOffset == 0) {        
c0d045f0:	8c60      	ldrh	r0, [r4, #34]	; 0x22
c0d045f2:	2301      	movs	r3, #1
c0d045f4:	9303      	str	r3, [sp, #12]
c0d045f6:	4b30      	ldr	r3, [pc, #192]	; (c0d046b8 <u2f_transport_receive_fakeChannel+0x118>)
c0d045f8:	2800      	cmp	r0, #0
c0d045fa:	d01e      	beq.n	c0d0463a <u2f_transport_receive_fakeChannel+0x9a>
c0d045fc:	9302      	str	r3, [sp, #8]
        service->fakeChannelTransportOffset = MIN(size - 4, service->transportLength);
        service->fakeChannelTransportPacketIndex = 0;
        service->fakeChannelCrc = cx_crc16_update(0, buffer + 4, service->fakeChannelTransportOffset);
    }
    else {
        if (buffer[4] != service->fakeChannelTransportPacketIndex) {
c0d045fe:	2324      	movs	r3, #36	; 0x24
c0d04600:	5ce5      	ldrb	r5, [r4, r3]
c0d04602:	4623      	mov	r3, r4
c0d04604:	3324      	adds	r3, #36	; 0x24
c0d04606:	42ae      	cmp	r6, r5
c0d04608:	d1eb      	bne.n	c0d045e2 <u2f_transport_receive_fakeChannel+0x42>
            goto error;
        }
        uint16_t xfer_len = MIN(size - 5, service->transportLength - service->fakeChannelTransportOffset);
c0d0460a:	8b25      	ldrh	r5, [r4, #24]
        service->fakeChannelTransportPacketIndex++;
c0d0460c:	9500      	str	r5, [sp, #0]
c0d0460e:	1c75      	adds	r5, r6, #1
c0d04610:	701d      	strb	r5, [r3, #0]
    }
    else {
        if (buffer[4] != service->fakeChannelTransportPacketIndex) {
            goto error;
        }
        uint16_t xfer_len = MIN(size - 5, service->transportLength - service->fakeChannelTransportOffset);
c0d04612:	9b00      	ldr	r3, [sp, #0]
c0d04614:	1a1e      	subs	r6, r3, r0
c0d04616:	1f53      	subs	r3, r2, #5
c0d04618:	2505      	movs	r5, #5
c0d0461a:	9501      	str	r5, [sp, #4]
c0d0461c:	42b3      	cmp	r3, r6
c0d0461e:	db00      	blt.n	c0d04622 <u2f_transport_receive_fakeChannel+0x82>
c0d04620:	9001      	str	r0, [sp, #4]
c0d04622:	42b3      	cmp	r3, r6
c0d04624:	db00      	blt.n	c0d04628 <u2f_transport_receive_fakeChannel+0x88>
c0d04626:	9a00      	ldr	r2, [sp, #0]
c0d04628:	9b01      	ldr	r3, [sp, #4]
c0d0462a:	1ad3      	subs	r3, r2, r3
        service->fakeChannelTransportPacketIndex++;
        service->fakeChannelTransportOffset += xfer_len;
c0d0462c:	1818      	adds	r0, r3, r0
c0d0462e:	8460      	strh	r0, [r4, #34]	; 0x22
c0d04630:	9a02      	ldr	r2, [sp, #8]
c0d04632:	401a      	ands	r2, r3
        service->fakeChannelCrc = cx_crc16_update(service->fakeChannelCrc, buffer + 5, xfer_len);   
c0d04634:	8d20      	ldrh	r0, [r4, #40]	; 0x28
c0d04636:	1d49      	adds	r1, r1, #5
c0d04638:	e025      	b.n	c0d04686 <u2f_transport_receive_fakeChannel+0xe6>
c0d0463a:	207c      	movs	r0, #124	; 0x7c
c0d0463c:	43c0      	mvns	r0, r0
    }
    if (service->fakeChannelTransportOffset == 0) {        
        uint16_t commandLength =
            (buffer[4 + 1] << 8) | (buffer[4 + 2]) + U2F_COMMAND_HEADER_SIZE;
        // Some buggy implementations can send a WINK here, reply it gently
        if (buffer[4] == U2F_CMD_WINK) {
c0d0463e:	1d40      	adds	r0, r0, #5
c0d04640:	b2c0      	uxtb	r0, r0
c0d04642:	9002      	str	r0, [sp, #8]
c0d04644:	2083      	movs	r0, #131	; 0x83
c0d04646:	9001      	str	r0, [sp, #4]
c0d04648:	9802      	ldr	r0, [sp, #8]
c0d0464a:	4286      	cmp	r6, r0
c0d0464c:	d103      	bne.n	c0d04656 <u2f_transport_receive_fakeChannel+0xb6>
            u2f_transport_send_wink(service);
c0d0464e:	4620      	mov	r0, r4
c0d04650:	f7ff ff8e 	bl	c0d04570 <u2f_transport_send_wink>
c0d04654:	e02d      	b.n	c0d046b2 <u2f_transport_receive_fakeChannel+0x112>
c0d04656:	9502      	str	r5, [sp, #8]
c0d04658:	461d      	mov	r5, r3
    if (memcmp(service->channel, buffer, 4) != 0) {
        goto error;
    }
    if (service->fakeChannelTransportOffset == 0) {        
        uint16_t commandLength =
            (buffer[4 + 1] << 8) | (buffer[4 + 2]) + U2F_COMMAND_HEADER_SIZE;
c0d0465a:	7948      	ldrb	r0, [r1, #5]
c0d0465c:	0203      	lsls	r3, r0, #8
c0d0465e:	7988      	ldrb	r0, [r1, #6]
c0d04660:	1cc0      	adds	r0, r0, #3
c0d04662:	4318      	orrs	r0, r3
        if (buffer[4] == U2F_CMD_WINK) {
            u2f_transport_send_wink(service);
            return true;
        }

        if (commandLength != service->transportLength) {
c0d04664:	9901      	ldr	r1, [sp, #4]
c0d04666:	428e      	cmp	r6, r1
c0d04668:	d1bb      	bne.n	c0d045e2 <u2f_transport_receive_fakeChannel+0x42>
c0d0466a:	8b21      	ldrh	r1, [r4, #24]
c0d0466c:	4288      	cmp	r0, r1
c0d0466e:	d1b8      	bne.n	c0d045e2 <u2f_transport_receive_fakeChannel+0x42>
            goto error;
        }
        if (buffer[4] != U2F_CMD_MSG) {
            goto error;
        }
        service->fakeChannelTransportOffset = MIN(size - 4, service->transportLength);
c0d04670:	1f11      	subs	r1, r2, #4
c0d04672:	4281      	cmp	r1, r0
c0d04674:	db00      	blt.n	c0d04678 <u2f_transport_receive_fakeChannel+0xd8>
c0d04676:	4601      	mov	r1, r0
c0d04678:	8461      	strh	r1, [r4, #34]	; 0x22
        service->fakeChannelTransportPacketIndex = 0;
c0d0467a:	2224      	movs	r2, #36	; 0x24
c0d0467c:	2000      	movs	r0, #0
c0d0467e:	54a0      	strb	r0, [r4, r2]
c0d04680:	462a      	mov	r2, r5
        service->fakeChannelCrc = cx_crc16_update(0, buffer + 4, service->fakeChannelTransportOffset);
c0d04682:	400a      	ands	r2, r1
c0d04684:	9902      	ldr	r1, [sp, #8]
c0d04686:	f7ff fc85 	bl	c0d03f94 <cx_crc16_update>
c0d0468a:	8520      	strh	r0, [r4, #40]	; 0x28
        uint16_t xfer_len = MIN(size - 5, service->transportLength - service->fakeChannelTransportOffset);
        service->fakeChannelTransportPacketIndex++;
        service->fakeChannelTransportOffset += xfer_len;
        service->fakeChannelCrc = cx_crc16_update(service->fakeChannelCrc, buffer + 5, xfer_len);   
    }
    if (service->fakeChannelTransportOffset >= service->transportLength) {
c0d0468c:	8b21      	ldrh	r1, [r4, #24]
c0d0468e:	8c62      	ldrh	r2, [r4, #34]	; 0x22
c0d04690:	428a      	cmp	r2, r1
c0d04692:	d30e      	bcc.n	c0d046b2 <u2f_transport_receive_fakeChannel+0x112>
        if (service->fakeChannelCrc != service->commandCrc) {
c0d04694:	8ce1      	ldrh	r1, [r4, #38]	; 0x26
c0d04696:	4288      	cmp	r0, r1
c0d04698:	d1a3      	bne.n	c0d045e2 <u2f_transport_receive_fakeChannel+0x42>
            goto error;
        }
        service->fakeChannelTransportState = U2F_FAKE_RECEIVED;
c0d0469a:	2006      	movs	r0, #6
c0d0469c:	7038      	strb	r0, [r7, #0]
        service->fakeChannelTransportOffset = 0;
c0d0469e:	2500      	movs	r5, #0
c0d046a0:	8465      	strh	r5, [r4, #34]	; 0x22
        // reply immediately when the asynch response is not yet ready
        if (service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_ON) {
c0d046a2:	202a      	movs	r0, #42	; 0x2a
c0d046a4:	5c20      	ldrb	r0, [r4, r0]
c0d046a6:	2801      	cmp	r0, #1
c0d046a8:	d103      	bne.n	c0d046b2 <u2f_transport_receive_fakeChannel+0x112>
            u2f_transport_send_usb_user_presence_required(service);
c0d046aa:	4620      	mov	r0, r4
c0d046ac:	f7ff ff42 	bl	c0d04534 <u2f_transport_send_usb_user_presence_required>
            // response sent
            service->fakeChannelTransportState = U2F_IDLE;
c0d046b0:	703d      	strb	r5, [r7, #0]
c0d046b2:	9803      	ldr	r0, [sp, #12]
c0d046b4:	e798      	b.n	c0d045e8 <u2f_transport_receive_fakeChannel+0x48>
c0d046b6:	46c0      	nop			; (mov r8, r8)
c0d046b8:	0000ffff 	.word	0x0000ffff

c0d046bc <u2f_transport_received>:
/** 
 * Function that process every message received on a media.
 * Performs message concatenation when message is splitted.
 */
void u2f_transport_received(u2f_service_t *service, uint8_t *buffer,
                          uint16_t size, u2f_transport_media_t media) {
c0d046bc:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d046be:	b08b      	sub	sp, #44	; 0x2c
c0d046c0:	4604      	mov	r4, r0
    uint16_t channelHeader = (media == U2F_MEDIA_USB ? 4 : 0);
    uint16_t xfer_len;
    service->media = media;
c0d046c2:	7223      	strb	r3, [r4, #8]

    // Handle a busy channel and avoid reentry
    if (service->transportState == U2F_SENDING_RESPONSE) {
c0d046c4:	2020      	movs	r0, #32
c0d046c6:	5c20      	ldrb	r0, [r4, r0]
c0d046c8:	4627      	mov	r7, r4
c0d046ca:	3720      	adds	r7, #32
            // Message to short, abort
            u2f_transport_error(service, ERROR_PROP_MESSAGE_TOO_SHORT);
            goto error;
        }
        // check this is a command, cannot accept continuation without previous command
        if ((buffer[channelHeader+0]&U2F_MASK_COMMAND) == 0) {
c0d046cc:	2585      	movs	r5, #133	; 0x85
    uint16_t channelHeader = (media == U2F_MEDIA_USB ? 4 : 0);
    uint16_t xfer_len;
    service->media = media;

    // Handle a busy channel and avoid reentry
    if (service->transportState == U2F_SENDING_RESPONSE) {
c0d046ce:	2803      	cmp	r0, #3
c0d046d0:	d00e      	beq.n	c0d046f0 <u2f_transport_received+0x34>
c0d046d2:	9109      	str	r1, [sp, #36]	; 0x24
c0d046d4:	920a      	str	r2, [sp, #40]	; 0x28
        u2f_transport_error(service, ERROR_CHANNEL_BUSY);
        goto error;
    }
    if (service->waitAsynchronousResponse != U2F_WAIT_ASYNCH_IDLE) {
c0d046d6:	212a      	movs	r1, #42	; 0x2a
c0d046d8:	5c61      	ldrb	r1, [r4, r1]
c0d046da:	4626      	mov	r6, r4
c0d046dc:	362a      	adds	r6, #42	; 0x2a
c0d046de:	2900      	cmp	r1, #0
c0d046e0:	d013      	beq.n	c0d0470a <u2f_transport_received+0x4e>
        if (!u2f_transport_receive_fakeChannel(service, buffer, size)) {
c0d046e2:	4620      	mov	r0, r4
c0d046e4:	9909      	ldr	r1, [sp, #36]	; 0x24
c0d046e6:	9a0a      	ldr	r2, [sp, #40]	; 0x28
c0d046e8:	f7ff ff5a 	bl	c0d045a0 <u2f_transport_receive_fakeChannel>
c0d046ec:	2800      	cmp	r0, #0
c0d046ee:	d173      	bne.n	c0d047d8 <u2f_transport_received+0x11c>
c0d046f0:	48e0      	ldr	r0, [pc, #896]	; (c0d04a74 <u2f_transport_received+0x3b8>)
c0d046f2:	2106      	movs	r1, #6
c0d046f4:	7201      	strb	r1, [r0, #8]
c0d046f6:	2104      	movs	r1, #4
c0d046f8:	7039      	strb	r1, [r7, #0]
c0d046fa:	2100      	movs	r1, #0
c0d046fc:	76a1      	strb	r1, [r4, #26]
c0d046fe:	3008      	adds	r0, #8
c0d04700:	61e0      	str	r0, [r4, #28]
c0d04702:	82e1      	strh	r1, [r4, #22]
c0d04704:	2001      	movs	r0, #1
c0d04706:	8320      	strh	r0, [r4, #24]
c0d04708:	e05f      	b.n	c0d047ca <u2f_transport_received+0x10e>
        }
        return;
    }
    
    // SENDING_ERROR is accepted, and triggers a reset => means the host hasn't consumed the error.
    if (service->transportState == U2F_SENDING_ERROR) {
c0d0470a:	2804      	cmp	r0, #4
c0d0470c:	d109      	bne.n	c0d04722 <u2f_transport_received+0x66>
c0d0470e:	2000      	movs	r0, #0
#warning TODO take into account the INIT during SEGMENTED message correctly (avoid erasing the first part of the apdu buffer when doing so)

// init
void u2f_transport_reset(u2f_service_t* service) {
    service->transportState = U2F_IDLE;
    service->transportOffset = 0;
c0d04710:	82e0      	strh	r0, [r4, #22]
    service->transportMedia = 0;
    service->transportPacketIndex = 0;
c0d04712:	76a0      	strb	r0, [r4, #26]
    service->fakeChannelTransportState = U2F_IDLE;
    service->fakeChannelTransportOffset = 0;
    service->fakeChannelTransportPacketIndex = 0;    
    service->sending = false;
c0d04714:	212b      	movs	r1, #43	; 0x2b
c0d04716:	5460      	strb	r0, [r4, r1]
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
c0d04718:	7030      	strb	r0, [r6, #0]

// init
void u2f_transport_reset(u2f_service_t* service) {
    service->transportState = U2F_IDLE;
    service->transportOffset = 0;
    service->transportMedia = 0;
c0d0471a:	80b8      	strh	r0, [r7, #4]
c0d0471c:	6038      	str	r0, [r7, #0]
    service->fakeChannelTransportOffset = 0;
    service->fakeChannelTransportPacketIndex = 0;    
    service->sending = false;
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
    // reset the receive buffer to allow for a new message to be received again (in case transmission of a CODE buffer the previous reply)
    service->transportBuffer = service->transportReceiveBuffer;
c0d0471e:	68e0      	ldr	r0, [r4, #12]
c0d04720:	61e0      	str	r0, [r4, #28]
    // SENDING_ERROR is accepted, and triggers a reset => means the host hasn't consumed the error.
    if (service->transportState == U2F_SENDING_ERROR) {
        u2f_transport_reset(service);
    }

    if (size < (1 + channelHeader)) {
c0d04722:	2104      	movs	r1, #4
c0d04724:	2000      	movs	r0, #0
c0d04726:	9308      	str	r3, [sp, #32]
c0d04728:	2b01      	cmp	r3, #1
c0d0472a:	d000      	beq.n	c0d0472e <u2f_transport_received+0x72>
c0d0472c:	4601      	mov	r1, r0
c0d0472e:	2301      	movs	r3, #1
c0d04730:	460a      	mov	r2, r1
c0d04732:	431a      	orrs	r2, r3
c0d04734:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d04736:	4290      	cmp	r0, r2
c0d04738:	d33d      	bcc.n	c0d047b6 <u2f_transport_received+0xfa>
c0d0473a:	9204      	str	r2, [sp, #16]
        // Message to short, abort
        u2f_transport_error(service, ERROR_PROP_MESSAGE_TOO_SHORT);
        goto error;
    }
    if (media == U2F_MEDIA_USB) {
c0d0473c:	9808      	ldr	r0, [sp, #32]
c0d0473e:	2801      	cmp	r0, #1
c0d04740:	9106      	str	r1, [sp, #24]
c0d04742:	9505      	str	r5, [sp, #20]
c0d04744:	9307      	str	r3, [sp, #28]
c0d04746:	d107      	bne.n	c0d04758 <u2f_transport_received+0x9c>
        // hold the current channel value to reply to, for example, INIT commands within flow of segments.
        os_memmove(service->channel, buffer, 4);
c0d04748:	1d20      	adds	r0, r4, #4
c0d0474a:	2204      	movs	r2, #4
c0d0474c:	9909      	ldr	r1, [sp, #36]	; 0x24
c0d0474e:	f7fe f970 	bl	c0d02a32 <os_memmove>
c0d04752:	9906      	ldr	r1, [sp, #24]
c0d04754:	9b07      	ldr	r3, [sp, #28]
c0d04756:	9d05      	ldr	r5, [sp, #20]
    }

    // no previous chunk processed for the current message
    if (service->transportOffset == 0
c0d04758:	8ae0      	ldrh	r0, [r4, #22]
c0d0475a:	4ac7      	ldr	r2, [pc, #796]	; (c0d04a78 <u2f_transport_received+0x3bc>)
        // on USB we could get an INIT within a flow of segments.
        || (media == U2F_MEDIA_USB && os_memcmp(service->transportChannel, service->channel, 4) != 0) ) {
c0d0475c:	2800      	cmp	r0, #0
c0d0475e:	d00f      	beq.n	c0d04780 <u2f_transport_received+0xc4>
c0d04760:	9808      	ldr	r0, [sp, #32]
c0d04762:	2801      	cmp	r0, #1
c0d04764:	d122      	bne.n	c0d047ac <u2f_transport_received+0xf0>
c0d04766:	4620      	mov	r0, r4
c0d04768:	3012      	adds	r0, #18
c0d0476a:	1d21      	adds	r1, r4, #4
c0d0476c:	4615      	mov	r5, r2
c0d0476e:	2204      	movs	r2, #4
c0d04770:	f7fe f9fc 	bl	c0d02b6c <os_memcmp>
c0d04774:	9906      	ldr	r1, [sp, #24]
c0d04776:	462a      	mov	r2, r5
c0d04778:	9b07      	ldr	r3, [sp, #28]
c0d0477a:	9d05      	ldr	r5, [sp, #20]
        // hold the current channel value to reply to, for example, INIT commands within flow of segments.
        os_memmove(service->channel, buffer, 4);
    }

    // no previous chunk processed for the current message
    if (service->transportOffset == 0
c0d0477c:	2800      	cmp	r0, #0
c0d0477e:	d015      	beq.n	c0d047ac <u2f_transport_received+0xf0>
        // on USB we could get an INIT within a flow of segments.
        || (media == U2F_MEDIA_USB && os_memcmp(service->transportChannel, service->channel, 4) != 0) ) {
        if (size < (channelHeader + 3)) {
c0d04780:	2603      	movs	r6, #3
c0d04782:	4608      	mov	r0, r1
c0d04784:	9603      	str	r6, [sp, #12]
c0d04786:	4330      	orrs	r0, r6
c0d04788:	460e      	mov	r6, r1
c0d0478a:	990a      	ldr	r1, [sp, #40]	; 0x28
c0d0478c:	4281      	cmp	r1, r0
c0d0478e:	d312      	bcc.n	c0d047b6 <u2f_transport_received+0xfa>
c0d04790:	9909      	ldr	r1, [sp, #36]	; 0x24
            // Message to short, abort
            u2f_transport_error(service, ERROR_PROP_MESSAGE_TOO_SHORT);
            goto error;
        }
        // check this is a command, cannot accept continuation without previous command
        if ((buffer[channelHeader+0]&U2F_MASK_COMMAND) == 0) {
c0d04792:	1988      	adds	r0, r1, r6
c0d04794:	9002      	str	r0, [sp, #8]
c0d04796:	5788      	ldrsb	r0, [r1, r6]
c0d04798:	460e      	mov	r6, r1
c0d0479a:	4629      	mov	r1, r5
c0d0479c:	317a      	adds	r1, #122	; 0x7a
c0d0479e:	b249      	sxtb	r1, r1
c0d047a0:	4288      	cmp	r0, r1
c0d047a2:	dd37      	ble.n	c0d04814 <u2f_transport_received+0x158>
c0d047a4:	48b3      	ldr	r0, [pc, #716]	; (c0d04a74 <u2f_transport_received+0x3b8>)
c0d047a6:	2104      	movs	r1, #4
c0d047a8:	7201      	strb	r1, [r0, #8]
c0d047aa:	e007      	b.n	c0d047bc <u2f_transport_received+0x100>
c0d047ac:	2002      	movs	r0, #2
            service->transportPacketIndex = 0;
            os_memmove(service->transportChannel, service->channel, 4);
        }
    } else {
        // Continuation
        if (size < (channelHeader + 2)) {
c0d047ae:	4308      	orrs	r0, r1
c0d047b0:	990a      	ldr	r1, [sp, #40]	; 0x28
c0d047b2:	4281      	cmp	r1, r0
c0d047b4:	d212      	bcs.n	c0d047dc <u2f_transport_received+0x120>
c0d047b6:	48af      	ldr	r0, [pc, #700]	; (c0d04a74 <u2f_transport_received+0x3b8>)
c0d047b8:	7205      	strb	r5, [r0, #8]
c0d047ba:	2104      	movs	r1, #4
c0d047bc:	7039      	strb	r1, [r7, #0]
c0d047be:	2100      	movs	r1, #0
c0d047c0:	76a1      	strb	r1, [r4, #26]
c0d047c2:	3008      	adds	r0, #8
c0d047c4:	61e0      	str	r0, [r4, #28]
c0d047c6:	82e1      	strh	r1, [r4, #22]
c0d047c8:	8323      	strh	r3, [r4, #24]
c0d047ca:	353a      	adds	r5, #58	; 0x3a
c0d047cc:	2040      	movs	r0, #64	; 0x40
c0d047ce:	5425      	strb	r5, [r4, r0]
c0d047d0:	7a21      	ldrb	r1, [r4, #8]
c0d047d2:	4620      	mov	r0, r4
c0d047d4:	f7ff fe32 	bl	c0d0443c <u2f_transport_sent>
        service->seqTimeout = 0;
        service->transportState = U2F_HANDLE_SEGMENTED;
    }
error:
    return;
}
c0d047d8:	b00b      	add	sp, #44	; 0x2c
c0d047da:	bdf0      	pop	{r4, r5, r6, r7, pc}
        if (size < (channelHeader + 2)) {
            // Message to short, abort
            u2f_transport_error(service, ERROR_PROP_MESSAGE_TOO_SHORT);
            goto error;
        }
        if (media != service->transportMedia) {
c0d047dc:	2021      	movs	r0, #33	; 0x21
c0d047de:	5c20      	ldrb	r0, [r4, r0]
c0d047e0:	9908      	ldr	r1, [sp, #32]
c0d047e2:	4288      	cmp	r0, r1
c0d047e4:	d14d      	bne.n	c0d04882 <u2f_transport_received+0x1c6>
            // Mixed medias
            u2f_transport_error(service, ERROR_PROP_MEDIA_MIXED);
            goto error;
        }
        if (service->transportState != U2F_HANDLE_SEGMENTED) {
c0d047e6:	7838      	ldrb	r0, [r7, #0]
c0d047e8:	2801      	cmp	r0, #1
c0d047ea:	d156      	bne.n	c0d0489a <u2f_transport_received+0x1de>
c0d047ec:	9203      	str	r2, [sp, #12]
            } else {
                u2f_transport_error(service, ERROR_INVALID_SEQ);
                goto error;
            }
        }
        if (media == U2F_MEDIA_USB) {
c0d047ee:	9808      	ldr	r0, [sp, #32]
c0d047f0:	2801      	cmp	r0, #1
c0d047f2:	d000      	beq.n	c0d047f6 <u2f_transport_received+0x13a>
c0d047f4:	e085      	b.n	c0d04902 <u2f_transport_received+0x246>
            // Check the channel
            if (os_memcmp(buffer, service->channel, 4) != 0) {
c0d047f6:	1d21      	adds	r1, r4, #4
c0d047f8:	2504      	movs	r5, #4
c0d047fa:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d047fc:	462a      	mov	r2, r5
c0d047fe:	461e      	mov	r6, r3
c0d04800:	f7fe f9b4 	bl	c0d02b6c <os_memcmp>
c0d04804:	4633      	mov	r3, r6
c0d04806:	2800      	cmp	r0, #0
c0d04808:	d07b      	beq.n	c0d04902 <u2f_transport_received+0x246>
/**
 * Reply an error at the U2F transport level (take into account the FIDO U2F framing)
 */
static void u2f_transport_error(u2f_service_t *service, char errorCode) {
    //u2f_transport_reset(service); // warning reset first to allow for U2F_io sent call to u2f_transport_sent internally on eventless platforms
    G_io_usb_ep_buffer[8] = errorCode;
c0d0480a:	489a      	ldr	r0, [pc, #616]	; (c0d04a74 <u2f_transport_received+0x3b8>)
c0d0480c:	2106      	movs	r1, #6
c0d0480e:	7201      	strb	r1, [r0, #8]

    // ensure the state is set to error sending to allow for special treatment in case reply is not read by the receiver
    service->transportState = U2F_SENDING_ERROR;
c0d04810:	703d      	strb	r5, [r7, #0]
c0d04812:	e0f6      	b.n	c0d04a02 <u2f_transport_received+0x346>
c0d04814:	9b08      	ldr	r3, [sp, #32]
            goto error;
        }

        // If waiting for a continuation on a different channel, reply BUSY
        // immediately
        if (media == U2F_MEDIA_USB) {
c0d04816:	2b01      	cmp	r3, #1
c0d04818:	d116      	bne.n	c0d04848 <u2f_transport_received+0x18c>
            if ((service->transportState == U2F_HANDLE_SEGMENTED) &&
c0d0481a:	7838      	ldrb	r0, [r7, #0]
c0d0481c:	2801      	cmp	r0, #1
c0d0481e:	d11f      	bne.n	c0d04860 <u2f_transport_received+0x1a4>
                (os_memcmp(service->channel, service->transportChannel, 4) !=
c0d04820:	1d20      	adds	r0, r4, #4
c0d04822:	4621      	mov	r1, r4
c0d04824:	3112      	adds	r1, #18
c0d04826:	4615      	mov	r5, r2
c0d04828:	2204      	movs	r2, #4
c0d0482a:	9001      	str	r0, [sp, #4]
c0d0482c:	f7fe f99e 	bl	c0d02b6c <os_memcmp>
c0d04830:	462a      	mov	r2, r5
c0d04832:	9b08      	ldr	r3, [sp, #32]
c0d04834:	9d05      	ldr	r5, [sp, #20]
                 0) &&
c0d04836:	2800      	cmp	r0, #0
c0d04838:	d006      	beq.n	c0d04848 <u2f_transport_received+0x18c>
                (buffer[channelHeader] != U2F_CMD_INIT)) {
c0d0483a:	9802      	ldr	r0, [sp, #8]
c0d0483c:	7800      	ldrb	r0, [r0, #0]
c0d0483e:	1c69      	adds	r1, r5, #1
c0d04840:	b2c9      	uxtb	r1, r1
        }

        // If waiting for a continuation on a different channel, reply BUSY
        // immediately
        if (media == U2F_MEDIA_USB) {
            if ((service->transportState == U2F_HANDLE_SEGMENTED) &&
c0d04842:	4288      	cmp	r0, r1
c0d04844:	d000      	beq.n	c0d04848 <u2f_transport_received+0x18c>
c0d04846:	e0f6      	b.n	c0d04a36 <u2f_transport_received+0x37a>
                goto error;
            }
        }
        // If a command was already sent, and we are not processing a INIT
        // command, abort
        if ((service->transportState == U2F_HANDLE_SEGMENTED) &&
c0d04848:	7838      	ldrb	r0, [r7, #0]
c0d0484a:	2801      	cmp	r0, #1
c0d0484c:	d108      	bne.n	c0d04860 <u2f_transport_received+0x1a4>
            !((media == U2F_MEDIA_USB) &&
c0d0484e:	2b01      	cmp	r3, #1
c0d04850:	d000      	beq.n	c0d04854 <u2f_transport_received+0x198>
c0d04852:	e082      	b.n	c0d0495a <u2f_transport_received+0x29e>
              (buffer[channelHeader] == U2F_CMD_INIT))) {
c0d04854:	9802      	ldr	r0, [sp, #8]
c0d04856:	7800      	ldrb	r0, [r0, #0]
c0d04858:	1c69      	adds	r1, r5, #1
c0d0485a:	b2c9      	uxtb	r1, r1
                goto error;
            }
        }
        // If a command was already sent, and we are not processing a INIT
        // command, abort
        if ((service->transportState == U2F_HANDLE_SEGMENTED) &&
c0d0485c:	4288      	cmp	r0, r1
c0d0485e:	d17c      	bne.n	c0d0495a <u2f_transport_received+0x29e>
            u2f_transport_error(service, ERROR_INVALID_SEQ);
            goto error;
        }
        // Check the length
        uint16_t commandLength =
            (buffer[channelHeader + 1] << 8) | (buffer[channelHeader + 2]);
c0d04860:	2002      	movs	r0, #2
c0d04862:	9906      	ldr	r1, [sp, #24]
c0d04864:	4308      	orrs	r0, r1
c0d04866:	5c30      	ldrb	r0, [r6, r0]
c0d04868:	9904      	ldr	r1, [sp, #16]
c0d0486a:	5c71      	ldrb	r1, [r6, r1]
c0d0486c:	0209      	lsls	r1, r1, #8
c0d0486e:	4301      	orrs	r1, r0
        if (commandLength > (service->transportReceiveBufferLength - 3)) {
c0d04870:	8a20      	ldrh	r0, [r4, #16]
c0d04872:	1ec0      	subs	r0, r0, #3
c0d04874:	4281      	cmp	r1, r0
c0d04876:	dd1e      	ble.n	c0d048b6 <u2f_transport_received+0x1fa>
/**
 * Reply an error at the U2F transport level (take into account the FIDO U2F framing)
 */
static void u2f_transport_error(u2f_service_t *service, char errorCode) {
    //u2f_transport_reset(service); // warning reset first to allow for U2F_io sent call to u2f_transport_sent internally on eventless platforms
    G_io_usb_ep_buffer[8] = errorCode;
c0d04878:	487e      	ldr	r0, [pc, #504]	; (c0d04a74 <u2f_transport_received+0x3b8>)
c0d0487a:	9903      	ldr	r1, [sp, #12]
c0d0487c:	7201      	strb	r1, [r0, #8]

    // ensure the state is set to error sending to allow for special treatment in case reply is not read by the receiver
    service->transportState = U2F_SENDING_ERROR;
c0d0487e:	2104      	movs	r1, #4
c0d04880:	e06e      	b.n	c0d04960 <u2f_transport_received+0x2a4>
/**
 * Reply an error at the U2F transport level (take into account the FIDO U2F framing)
 */
static void u2f_transport_error(u2f_service_t *service, char errorCode) {
    //u2f_transport_reset(service); // warning reset first to allow for U2F_io sent call to u2f_transport_sent internally on eventless platforms
    G_io_usb_ep_buffer[8] = errorCode;
c0d04882:	4628      	mov	r0, r5
c0d04884:	3008      	adds	r0, #8
c0d04886:	497b      	ldr	r1, [pc, #492]	; (c0d04a74 <u2f_transport_received+0x3b8>)
c0d04888:	7208      	strb	r0, [r1, #8]

    // ensure the state is set to error sending to allow for special treatment in case reply is not read by the receiver
    service->transportState = U2F_SENDING_ERROR;
c0d0488a:	2004      	movs	r0, #4
c0d0488c:	7038      	strb	r0, [r7, #0]
c0d0488e:	2000      	movs	r0, #0
    service->transportPacketIndex = 0;
c0d04890:	76a0      	strb	r0, [r4, #26]
/**
 * Reply an error at the U2F transport level (take into account the FIDO U2F framing)
 */
static void u2f_transport_error(u2f_service_t *service, char errorCode) {
    //u2f_transport_reset(service); // warning reset first to allow for U2F_io sent call to u2f_transport_sent internally on eventless platforms
    G_io_usb_ep_buffer[8] = errorCode;
c0d04892:	3108      	adds	r1, #8

    // ensure the state is set to error sending to allow for special treatment in case reply is not read by the receiver
    service->transportState = U2F_SENDING_ERROR;
    service->transportPacketIndex = 0;
    service->transportBuffer = G_io_usb_ep_buffer + 8;
c0d04894:	61e1      	str	r1, [r4, #28]
    service->transportOffset = 0;
c0d04896:	82e0      	strh	r0, [r4, #22]
c0d04898:	e796      	b.n	c0d047c8 <u2f_transport_received+0x10c>
            goto error;
        }
        if (service->transportState != U2F_HANDLE_SEGMENTED) {
            // Unexpected continuation at this stage, abort
            // TODO : review the behavior is HID only
            if (media == U2F_MEDIA_USB) {
c0d0489a:	9808      	ldr	r0, [sp, #32]
c0d0489c:	2801      	cmp	r0, #1
c0d0489e:	d181      	bne.n	c0d047a4 <u2f_transport_received+0xe8>
c0d048a0:	2000      	movs	r0, #0
#warning TODO take into account the INIT during SEGMENTED message correctly (avoid erasing the first part of the apdu buffer when doing so)

// init
void u2f_transport_reset(u2f_service_t* service) {
    service->transportState = U2F_IDLE;
    service->transportOffset = 0;
c0d048a2:	82e0      	strh	r0, [r4, #22]
    service->transportMedia = 0;
    service->transportPacketIndex = 0;
c0d048a4:	76a0      	strb	r0, [r4, #26]
    service->fakeChannelTransportState = U2F_IDLE;
    service->fakeChannelTransportOffset = 0;
    service->fakeChannelTransportPacketIndex = 0;    
    service->sending = false;
c0d048a6:	212b      	movs	r1, #43	; 0x2b
c0d048a8:	5460      	strb	r0, [r4, r1]
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
c0d048aa:	7030      	strb	r0, [r6, #0]

// init
void u2f_transport_reset(u2f_service_t* service) {
    service->transportState = U2F_IDLE;
    service->transportOffset = 0;
    service->transportMedia = 0;
c0d048ac:	80b8      	strh	r0, [r7, #4]
c0d048ae:	6038      	str	r0, [r7, #0]
    service->fakeChannelTransportOffset = 0;
    service->fakeChannelTransportPacketIndex = 0;    
    service->sending = false;
    service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_IDLE;
    // reset the receive buffer to allow for a new message to be received again (in case transmission of a CODE buffer the previous reply)
    service->transportBuffer = service->transportReceiveBuffer;
c0d048b0:	68e0      	ldr	r0, [r4, #12]
c0d048b2:	61e0      	str	r0, [r4, #28]
c0d048b4:	e790      	b.n	c0d047d8 <u2f_transport_received+0x11c>
            // Overflow in message size, abort
            u2f_transport_error(service, ERROR_INVALID_LEN);
            goto error;
        }
        // Check if the command is supported
        switch (buffer[channelHeader]) {
c0d048b6:	9802      	ldr	r0, [sp, #8]
c0d048b8:	7800      	ldrb	r0, [r0, #0]
c0d048ba:	2881      	cmp	r0, #129	; 0x81
c0d048bc:	9b07      	ldr	r3, [sp, #28]
c0d048be:	d004      	beq.n	c0d048ca <u2f_transport_received+0x20e>
c0d048c0:	2886      	cmp	r0, #134	; 0x86
c0d048c2:	d059      	beq.n	c0d04978 <u2f_transport_received+0x2bc>
c0d048c4:	2883      	cmp	r0, #131	; 0x83
c0d048c6:	d000      	beq.n	c0d048ca <u2f_transport_received+0x20e>
c0d048c8:	e0ac      	b.n	c0d04a24 <u2f_transport_received+0x368>
c0d048ca:	9109      	str	r1, [sp, #36]	; 0x24
c0d048cc:	9203      	str	r2, [sp, #12]
        case U2F_CMD_PING:
        case U2F_CMD_MSG:
            if (media == U2F_MEDIA_USB) {
c0d048ce:	9808      	ldr	r0, [sp, #32]
c0d048d0:	2801      	cmp	r0, #1
c0d048d2:	d15f      	bne.n	c0d04994 <u2f_transport_received+0x2d8>
                if (u2f_is_channel_broadcast(service->channel) ||
c0d048d4:	1d26      	adds	r6, r4, #4
error:
    return;
}

bool u2f_is_channel_broadcast(uint8_t *channel) {
    return (os_memcmp(channel, BROADCAST_CHANNEL, 4) == 0);
c0d048d6:	4969      	ldr	r1, [pc, #420]	; (c0d04a7c <u2f_transport_received+0x3c0>)
c0d048d8:	4479      	add	r1, pc
c0d048da:	2504      	movs	r5, #4
c0d048dc:	4630      	mov	r0, r6
c0d048de:	462a      	mov	r2, r5
c0d048e0:	f7fe f944 	bl	c0d02b6c <os_memcmp>
        // Check if the command is supported
        switch (buffer[channelHeader]) {
        case U2F_CMD_PING:
        case U2F_CMD_MSG:
            if (media == U2F_MEDIA_USB) {
                if (u2f_is_channel_broadcast(service->channel) ||
c0d048e4:	2800      	cmp	r0, #0
c0d048e6:	d007      	beq.n	c0d048f8 <u2f_transport_received+0x23c>
bool u2f_is_channel_broadcast(uint8_t *channel) {
    return (os_memcmp(channel, BROADCAST_CHANNEL, 4) == 0);
}

bool u2f_is_channel_forbidden(uint8_t *channel) {
    return (os_memcmp(channel, FORBIDDEN_CHANNEL, 4) == 0);
c0d048e8:	4965      	ldr	r1, [pc, #404]	; (c0d04a80 <u2f_transport_received+0x3c4>)
c0d048ea:	4479      	add	r1, pc
c0d048ec:	2204      	movs	r2, #4
c0d048ee:	4630      	mov	r0, r6
c0d048f0:	f7fe f93c 	bl	c0d02b6c <os_memcmp>
        // Check if the command is supported
        switch (buffer[channelHeader]) {
        case U2F_CMD_PING:
        case U2F_CMD_MSG:
            if (media == U2F_MEDIA_USB) {
                if (u2f_is_channel_broadcast(service->channel) ||
c0d048f4:	2800      	cmp	r0, #0
c0d048f6:	d14d      	bne.n	c0d04994 <u2f_transport_received+0x2d8>
/**
 * Reply an error at the U2F transport level (take into account the FIDO U2F framing)
 */
static void u2f_transport_error(u2f_service_t *service, char errorCode) {
    //u2f_transport_reset(service); // warning reset first to allow for U2F_io sent call to u2f_transport_sent internally on eventless platforms
    G_io_usb_ep_buffer[8] = errorCode;
c0d048f8:	485e      	ldr	r0, [pc, #376]	; (c0d04a74 <u2f_transport_received+0x3b8>)
c0d048fa:	210b      	movs	r1, #11
c0d048fc:	7201      	strb	r1, [r0, #8]

    // ensure the state is set to error sending to allow for special treatment in case reply is not read by the receiver
    service->transportState = U2F_SENDING_ERROR;
c0d048fe:	703d      	strb	r5, [r7, #0]
c0d04900:	e0b0      	b.n	c0d04a64 <u2f_transport_received+0x3a8>
c0d04902:	9806      	ldr	r0, [sp, #24]
c0d04904:	9a09      	ldr	r2, [sp, #36]	; 0x24
                u2f_transport_error(service, ERROR_CHANNEL_BUSY);
                goto error;
            }
        }
        // also discriminate invalid command sent instead of a continuation
        if (buffer[channelHeader] != service->transportPacketIndex) {
c0d04906:	1811      	adds	r1, r2, r0
c0d04908:	5c10      	ldrb	r0, [r2, r0]
c0d0490a:	7ea2      	ldrb	r2, [r4, #26]
c0d0490c:	4290      	cmp	r0, r2
c0d0490e:	d12f      	bne.n	c0d04970 <u2f_transport_received+0x2b4>
            // Bad continuation packet, abort
            u2f_transport_error(service, ERROR_INVALID_SEQ);
            goto error;
        }
        xfer_len = MIN(size - (channelHeader + 1), service->transportLength - service->transportOffset);
c0d04910:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d04912:	9a04      	ldr	r2, [sp, #16]
c0d04914:	1a85      	subs	r5, r0, r2
c0d04916:	8ae0      	ldrh	r0, [r4, #22]
c0d04918:	8b22      	ldrh	r2, [r4, #24]
c0d0491a:	1a12      	subs	r2, r2, r0
c0d0491c:	4295      	cmp	r5, r2
c0d0491e:	db00      	blt.n	c0d04922 <u2f_transport_received+0x266>
c0d04920:	4615      	mov	r5, r2
c0d04922:	9e03      	ldr	r6, [sp, #12]
        os_memmove(service->transportBuffer + service->transportOffset, buffer + channelHeader + 1, xfer_len);
c0d04924:	402e      	ands	r6, r5
c0d04926:	69e2      	ldr	r2, [r4, #28]
c0d04928:	1810      	adds	r0, r2, r0
c0d0492a:	1c49      	adds	r1, r1, #1
c0d0492c:	4632      	mov	r2, r6
c0d0492e:	f7fe f880 	bl	c0d02a32 <os_memmove>
        if (media == U2F_MEDIA_USB) {
c0d04932:	9808      	ldr	r0, [sp, #32]
c0d04934:	2801      	cmp	r0, #1
c0d04936:	d107      	bne.n	c0d04948 <u2f_transport_received+0x28c>
            service->commandCrc = cx_crc16_update(service->commandCrc, service->transportBuffer + service->transportOffset, xfer_len);
c0d04938:	8ae0      	ldrh	r0, [r4, #22]
c0d0493a:	69e1      	ldr	r1, [r4, #28]
c0d0493c:	1809      	adds	r1, r1, r0
c0d0493e:	8ce0      	ldrh	r0, [r4, #38]	; 0x26
c0d04940:	4632      	mov	r2, r6
c0d04942:	f7ff fb27 	bl	c0d03f94 <cx_crc16_update>
c0d04946:	84e0      	strh	r0, [r4, #38]	; 0x26
        }        
        service->transportOffset += xfer_len;
c0d04948:	8ae0      	ldrh	r0, [r4, #22]
c0d0494a:	1940      	adds	r0, r0, r5
c0d0494c:	82e0      	strh	r0, [r4, #22]
        service->transportPacketIndex++;
c0d0494e:	7ea0      	ldrb	r0, [r4, #26]
c0d04950:	1c40      	adds	r0, r0, #1
c0d04952:	76a0      	strb	r0, [r4, #26]
c0d04954:	9b07      	ldr	r3, [sp, #28]
c0d04956:	9d08      	ldr	r5, [sp, #32]
c0d04958:	e045      	b.n	c0d049e6 <u2f_transport_received+0x32a>
/**
 * Reply an error at the U2F transport level (take into account the FIDO U2F framing)
 */
static void u2f_transport_error(u2f_service_t *service, char errorCode) {
    //u2f_transport_reset(service); // warning reset first to allow for U2F_io sent call to u2f_transport_sent internally on eventless platforms
    G_io_usb_ep_buffer[8] = errorCode;
c0d0495a:	4846      	ldr	r0, [pc, #280]	; (c0d04a74 <u2f_transport_received+0x3b8>)
c0d0495c:	2104      	movs	r1, #4
c0d0495e:	7201      	strb	r1, [r0, #8]
c0d04960:	7039      	strb	r1, [r7, #0]
c0d04962:	2100      	movs	r1, #0
c0d04964:	76a1      	strb	r1, [r4, #26]
c0d04966:	3008      	adds	r0, #8
c0d04968:	61e0      	str	r0, [r4, #28]
c0d0496a:	82e1      	strh	r1, [r4, #22]
c0d0496c:	9807      	ldr	r0, [sp, #28]
c0d0496e:	e6ca      	b.n	c0d04706 <u2f_transport_received+0x4a>
c0d04970:	4840      	ldr	r0, [pc, #256]	; (c0d04a74 <u2f_transport_received+0x3b8>)
c0d04972:	2104      	movs	r1, #4
c0d04974:	7201      	strb	r1, [r0, #8]
c0d04976:	e043      	b.n	c0d04a00 <u2f_transport_received+0x344>
                }
            }
            // no channel for BLE
            break;
        case U2F_CMD_INIT:
            if (media != U2F_MEDIA_USB) {
c0d04978:	9808      	ldr	r0, [sp, #32]
c0d0497a:	2801      	cmp	r0, #1
c0d0497c:	d152      	bne.n	c0d04a24 <u2f_transport_received+0x368>
c0d0497e:	9109      	str	r1, [sp, #36]	; 0x24
c0d04980:	9203      	str	r2, [sp, #12]
                // Unknown command, abort
                u2f_transport_error(service, ERROR_INVALID_CMD);
                goto error;
            }

            if (u2f_is_channel_forbidden(service->channel)) {
c0d04982:	1d20      	adds	r0, r4, #4
bool u2f_is_channel_broadcast(uint8_t *channel) {
    return (os_memcmp(channel, BROADCAST_CHANNEL, 4) == 0);
}

bool u2f_is_channel_forbidden(uint8_t *channel) {
    return (os_memcmp(channel, FORBIDDEN_CHANNEL, 4) == 0);
c0d04984:	493f      	ldr	r1, [pc, #252]	; (c0d04a84 <u2f_transport_received+0x3c8>)
c0d04986:	4479      	add	r1, pc
c0d04988:	2604      	movs	r6, #4
c0d0498a:	4632      	mov	r2, r6
c0d0498c:	f7fe f8ee 	bl	c0d02b6c <os_memcmp>
                // Unknown command, abort
                u2f_transport_error(service, ERROR_INVALID_CMD);
                goto error;
            }

            if (u2f_is_channel_forbidden(service->channel)) {
c0d04990:	2800      	cmp	r0, #0
c0d04992:	d063      	beq.n	c0d04a5c <u2f_transport_received+0x3a0>
        }

        // Ok, initialize the buffer
        //if (buffer[channelHeader] != U2F_CMD_INIT) 
        {
            xfer_len = MIN(size - (channelHeader), U2F_COMMAND_HEADER_SIZE+commandLength);
c0d04994:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d04996:	9906      	ldr	r1, [sp, #24]
c0d04998:	1a46      	subs	r6, r0, r1
c0d0499a:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d0499c:	1cc0      	adds	r0, r0, #3
c0d0499e:	4286      	cmp	r6, r0
c0d049a0:	9d03      	ldr	r5, [sp, #12]
c0d049a2:	db00      	blt.n	c0d049a6 <u2f_transport_received+0x2ea>
c0d049a4:	4606      	mov	r6, r0
c0d049a6:	900a      	str	r0, [sp, #40]	; 0x28
            os_memmove(service->transportBuffer, buffer + channelHeader, xfer_len);
c0d049a8:	4035      	ands	r5, r6
c0d049aa:	69e0      	ldr	r0, [r4, #28]
c0d049ac:	9902      	ldr	r1, [sp, #8]
c0d049ae:	462a      	mov	r2, r5
c0d049b0:	f7fe f83f 	bl	c0d02a32 <os_memmove>
c0d049b4:	9b08      	ldr	r3, [sp, #32]
            if (media == U2F_MEDIA_USB) {
c0d049b6:	2b01      	cmp	r3, #1
c0d049b8:	d106      	bne.n	c0d049c8 <u2f_transport_received+0x30c>
                service->commandCrc = cx_crc16_update(0, service->transportBuffer, xfer_len);
c0d049ba:	69e1      	ldr	r1, [r4, #28]
c0d049bc:	2000      	movs	r0, #0
c0d049be:	462a      	mov	r2, r5
c0d049c0:	f7ff fae8 	bl	c0d03f94 <cx_crc16_update>
c0d049c4:	9b08      	ldr	r3, [sp, #32]
c0d049c6:	84e0      	strh	r0, [r4, #38]	; 0x26
            }
            service->transportOffset = xfer_len;
c0d049c8:	82e6      	strh	r6, [r4, #22]
            service->transportLength = U2F_COMMAND_HEADER_SIZE+commandLength;
c0d049ca:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d049cc:	8320      	strh	r0, [r4, #24]
            service->transportMedia = media;
c0d049ce:	2021      	movs	r0, #33	; 0x21
c0d049d0:	5423      	strb	r3, [r4, r0]
            // initialize the response
            service->transportPacketIndex = 0;
c0d049d2:	2000      	movs	r0, #0
c0d049d4:	76a0      	strb	r0, [r4, #26]
            os_memmove(service->transportChannel, service->channel, 4);
c0d049d6:	4620      	mov	r0, r4
c0d049d8:	3012      	adds	r0, #18
c0d049da:	1d21      	adds	r1, r4, #4
c0d049dc:	2204      	movs	r2, #4
c0d049de:	461d      	mov	r5, r3
c0d049e0:	f7fe f827 	bl	c0d02a32 <os_memmove>
c0d049e4:	9b07      	ldr	r3, [sp, #28]
c0d049e6:	8ae0      	ldrh	r0, [r4, #22]
        }        
        service->transportOffset += xfer_len;
        service->transportPacketIndex++;
    }
    // See if we can process the command
    if ((media != U2F_MEDIA_USB) &&
c0d049e8:	2d01      	cmp	r5, #1
c0d049ea:	d101      	bne.n	c0d049f0 <u2f_transport_received+0x334>
c0d049ec:	8b21      	ldrh	r1, [r4, #24]
c0d049ee:	e013      	b.n	c0d04a18 <u2f_transport_received+0x35c>
        (service->transportOffset >
         (service->transportLength + U2F_COMMAND_HEADER_SIZE))) {
c0d049f0:	8b21      	ldrh	r1, [r4, #24]
c0d049f2:	1cca      	adds	r2, r1, #3
        }        
        service->transportOffset += xfer_len;
        service->transportPacketIndex++;
    }
    // See if we can process the command
    if ((media != U2F_MEDIA_USB) &&
c0d049f4:	4290      	cmp	r0, r2
c0d049f6:	d90f      	bls.n	c0d04a18 <u2f_transport_received+0x35c>
/**
 * Reply an error at the U2F transport level (take into account the FIDO U2F framing)
 */
static void u2f_transport_error(u2f_service_t *service, char errorCode) {
    //u2f_transport_reset(service); // warning reset first to allow for U2F_io sent call to u2f_transport_sent internally on eventless platforms
    G_io_usb_ep_buffer[8] = errorCode;
c0d049f8:	481e      	ldr	r0, [pc, #120]	; (c0d04a74 <u2f_transport_received+0x3b8>)
c0d049fa:	2103      	movs	r1, #3
c0d049fc:	7201      	strb	r1, [r0, #8]

    // ensure the state is set to error sending to allow for special treatment in case reply is not read by the receiver
    service->transportState = U2F_SENDING_ERROR;
c0d049fe:	2104      	movs	r1, #4
c0d04a00:	7039      	strb	r1, [r7, #0]
c0d04a02:	2100      	movs	r1, #0
c0d04a04:	76a1      	strb	r1, [r4, #26]
c0d04a06:	3008      	adds	r0, #8
c0d04a08:	61e0      	str	r0, [r4, #28]
c0d04a0a:	82e1      	strh	r1, [r4, #22]
c0d04a0c:	8323      	strh	r3, [r4, #24]
c0d04a0e:	9905      	ldr	r1, [sp, #20]
c0d04a10:	313a      	adds	r1, #58	; 0x3a
c0d04a12:	2040      	movs	r0, #64	; 0x40
c0d04a14:	5421      	strb	r1, [r4, r0]
c0d04a16:	e6db      	b.n	c0d047d0 <u2f_transport_received+0x114>
        (service->transportOffset >
         (service->transportLength + U2F_COMMAND_HEADER_SIZE))) {
        // Overflow, abort
        u2f_transport_error(service, ERROR_INVALID_LEN);
        goto error;
    } else if (service->transportOffset >= service->transportLength) {
c0d04a18:	4288      	cmp	r0, r1
c0d04a1a:	d206      	bcs.n	c0d04a2a <u2f_transport_received+0x36e>
c0d04a1c:	2000      	movs	r0, #0
        service->transportState = U2F_PROCESSING_COMMAND;
        // internal notification of a complete message received
        u2f_message_complete(service);
    } else {
        // new segment received, reset the timeout for the current piece
        service->seqTimeout = 0;
c0d04a1e:	6360      	str	r0, [r4, #52]	; 0x34
        service->transportState = U2F_HANDLE_SEGMENTED;
c0d04a20:	703b      	strb	r3, [r7, #0]
c0d04a22:	e6d9      	b.n	c0d047d8 <u2f_transport_received+0x11c>
c0d04a24:	4813      	ldr	r0, [pc, #76]	; (c0d04a74 <u2f_transport_received+0x3b8>)
c0d04a26:	7203      	strb	r3, [r0, #8]
c0d04a28:	e6c7      	b.n	c0d047ba <u2f_transport_received+0xfe>
        // Overflow, abort
        u2f_transport_error(service, ERROR_INVALID_LEN);
        goto error;
    } else if (service->transportOffset >= service->transportLength) {
        // switch before the handler gets the opportunity to change it again
        service->transportState = U2F_PROCESSING_COMMAND;
c0d04a2a:	2002      	movs	r0, #2
c0d04a2c:	7038      	strb	r0, [r7, #0]
        // internal notification of a complete message received
        u2f_message_complete(service);
c0d04a2e:	4620      	mov	r0, r4
c0d04a30:	f7ff fcbe 	bl	c0d043b0 <u2f_message_complete>
c0d04a34:	e6d0      	b.n	c0d047d8 <u2f_transport_received+0x11c>
                // special error case, we reply but don't change the current state of the transport (ongoing message for example)
                //u2f_transport_error_no_reset(service, ERROR_CHANNEL_BUSY);
                uint16_t offset = 0;
                // Fragment
                if (media == U2F_MEDIA_USB) {
                    os_memmove(G_io_usb_ep_buffer, service->channel, 4);
c0d04a36:	4c0f      	ldr	r4, [pc, #60]	; (c0d04a74 <u2f_transport_received+0x3b8>)
c0d04a38:	2204      	movs	r2, #4
c0d04a3a:	4620      	mov	r0, r4
c0d04a3c:	9901      	ldr	r1, [sp, #4]
c0d04a3e:	f7fd fff8 	bl	c0d02a32 <os_memmove>
                    offset += 4;
                }
                G_io_usb_ep_buffer[offset++] = U2F_STATUS_ERROR;
c0d04a42:	353a      	adds	r5, #58	; 0x3a
c0d04a44:	7125      	strb	r5, [r4, #4]
                G_io_usb_ep_buffer[offset++] = 0;
c0d04a46:	2000      	movs	r0, #0
c0d04a48:	7160      	strb	r0, [r4, #5]
c0d04a4a:	9a07      	ldr	r2, [sp, #28]
                G_io_usb_ep_buffer[offset++] = 1;
c0d04a4c:	71a2      	strb	r2, [r4, #6]
c0d04a4e:	2006      	movs	r0, #6
                G_io_usb_ep_buffer[offset++] = ERROR_CHANNEL_BUSY;
c0d04a50:	71e0      	strb	r0, [r4, #7]
                u2f_io_send(G_io_usb_ep_buffer, offset, media);
c0d04a52:	2108      	movs	r1, #8
c0d04a54:	4620      	mov	r0, r4
c0d04a56:	f7ff fcc9 	bl	c0d043ec <u2f_io_send>
c0d04a5a:	e6bd      	b.n	c0d047d8 <u2f_transport_received+0x11c>
/**
 * Reply an error at the U2F transport level (take into account the FIDO U2F framing)
 */
static void u2f_transport_error(u2f_service_t *service, char errorCode) {
    //u2f_transport_reset(service); // warning reset first to allow for U2F_io sent call to u2f_transport_sent internally on eventless platforms
    G_io_usb_ep_buffer[8] = errorCode;
c0d04a5c:	4805      	ldr	r0, [pc, #20]	; (c0d04a74 <u2f_transport_received+0x3b8>)
c0d04a5e:	210b      	movs	r1, #11
c0d04a60:	7201      	strb	r1, [r0, #8]

    // ensure the state is set to error sending to allow for special treatment in case reply is not read by the receiver
    service->transportState = U2F_SENDING_ERROR;
c0d04a62:	703e      	strb	r6, [r7, #0]
c0d04a64:	2100      	movs	r1, #0
c0d04a66:	76a1      	strb	r1, [r4, #26]
c0d04a68:	3008      	adds	r0, #8
c0d04a6a:	61e0      	str	r0, [r4, #28]
c0d04a6c:	82e1      	strh	r1, [r4, #22]
c0d04a6e:	9807      	ldr	r0, [sp, #28]
c0d04a70:	8320      	strh	r0, [r4, #24]
c0d04a72:	e7cc      	b.n	c0d04a0e <u2f_transport_received+0x352>
c0d04a74:	20001f5c 	.word	0x20001f5c
c0d04a78:	0000ffff 	.word	0x0000ffff
c0d04a7c:	0000bda5 	.word	0x0000bda5
c0d04a80:	0000bd97 	.word	0x0000bd97
c0d04a84:	0000bcfb 	.word	0x0000bcfb

c0d04a88 <u2f_is_channel_broadcast>:
    }
error:
    return;
}

bool u2f_is_channel_broadcast(uint8_t *channel) {
c0d04a88:	b580      	push	{r7, lr}
    return (os_memcmp(channel, BROADCAST_CHANNEL, 4) == 0);
c0d04a8a:	4906      	ldr	r1, [pc, #24]	; (c0d04aa4 <u2f_is_channel_broadcast+0x1c>)
c0d04a8c:	4479      	add	r1, pc
c0d04a8e:	2204      	movs	r2, #4
c0d04a90:	f7fe f86c 	bl	c0d02b6c <os_memcmp>
c0d04a94:	4601      	mov	r1, r0
c0d04a96:	2001      	movs	r0, #1
c0d04a98:	2200      	movs	r2, #0
c0d04a9a:	2900      	cmp	r1, #0
c0d04a9c:	d000      	beq.n	c0d04aa0 <u2f_is_channel_broadcast+0x18>
c0d04a9e:	4610      	mov	r0, r2
c0d04aa0:	bd80      	pop	{r7, pc}
c0d04aa2:	46c0      	nop			; (mov r8, r8)
c0d04aa4:	0000bbf1 	.word	0x0000bbf1

c0d04aa8 <u2f_message_set_autoreply_wait_user_presence>:
}

/**
 * Auto reply hodl until the real reply is prepared and sent
 */
void u2f_message_set_autoreply_wait_user_presence(u2f_service_t* service, bool enabled) {
c0d04aa8:	b580      	push	{r7, lr}
c0d04aaa:	222a      	movs	r2, #42	; 0x2a
c0d04aac:	5c83      	ldrb	r3, [r0, r2]
c0d04aae:	4602      	mov	r2, r0
c0d04ab0:	322a      	adds	r2, #42	; 0x2a

    if (enabled) {
c0d04ab2:	2901      	cmp	r1, #1
c0d04ab4:	d106      	bne.n	c0d04ac4 <u2f_message_set_autoreply_wait_user_presence+0x1c>
        // start replying placeholder until user presence validated
        if (service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE) {
c0d04ab6:	2b00      	cmp	r3, #0
c0d04ab8:	d108      	bne.n	c0d04acc <u2f_message_set_autoreply_wait_user_presence+0x24>
            service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_ON;
c0d04aba:	2101      	movs	r1, #1
c0d04abc:	7011      	strb	r1, [r2, #0]
            u2f_transport_send_usb_user_presence_required(service);
c0d04abe:	f7ff fd39 	bl	c0d04534 <u2f_transport_send_usb_user_presence_required>
    }
    // don't set to REPLY_READY when it has not been enabled beforehand
    else if (service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_ON) {
        service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_REPLY_READY;
    }
}
c0d04ac2:	bd80      	pop	{r7, pc}
            service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_ON;
            u2f_transport_send_usb_user_presence_required(service);
        }
    }
    // don't set to REPLY_READY when it has not been enabled beforehand
    else if (service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_ON) {
c0d04ac4:	2b01      	cmp	r3, #1
c0d04ac6:	d101      	bne.n	c0d04acc <u2f_message_set_autoreply_wait_user_presence+0x24>
        service->waitAsynchronousResponse = U2F_WAIT_ASYNCH_REPLY_READY;
c0d04ac8:	2002      	movs	r0, #2
c0d04aca:	7010      	strb	r0, [r2, #0]
    }
}
c0d04acc:	bd80      	pop	{r7, pc}

c0d04ace <u2f_message_repliable>:

bool u2f_message_repliable(u2f_service_t* service) {
c0d04ace:	4601      	mov	r1, r0
    // no more asynch replies
    // finished receiving the command
    // and not sending a user presence required status
    return service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE
c0d04ad0:	202a      	movs	r0, #42	; 0x2a
c0d04ad2:	5c0a      	ldrb	r2, [r1, r0]
c0d04ad4:	2001      	movs	r0, #1
        || (service->waitAsynchronousResponse != U2F_WAIT_ASYNCH_ON 
c0d04ad6:	2a00      	cmp	r2, #0
c0d04ad8:	d010      	beq.n	c0d04afc <u2f_message_repliable+0x2e>
c0d04ada:	2a01      	cmp	r2, #1
c0d04adc:	d101      	bne.n	c0d04ae2 <u2f_message_repliable+0x14>
c0d04ade:	2000      	movs	r0, #0

bool u2f_message_repliable(u2f_service_t* service) {
    // no more asynch replies
    // finished receiving the command
    // and not sending a user presence required status
    return service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE
c0d04ae0:	4770      	bx	lr
        || (service->waitAsynchronousResponse != U2F_WAIT_ASYNCH_ON 
            && service->fakeChannelTransportState == U2F_FAKE_RECEIVED 
c0d04ae2:	2025      	movs	r0, #37	; 0x25
c0d04ae4:	5c0a      	ldrb	r2, [r1, r0]
c0d04ae6:	2000      	movs	r0, #0
            && service->sending == false)
c0d04ae8:	2a06      	cmp	r2, #6
c0d04aea:	d107      	bne.n	c0d04afc <u2f_message_repliable+0x2e>
c0d04aec:	202b      	movs	r0, #43	; 0x2b
c0d04aee:	5c0a      	ldrb	r2, [r1, r0]
c0d04af0:	2001      	movs	r0, #1
c0d04af2:	2100      	movs	r1, #0
c0d04af4:	2a00      	cmp	r2, #0
c0d04af6:	d001      	beq.n	c0d04afc <u2f_message_repliable+0x2e>
c0d04af8:	4608      	mov	r0, r1

bool u2f_message_repliable(u2f_service_t* service) {
    // no more asynch replies
    // finished receiving the command
    // and not sending a user presence required status
    return service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE
c0d04afa:	4770      	bx	lr
c0d04afc:	4770      	bx	lr

c0d04afe <u2f_message_reply>:
            && service->fakeChannelTransportState == U2F_FAKE_RECEIVED 
            && service->sending == false)
        ;
}

void u2f_message_reply(u2f_service_t *service, uint8_t cmd, uint8_t *buffer, uint16_t len) {
c0d04afe:	b5b0      	push	{r4, r5, r7, lr}

bool u2f_message_repliable(u2f_service_t* service) {
    // no more asynch replies
    // finished receiving the command
    // and not sending a user presence required status
    return service->waitAsynchronousResponse == U2F_WAIT_ASYNCH_IDLE
c0d04b00:	242a      	movs	r4, #42	; 0x2a
c0d04b02:	5d04      	ldrb	r4, [r0, r4]
        || (service->waitAsynchronousResponse != U2F_WAIT_ASYNCH_ON 
c0d04b04:	2c00      	cmp	r4, #0
c0d04b06:	d009      	beq.n	c0d04b1c <u2f_message_reply+0x1e>
c0d04b08:	2c01      	cmp	r4, #1
c0d04b0a:	d015      	beq.n	c0d04b38 <u2f_message_reply+0x3a>
            && service->fakeChannelTransportState == U2F_FAKE_RECEIVED 
c0d04b0c:	2425      	movs	r4, #37	; 0x25
c0d04b0e:	5d04      	ldrb	r4, [r0, r4]
            && service->sending == false)
c0d04b10:	2c06      	cmp	r4, #6
c0d04b12:	d111      	bne.n	c0d04b38 <u2f_message_reply+0x3a>
c0d04b14:	242b      	movs	r4, #43	; 0x2b
c0d04b16:	5d04      	ldrb	r4, [r0, r4]
}

void u2f_message_reply(u2f_service_t *service, uint8_t cmd, uint8_t *buffer, uint16_t len) {

    // if U2F is not ready to reply, then gently avoid replying
    if (u2f_message_repliable(service)) 
c0d04b18:	2c00      	cmp	r4, #0
c0d04b1a:	d10d      	bne.n	c0d04b38 <u2f_message_reply+0x3a>
    {
        service->transportState = U2F_SENDING_RESPONSE;
c0d04b1c:	2420      	movs	r4, #32
c0d04b1e:	2503      	movs	r5, #3
c0d04b20:	5505      	strb	r5, [r0, r4]
c0d04b22:	2400      	movs	r4, #0
        service->transportPacketIndex = 0;
c0d04b24:	7684      	strb	r4, [r0, #26]
        service->transportBuffer = buffer;
c0d04b26:	61c2      	str	r2, [r0, #28]
        service->transportOffset = 0;
c0d04b28:	82c4      	strh	r4, [r0, #22]
        service->transportLength = len;
c0d04b2a:	8303      	strh	r3, [r0, #24]
        service->sendCmd = cmd;
c0d04b2c:	2240      	movs	r2, #64	; 0x40
c0d04b2e:	5481      	strb	r1, [r0, r2]
        // pump the first message
        u2f_transport_sent(service, service->transportMedia);
c0d04b30:	2121      	movs	r1, #33	; 0x21
c0d04b32:	5c41      	ldrb	r1, [r0, r1]
c0d04b34:	f7ff fc82 	bl	c0d0443c <u2f_transport_sent>
    }
}
c0d04b38:	bdb0      	pop	{r4, r5, r7, pc}

c0d04b3a <readUint64BE>:

#include "uint256.h"

static const char HEXDIGITS[] = "0123456789abcdef";

static uint64_t readUint64BE(uint8_t *buffer) {
c0d04b3a:	b510      	push	{r4, lr}
    return (((uint64_t)buffer[0]) << 56) | (((uint64_t)buffer[1]) << 48) |
           (((uint64_t)buffer[2]) << 40) | (((uint64_t)buffer[3]) << 32) |
           (((uint64_t)buffer[4]) << 24) | (((uint64_t)buffer[5]) << 16) |
c0d04b3c:	7941      	ldrb	r1, [r0, #5]
c0d04b3e:	0409      	lsls	r1, r1, #16
c0d04b40:	7902      	ldrb	r2, [r0, #4]
c0d04b42:	0612      	lsls	r2, r2, #24
c0d04b44:	430a      	orrs	r2, r1
           (((uint64_t)buffer[6]) << 8) | (((uint64_t)buffer[7]));
c0d04b46:	7981      	ldrb	r1, [r0, #6]
c0d04b48:	0209      	lsls	r1, r1, #8
static const char HEXDIGITS[] = "0123456789abcdef";

static uint64_t readUint64BE(uint8_t *buffer) {
    return (((uint64_t)buffer[0]) << 56) | (((uint64_t)buffer[1]) << 48) |
           (((uint64_t)buffer[2]) << 40) | (((uint64_t)buffer[3]) << 32) |
           (((uint64_t)buffer[4]) << 24) | (((uint64_t)buffer[5]) << 16) |
c0d04b4a:	4311      	orrs	r1, r2
           (((uint64_t)buffer[6]) << 8) | (((uint64_t)buffer[7]));
c0d04b4c:	79c2      	ldrb	r2, [r0, #7]
c0d04b4e:	430a      	orrs	r2, r1
#include "uint256.h"

static const char HEXDIGITS[] = "0123456789abcdef";

static uint64_t readUint64BE(uint8_t *buffer) {
    return (((uint64_t)buffer[0]) << 56) | (((uint64_t)buffer[1]) << 48) |
c0d04b50:	7801      	ldrb	r1, [r0, #0]
c0d04b52:	0609      	lsls	r1, r1, #24
c0d04b54:	7843      	ldrb	r3, [r0, #1]
c0d04b56:	041b      	lsls	r3, r3, #16
c0d04b58:	430b      	orrs	r3, r1
           (((uint64_t)buffer[2]) << 40) | (((uint64_t)buffer[3]) << 32) |
c0d04b5a:	7881      	ldrb	r1, [r0, #2]
c0d04b5c:	020c      	lsls	r4, r1, #8
#include "uint256.h"

static const char HEXDIGITS[] = "0123456789abcdef";

static uint64_t readUint64BE(uint8_t *buffer) {
    return (((uint64_t)buffer[0]) << 56) | (((uint64_t)buffer[1]) << 48) |
c0d04b5e:	431c      	orrs	r4, r3
           (((uint64_t)buffer[2]) << 40) | (((uint64_t)buffer[3]) << 32) |
c0d04b60:	78c1      	ldrb	r1, [r0, #3]
c0d04b62:	4321      	orrs	r1, r4
#include "uint256.h"

static const char HEXDIGITS[] = "0123456789abcdef";

static uint64_t readUint64BE(uint8_t *buffer) {
    return (((uint64_t)buffer[0]) << 56) | (((uint64_t)buffer[1]) << 48) |
c0d04b64:	4610      	mov	r0, r2
c0d04b66:	bd10      	pop	{r4, pc}

c0d04b68 <readu256BE>:
void readu128BE(uint8_t *buffer, uint128_t *target) {
    UPPER_P(target) = readUint64BE(buffer);
    LOWER_P(target) = readUint64BE(buffer + 8);
}

void readu256BE(uint8_t *buffer, uint256_t *target) {
c0d04b68:	b5b0      	push	{r4, r5, r7, lr}
c0d04b6a:	460c      	mov	r4, r1
c0d04b6c:	4605      	mov	r5, r0
           (((uint64_t)buffer[4]) << 24) | (((uint64_t)buffer[5]) << 16) |
           (((uint64_t)buffer[6]) << 8) | (((uint64_t)buffer[7]));
}

void readu128BE(uint8_t *buffer, uint128_t *target) {
    UPPER_P(target) = readUint64BE(buffer);
c0d04b6e:	f7ff ffe4 	bl	c0d04b3a <readUint64BE>
c0d04b72:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = readUint64BE(buffer + 8);
c0d04b74:	4628      	mov	r0, r5
c0d04b76:	3008      	adds	r0, #8
           (((uint64_t)buffer[4]) << 24) | (((uint64_t)buffer[5]) << 16) |
           (((uint64_t)buffer[6]) << 8) | (((uint64_t)buffer[7]));
}

void readu128BE(uint8_t *buffer, uint128_t *target) {
    UPPER_P(target) = readUint64BE(buffer);
c0d04b78:	3c08      	subs	r4, #8
    LOWER_P(target) = readUint64BE(buffer + 8);
c0d04b7a:	f7ff ffde 	bl	c0d04b3a <readUint64BE>
c0d04b7e:	60a0      	str	r0, [r4, #8]
c0d04b80:	60e1      	str	r1, [r4, #12]
}

void readu256BE(uint8_t *buffer, uint256_t *target) {
    readu128BE(buffer, &UPPER_P(target));
    readu128BE(buffer + 16, &LOWER_P(target));
c0d04b82:	4628      	mov	r0, r5
c0d04b84:	3010      	adds	r0, #16
           (((uint64_t)buffer[4]) << 24) | (((uint64_t)buffer[5]) << 16) |
           (((uint64_t)buffer[6]) << 8) | (((uint64_t)buffer[7]));
}

void readu128BE(uint8_t *buffer, uint128_t *target) {
    UPPER_P(target) = readUint64BE(buffer);
c0d04b86:	f7ff ffd8 	bl	c0d04b3a <readUint64BE>
c0d04b8a:	6120      	str	r0, [r4, #16]
c0d04b8c:	6161      	str	r1, [r4, #20]
    LOWER_P(target) = readUint64BE(buffer + 8);
c0d04b8e:	3518      	adds	r5, #24
c0d04b90:	4628      	mov	r0, r5
c0d04b92:	f7ff ffd2 	bl	c0d04b3a <readUint64BE>
c0d04b96:	61a0      	str	r0, [r4, #24]
c0d04b98:	61e1      	str	r1, [r4, #28]
}

void readu256BE(uint8_t *buffer, uint256_t *target) {
    readu128BE(buffer, &UPPER_P(target));
    readu128BE(buffer + 16, &LOWER_P(target));
}
c0d04b9a:	bdb0      	pop	{r4, r5, r7, pc}

c0d04b9c <shiftl128>:
void clear256(uint256_t *target) {
    clear128(&UPPER_P(target));
    clear128(&LOWER_P(target));
}

void shiftl128(uint128_t *number, uint32_t value, uint128_t *target) {
c0d04b9c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04b9e:	b088      	sub	sp, #32
    if (value >= 128) {
c0d04ba0:	2980      	cmp	r1, #128	; 0x80
c0d04ba2:	d305      	bcc.n	c0d04bb0 <shiftl128+0x14>
c0d04ba4:	2000      	movs	r0, #0
c0d04ba6:	6010      	str	r0, [r2, #0]
c0d04ba8:	6050      	str	r0, [r2, #4]
c0d04baa:	6090      	str	r0, [r2, #8]
c0d04bac:	60d0      	str	r0, [r2, #12]
c0d04bae:	e061      	b.n	c0d04c74 <shiftl128+0xd8>
        clear128(target);
    } else if (value == 64) {
c0d04bb0:	2900      	cmp	r1, #0
c0d04bb2:	d008      	beq.n	c0d04bc6 <shiftl128+0x2a>
c0d04bb4:	2940      	cmp	r1, #64	; 0x40
c0d04bb6:	d10d      	bne.n	c0d04bd4 <shiftl128+0x38>
        UPPER_P(target) = LOWER_P(number);
c0d04bb8:	6881      	ldr	r1, [r0, #8]
c0d04bba:	68c0      	ldr	r0, [r0, #12]
        LOWER_P(target) = 0;
c0d04bbc:	2300      	movs	r3, #0

void shiftl128(uint128_t *number, uint32_t value, uint128_t *target) {
    if (value >= 128) {
        clear128(target);
    } else if (value == 64) {
        UPPER_P(target) = LOWER_P(number);
c0d04bbe:	6011      	str	r1, [r2, #0]
c0d04bc0:	6050      	str	r0, [r2, #4]
        LOWER_P(target) = 0;
c0d04bc2:	6093      	str	r3, [r2, #8]
c0d04bc4:	e055      	b.n	c0d04c72 <shiftl128+0xd6>
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d04bc6:	c80a      	ldmia	r0!, {r1, r3}
c0d04bc8:	c20a      	stmia	r2!, {r1, r3}
    LOWER_P(target) = LOWER_P(number);
c0d04bca:	6801      	ldr	r1, [r0, #0]
c0d04bcc:	6840      	ldr	r0, [r0, #4]
c0d04bce:	6050      	str	r0, [r2, #4]
c0d04bd0:	6011      	str	r1, [r2, #0]
c0d04bd2:	e04f      	b.n	c0d04c74 <shiftl128+0xd8>
    } else if (value == 64) {
        UPPER_P(target) = LOWER_P(number);
        LOWER_P(target) = 0;
    } else if (value == 0) {
        copy128(target, number);
    } else if (value < 64) {
c0d04bd4:	293f      	cmp	r1, #63	; 0x3f
c0d04bd6:	d84f      	bhi.n	c0d04c78 <shiftl128+0xdc>
c0d04bd8:	2320      	movs	r3, #32
c0d04bda:	9304      	str	r3, [sp, #16]
        UPPER_P(target) =
            (UPPER_P(number) << value) + (LOWER_P(number) >> (64 - value));
c0d04bdc:	1a5f      	subs	r7, r3, r1
c0d04bde:	2340      	movs	r3, #64	; 0x40
c0d04be0:	1a5c      	subs	r4, r3, r1
c0d04be2:	68c5      	ldr	r5, [r0, #12]
c0d04be4:	462b      	mov	r3, r5
c0d04be6:	9402      	str	r4, [sp, #8]
c0d04be8:	40e3      	lsrs	r3, r4
c0d04bea:	2400      	movs	r4, #0
c0d04bec:	2f00      	cmp	r7, #0
c0d04bee:	9407      	str	r4, [sp, #28]
c0d04bf0:	da00      	bge.n	c0d04bf4 <shiftl128+0x58>
c0d04bf2:	461c      	mov	r4, r3
c0d04bf4:	9501      	str	r5, [sp, #4]
c0d04bf6:	9405      	str	r4, [sp, #20]
c0d04bf8:	c828      	ldmia	r0!, {r3, r5}
c0d04bfa:	408d      	lsls	r5, r1
c0d04bfc:	461c      	mov	r4, r3
c0d04bfe:	9706      	str	r7, [sp, #24]
c0d04c00:	40fc      	lsrs	r4, r7
c0d04c02:	432c      	orrs	r4, r5
c0d04c04:	460d      	mov	r5, r1
c0d04c06:	3d20      	subs	r5, #32
c0d04c08:	9300      	str	r3, [sp, #0]
c0d04c0a:	461f      	mov	r7, r3
c0d04c0c:	40af      	lsls	r7, r5
c0d04c0e:	3808      	subs	r0, #8
c0d04c10:	2d00      	cmp	r5, #0
c0d04c12:	da00      	bge.n	c0d04c16 <shiftl128+0x7a>
c0d04c14:	4627      	mov	r7, r4
c0d04c16:	9703      	str	r7, [sp, #12]
c0d04c18:	6887      	ldr	r7, [r0, #8]
c0d04c1a:	9e02      	ldr	r6, [sp, #8]
c0d04c1c:	40f7      	lsrs	r7, r6
c0d04c1e:	9c04      	ldr	r4, [sp, #16]
c0d04c20:	1ba3      	subs	r3, r4, r6
c0d04c22:	9304      	str	r3, [sp, #16]
c0d04c24:	9e01      	ldr	r6, [sp, #4]
c0d04c26:	4634      	mov	r4, r6
c0d04c28:	9b04      	ldr	r3, [sp, #16]
c0d04c2a:	409c      	lsls	r4, r3
c0d04c2c:	433c      	orrs	r4, r7
c0d04c2e:	9f06      	ldr	r7, [sp, #24]
c0d04c30:	40fe      	lsrs	r6, r7
c0d04c32:	2f00      	cmp	r7, #0
c0d04c34:	da00      	bge.n	c0d04c38 <shiftl128+0x9c>
c0d04c36:	4626      	mov	r6, r4
c0d04c38:	9b00      	ldr	r3, [sp, #0]
c0d04c3a:	408b      	lsls	r3, r1
c0d04c3c:	2d00      	cmp	r5, #0
c0d04c3e:	9c07      	ldr	r4, [sp, #28]
c0d04c40:	da00      	bge.n	c0d04c44 <shiftl128+0xa8>
c0d04c42:	461c      	mov	r4, r3
c0d04c44:	1933      	adds	r3, r6, r4
c0d04c46:	9c05      	ldr	r4, [sp, #20]
c0d04c48:	9e03      	ldr	r6, [sp, #12]
c0d04c4a:	4174      	adcs	r4, r6
        UPPER_P(target) = LOWER_P(number);
        LOWER_P(target) = 0;
    } else if (value == 0) {
        copy128(target, number);
    } else if (value < 64) {
        UPPER_P(target) =
c0d04c4c:	c218      	stmia	r2!, {r3, r4}
            (UPPER_P(number) << value) + (LOWER_P(number) >> (64 - value));
        LOWER_P(target) = (LOWER_P(number) << value);
c0d04c4e:	6883      	ldr	r3, [r0, #8]
c0d04c50:	461c      	mov	r4, r3
c0d04c52:	408c      	lsls	r4, r1
        UPPER_P(target) = LOWER_P(number);
        LOWER_P(target) = 0;
    } else if (value == 0) {
        copy128(target, number);
    } else if (value < 64) {
        UPPER_P(target) =
c0d04c54:	3a08      	subs	r2, #8
            (UPPER_P(number) << value) + (LOWER_P(number) >> (64 - value));
        LOWER_P(target) = (LOWER_P(number) << value);
c0d04c56:	2d00      	cmp	r5, #0
c0d04c58:	da00      	bge.n	c0d04c5c <shiftl128+0xc0>
c0d04c5a:	9407      	str	r4, [sp, #28]
c0d04c5c:	68c4      	ldr	r4, [r0, #12]
c0d04c5e:	9807      	ldr	r0, [sp, #28]
c0d04c60:	6090      	str	r0, [r2, #8]
c0d04c62:	408c      	lsls	r4, r1
c0d04c64:	4618      	mov	r0, r3
c0d04c66:	40f8      	lsrs	r0, r7
c0d04c68:	4320      	orrs	r0, r4
c0d04c6a:	40ab      	lsls	r3, r5
c0d04c6c:	2d00      	cmp	r5, #0
c0d04c6e:	da00      	bge.n	c0d04c72 <shiftl128+0xd6>
c0d04c70:	4603      	mov	r3, r0
c0d04c72:	60d3      	str	r3, [r2, #12]
        UPPER_P(target) = LOWER_P(number) << (value - 64);
        LOWER_P(target) = 0;
    } else {
        clear128(target);
    }
}
c0d04c74:	b008      	add	sp, #32
c0d04c76:	bdf0      	pop	{r4, r5, r6, r7, pc}
        copy128(target, number);
    } else if (value < 64) {
        UPPER_P(target) =
            (UPPER_P(number) << value) + (LOWER_P(number) >> (64 - value));
        LOWER_P(target) = (LOWER_P(number) << value);
    } else if ((128 > value) && (value > 64)) {
c0d04c78:	2940      	cmp	r1, #64	; 0x40
c0d04c7a:	d093      	beq.n	c0d04ba4 <shiftl128+0x8>
        UPPER_P(target) = LOWER_P(number) << (value - 64);
c0d04c7c:	460e      	mov	r6, r1
c0d04c7e:	3e40      	subs	r6, #64	; 0x40
c0d04c80:	6883      	ldr	r3, [r0, #8]
c0d04c82:	461f      	mov	r7, r3
c0d04c84:	40b7      	lsls	r7, r6
c0d04c86:	460d      	mov	r5, r1
c0d04c88:	3d60      	subs	r5, #96	; 0x60
c0d04c8a:	2400      	movs	r4, #0
c0d04c8c:	2d00      	cmp	r5, #0
c0d04c8e:	9407      	str	r4, [sp, #28]
c0d04c90:	da00      	bge.n	c0d04c94 <shiftl128+0xf8>
c0d04c92:	463c      	mov	r4, r7
c0d04c94:	68c7      	ldr	r7, [r0, #12]
c0d04c96:	6014      	str	r4, [r2, #0]
c0d04c98:	40b7      	lsls	r7, r6
c0d04c9a:	2060      	movs	r0, #96	; 0x60
c0d04c9c:	1a41      	subs	r1, r0, r1
c0d04c9e:	4618      	mov	r0, r3
c0d04ca0:	40c8      	lsrs	r0, r1
c0d04ca2:	4338      	orrs	r0, r7
c0d04ca4:	40ab      	lsls	r3, r5
c0d04ca6:	2d00      	cmp	r5, #0
c0d04ca8:	da00      	bge.n	c0d04cac <shiftl128+0x110>
c0d04caa:	4603      	mov	r3, r0
c0d04cac:	6053      	str	r3, [r2, #4]
c0d04cae:	9807      	ldr	r0, [sp, #28]
c0d04cb0:	e77b      	b.n	c0d04baa <shiftl128+0xe>

c0d04cb2 <shiftl256>:
    } else {
        clear128(target);
    }
}

void shiftl256(uint256_t *number, uint32_t value, uint256_t *target) {
c0d04cb2:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04cb4:	b095      	sub	sp, #84	; 0x54
c0d04cb6:	4614      	mov	r4, r2
c0d04cb8:	460e      	mov	r6, r1
c0d04cba:	4605      	mov	r5, r0
    if (value >= 256) {
c0d04cbc:	0a30      	lsrs	r0, r6, #8
c0d04cbe:	d004      	beq.n	c0d04cca <shiftl256+0x18>
c0d04cc0:	2120      	movs	r1, #32
c0d04cc2:	4620      	mov	r0, r4
c0d04cc4:	f002 f8e4 	bl	c0d06e90 <__aeabi_memclr>
c0d04cc8:	e06e      	b.n	c0d04da8 <shiftl256+0xf6>
        clear256(target);
    } else if (value == 128) {
c0d04cca:	2e00      	cmp	r6, #0
c0d04ccc:	d00e      	beq.n	c0d04cec <shiftl256+0x3a>
c0d04cce:	2e80      	cmp	r6, #128	; 0x80
c0d04cd0:	d119      	bne.n	c0d04d06 <shiftl256+0x54>
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d04cd2:	6928      	ldr	r0, [r5, #16]
c0d04cd4:	6969      	ldr	r1, [r5, #20]
c0d04cd6:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0d04cd8:	69a8      	ldr	r0, [r5, #24]
c0d04cda:	69e9      	ldr	r1, [r5, #28]
c0d04cdc:	6061      	str	r1, [r4, #4]
c0d04cde:	6020      	str	r0, [r4, #0]
c0d04ce0:	2000      	movs	r0, #0
    copy128(&LOWER_P(target), &LOWER_P(number));
}

void clear128(uint128_t *target) {
    UPPER_P(target) = 0;
    LOWER_P(target) = 0;
c0d04ce2:	6160      	str	r0, [r4, #20]
c0d04ce4:	6120      	str	r0, [r4, #16]
c0d04ce6:	60e0      	str	r0, [r4, #12]
c0d04ce8:	60a0      	str	r0, [r4, #8]
c0d04cea:	e05d      	b.n	c0d04da8 <shiftl256+0xf6>
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d04cec:	cd03      	ldmia	r5!, {r0, r1}
c0d04cee:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0d04cf0:	6828      	ldr	r0, [r5, #0]
c0d04cf2:	6869      	ldr	r1, [r5, #4]
c0d04cf4:	6061      	str	r1, [r4, #4]
c0d04cf6:	6020      	str	r0, [r4, #0]
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d04cf8:	68a8      	ldr	r0, [r5, #8]
c0d04cfa:	68e9      	ldr	r1, [r5, #12]
c0d04cfc:	60e1      	str	r1, [r4, #12]
c0d04cfe:	60a0      	str	r0, [r4, #8]
    LOWER_P(target) = LOWER_P(number);
c0d04d00:	6928      	ldr	r0, [r5, #16]
c0d04d02:	6969      	ldr	r1, [r5, #20]
c0d04d04:	e04d      	b.n	c0d04da2 <shiftl256+0xf0>
    } else if (value == 128) {
        copy128(&UPPER_P(target), &LOWER_P(number));
        clear128(&LOWER_P(target));
    } else if (value == 0) {
        copy256(target, number);
    } else if (value < 128) {
c0d04d06:	2e7f      	cmp	r6, #127	; 0x7f
c0d04d08:	d850      	bhi.n	c0d04dac <shiftl256+0xfa>
c0d04d0a:	aa10      	add	r2, sp, #64	; 0x40
        uint128_t tmp1;
        uint128_t tmp2;
        uint256_t result;
        shiftl128(&UPPER_P(number), value, &tmp1);
c0d04d0c:	4628      	mov	r0, r5
c0d04d0e:	4631      	mov	r1, r6
c0d04d10:	f7ff ff44 	bl	c0d04b9c <shiftl128>
        shiftr128(&LOWER_P(number), (128 - value), &tmp2);
c0d04d14:	2080      	movs	r0, #128	; 0x80
c0d04d16:	1b81      	subs	r1, r0, r6
c0d04d18:	3510      	adds	r5, #16
c0d04d1a:	aa0c      	add	r2, sp, #48	; 0x30
c0d04d1c:	4628      	mov	r0, r5
c0d04d1e:	f000 f854 	bl	c0d04dca <shiftr128>
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
        ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d04d22:	9912      	ldr	r1, [sp, #72]	; 0x48
c0d04d24:	9a0e      	ldr	r2, [sp, #56]	; 0x38
c0d04d26:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0d04d28:	9f0f      	ldr	r7, [sp, #60]	; 0x3c
c0d04d2a:	1853      	adds	r3, r2, r1
c0d04d2c:	4178      	adcs	r0, r7
c0d04d2e:	2101      	movs	r1, #1
c0d04d30:	9101      	str	r1, [sp, #4]
c0d04d32:	2100      	movs	r1, #0
c0d04d34:	9302      	str	r3, [sp, #8]
c0d04d36:	4293      	cmp	r3, r2
c0d04d38:	9a01      	ldr	r2, [sp, #4]
c0d04d3a:	9203      	str	r2, [sp, #12]
c0d04d3c:	d300      	bcc.n	c0d04d40 <shiftl256+0x8e>
c0d04d3e:	9103      	str	r1, [sp, #12]
c0d04d40:	42b8      	cmp	r0, r7
c0d04d42:	d300      	bcc.n	c0d04d46 <shiftl256+0x94>
c0d04d44:	460a      	mov	r2, r1
c0d04d46:	42b8      	cmp	r0, r7
c0d04d48:	d000      	beq.n	c0d04d4c <shiftl256+0x9a>
c0d04d4a:	9203      	str	r2, [sp, #12]
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
c0d04d4c:	9b10      	ldr	r3, [sp, #64]	; 0x40
c0d04d4e:	9f0c      	ldr	r7, [sp, #48]	; 0x30
c0d04d50:	9a11      	ldr	r2, [sp, #68]	; 0x44
c0d04d52:	9201      	str	r2, [sp, #4]
c0d04d54:	9a0d      	ldr	r2, [sp, #52]	; 0x34
c0d04d56:	18fb      	adds	r3, r7, r3
c0d04d58:	9f01      	ldr	r7, [sp, #4]
c0d04d5a:	417a      	adcs	r2, r7
c0d04d5c:	9301      	str	r3, [sp, #4]
c0d04d5e:	1c5f      	adds	r7, r3, #1
c0d04d60:	4151      	adcs	r1, r2
c0d04d62:	9b03      	ldr	r3, [sp, #12]
c0d04d64:	2b00      	cmp	r3, #0
c0d04d66:	d100      	bne.n	c0d04d6a <shiftl256+0xb8>
c0d04d68:	4611      	mov	r1, r2
bool gte256(uint256_t *number1, uint256_t *number2) {
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
c0d04d6a:	9105      	str	r1, [sp, #20]
        UPPER_P(number1) + UPPER_P(number2) +
c0d04d6c:	9903      	ldr	r1, [sp, #12]
c0d04d6e:	2900      	cmp	r1, #0
c0d04d70:	d100      	bne.n	c0d04d74 <shiftl256+0xc2>
c0d04d72:	9f01      	ldr	r7, [sp, #4]
bool gte256(uint256_t *number1, uint256_t *number2) {
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
c0d04d74:	9704      	str	r7, [sp, #16]
        UPPER_P(number1) + UPPER_P(number2) +
        ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0d04d76:	9007      	str	r0, [sp, #28]
c0d04d78:	9802      	ldr	r0, [sp, #8]
c0d04d7a:	9006      	str	r0, [sp, #24]
c0d04d7c:	aa04      	add	r2, sp, #16
        uint128_t tmp2;
        uint256_t result;
        shiftl128(&UPPER_P(number), value, &tmp1);
        shiftr128(&LOWER_P(number), (128 - value), &tmp2);
        add128(&tmp1, &tmp2, &UPPER(result));
        shiftl128(&LOWER_P(number), value, &LOWER(result));
c0d04d7e:	3210      	adds	r2, #16
c0d04d80:	4628      	mov	r0, r5
c0d04d82:	4631      	mov	r1, r6
c0d04d84:	f7ff ff0a 	bl	c0d04b9c <shiftl128>
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d04d88:	9804      	ldr	r0, [sp, #16]
c0d04d8a:	9905      	ldr	r1, [sp, #20]
c0d04d8c:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0d04d8e:	9806      	ldr	r0, [sp, #24]
c0d04d90:	9907      	ldr	r1, [sp, #28]
c0d04d92:	6061      	str	r1, [r4, #4]
c0d04d94:	6020      	str	r0, [r4, #0]
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d04d96:	9808      	ldr	r0, [sp, #32]
c0d04d98:	9909      	ldr	r1, [sp, #36]	; 0x24
c0d04d9a:	60e1      	str	r1, [r4, #12]
c0d04d9c:	60a0      	str	r0, [r4, #8]
    LOWER_P(target) = LOWER_P(number);
c0d04d9e:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d04da0:	990b      	ldr	r1, [sp, #44]	; 0x2c
c0d04da2:	3c08      	subs	r4, #8
c0d04da4:	61e1      	str	r1, [r4, #28]
c0d04da6:	61a0      	str	r0, [r4, #24]
        shiftl128(&LOWER_P(number), (value - 128), &UPPER_P(target));
        clear128(&LOWER_P(target));
    } else {
        clear256(target);
    }
}
c0d04da8:	b015      	add	sp, #84	; 0x54
c0d04daa:	bdf0      	pop	{r4, r5, r6, r7, pc}
        shiftl128(&UPPER_P(number), value, &tmp1);
        shiftr128(&LOWER_P(number), (128 - value), &tmp2);
        add128(&tmp1, &tmp2, &UPPER(result));
        shiftl128(&LOWER_P(number), value, &LOWER(result));
        copy256(target, &result);
    } else if ((256 > value) && (value > 128)) {
c0d04dac:	2e80      	cmp	r6, #128	; 0x80
c0d04dae:	d087      	beq.n	c0d04cc0 <shiftl256+0xe>
        shiftl128(&LOWER_P(number), (value - 128), &UPPER_P(target));
c0d04db0:	3510      	adds	r5, #16
c0d04db2:	3e80      	subs	r6, #128	; 0x80
c0d04db4:	4628      	mov	r0, r5
c0d04db6:	4631      	mov	r1, r6
c0d04db8:	4622      	mov	r2, r4
c0d04dba:	f7ff feef 	bl	c0d04b9c <shiftl128>
    copy128(&LOWER_P(target), &LOWER_P(number));
}

void clear128(uint128_t *target) {
    UPPER_P(target) = 0;
    LOWER_P(target) = 0;
c0d04dbe:	2000      	movs	r0, #0
c0d04dc0:	6120      	str	r0, [r4, #16]
c0d04dc2:	6160      	str	r0, [r4, #20]
c0d04dc4:	61a0      	str	r0, [r4, #24]
c0d04dc6:	61e0      	str	r0, [r4, #28]
c0d04dc8:	e7ee      	b.n	c0d04da8 <shiftl256+0xf6>

c0d04dca <shiftr128>:
    } else {
        clear256(target);
    }
}

void shiftr128(uint128_t *number, uint32_t value, uint128_t *target) {
c0d04dca:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04dcc:	b087      	sub	sp, #28
    if (value >= 128) {
c0d04dce:	2980      	cmp	r1, #128	; 0x80
c0d04dd0:	d305      	bcc.n	c0d04dde <shiftr128+0x14>
c0d04dd2:	2000      	movs	r0, #0
c0d04dd4:	6010      	str	r0, [r2, #0]
c0d04dd6:	6050      	str	r0, [r2, #4]
c0d04dd8:	6090      	str	r0, [r2, #8]
c0d04dda:	60d0      	str	r0, [r2, #12]
c0d04ddc:	e07f      	b.n	c0d04ede <shiftr128+0x114>
        clear128(target);
    } else if (value == 64) {
c0d04dde:	2900      	cmp	r1, #0
c0d04de0:	d007      	beq.n	c0d04df2 <shiftr128+0x28>
c0d04de2:	2940      	cmp	r1, #64	; 0x40
c0d04de4:	d10d      	bne.n	c0d04e02 <shiftr128+0x38>
        UPPER_P(target) = 0;
c0d04de6:	2100      	movs	r1, #0
c0d04de8:	6051      	str	r1, [r2, #4]
c0d04dea:	6011      	str	r1, [r2, #0]
        LOWER_P(target) = UPPER_P(number);
c0d04dec:	6801      	ldr	r1, [r0, #0]
c0d04dee:	6840      	ldr	r0, [r0, #4]
c0d04df0:	e004      	b.n	c0d04dfc <shiftr128+0x32>
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d04df2:	c80a      	ldmia	r0!, {r1, r3}
c0d04df4:	c20a      	stmia	r2!, {r1, r3}
    LOWER_P(target) = LOWER_P(number);
c0d04df6:	6801      	ldr	r1, [r0, #0]
c0d04df8:	6840      	ldr	r0, [r0, #4]
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d04dfa:	3a08      	subs	r2, #8
c0d04dfc:	60d0      	str	r0, [r2, #12]
c0d04dfe:	6091      	str	r1, [r2, #8]
c0d04e00:	e06d      	b.n	c0d04ede <shiftr128+0x114>
    } else if (value == 64) {
        UPPER_P(target) = 0;
        LOWER_P(target) = UPPER_P(number);
    } else if (value == 0) {
        copy128(target, number);
    } else if (value < 64) {
c0d04e02:	293f      	cmp	r1, #63	; 0x3f
c0d04e04:	d84d      	bhi.n	c0d04ea2 <shiftr128+0xd8>
        uint128_t result;
        UPPER(result) = UPPER_P(number) >> value;
c0d04e06:	6843      	ldr	r3, [r0, #4]
c0d04e08:	9303      	str	r3, [sp, #12]
c0d04e0a:	40cb      	lsrs	r3, r1
c0d04e0c:	460c      	mov	r4, r1
c0d04e0e:	3c20      	subs	r4, #32
c0d04e10:	2600      	movs	r6, #0
c0d04e12:	2c00      	cmp	r4, #0
c0d04e14:	9605      	str	r6, [sp, #20]
c0d04e16:	da00      	bge.n	c0d04e1a <shiftr128+0x50>
c0d04e18:	461e      	mov	r6, r3
        LOWER(result) =
            (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d04e1a:	6885      	ldr	r5, [r0, #8]
c0d04e1c:	68c3      	ldr	r3, [r0, #12]
        LOWER_P(target) = UPPER_P(number);
    } else if (value == 0) {
        copy128(target, number);
    } else if (value < 64) {
        uint128_t result;
        UPPER(result) = UPPER_P(number) >> value;
c0d04e1e:	9304      	str	r3, [sp, #16]
c0d04e20:	6800      	ldr	r0, [r0, #0]
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d04e22:	6056      	str	r6, [r2, #4]
c0d04e24:	2320      	movs	r3, #32
c0d04e26:	9302      	str	r3, [sp, #8]
        copy128(target, number);
    } else if (value < 64) {
        uint128_t result;
        UPPER(result) = UPPER_P(number) >> value;
        LOWER(result) =
            (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d04e28:	1a5b      	subs	r3, r3, r1
c0d04e2a:	9f03      	ldr	r7, [sp, #12]
        LOWER_P(target) = UPPER_P(number);
    } else if (value == 0) {
        copy128(target, number);
    } else if (value < 64) {
        uint128_t result;
        UPPER(result) = UPPER_P(number) >> value;
c0d04e2c:	463e      	mov	r6, r7
c0d04e2e:	9306      	str	r3, [sp, #24]
c0d04e30:	409e      	lsls	r6, r3
c0d04e32:	4603      	mov	r3, r0
c0d04e34:	40cb      	lsrs	r3, r1
c0d04e36:	4333      	orrs	r3, r6
c0d04e38:	40e7      	lsrs	r7, r4
c0d04e3a:	2c00      	cmp	r4, #0
c0d04e3c:	da00      	bge.n	c0d04e40 <shiftr128+0x76>
c0d04e3e:	461f      	mov	r7, r3
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d04e40:	6017      	str	r7, [r2, #0]
        copy128(target, number);
    } else if (value < 64) {
        uint128_t result;
        UPPER(result) = UPPER_P(number) >> value;
        LOWER(result) =
            (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d04e42:	2340      	movs	r3, #64	; 0x40
c0d04e44:	1a5e      	subs	r6, r3, r1
c0d04e46:	4603      	mov	r3, r0
c0d04e48:	9600      	str	r6, [sp, #0]
c0d04e4a:	40b3      	lsls	r3, r6
c0d04e4c:	9e06      	ldr	r6, [sp, #24]
c0d04e4e:	2e00      	cmp	r6, #0
c0d04e50:	9e05      	ldr	r6, [sp, #20]
c0d04e52:	da00      	bge.n	c0d04e56 <shiftr128+0x8c>
c0d04e54:	461e      	mov	r6, r3
c0d04e56:	9601      	str	r6, [sp, #4]
c0d04e58:	9e04      	ldr	r6, [sp, #16]
c0d04e5a:	4633      	mov	r3, r6
c0d04e5c:	9f06      	ldr	r7, [sp, #24]
c0d04e5e:	40bb      	lsls	r3, r7
c0d04e60:	40cd      	lsrs	r5, r1
c0d04e62:	431d      	orrs	r5, r3
c0d04e64:	4633      	mov	r3, r6
c0d04e66:	40e3      	lsrs	r3, r4
c0d04e68:	2c00      	cmp	r4, #0
c0d04e6a:	da00      	bge.n	c0d04e6e <shiftr128+0xa4>
c0d04e6c:	462b      	mov	r3, r5
c0d04e6e:	9f03      	ldr	r7, [sp, #12]
c0d04e70:	9e00      	ldr	r6, [sp, #0]
c0d04e72:	40b7      	lsls	r7, r6
c0d04e74:	9d02      	ldr	r5, [sp, #8]
c0d04e76:	1bae      	subs	r6, r5, r6
c0d04e78:	4605      	mov	r5, r0
c0d04e7a:	40f5      	lsrs	r5, r6
c0d04e7c:	433d      	orrs	r5, r7
c0d04e7e:	9e06      	ldr	r6, [sp, #24]
c0d04e80:	40b0      	lsls	r0, r6
c0d04e82:	2e00      	cmp	r6, #0
c0d04e84:	da00      	bge.n	c0d04e88 <shiftr128+0xbe>
c0d04e86:	4628      	mov	r0, r5
c0d04e88:	9d04      	ldr	r5, [sp, #16]
c0d04e8a:	40cd      	lsrs	r5, r1
c0d04e8c:	4629      	mov	r1, r5
c0d04e8e:	2c00      	cmp	r4, #0
c0d04e90:	9c01      	ldr	r4, [sp, #4]
c0d04e92:	da00      	bge.n	c0d04e96 <shiftr128+0xcc>
c0d04e94:	9105      	str	r1, [sp, #20]
c0d04e96:	1919      	adds	r1, r3, r4
c0d04e98:	9b05      	ldr	r3, [sp, #20]
c0d04e9a:	4143      	adcs	r3, r0
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
    LOWER_P(target) = LOWER_P(number);
c0d04e9c:	6091      	str	r1, [r2, #8]
c0d04e9e:	60d3      	str	r3, [r2, #12]
c0d04ea0:	e01d      	b.n	c0d04ede <shiftr128+0x114>
        uint128_t result;
        UPPER(result) = UPPER_P(number) >> value;
        LOWER(result) =
            (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
        copy128(target, &result);
    } else if ((128 > value) && (value > 64)) {
c0d04ea2:	2940      	cmp	r1, #64	; 0x40
c0d04ea4:	d095      	beq.n	c0d04dd2 <shiftr128+0x8>
        LOWER_P(target) = UPPER_P(number) >> (value - 64);
c0d04ea6:	460d      	mov	r5, r1
c0d04ea8:	3d40      	subs	r5, #64	; 0x40
c0d04eaa:	6843      	ldr	r3, [r0, #4]
c0d04eac:	461f      	mov	r7, r3
c0d04eae:	40ef      	lsrs	r7, r5
c0d04eb0:	460e      	mov	r6, r1
c0d04eb2:	3e60      	subs	r6, #96	; 0x60
c0d04eb4:	2400      	movs	r4, #0
c0d04eb6:	2e00      	cmp	r6, #0
c0d04eb8:	9406      	str	r4, [sp, #24]
c0d04eba:	da00      	bge.n	c0d04ebe <shiftr128+0xf4>
c0d04ebc:	463c      	mov	r4, r7
c0d04ebe:	6800      	ldr	r0, [r0, #0]
c0d04ec0:	60d4      	str	r4, [r2, #12]
c0d04ec2:	2460      	movs	r4, #96	; 0x60
c0d04ec4:	1a61      	subs	r1, r4, r1
c0d04ec6:	461c      	mov	r4, r3
c0d04ec8:	408c      	lsls	r4, r1
c0d04eca:	40e8      	lsrs	r0, r5
c0d04ecc:	4320      	orrs	r0, r4
c0d04ece:	40f3      	lsrs	r3, r6
c0d04ed0:	2e00      	cmp	r6, #0
c0d04ed2:	da00      	bge.n	c0d04ed6 <shiftr128+0x10c>
c0d04ed4:	4603      	mov	r3, r0
c0d04ed6:	9806      	ldr	r0, [sp, #24]
        UPPER_P(target) = 0;
c0d04ed8:	6010      	str	r0, [r2, #0]
c0d04eda:	6050      	str	r0, [r2, #4]
        UPPER(result) = UPPER_P(number) >> value;
        LOWER(result) =
            (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
        copy128(target, &result);
    } else if ((128 > value) && (value > 64)) {
        LOWER_P(target) = UPPER_P(number) >> (value - 64);
c0d04edc:	6093      	str	r3, [r2, #8]
        UPPER_P(target) = 0;
    } else {
        clear128(target);
    }
}
c0d04ede:	b007      	add	sp, #28
c0d04ee0:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d04ee2 <shiftr256>:

void shiftr256(uint256_t *number, uint32_t value, uint256_t *target) {
c0d04ee2:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d04ee4:	b093      	sub	sp, #76	; 0x4c
c0d04ee6:	4614      	mov	r4, r2
c0d04ee8:	460e      	mov	r6, r1
c0d04eea:	4605      	mov	r5, r0
    if (value >= 256) {
c0d04eec:	0a30      	lsrs	r0, r6, #8
c0d04eee:	d004      	beq.n	c0d04efa <shiftr256+0x18>
c0d04ef0:	2120      	movs	r1, #32
c0d04ef2:	4620      	mov	r0, r4
c0d04ef4:	f001 ffcc 	bl	c0d06e90 <__aeabi_memclr>
c0d04ef8:	e073      	b.n	c0d04fe2 <shiftr256+0x100>
        clear256(target);
    } else if (value == 128) {
c0d04efa:	2e00      	cmp	r6, #0
c0d04efc:	d00e      	beq.n	c0d04f1c <shiftr256+0x3a>
c0d04efe:	2e80      	cmp	r6, #128	; 0x80
c0d04f00:	d11b      	bne.n	c0d04f3a <shiftr256+0x58>
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d04f02:	cd03      	ldmia	r5!, {r0, r1}
c0d04f04:	6161      	str	r1, [r4, #20]
c0d04f06:	6120      	str	r0, [r4, #16]
    LOWER_P(target) = LOWER_P(number);
c0d04f08:	6828      	ldr	r0, [r5, #0]
c0d04f0a:	6869      	ldr	r1, [r5, #4]
c0d04f0c:	61e1      	str	r1, [r4, #28]
c0d04f0e:	61a0      	str	r0, [r4, #24]
c0d04f10:	2000      	movs	r0, #0
    copy128(&LOWER_P(target), &LOWER_P(number));
}

void clear128(uint128_t *target) {
    UPPER_P(target) = 0;
    LOWER_P(target) = 0;
c0d04f12:	60e0      	str	r0, [r4, #12]
c0d04f14:	60a0      	str	r0, [r4, #8]
c0d04f16:	6060      	str	r0, [r4, #4]
c0d04f18:	6020      	str	r0, [r4, #0]
c0d04f1a:	e062      	b.n	c0d04fe2 <shiftr256+0x100>
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d04f1c:	cd03      	ldmia	r5!, {r0, r1}
c0d04f1e:	c403      	stmia	r4!, {r0, r1}
    LOWER_P(target) = LOWER_P(number);
c0d04f20:	6828      	ldr	r0, [r5, #0]
c0d04f22:	6869      	ldr	r1, [r5, #4]
c0d04f24:	6061      	str	r1, [r4, #4]
c0d04f26:	6020      	str	r0, [r4, #0]
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d04f28:	68a8      	ldr	r0, [r5, #8]
c0d04f2a:	68e9      	ldr	r1, [r5, #12]
c0d04f2c:	60e1      	str	r1, [r4, #12]
c0d04f2e:	60a0      	str	r0, [r4, #8]
    LOWER_P(target) = LOWER_P(number);
c0d04f30:	6928      	ldr	r0, [r5, #16]
c0d04f32:	6969      	ldr	r1, [r5, #20]
c0d04f34:	6161      	str	r1, [r4, #20]
c0d04f36:	6120      	str	r0, [r4, #16]
c0d04f38:	e053      	b.n	c0d04fe2 <shiftr256+0x100>
    } else if (value == 128) {
        copy128(&LOWER_P(target), &UPPER_P(number));
        clear128(&UPPER_P(target));
    } else if (value == 0) {
        copy256(target, number);
    } else if (value < 128) {
c0d04f3a:	2e7f      	cmp	r6, #127	; 0x7f
c0d04f3c:	d843      	bhi.n	c0d04fc6 <shiftr256+0xe4>
c0d04f3e:	aa02      	add	r2, sp, #8
        uint128_t tmp1;
        uint128_t tmp2;
        uint256_t result;
        shiftr128(&UPPER_P(number), value, &UPPER(result));
c0d04f40:	4628      	mov	r0, r5
c0d04f42:	4631      	mov	r1, r6
c0d04f44:	f7ff ff41 	bl	c0d04dca <shiftr128>
        shiftr128(&LOWER_P(number), value, &tmp1);
c0d04f48:	4628      	mov	r0, r5
c0d04f4a:	3010      	adds	r0, #16
c0d04f4c:	aa0e      	add	r2, sp, #56	; 0x38
c0d04f4e:	4631      	mov	r1, r6
c0d04f50:	f7ff ff3b 	bl	c0d04dca <shiftr128>
        shiftl128(&UPPER_P(number), (128 - value), &tmp2);
c0d04f54:	2080      	movs	r0, #128	; 0x80
c0d04f56:	1b81      	subs	r1, r0, r6
c0d04f58:	aa0a      	add	r2, sp, #40	; 0x28
c0d04f5a:	4628      	mov	r0, r5
c0d04f5c:	f7ff fe1e 	bl	c0d04b9c <shiftl128>
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
        ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d04f60:	9910      	ldr	r1, [sp, #64]	; 0x40
c0d04f62:	9b0c      	ldr	r3, [sp, #48]	; 0x30
c0d04f64:	9811      	ldr	r0, [sp, #68]	; 0x44
c0d04f66:	9d0d      	ldr	r5, [sp, #52]	; 0x34
c0d04f68:	1859      	adds	r1, r3, r1
c0d04f6a:	4168      	adcs	r0, r5
c0d04f6c:	2601      	movs	r6, #1
c0d04f6e:	2200      	movs	r2, #0
c0d04f70:	9101      	str	r1, [sp, #4]
c0d04f72:	4299      	cmp	r1, r3
c0d04f74:	4633      	mov	r3, r6
c0d04f76:	d300      	bcc.n	c0d04f7a <shiftr256+0x98>
c0d04f78:	4613      	mov	r3, r2
c0d04f7a:	42a8      	cmp	r0, r5
c0d04f7c:	d300      	bcc.n	c0d04f80 <shiftr256+0x9e>
c0d04f7e:	4616      	mov	r6, r2
c0d04f80:	42a8      	cmp	r0, r5
c0d04f82:	d000      	beq.n	c0d04f86 <shiftr256+0xa4>
c0d04f84:	4633      	mov	r3, r6
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
c0d04f86:	9d0e      	ldr	r5, [sp, #56]	; 0x38
c0d04f88:	9e0a      	ldr	r6, [sp, #40]	; 0x28
c0d04f8a:	990f      	ldr	r1, [sp, #60]	; 0x3c
c0d04f8c:	9f0b      	ldr	r7, [sp, #44]	; 0x2c
c0d04f8e:	1976      	adds	r6, r6, r5
c0d04f90:	414f      	adcs	r7, r1
c0d04f92:	1c75      	adds	r5, r6, #1
c0d04f94:	417a      	adcs	r2, r7
c0d04f96:	2b00      	cmp	r3, #0
c0d04f98:	d100      	bne.n	c0d04f9c <shiftr256+0xba>
c0d04f9a:	463a      	mov	r2, r7
bool gte256(uint256_t *number1, uint256_t *number2) {
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
c0d04f9c:	9207      	str	r2, [sp, #28]
        UPPER_P(number1) + UPPER_P(number2) +
c0d04f9e:	2b00      	cmp	r3, #0
c0d04fa0:	d100      	bne.n	c0d04fa4 <shiftr256+0xc2>
c0d04fa2:	4635      	mov	r5, r6
bool gte256(uint256_t *number1, uint256_t *number2) {
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
c0d04fa4:	9506      	str	r5, [sp, #24]
        UPPER_P(number1) + UPPER_P(number2) +
        ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0d04fa6:	9009      	str	r0, [sp, #36]	; 0x24
c0d04fa8:	9e01      	ldr	r6, [sp, #4]
c0d04faa:	9608      	str	r6, [sp, #32]
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d04fac:	9902      	ldr	r1, [sp, #8]
c0d04fae:	9b03      	ldr	r3, [sp, #12]
c0d04fb0:	c40a      	stmia	r4!, {r1, r3}
    LOWER_P(target) = LOWER_P(number);
c0d04fb2:	9904      	ldr	r1, [sp, #16]
c0d04fb4:	9b05      	ldr	r3, [sp, #20]
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d04fb6:	60e2      	str	r2, [r4, #12]
c0d04fb8:	3c08      	subs	r4, #8
    LOWER_P(target) = LOWER_P(number);
c0d04fba:	4622      	mov	r2, r4
c0d04fbc:	3208      	adds	r2, #8
c0d04fbe:	c22a      	stmia	r2!, {r1, r3, r5}
c0d04fc0:	61e0      	str	r0, [r4, #28]
c0d04fc2:	61a6      	str	r6, [r4, #24]
c0d04fc4:	e00d      	b.n	c0d04fe2 <shiftr256+0x100>
        shiftr128(&UPPER_P(number), value, &UPPER(result));
        shiftr128(&LOWER_P(number), value, &tmp1);
        shiftl128(&UPPER_P(number), (128 - value), &tmp2);
        add128(&tmp1, &tmp2, &LOWER(result));
        copy256(target, &result);
    } else if ((256 > value) && (value > 128)) {
c0d04fc6:	2e80      	cmp	r6, #128	; 0x80
c0d04fc8:	d092      	beq.n	c0d04ef0 <shiftr256+0xe>
        shiftr128(&UPPER_P(number), (value - 128), &LOWER_P(target));
c0d04fca:	3e80      	subs	r6, #128	; 0x80
c0d04fcc:	4622      	mov	r2, r4
c0d04fce:	3210      	adds	r2, #16
c0d04fd0:	4628      	mov	r0, r5
c0d04fd2:	4631      	mov	r1, r6
c0d04fd4:	f7ff fef9 	bl	c0d04dca <shiftr128>
    copy128(&LOWER_P(target), &LOWER_P(number));
}

void clear128(uint128_t *target) {
    UPPER_P(target) = 0;
    LOWER_P(target) = 0;
c0d04fd8:	2000      	movs	r0, #0
c0d04fda:	6020      	str	r0, [r4, #0]
c0d04fdc:	6060      	str	r0, [r4, #4]
c0d04fde:	60a0      	str	r0, [r4, #8]
c0d04fe0:	60e0      	str	r0, [r4, #12]
        shiftr128(&UPPER_P(number), (value - 128), &LOWER_P(target));
        clear128(&UPPER_P(target));
    } else {
        clear256(target);
    }
}
c0d04fe2:	b013      	add	sp, #76	; 0x4c
c0d04fe4:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d04fe6 <bits256>:
        }
    }
    return result;
}

uint32_t bits256(uint256_t *number) {
c0d04fe6:	b570      	push	{r4, r5, r6, lr}
c0d04fe8:	6804      	ldr	r4, [r0, #0]
c0d04fea:	1d03      	adds	r3, r0, #4
c0d04fec:	cb0e      	ldmia	r3, {r1, r2, r3}
    readu128BE(buffer, &UPPER_P(target));
    readu128BE(buffer + 16, &LOWER_P(target));
}

bool zero128(uint128_t *number) {
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d04fee:	461e      	mov	r6, r3
c0d04ff0:	430e      	orrs	r6, r1
c0d04ff2:	4615      	mov	r5, r2
c0d04ff4:	4325      	orrs	r5, r4
c0d04ff6:	4335      	orrs	r5, r6
c0d04ff8:	2d00      	cmp	r5, #0
c0d04ffa:	d017      	beq.n	c0d0502c <bits256+0x46>
c0d04ffc:	2080      	movs	r0, #128	; 0x80
c0d04ffe:	2d00      	cmp	r5, #0
c0d05000:	d034      	beq.n	c0d0506c <bits256+0x86>
c0d05002:	2080      	movs	r0, #128	; 0x80
        copy128(target, number);
    } else if (value < 64) {
        uint128_t result;
        UPPER(result) = UPPER_P(number) >> value;
        LOWER(result) =
            (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d05004:	0855      	lsrs	r5, r2, #1
c0d05006:	07da      	lsls	r2, r3, #31
c0d05008:	432a      	orrs	r2, r5
        LOWER_P(target) = UPPER_P(number);
    } else if (value == 0) {
        copy128(target, number);
    } else if (value < 64) {
        uint128_t result;
        UPPER(result) = UPPER_P(number) >> value;
c0d0500a:	0866      	lsrs	r6, r4, #1
c0d0500c:	07cd      	lsls	r5, r1, #31
c0d0500e:	4335      	orrs	r5, r6
    readu128BE(buffer, &UPPER_P(target));
    readu128BE(buffer + 16, &LOWER_P(target));
}

bool zero128(uint128_t *number) {
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d05010:	462e      	mov	r6, r5
c0d05012:	4316      	orrs	r6, r2
        copy128(target, number);
    } else if (value < 64) {
        uint128_t result;
        UPPER(result) = UPPER_P(number) >> value;
        LOWER(result) =
            (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d05014:	07e4      	lsls	r4, r4, #31
c0d05016:	085b      	lsrs	r3, r3, #1
c0d05018:	4323      	orrs	r3, r4
        LOWER_P(target) = UPPER_P(number);
    } else if (value == 0) {
        copy128(target, number);
    } else if (value < 64) {
        uint128_t result;
        UPPER(result) = UPPER_P(number) >> value;
c0d0501a:	0849      	lsrs	r1, r1, #1
    readu128BE(buffer, &UPPER_P(target));
    readu128BE(buffer + 16, &LOWER_P(target));
}

bool zero128(uint128_t *number) {
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d0501c:	460c      	mov	r4, r1
c0d0501e:	431c      	orrs	r4, r3
c0d05020:	4334      	orrs	r4, r6
        result = 128;
        uint128_t up;
        copy128(&up, &UPPER_P(number));
        while (!zero128(&up)) {
            shiftr128(&up, 1, &up);
            result++;
c0d05022:	1c40      	adds	r0, r0, #1
    readu128BE(buffer, &UPPER_P(target));
    readu128BE(buffer + 16, &LOWER_P(target));
}

bool zero128(uint128_t *number) {
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d05024:	2c00      	cmp	r4, #0
c0d05026:	462c      	mov	r4, r5
c0d05028:	d1ec      	bne.n	c0d05004 <bits256+0x1e>
c0d0502a:	e01f      	b.n	c0d0506c <bits256+0x86>
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d0502c:	6904      	ldr	r4, [r0, #16]
c0d0502e:	4603      	mov	r3, r0
c0d05030:	3314      	adds	r3, #20
c0d05032:	cb0e      	ldmia	r3, {r1, r2, r3}
    readu128BE(buffer, &UPPER_P(target));
    readu128BE(buffer + 16, &LOWER_P(target));
}

bool zero128(uint128_t *number) {
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d05034:	4608      	mov	r0, r1
c0d05036:	4318      	orrs	r0, r3
c0d05038:	4625      	mov	r5, r4
c0d0503a:	4315      	orrs	r5, r2
c0d0503c:	4305      	orrs	r5, r0
c0d0503e:	2000      	movs	r0, #0
c0d05040:	2d00      	cmp	r5, #0
c0d05042:	d013      	beq.n	c0d0506c <bits256+0x86>
c0d05044:	2000      	movs	r0, #0
        copy128(target, number);
    } else if (value < 64) {
        uint128_t result;
        UPPER(result) = UPPER_P(number) >> value;
        LOWER(result) =
            (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d05046:	0855      	lsrs	r5, r2, #1
c0d05048:	07da      	lsls	r2, r3, #31
c0d0504a:	432a      	orrs	r2, r5
        LOWER_P(target) = UPPER_P(number);
    } else if (value == 0) {
        copy128(target, number);
    } else if (value < 64) {
        uint128_t result;
        UPPER(result) = UPPER_P(number) >> value;
c0d0504c:	0866      	lsrs	r6, r4, #1
c0d0504e:	07cd      	lsls	r5, r1, #31
c0d05050:	4335      	orrs	r5, r6
    readu128BE(buffer, &UPPER_P(target));
    readu128BE(buffer + 16, &LOWER_P(target));
}

bool zero128(uint128_t *number) {
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d05052:	462e      	mov	r6, r5
c0d05054:	4316      	orrs	r6, r2
        copy128(target, number);
    } else if (value < 64) {
        uint128_t result;
        UPPER(result) = UPPER_P(number) >> value;
        LOWER(result) =
            (UPPER_P(number) << (64 - value)) + (LOWER_P(number) >> value);
c0d05056:	07e4      	lsls	r4, r4, #31
c0d05058:	085b      	lsrs	r3, r3, #1
c0d0505a:	4323      	orrs	r3, r4
        LOWER_P(target) = UPPER_P(number);
    } else if (value == 0) {
        copy128(target, number);
    } else if (value < 64) {
        uint128_t result;
        UPPER(result) = UPPER_P(number) >> value;
c0d0505c:	0849      	lsrs	r1, r1, #1
    readu128BE(buffer, &UPPER_P(target));
    readu128BE(buffer + 16, &LOWER_P(target));
}

bool zero128(uint128_t *number) {
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d0505e:	460c      	mov	r4, r1
c0d05060:	431c      	orrs	r4, r3
c0d05062:	4334      	orrs	r4, r6
    } else {
        uint128_t low;
        copy128(&low, &LOWER_P(number));
        while (!zero128(&low)) {
            shiftr128(&low, 1, &low);
            result++;
c0d05064:	1c40      	adds	r0, r0, #1
    readu128BE(buffer, &UPPER_P(target));
    readu128BE(buffer + 16, &LOWER_P(target));
}

bool zero128(uint128_t *number) {
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d05066:	2c00      	cmp	r4, #0
c0d05068:	462c      	mov	r4, r5
c0d0506a:	d1ec      	bne.n	c0d05046 <bits256+0x60>
        while (!zero128(&low)) {
            shiftr128(&low, 1, &low);
            result++;
        }
    }
    return result;
c0d0506c:	bd70      	pop	{r4, r5, r6, pc}

c0d0506e <gt256>:
        return (LOWER_P(number1) > LOWER_P(number2));
    }
    return (UPPER_P(number1) > UPPER_P(number2));
}

bool gt256(uint256_t *number1, uint256_t *number2) {
c0d0506e:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05070:	4602      	mov	r2, r0
    }
    return result;
}

bool equal128(uint128_t *number1, uint128_t *number2) {
    return (UPPER_P(number1) == UPPER_P(number2)) &&
c0d05072:	c909      	ldmia	r1!, {r0, r3}
c0d05074:	6815      	ldr	r5, [r2, #0]
c0d05076:	6854      	ldr	r4, [r2, #4]
c0d05078:	4626      	mov	r6, r4
c0d0507a:	405e      	eors	r6, r3
c0d0507c:	462f      	mov	r7, r5
c0d0507e:	4047      	eors	r7, r0
c0d05080:	4337      	orrs	r7, r6
c0d05082:	3908      	subs	r1, #8
c0d05084:	2f00      	cmp	r7, #0
c0d05086:	d11e      	bne.n	c0d050c6 <gt256+0x58>
           (LOWER_P(number1) == LOWER_P(number2));
c0d05088:	6888      	ldr	r0, [r1, #8]
c0d0508a:	68cb      	ldr	r3, [r1, #12]
c0d0508c:	6894      	ldr	r4, [r2, #8]
c0d0508e:	68d5      	ldr	r5, [r2, #12]
    }
    return (UPPER_P(number1) > UPPER_P(number2));
}

bool gt256(uint256_t *number1, uint256_t *number2) {
    if (equal128(&UPPER_P(number1), &UPPER_P(number2))) {
c0d05090:	405d      	eors	r5, r3
c0d05092:	4044      	eors	r4, r0
c0d05094:	432c      	orrs	r4, r5
c0d05096:	2c00      	cmp	r4, #0
c0d05098:	d122      	bne.n	c0d050e0 <gt256+0x72>
    return (equal128(&UPPER_P(number1), &UPPER_P(number2)) &&
            equal128(&LOWER_P(number1), &LOWER_P(number2)));
}

bool gt128(uint128_t *number1, uint128_t *number2) {
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d0509a:	6908      	ldr	r0, [r1, #16]
c0d0509c:	694b      	ldr	r3, [r1, #20]
c0d0509e:	6915      	ldr	r5, [r2, #16]
c0d050a0:	6954      	ldr	r4, [r2, #20]
c0d050a2:	4626      	mov	r6, r4
c0d050a4:	405e      	eors	r6, r3
c0d050a6:	462f      	mov	r7, r5
c0d050a8:	4047      	eors	r7, r0
c0d050aa:	4337      	orrs	r7, r6
c0d050ac:	2f00      	cmp	r7, #0
c0d050ae:	d10a      	bne.n	c0d050c6 <gt256+0x58>
        return (LOWER_P(number1) > LOWER_P(number2));
c0d050b0:	6988      	ldr	r0, [r1, #24]
c0d050b2:	6995      	ldr	r5, [r2, #24]
c0d050b4:	2301      	movs	r3, #1
c0d050b6:	2400      	movs	r4, #0
c0d050b8:	4285      	cmp	r5, r0
c0d050ba:	4618      	mov	r0, r3
c0d050bc:	d800      	bhi.n	c0d050c0 <gt256+0x52>
c0d050be:	4620      	mov	r0, r4
c0d050c0:	69c9      	ldr	r1, [r1, #28]
c0d050c2:	69d2      	ldr	r2, [r2, #28]
c0d050c4:	e016      	b.n	c0d050f4 <gt256+0x86>
c0d050c6:	2101      	movs	r1, #1
c0d050c8:	2200      	movs	r2, #0
c0d050ca:	4285      	cmp	r5, r0
c0d050cc:	4608      	mov	r0, r1
c0d050ce:	d800      	bhi.n	c0d050d2 <gt256+0x64>
c0d050d0:	4610      	mov	r0, r2
c0d050d2:	429c      	cmp	r4, r3
c0d050d4:	d800      	bhi.n	c0d050d8 <gt256+0x6a>
c0d050d6:	4611      	mov	r1, r2
c0d050d8:	429c      	cmp	r4, r3
c0d050da:	d012      	beq.n	c0d05102 <gt256+0x94>
c0d050dc:	4608      	mov	r0, r1
bool gt256(uint256_t *number1, uint256_t *number2) {
    if (equal128(&UPPER_P(number1), &UPPER_P(number2))) {
        return gt128(&LOWER_P(number1), &LOWER_P(number2));
    }
    return gt128(&UPPER_P(number1), &UPPER_P(number2));
}
c0d050de:	bdf0      	pop	{r4, r5, r6, r7, pc}
            equal128(&LOWER_P(number1), &LOWER_P(number2)));
}

bool gt128(uint128_t *number1, uint128_t *number2) {
    if (UPPER_P(number1) == UPPER_P(number2)) {
        return (LOWER_P(number1) > LOWER_P(number2));
c0d050e0:	6888      	ldr	r0, [r1, #8]
c0d050e2:	6895      	ldr	r5, [r2, #8]
c0d050e4:	2301      	movs	r3, #1
c0d050e6:	2400      	movs	r4, #0
c0d050e8:	4285      	cmp	r5, r0
c0d050ea:	4618      	mov	r0, r3
c0d050ec:	d800      	bhi.n	c0d050f0 <gt256+0x82>
c0d050ee:	4620      	mov	r0, r4
c0d050f0:	68c9      	ldr	r1, [r1, #12]
c0d050f2:	68d2      	ldr	r2, [r2, #12]
c0d050f4:	428a      	cmp	r2, r1
c0d050f6:	d800      	bhi.n	c0d050fa <gt256+0x8c>
c0d050f8:	4623      	mov	r3, r4
c0d050fa:	428a      	cmp	r2, r1
c0d050fc:	d001      	beq.n	c0d05102 <gt256+0x94>
c0d050fe:	4618      	mov	r0, r3
bool gt256(uint256_t *number1, uint256_t *number2) {
    if (equal128(&UPPER_P(number1), &UPPER_P(number2))) {
        return gt128(&LOWER_P(number1), &LOWER_P(number2));
    }
    return gt128(&UPPER_P(number1), &UPPER_P(number2));
}
c0d05100:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d05102:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d05104 <gte256>:

bool gte128(uint128_t *number1, uint128_t *number2) {
    return gt128(number1, number2) || equal128(number1, number2);
}

bool gte256(uint256_t *number1, uint256_t *number2) {
c0d05104:	b570      	push	{r4, r5, r6, lr}
c0d05106:	460d      	mov	r5, r1
c0d05108:	4604      	mov	r4, r0
    return gt256(number1, number2) || equal256(number1, number2);
c0d0510a:	f7ff ffb0 	bl	c0d0506e <gt256>
c0d0510e:	4601      	mov	r1, r0
c0d05110:	2001      	movs	r0, #1
c0d05112:	2900      	cmp	r1, #0
c0d05114:	d127      	bne.n	c0d05166 <gte256+0x62>
    }
    return result;
}

bool equal128(uint128_t *number1, uint128_t *number2) {
    return (UPPER_P(number1) == UPPER_P(number2)) &&
c0d05116:	cd03      	ldmia	r5!, {r0, r1}
c0d05118:	cc0c      	ldmia	r4!, {r2, r3}
c0d0511a:	404b      	eors	r3, r1
c0d0511c:	4042      	eors	r2, r0
c0d0511e:	431a      	orrs	r2, r3
c0d05120:	2000      	movs	r0, #0
c0d05122:	3c08      	subs	r4, #8
c0d05124:	3d08      	subs	r5, #8
c0d05126:	2a00      	cmp	r2, #0
c0d05128:	d11d      	bne.n	c0d05166 <gte256+0x62>
           (LOWER_P(number1) == LOWER_P(number2));
c0d0512a:	68a9      	ldr	r1, [r5, #8]
c0d0512c:	68ea      	ldr	r2, [r5, #12]
c0d0512e:	68a3      	ldr	r3, [r4, #8]
c0d05130:	68e6      	ldr	r6, [r4, #12]
}

bool equal256(uint256_t *number1, uint256_t *number2) {
    return (equal128(&UPPER_P(number1), &UPPER_P(number2)) &&
c0d05132:	4056      	eors	r6, r2
c0d05134:	404b      	eors	r3, r1
c0d05136:	4333      	orrs	r3, r6
c0d05138:	2b00      	cmp	r3, #0
c0d0513a:	d114      	bne.n	c0d05166 <gte256+0x62>
    }
    return result;
}

bool equal128(uint128_t *number1, uint128_t *number2) {
    return (UPPER_P(number1) == UPPER_P(number2)) &&
c0d0513c:	6929      	ldr	r1, [r5, #16]
c0d0513e:	696a      	ldr	r2, [r5, #20]
c0d05140:	6923      	ldr	r3, [r4, #16]
c0d05142:	6966      	ldr	r6, [r4, #20]
c0d05144:	4056      	eors	r6, r2
c0d05146:	404b      	eors	r3, r1
c0d05148:	4333      	orrs	r3, r6
c0d0514a:	2b00      	cmp	r3, #0
c0d0514c:	d10b      	bne.n	c0d05166 <gte256+0x62>
           (LOWER_P(number1) == LOWER_P(number2));
c0d0514e:	69a8      	ldr	r0, [r5, #24]
c0d05150:	69e9      	ldr	r1, [r5, #28]
c0d05152:	69a2      	ldr	r2, [r4, #24]
c0d05154:	69e3      	ldr	r3, [r4, #28]
c0d05156:	404b      	eors	r3, r1
c0d05158:	4042      	eors	r2, r0
c0d0515a:	431a      	orrs	r2, r3
c0d0515c:	2001      	movs	r0, #1
c0d0515e:	2100      	movs	r1, #0
c0d05160:	2a00      	cmp	r2, #0
c0d05162:	d000      	beq.n	c0d05166 <gte256+0x62>
c0d05164:	4608      	mov	r0, r1
bool gte128(uint128_t *number1, uint128_t *number2) {
    return gt128(number1, number2) || equal128(number1, number2);
}

bool gte256(uint256_t *number1, uint256_t *number2) {
    return gt256(number1, number2) || equal256(number1, number2);
c0d05166:	bd70      	pop	{r4, r5, r6, pc}

c0d05168 <add256>:
        UPPER_P(number1) + UPPER_P(number2) +
        ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
}

void add256(uint256_t *number1, uint256_t *number2, uint256_t *target) {
c0d05168:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0516a:	b092      	sub	sp, #72	; 0x48
c0d0516c:	9210      	str	r2, [sp, #64]	; 0x40
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
        ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d0516e:	6884      	ldr	r4, [r0, #8]
c0d05170:	68c3      	ldr	r3, [r0, #12]
c0d05172:	688e      	ldr	r6, [r1, #8]
c0d05174:	68cd      	ldr	r5, [r1, #12]
c0d05176:	1932      	adds	r2, r6, r4
c0d05178:	416b      	adcs	r3, r5
c0d0517a:	2401      	movs	r4, #1
c0d0517c:	2700      	movs	r7, #0
c0d0517e:	9711      	str	r7, [sp, #68]	; 0x44
c0d05180:	42b2      	cmp	r2, r6
c0d05182:	940f      	str	r4, [sp, #60]	; 0x3c
c0d05184:	d300      	bcc.n	c0d05188 <add256+0x20>
c0d05186:	9c11      	ldr	r4, [sp, #68]	; 0x44
c0d05188:	42ab      	cmp	r3, r5
c0d0518a:	9e0f      	ldr	r6, [sp, #60]	; 0x3c
c0d0518c:	d300      	bcc.n	c0d05190 <add256+0x28>
c0d0518e:	9e11      	ldr	r6, [sp, #68]	; 0x44
c0d05190:	42ab      	cmp	r3, r5
c0d05192:	d000      	beq.n	c0d05196 <add256+0x2e>
c0d05194:	4634      	mov	r4, r6
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
c0d05196:	c848      	ldmia	r0!, {r3, r6}
c0d05198:	680f      	ldr	r7, [r1, #0]
c0d0519a:	684d      	ldr	r5, [r1, #4]
c0d0519c:	3808      	subs	r0, #8
c0d0519e:	18fb      	adds	r3, r7, r3
c0d051a0:	4175      	adcs	r5, r6
c0d051a2:	1c5a      	adds	r2, r3, #1
c0d051a4:	462f      	mov	r7, r5
c0d051a6:	9e11      	ldr	r6, [sp, #68]	; 0x44
c0d051a8:	4177      	adcs	r7, r6
c0d051aa:	2c00      	cmp	r4, #0
c0d051ac:	d100      	bne.n	c0d051b0 <add256+0x48>
c0d051ae:	462f      	mov	r7, r5
c0d051b0:	9e10      	ldr	r6, [sp, #64]	; 0x40
bool gte256(uint256_t *number1, uint256_t *number2) {
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
c0d051b2:	6077      	str	r7, [r6, #4]
        UPPER_P(number1) + UPPER_P(number2) +
c0d051b4:	2c00      	cmp	r4, #0
c0d051b6:	d100      	bne.n	c0d051ba <add256+0x52>
c0d051b8:	461a      	mov	r2, r3
c0d051ba:	9204      	str	r2, [sp, #16]
bool gte256(uint256_t *number1, uint256_t *number2) {
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
c0d051bc:	6032      	str	r2, [r6, #0]
        UPPER_P(number1) + UPPER_P(number2) +
        ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0d051be:	6882      	ldr	r2, [r0, #8]
c0d051c0:	688b      	ldr	r3, [r1, #8]
c0d051c2:	68c5      	ldr	r5, [r0, #12]
c0d051c4:	68cc      	ldr	r4, [r1, #12]
c0d051c6:	189a      	adds	r2, r3, r2
c0d051c8:	416c      	adcs	r4, r5
c0d051ca:	9206      	str	r2, [sp, #24]
c0d051cc:	60b2      	str	r2, [r6, #8]
c0d051ce:	9407      	str	r4, [sp, #28]
c0d051d0:	60f4      	str	r4, [r6, #12]
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
        ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d051d2:	6985      	ldr	r5, [r0, #24]
c0d051d4:	69c3      	ldr	r3, [r0, #28]
c0d051d6:	698c      	ldr	r4, [r1, #24]
c0d051d8:	69ca      	ldr	r2, [r1, #28]
c0d051da:	950e      	str	r5, [sp, #56]	; 0x38
c0d051dc:	1965      	adds	r5, r4, r5
c0d051de:	4616      	mov	r6, r2
c0d051e0:	930d      	str	r3, [sp, #52]	; 0x34
c0d051e2:	415e      	adcs	r6, r3
c0d051e4:	9500      	str	r5, [sp, #0]
c0d051e6:	42a5      	cmp	r5, r4
c0d051e8:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
c0d051ea:	9d11      	ldr	r5, [sp, #68]	; 0x44
c0d051ec:	d300      	bcc.n	c0d051f0 <add256+0x88>
c0d051ee:	462b      	mov	r3, r5
c0d051f0:	4296      	cmp	r6, r2
c0d051f2:	d300      	bcc.n	c0d051f6 <add256+0x8e>
c0d051f4:	950f      	str	r5, [sp, #60]	; 0x3c
c0d051f6:	9405      	str	r4, [sp, #20]
c0d051f8:	9703      	str	r7, [sp, #12]
c0d051fa:	9209      	str	r2, [sp, #36]	; 0x24
c0d051fc:	9601      	str	r6, [sp, #4]
c0d051fe:	4296      	cmp	r6, r2
c0d05200:	d000      	beq.n	c0d05204 <add256+0x9c>
c0d05202:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
c0d05204:	6904      	ldr	r4, [r0, #16]
c0d05206:	6946      	ldr	r6, [r0, #20]
c0d05208:	690a      	ldr	r2, [r1, #16]
c0d0520a:	694d      	ldr	r5, [r1, #20]
c0d0520c:	920b      	str	r2, [sp, #44]	; 0x2c
c0d0520e:	1917      	adds	r7, r2, r4
c0d05210:	950c      	str	r5, [sp, #48]	; 0x30
c0d05212:	960f      	str	r6, [sp, #60]	; 0x3c
c0d05214:	4175      	adcs	r5, r6
c0d05216:	1c7a      	adds	r2, r7, #1
c0d05218:	9e11      	ldr	r6, [sp, #68]	; 0x44
c0d0521a:	416e      	adcs	r6, r5
c0d0521c:	2b00      	cmp	r3, #0
c0d0521e:	d100      	bne.n	c0d05222 <add256+0xba>
c0d05220:	462e      	mov	r6, r5
    return (equal128(&UPPER_P(number1), &UPPER_P(number2)) &&
            equal128(&LOWER_P(number1), &LOWER_P(number2)));
}

bool gt128(uint128_t *number1, uint128_t *number2) {
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d05222:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
c0d05224:	4075      	eors	r5, r6
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
c0d05226:	2b00      	cmp	r3, #0
c0d05228:	d100      	bne.n	c0d0522c <add256+0xc4>
c0d0522a:	463a      	mov	r2, r7
    return (equal128(&UPPER_P(number1), &UPPER_P(number2)) &&
            equal128(&LOWER_P(number1), &LOWER_P(number2)));
}

bool gt128(uint128_t *number1, uint128_t *number2) {
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d0522c:	4623      	mov	r3, r4
c0d0522e:	4053      	eors	r3, r2
c0d05230:	432b      	orrs	r3, r5
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
        ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d05232:	460f      	mov	r7, r1
c0d05234:	3718      	adds	r7, #24
c0d05236:	4605      	mov	r5, r0
c0d05238:	3518      	adds	r5, #24
c0d0523a:	9511      	str	r5, [sp, #68]	; 0x44
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
c0d0523c:	3110      	adds	r1, #16
c0d0523e:	3010      	adds	r0, #16
        ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0d05240:	9d10      	ldr	r5, [sp, #64]	; 0x40
c0d05242:	3508      	adds	r5, #8
c0d05244:	9502      	str	r5, [sp, #8]
    return (equal128(&UPPER_P(number1), &UPPER_P(number2)) &&
            equal128(&LOWER_P(number1), &LOWER_P(number2)));
}

bool gt128(uint128_t *number1, uint128_t *number2) {
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d05246:	2b00      	cmp	r3, #0
c0d05248:	9708      	str	r7, [sp, #32]
c0d0524a:	940a      	str	r4, [sp, #40]	; 0x28
c0d0524c:	d118      	bne.n	c0d05280 <add256+0x118>

void add256(uint256_t *number1, uint256_t *number2, uint256_t *target) {
    uint128_t tmp;
    add128(&UPPER_P(number1), &UPPER_P(number2), &UPPER_P(target));
    add128(&LOWER_P(number1), &LOWER_P(number2), &tmp);
    if (gt128(&LOWER_P(number1), &tmp)) {
c0d0524e:	2201      	movs	r2, #1
c0d05250:	2400      	movs	r4, #0
c0d05252:	9b0e      	ldr	r3, [sp, #56]	; 0x38
c0d05254:	9d00      	ldr	r5, [sp, #0]
c0d05256:	429d      	cmp	r5, r3
c0d05258:	4613      	mov	r3, r2
c0d0525a:	d200      	bcs.n	c0d0525e <add256+0xf6>
c0d0525c:	4623      	mov	r3, r4
c0d0525e:	9d0d      	ldr	r5, [sp, #52]	; 0x34
c0d05260:	9e01      	ldr	r6, [sp, #4]
c0d05262:	42ae      	cmp	r6, r5
c0d05264:	d200      	bcs.n	c0d05268 <add256+0x100>
c0d05266:	4622      	mov	r2, r4
c0d05268:	9c0d      	ldr	r4, [sp, #52]	; 0x34
c0d0526a:	42a6      	cmp	r6, r4
c0d0526c:	4626      	mov	r6, r4
c0d0526e:	9d05      	ldr	r5, [sp, #20]
c0d05270:	d000      	beq.n	c0d05274 <add256+0x10c>
c0d05272:	4613      	mov	r3, r2
c0d05274:	2b00      	cmp	r3, #0
c0d05276:	9f08      	ldr	r7, [sp, #32]
c0d05278:	9b09      	ldr	r3, [sp, #36]	; 0x24
c0d0527a:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
c0d0527c:	d014      	beq.n	c0d052a8 <add256+0x140>
c0d0527e:	e039      	b.n	c0d052f4 <add256+0x18c>
c0d05280:	2301      	movs	r3, #1
c0d05282:	2500      	movs	r5, #0

bool gt128(uint128_t *number1, uint128_t *number2) {
    if (UPPER_P(number1) == UPPER_P(number2)) {
        return (LOWER_P(number1) > LOWER_P(number2));
    }
    return (UPPER_P(number1) > UPPER_P(number2));
c0d05284:	4294      	cmp	r4, r2
c0d05286:	461a      	mov	r2, r3
c0d05288:	d800      	bhi.n	c0d0528c <add256+0x124>
c0d0528a:	462a      	mov	r2, r5
c0d0528c:	9501      	str	r5, [sp, #4]
c0d0528e:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
c0d05290:	4635      	mov	r5, r6
c0d05292:	42b4      	cmp	r4, r6
c0d05294:	9e0d      	ldr	r6, [sp, #52]	; 0x34
c0d05296:	d800      	bhi.n	c0d0529a <add256+0x132>
c0d05298:	9b01      	ldr	r3, [sp, #4]
c0d0529a:	42ac      	cmp	r4, r5
c0d0529c:	d000      	beq.n	c0d052a0 <add256+0x138>
c0d0529e:	461a      	mov	r2, r3

void add256(uint256_t *number1, uint256_t *number2, uint256_t *target) {
    uint128_t tmp;
    add128(&UPPER_P(number1), &UPPER_P(number2), &UPPER_P(target));
    add128(&LOWER_P(number1), &LOWER_P(number2), &tmp);
    if (gt128(&LOWER_P(number1), &tmp)) {
c0d052a0:	2a00      	cmp	r2, #0
c0d052a2:	9b09      	ldr	r3, [sp, #36]	; 0x24
c0d052a4:	9d05      	ldr	r5, [sp, #20]
c0d052a6:	d025      	beq.n	c0d052f4 <add256+0x18c>
c0d052a8:	2200      	movs	r2, #0
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
c0d052aa:	9b04      	ldr	r3, [sp, #16]
c0d052ac:	1c5f      	adds	r7, r3, #1
c0d052ae:	9e03      	ldr	r6, [sp, #12]
c0d052b0:	4635      	mov	r5, r6
c0d052b2:	4155      	adcs	r5, r2
        ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d052b4:	9c06      	ldr	r4, [sp, #24]
c0d052b6:	9b07      	ldr	r3, [sp, #28]
c0d052b8:	401c      	ands	r4, r3
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
c0d052ba:	3401      	adds	r4, #1
c0d052bc:	d000      	beq.n	c0d052c0 <add256+0x158>
c0d052be:	4635      	mov	r5, r6
c0d052c0:	9b10      	ldr	r3, [sp, #64]	; 0x40
bool gte256(uint256_t *number1, uint256_t *number2) {
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
c0d052c2:	605d      	str	r5, [r3, #4]
        UPPER_P(number1) + UPPER_P(number2) +
c0d052c4:	2c00      	cmp	r4, #0
c0d052c6:	d000      	beq.n	c0d052ca <add256+0x162>
c0d052c8:	9f04      	ldr	r7, [sp, #16]
bool gte256(uint256_t *number1, uint256_t *number2) {
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
c0d052ca:	601f      	str	r7, [r3, #0]
        UPPER_P(number1) + UPPER_P(number2) +
        ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0d052cc:	9b06      	ldr	r3, [sp, #24]
c0d052ce:	1c5b      	adds	r3, r3, #1
c0d052d0:	9c07      	ldr	r4, [sp, #28]
c0d052d2:	4154      	adcs	r4, r2
c0d052d4:	9a02      	ldr	r2, [sp, #8]
c0d052d6:	c218      	stmia	r2!, {r3, r4}
c0d052d8:	9f08      	ldr	r7, [sp, #32]
c0d052da:	683d      	ldr	r5, [r7, #0]
c0d052dc:	687b      	ldr	r3, [r7, #4]
c0d052de:	9a11      	ldr	r2, [sp, #68]	; 0x44
c0d052e0:	6816      	ldr	r6, [r2, #0]
c0d052e2:	960e      	str	r6, [sp, #56]	; 0x38
c0d052e4:	6856      	ldr	r6, [r2, #4]
c0d052e6:	680a      	ldr	r2, [r1, #0]
c0d052e8:	920b      	str	r2, [sp, #44]	; 0x2c
c0d052ea:	6849      	ldr	r1, [r1, #4]
c0d052ec:	910c      	str	r1, [sp, #48]	; 0x30
c0d052ee:	6801      	ldr	r1, [r0, #0]
c0d052f0:	910a      	str	r1, [sp, #40]	; 0x28
c0d052f2:	6844      	ldr	r4, [r0, #4]
c0d052f4:	980e      	ldr	r0, [sp, #56]	; 0x38
c0d052f6:	1829      	adds	r1, r5, r0
c0d052f8:	415e      	adcs	r6, r3
c0d052fa:	2201      	movs	r2, #1
c0d052fc:	2000      	movs	r0, #0
c0d052fe:	42a9      	cmp	r1, r5
c0d05300:	4611      	mov	r1, r2
c0d05302:	d300      	bcc.n	c0d05306 <add256+0x19e>
c0d05304:	4601      	mov	r1, r0
c0d05306:	429e      	cmp	r6, r3
c0d05308:	9d0c      	ldr	r5, [sp, #48]	; 0x30
c0d0530a:	d300      	bcc.n	c0d0530e <add256+0x1a6>
c0d0530c:	4602      	mov	r2, r0
c0d0530e:	429e      	cmp	r6, r3
c0d05310:	d000      	beq.n	c0d05314 <add256+0x1ac>
c0d05312:	4611      	mov	r1, r2
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
c0d05314:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
c0d05316:	9b0a      	ldr	r3, [sp, #40]	; 0x28
c0d05318:	18d2      	adds	r2, r2, r3
c0d0531a:	4165      	adcs	r5, r4
c0d0531c:	1c53      	adds	r3, r2, #1
c0d0531e:	4168      	adcs	r0, r5
c0d05320:	2900      	cmp	r1, #0
c0d05322:	d100      	bne.n	c0d05326 <add256+0x1be>
c0d05324:	4628      	mov	r0, r5
c0d05326:	9c10      	ldr	r4, [sp, #64]	; 0x40
bool gte256(uint256_t *number1, uint256_t *number2) {
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
c0d05328:	6160      	str	r0, [r4, #20]
        UPPER_P(number1) + UPPER_P(number2) +
c0d0532a:	2900      	cmp	r1, #0
c0d0532c:	d100      	bne.n	c0d05330 <add256+0x1c8>
c0d0532e:	4613      	mov	r3, r2
bool gte256(uint256_t *number1, uint256_t *number2) {
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
c0d05330:	6123      	str	r3, [r4, #16]
c0d05332:	9911      	ldr	r1, [sp, #68]	; 0x44
        UPPER_P(number1) + UPPER_P(number2) +
        ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0d05334:	c903      	ldmia	r1, {r0, r1}
c0d05336:	cf0c      	ldmia	r7!, {r2, r3}
c0d05338:	1810      	adds	r0, r2, r0
c0d0533a:	414b      	adcs	r3, r1
c0d0533c:	61a0      	str	r0, [r4, #24]
c0d0533e:	61e3      	str	r3, [r4, #28]
        UPPER(one) = 0;
        LOWER(one) = 1;
        add128(&UPPER_P(target), &one, &UPPER_P(target));
    }
    add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}
c0d05340:	b012      	add	sp, #72	; 0x48
c0d05342:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d05344 <minus256>:
        UPPER_P(number1) - UPPER_P(number2) -
        ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
    LOWER_P(target) = LOWER_P(number1) - LOWER_P(number2);
}

void minus256(uint256_t *number1, uint256_t *number2, uint256_t *target) {
c0d05344:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05346:	b092      	sub	sp, #72	; 0x48
c0d05348:	9211      	str	r2, [sp, #68]	; 0x44
}

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) - UPPER_P(number2) -
        ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d0534a:	688a      	ldr	r2, [r1, #8]
c0d0534c:	68cc      	ldr	r4, [r1, #12]
c0d0534e:	6886      	ldr	r6, [r0, #8]
c0d05350:	68c3      	ldr	r3, [r0, #12]
c0d05352:	1ab7      	subs	r7, r6, r2
c0d05354:	461d      	mov	r5, r3
c0d05356:	41a5      	sbcs	r5, r4
c0d05358:	2201      	movs	r2, #1
c0d0535a:	2400      	movs	r4, #0
c0d0535c:	42b7      	cmp	r7, r6
c0d0535e:	4616      	mov	r6, r2
c0d05360:	d800      	bhi.n	c0d05364 <minus256+0x20>
c0d05362:	4626      	mov	r6, r4
c0d05364:	429d      	cmp	r5, r3
c0d05366:	4617      	mov	r7, r2
c0d05368:	d800      	bhi.n	c0d0536c <minus256+0x28>
c0d0536a:	4627      	mov	r7, r4
c0d0536c:	9210      	str	r2, [sp, #64]	; 0x40
c0d0536e:	429d      	cmp	r5, r3
c0d05370:	d000      	beq.n	c0d05374 <minus256+0x30>
c0d05372:	463e      	mov	r6, r7
    add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) - UPPER_P(number2) -
c0d05374:	c928      	ldmia	r1!, {r3, r5}
c0d05376:	c884      	ldmia	r0!, {r2, r7}
c0d05378:	3808      	subs	r0, #8
c0d0537a:	3908      	subs	r1, #8
c0d0537c:	1ad3      	subs	r3, r2, r3
c0d0537e:	41af      	sbcs	r7, r5
c0d05380:	940f      	str	r4, [sp, #60]	; 0x3c
c0d05382:	43e4      	mvns	r4, r4
c0d05384:	1e5a      	subs	r2, r3, #1
c0d05386:	463d      	mov	r5, r7
c0d05388:	940e      	str	r4, [sp, #56]	; 0x38
c0d0538a:	4165      	adcs	r5, r4
c0d0538c:	2e00      	cmp	r6, #0
c0d0538e:	d100      	bne.n	c0d05392 <minus256+0x4e>
c0d05390:	463d      	mov	r5, r7
c0d05392:	9f11      	ldr	r7, [sp, #68]	; 0x44
c0d05394:	9507      	str	r5, [sp, #28]
    }
    add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
c0d05396:	607d      	str	r5, [r7, #4]
        UPPER_P(number1) - UPPER_P(number2) -
c0d05398:	2e00      	cmp	r6, #0
c0d0539a:	9c10      	ldr	r4, [sp, #64]	; 0x40
c0d0539c:	d100      	bne.n	c0d053a0 <minus256+0x5c>
c0d0539e:	461a      	mov	r2, r3
c0d053a0:	9202      	str	r2, [sp, #8]
    }
    add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
c0d053a2:	603a      	str	r2, [r7, #0]
        UPPER_P(number1) - UPPER_P(number2) -
        ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
    LOWER_P(target) = LOWER_P(number1) - LOWER_P(number2);
c0d053a4:	688a      	ldr	r2, [r1, #8]
c0d053a6:	6883      	ldr	r3, [r0, #8]
c0d053a8:	68cd      	ldr	r5, [r1, #12]
c0d053aa:	68c6      	ldr	r6, [r0, #12]
c0d053ac:	1a9a      	subs	r2, r3, r2
c0d053ae:	41ae      	sbcs	r6, r5
c0d053b0:	9205      	str	r2, [sp, #20]
c0d053b2:	60ba      	str	r2, [r7, #8]
c0d053b4:	9606      	str	r6, [sp, #24]
c0d053b6:	60fe      	str	r6, [r7, #12]
}

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) - UPPER_P(number2) -
        ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d053b8:	698d      	ldr	r5, [r1, #24]
c0d053ba:	69ce      	ldr	r6, [r1, #28]
c0d053bc:	6983      	ldr	r3, [r0, #24]
c0d053be:	69c2      	ldr	r2, [r0, #28]
c0d053c0:	9504      	str	r5, [sp, #16]
c0d053c2:	1b5d      	subs	r5, r3, r5
c0d053c4:	4617      	mov	r7, r2
c0d053c6:	960a      	str	r6, [sp, #40]	; 0x28
c0d053c8:	41b7      	sbcs	r7, r6
c0d053ca:	930d      	str	r3, [sp, #52]	; 0x34
c0d053cc:	9500      	str	r5, [sp, #0]
c0d053ce:	429d      	cmp	r5, r3
c0d053d0:	4623      	mov	r3, r4
c0d053d2:	d800      	bhi.n	c0d053d6 <minus256+0x92>
c0d053d4:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
c0d053d6:	4297      	cmp	r7, r2
c0d053d8:	d800      	bhi.n	c0d053dc <minus256+0x98>
c0d053da:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
c0d053dc:	9210      	str	r2, [sp, #64]	; 0x40
c0d053de:	4297      	cmp	r7, r2
c0d053e0:	d000      	beq.n	c0d053e4 <minus256+0xa0>
c0d053e2:	4623      	mov	r3, r4
    add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) - UPPER_P(number2) -
c0d053e4:	690a      	ldr	r2, [r1, #16]
c0d053e6:	694e      	ldr	r6, [r1, #20]
c0d053e8:	6904      	ldr	r4, [r0, #16]
c0d053ea:	6945      	ldr	r5, [r0, #20]
c0d053ec:	9209      	str	r2, [sp, #36]	; 0x24
c0d053ee:	940f      	str	r4, [sp, #60]	; 0x3c
c0d053f0:	1aa2      	subs	r2, r4, r2
c0d053f2:	462c      	mov	r4, r5
c0d053f4:	9608      	str	r6, [sp, #32]
c0d053f6:	41b5      	sbcs	r5, r6
c0d053f8:	1e56      	subs	r6, r2, #1
c0d053fa:	960c      	str	r6, [sp, #48]	; 0x30
c0d053fc:	9e0e      	ldr	r6, [sp, #56]	; 0x38
c0d053fe:	416e      	adcs	r6, r5
c0d05400:	2b00      	cmp	r3, #0
c0d05402:	d100      	bne.n	c0d05406 <minus256+0xc2>
c0d05404:	462e      	mov	r6, r5
c0d05406:	960e      	str	r6, [sp, #56]	; 0x38
    return (equal128(&UPPER_P(number1), &UPPER_P(number2)) &&
            equal128(&LOWER_P(number1), &LOWER_P(number2)));
}

bool gt128(uint128_t *number1, uint128_t *number2) {
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d05408:	4635      	mov	r5, r6
c0d0540a:	9403      	str	r4, [sp, #12]
c0d0540c:	4065      	eors	r5, r4
    add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) - UPPER_P(number2) -
c0d0540e:	2b00      	cmp	r3, #0
c0d05410:	9e0c      	ldr	r6, [sp, #48]	; 0x30
c0d05412:	d100      	bne.n	c0d05416 <minus256+0xd2>
c0d05414:	4616      	mov	r6, r2
    return (equal128(&UPPER_P(number1), &UPPER_P(number2)) &&
            equal128(&LOWER_P(number1), &LOWER_P(number2)));
}

bool gt128(uint128_t *number1, uint128_t *number2) {
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d05416:	4632      	mov	r2, r6
c0d05418:	9c0f      	ldr	r4, [sp, #60]	; 0x3c
c0d0541a:	4062      	eors	r2, r4
c0d0541c:	432a      	orrs	r2, r5
}

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) - UPPER_P(number2) -
        ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d0541e:	460b      	mov	r3, r1
c0d05420:	3318      	adds	r3, #24
c0d05422:	930b      	str	r3, [sp, #44]	; 0x2c
c0d05424:	4603      	mov	r3, r0
c0d05426:	3318      	adds	r3, #24
c0d05428:	930c      	str	r3, [sp, #48]	; 0x30
    add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) - UPPER_P(number2) -
c0d0542a:	3110      	adds	r1, #16
c0d0542c:	3010      	adds	r0, #16
        ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
    LOWER_P(target) = LOWER_P(number1) - LOWER_P(number2);
c0d0542e:	9b11      	ldr	r3, [sp, #68]	; 0x44
c0d05430:	3308      	adds	r3, #8
c0d05432:	9301      	str	r3, [sp, #4]
    return (equal128(&UPPER_P(number1), &UPPER_P(number2)) &&
            equal128(&LOWER_P(number1), &LOWER_P(number2)));
}

bool gt128(uint128_t *number1, uint128_t *number2) {
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d05434:	2a00      	cmp	r2, #0
c0d05436:	d116      	bne.n	c0d05466 <minus256+0x122>

void minus256(uint256_t *number1, uint256_t *number2, uint256_t *target) {
    uint128_t tmp;
    minus128(&UPPER_P(number1), &UPPER_P(number2), &UPPER_P(target));
    minus128(&LOWER_P(number1), &LOWER_P(number2), &tmp);
    if (gt128(&tmp, &LOWER_P(number1))) {
c0d05438:	2201      	movs	r2, #1
c0d0543a:	2500      	movs	r5, #0
c0d0543c:	9b0d      	ldr	r3, [sp, #52]	; 0x34
c0d0543e:	9c00      	ldr	r4, [sp, #0]
c0d05440:	429c      	cmp	r4, r3
c0d05442:	4613      	mov	r3, r2
c0d05444:	d900      	bls.n	c0d05448 <minus256+0x104>
c0d05446:	462b      	mov	r3, r5
c0d05448:	9e10      	ldr	r6, [sp, #64]	; 0x40
c0d0544a:	42b7      	cmp	r7, r6
c0d0544c:	9c03      	ldr	r4, [sp, #12]
c0d0544e:	d900      	bls.n	c0d05452 <minus256+0x10e>
c0d05450:	462a      	mov	r2, r5
c0d05452:	9d10      	ldr	r5, [sp, #64]	; 0x40
c0d05454:	42af      	cmp	r7, r5
c0d05456:	d000      	beq.n	c0d0545a <minus256+0x116>
c0d05458:	4613      	mov	r3, r2
c0d0545a:	2b00      	cmp	r3, #0
c0d0545c:	9e11      	ldr	r6, [sp, #68]	; 0x44
c0d0545e:	9f07      	ldr	r7, [sp, #28]
c0d05460:	9b04      	ldr	r3, [sp, #16]
c0d05462:	d013      	beq.n	c0d0548c <minus256+0x148>
c0d05464:	e03b      	b.n	c0d054de <minus256+0x19a>
c0d05466:	2201      	movs	r2, #1
c0d05468:	2500      	movs	r5, #0

bool gt128(uint128_t *number1, uint128_t *number2) {
    if (UPPER_P(number1) == UPPER_P(number2)) {
        return (LOWER_P(number1) > LOWER_P(number2));
    }
    return (UPPER_P(number1) > UPPER_P(number2));
c0d0546a:	42a6      	cmp	r6, r4
c0d0546c:	4613      	mov	r3, r2
c0d0546e:	d800      	bhi.n	c0d05472 <minus256+0x12e>
c0d05470:	462b      	mov	r3, r5
c0d05472:	9c03      	ldr	r4, [sp, #12]
c0d05474:	9f0e      	ldr	r7, [sp, #56]	; 0x38
c0d05476:	42a7      	cmp	r7, r4
c0d05478:	9e11      	ldr	r6, [sp, #68]	; 0x44
c0d0547a:	d800      	bhi.n	c0d0547e <minus256+0x13a>
c0d0547c:	462a      	mov	r2, r5
c0d0547e:	42a7      	cmp	r7, r4
c0d05480:	d000      	beq.n	c0d05484 <minus256+0x140>
c0d05482:	4613      	mov	r3, r2

void minus256(uint256_t *number1, uint256_t *number2, uint256_t *target) {
    uint128_t tmp;
    minus128(&UPPER_P(number1), &UPPER_P(number2), &UPPER_P(target));
    minus128(&LOWER_P(number1), &LOWER_P(number2), &tmp);
    if (gt128(&tmp, &LOWER_P(number1))) {
c0d05484:	2b00      	cmp	r3, #0
c0d05486:	9f07      	ldr	r7, [sp, #28]
c0d05488:	9b04      	ldr	r3, [sp, #16]
c0d0548a:	d028      	beq.n	c0d054de <minus256+0x19a>
c0d0548c:	2200      	movs	r2, #0
c0d0548e:	43d2      	mvns	r2, r2
    add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) - UPPER_P(number2) -
c0d05490:	9b02      	ldr	r3, [sp, #8]
c0d05492:	1e5b      	subs	r3, r3, #1
c0d05494:	9311      	str	r3, [sp, #68]	; 0x44
c0d05496:	463d      	mov	r5, r7
c0d05498:	4155      	adcs	r5, r2
        ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d0549a:	9c05      	ldr	r4, [sp, #20]
c0d0549c:	9b06      	ldr	r3, [sp, #24]
c0d0549e:	431c      	orrs	r4, r3
    add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) - UPPER_P(number2) -
c0d054a0:	2c00      	cmp	r4, #0
c0d054a2:	d000      	beq.n	c0d054a6 <minus256+0x162>
c0d054a4:	463d      	mov	r5, r7
    }
    add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
c0d054a6:	6075      	str	r5, [r6, #4]
        UPPER_P(number1) - UPPER_P(number2) -
c0d054a8:	2c00      	cmp	r4, #0
c0d054aa:	9b11      	ldr	r3, [sp, #68]	; 0x44
c0d054ac:	d000      	beq.n	c0d054b0 <minus256+0x16c>
c0d054ae:	9b02      	ldr	r3, [sp, #8]
    }
    add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
c0d054b0:	6033      	str	r3, [r6, #0]
        UPPER_P(number1) - UPPER_P(number2) -
        ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
    LOWER_P(target) = LOWER_P(number1) - LOWER_P(number2);
c0d054b2:	9b05      	ldr	r3, [sp, #20]
c0d054b4:	1e5b      	subs	r3, r3, #1
c0d054b6:	9c06      	ldr	r4, [sp, #24]
c0d054b8:	4154      	adcs	r4, r2
c0d054ba:	9a01      	ldr	r2, [sp, #4]
c0d054bc:	c218      	stmia	r2!, {r3, r4}
c0d054be:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
c0d054c0:	6813      	ldr	r3, [r2, #0]
c0d054c2:	6852      	ldr	r2, [r2, #4]
c0d054c4:	920a      	str	r2, [sp, #40]	; 0x28
c0d054c6:	9c0c      	ldr	r4, [sp, #48]	; 0x30
c0d054c8:	6822      	ldr	r2, [r4, #0]
c0d054ca:	920d      	str	r2, [sp, #52]	; 0x34
c0d054cc:	6862      	ldr	r2, [r4, #4]
c0d054ce:	9210      	str	r2, [sp, #64]	; 0x40
c0d054d0:	680a      	ldr	r2, [r1, #0]
c0d054d2:	9209      	str	r2, [sp, #36]	; 0x24
c0d054d4:	6849      	ldr	r1, [r1, #4]
c0d054d6:	9108      	str	r1, [sp, #32]
c0d054d8:	6801      	ldr	r1, [r0, #0]
c0d054da:	910f      	str	r1, [sp, #60]	; 0x3c
c0d054dc:	6844      	ldr	r4, [r0, #4]
c0d054de:	9f0d      	ldr	r7, [sp, #52]	; 0x34
}

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) - UPPER_P(number2) -
        ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
c0d054e0:	1af8      	subs	r0, r7, r3
c0d054e2:	9d10      	ldr	r5, [sp, #64]	; 0x40
c0d054e4:	462b      	mov	r3, r5
c0d054e6:	990a      	ldr	r1, [sp, #40]	; 0x28
c0d054e8:	418b      	sbcs	r3, r1
c0d054ea:	2201      	movs	r2, #1
c0d054ec:	2100      	movs	r1, #0
c0d054ee:	42b8      	cmp	r0, r7
c0d054f0:	4610      	mov	r0, r2
c0d054f2:	d800      	bhi.n	c0d054f6 <minus256+0x1b2>
c0d054f4:	4608      	mov	r0, r1
c0d054f6:	42ab      	cmp	r3, r5
c0d054f8:	d800      	bhi.n	c0d054fc <minus256+0x1b8>
c0d054fa:	460a      	mov	r2, r1
c0d054fc:	42ab      	cmp	r3, r5
c0d054fe:	9b0f      	ldr	r3, [sp, #60]	; 0x3c
c0d05500:	d000      	beq.n	c0d05504 <minus256+0x1c0>
c0d05502:	4610      	mov	r0, r2
    add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) - UPPER_P(number2) -
c0d05504:	9a09      	ldr	r2, [sp, #36]	; 0x24
c0d05506:	1a9a      	subs	r2, r3, r2
c0d05508:	9b08      	ldr	r3, [sp, #32]
c0d0550a:	419c      	sbcs	r4, r3
c0d0550c:	43cb      	mvns	r3, r1
c0d0550e:	1e51      	subs	r1, r2, #1
c0d05510:	4163      	adcs	r3, r4
c0d05512:	2800      	cmp	r0, #0
c0d05514:	d100      	bne.n	c0d05518 <minus256+0x1d4>
c0d05516:	4623      	mov	r3, r4
    }
    add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
c0d05518:	6173      	str	r3, [r6, #20]
        UPPER_P(number1) - UPPER_P(number2) -
c0d0551a:	2800      	cmp	r0, #0
c0d0551c:	d100      	bne.n	c0d05520 <minus256+0x1dc>
c0d0551e:	4611      	mov	r1, r2
    }
    add128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void minus128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
c0d05520:	6131      	str	r1, [r6, #16]
c0d05522:	990b      	ldr	r1, [sp, #44]	; 0x2c
        UPPER_P(number1) - UPPER_P(number2) -
        ((LOWER_P(number1) - LOWER_P(number2)) > LOWER_P(number1));
    LOWER_P(target) = LOWER_P(number1) - LOWER_P(number2);
c0d05524:	c903      	ldmia	r1, {r0, r1}
c0d05526:	9b0c      	ldr	r3, [sp, #48]	; 0x30
c0d05528:	cb0c      	ldmia	r3, {r2, r3}
c0d0552a:	1a10      	subs	r0, r2, r0
c0d0552c:	418b      	sbcs	r3, r1
c0d0552e:	61b0      	str	r0, [r6, #24]
c0d05530:	61f3      	str	r3, [r6, #28]
        UPPER(one) = 0;
        LOWER(one) = 1;
        minus128(&UPPER_P(target), &one, &UPPER_P(target));
    }
    minus128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}
c0d05532:	b012      	add	sp, #72	; 0x48
c0d05534:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d05536 <mul128>:
void or256(uint256_t *number1, uint256_t *number2, uint256_t *target) {
    or128(&UPPER_P(number1), &UPPER_P(number2), &UPPER_P(target));
    or128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void mul128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
c0d05536:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05538:	b0b9      	sub	sp, #228	; 0xe4
c0d0553a:	9202      	str	r2, [sp, #8]
    uint64_t top[4] = {UPPER_P(number1) >> 32, UPPER_P(number1) & 0xffffffff,
c0d0553c:	c80c      	ldmia	r0!, {r2, r3}
c0d0553e:	2600      	movs	r6, #0
c0d05540:	9631      	str	r6, [sp, #196]	; 0xc4
c0d05542:	9330      	str	r3, [sp, #192]	; 0xc0
c0d05544:	9633      	str	r6, [sp, #204]	; 0xcc
c0d05546:	9232      	str	r2, [sp, #200]	; 0xc8
                       LOWER_P(number1) >> 32, LOWER_P(number1) & 0xffffffff};
c0d05548:	6802      	ldr	r2, [r0, #0]
c0d0554a:	6840      	ldr	r0, [r0, #4]
    or128(&UPPER_P(number1), &UPPER_P(number2), &UPPER_P(target));
    or128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void mul128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    uint64_t top[4] = {UPPER_P(number1) >> 32, UPPER_P(number1) & 0xffffffff,
c0d0554c:	9635      	str	r6, [sp, #212]	; 0xd4
c0d0554e:	9034      	str	r0, [sp, #208]	; 0xd0
c0d05550:	9637      	str	r6, [sp, #220]	; 0xdc
c0d05552:	9236      	str	r2, [sp, #216]	; 0xd8
                       LOWER_P(number1) >> 32, LOWER_P(number1) & 0xffffffff};
    uint64_t bottom[4] = {UPPER_P(number2) >> 32, UPPER_P(number2) & 0xffffffff,
c0d05554:	c905      	ldmia	r1!, {r0, r2}
c0d05556:	9629      	str	r6, [sp, #164]	; 0xa4
c0d05558:	9228      	str	r2, [sp, #160]	; 0xa0
c0d0555a:	962b      	str	r6, [sp, #172]	; 0xac
c0d0555c:	902a      	str	r0, [sp, #168]	; 0xa8
                          LOWER_P(number2) >> 32,
c0d0555e:	680a      	ldr	r2, [r1, #0]
c0d05560:	6848      	ldr	r0, [r1, #4]
}

void mul128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    uint64_t top[4] = {UPPER_P(number1) >> 32, UPPER_P(number1) & 0xffffffff,
                       LOWER_P(number1) >> 32, LOWER_P(number1) & 0xffffffff};
    uint64_t bottom[4] = {UPPER_P(number2) >> 32, UPPER_P(number2) & 0xffffffff,
c0d05562:	962d      	str	r6, [sp, #180]	; 0xb4
c0d05564:	902c      	str	r0, [sp, #176]	; 0xb0
c0d05566:	962f      	str	r6, [sp, #188]	; 0xbc
c0d05568:	9207      	str	r2, [sp, #28]
c0d0556a:	922e      	str	r2, [sp, #184]	; 0xb8

    third32 += products[1][3] & 0xffffffff;
    second32 += (products[1][2] & 0xffffffff) + (products[1][3] >> 32);
    first32 += (products[1][1] & 0xffffffff) + (products[1][2] >> 32);

    second32 += products[2][3] & 0xffffffff;
c0d0556c:	43f2      	mvns	r2, r6
c0d0556e:	ac08      	add	r4, sp, #32
                          LOWER_P(number2) >> 32,
                          LOWER_P(number2) & 0xffffffff};
    uint64_t products[4][4];
    uint128_t tmp, tmp2;

    for (int y = 3; y > -1; y--) {
c0d05570:	3418      	adds	r4, #24
c0d05572:	a830      	add	r0, sp, #192	; 0xc0
    or128(&UPPER_P(number1), &UPPER_P(number2), &UPPER_P(target));
    or128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void mul128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    uint64_t top[4] = {UPPER_P(number1) >> 32, UPPER_P(number1) & 0xffffffff,
c0d05574:	3018      	adds	r0, #24
c0d05576:	9003      	str	r0, [sp, #12]
c0d05578:	2003      	movs	r0, #3
c0d0557a:	9005      	str	r0, [sp, #20]
c0d0557c:	9601      	str	r6, [sp, #4]
c0d0557e:	4630      	mov	r0, r6
c0d05580:	e009      	b.n	c0d05596 <mul128+0x60>
c0d05582:	00ca      	lsls	r2, r1, #3
c0d05584:	ab28      	add	r3, sp, #160	; 0xa0
c0d05586:	589c      	ldr	r4, [r3, r2]
c0d05588:	9407      	str	r4, [sp, #28]
c0d0558a:	9c04      	ldr	r4, [sp, #16]
                          LOWER_P(number2) >> 32,
                          LOWER_P(number2) & 0xffffffff};
    uint64_t products[4][4];
    uint128_t tmp, tmp2;

    for (int y = 3; y > -1; y--) {
c0d0558c:	1824      	adds	r4, r4, r0
c0d0558e:	1898      	adds	r0, r3, r2
c0d05590:	4632      	mov	r2, r6
c0d05592:	6840      	ldr	r0, [r0, #4]
c0d05594:	9105      	str	r1, [sp, #20]
c0d05596:	9006      	str	r0, [sp, #24]
c0d05598:	2704      	movs	r7, #4
c0d0559a:	9404      	str	r4, [sp, #16]
c0d0559c:	9d03      	ldr	r5, [sp, #12]
c0d0559e:	4616      	mov	r6, r2
        for (int x = 3; x > -1; x--) {
            products[3 - x][y] = top[x] * bottom[y];
c0d055a0:	cd0c      	ldmia	r5!, {r2, r3}
c0d055a2:	9807      	ldr	r0, [sp, #28]
c0d055a4:	9906      	ldr	r1, [sp, #24]
c0d055a6:	3d08      	subs	r5, #8
c0d055a8:	f001 fc46 	bl	c0d06e38 <__aeabi_lmul>
c0d055ac:	4632      	mov	r2, r6
c0d055ae:	c403      	stmia	r4!, {r0, r1}
                          LOWER_P(number2) & 0xffffffff};
    uint64_t products[4][4];
    uint128_t tmp, tmp2;

    for (int y = 3; y > -1; y--) {
        for (int x = 3; x > -1; x--) {
c0d055b0:	00d0      	lsls	r0, r2, #3
c0d055b2:	182d      	adds	r5, r5, r0
c0d055b4:	3418      	adds	r4, #24
c0d055b6:	1e7f      	subs	r7, r7, #1
c0d055b8:	2f00      	cmp	r7, #0
c0d055ba:	dcf0      	bgt.n	c0d0559e <mul128+0x68>
c0d055bc:	9b05      	ldr	r3, [sp, #20]
                          LOWER_P(number2) >> 32,
                          LOWER_P(number2) & 0xffffffff};
    uint64_t products[4][4];
    uint128_t tmp, tmp2;

    for (int y = 3; y > -1; y--) {
c0d055be:	1e59      	subs	r1, r3, #1
c0d055c0:	2b01      	cmp	r3, #1
c0d055c2:	dade      	bge.n	c0d05582 <mul128+0x4c>
            products[3 - x][y] = top[x] * bottom[y];
        }
    }

    uint64_t fourth32 = products[0][3] & 0xffffffff;
    uint64_t third32 = (products[0][2] & 0xffffffff) + (products[0][3] >> 32);
c0d055c4:	980c      	ldr	r0, [sp, #48]	; 0x30
c0d055c6:	4010      	ands	r0, r2
        for (int x = 3; x > -1; x--) {
            products[3 - x][y] = top[x] * bottom[y];
        }
    }

    uint64_t fourth32 = products[0][3] & 0xffffffff;
c0d055c8:	990f      	ldr	r1, [sp, #60]	; 0x3c
    uint64_t third32 = (products[0][2] & 0xffffffff) + (products[0][3] >> 32);
c0d055ca:	1840      	adds	r0, r0, r1
c0d055cc:	9d01      	ldr	r5, [sp, #4]
c0d055ce:	4629      	mov	r1, r5
c0d055d0:	4149      	adcs	r1, r1
c0d055d2:	4616      	mov	r6, r2
    uint64_t second32 = (products[0][1] & 0xffffffff) + (products[0][2] >> 32);
    uint64_t first32 = (products[0][0] & 0xffffffff) + (products[0][1] >> 32);

    third32 += products[1][3] & 0xffffffff;
c0d055d4:	9a16      	ldr	r2, [sp, #88]	; 0x58
c0d055d6:	4032      	ands	r2, r6
c0d055d8:	1880      	adds	r0, r0, r2
c0d055da:	4169      	adcs	r1, r5
        }
    }

    uint64_t fourth32 = products[0][3] & 0xffffffff;
    uint64_t third32 = (products[0][2] & 0xffffffff) + (products[0][3] >> 32);
    uint64_t second32 = (products[0][1] & 0xffffffff) + (products[0][2] >> 32);
c0d055dc:	9a0a      	ldr	r2, [sp, #40]	; 0x28
c0d055de:	4032      	ands	r2, r6
            products[3 - x][y] = top[x] * bottom[y];
        }
    }

    uint64_t fourth32 = products[0][3] & 0xffffffff;
    uint64_t third32 = (products[0][2] & 0xffffffff) + (products[0][3] >> 32);
c0d055e0:	9b0d      	ldr	r3, [sp, #52]	; 0x34
    uint64_t second32 = (products[0][1] & 0xffffffff) + (products[0][2] >> 32);
    uint64_t first32 = (products[0][0] & 0xffffffff) + (products[0][1] >> 32);

    third32 += products[1][3] & 0xffffffff;
    second32 += (products[1][2] & 0xffffffff) + (products[1][3] >> 32);
c0d055e2:	18d3      	adds	r3, r2, r3
c0d055e4:	462a      	mov	r2, r5
c0d055e6:	4152      	adcs	r2, r2
    uint64_t fourth32 = products[0][3] & 0xffffffff;
    uint64_t third32 = (products[0][2] & 0xffffffff) + (products[0][3] >> 32);
    uint64_t second32 = (products[0][1] & 0xffffffff) + (products[0][2] >> 32);
    uint64_t first32 = (products[0][0] & 0xffffffff) + (products[0][1] >> 32);

    third32 += products[1][3] & 0xffffffff;
c0d055e8:	9c17      	ldr	r4, [sp, #92]	; 0x5c
        }
    }

    uint64_t fourth32 = products[0][3] & 0xffffffff;
    uint64_t third32 = (products[0][2] & 0xffffffff) + (products[0][3] >> 32);
    uint64_t second32 = (products[0][1] & 0xffffffff) + (products[0][2] >> 32);
c0d055ea:	191b      	adds	r3, r3, r4
c0d055ec:	416a      	adcs	r2, r5
    uint64_t first32 = (products[0][0] & 0xffffffff) + (products[0][1] >> 32);

    third32 += products[1][3] & 0xffffffff;
    second32 += (products[1][2] & 0xffffffff) + (products[1][3] >> 32);
c0d055ee:	9c14      	ldr	r4, [sp, #80]	; 0x50
c0d055f0:	4034      	ands	r4, r6
c0d055f2:	191b      	adds	r3, r3, r4
c0d055f4:	416a      	adcs	r2, r5
    first32 += (products[1][1] & 0xffffffff) + (products[1][2] >> 32);

    second32 += products[2][3] & 0xffffffff;
c0d055f6:	9c1e      	ldr	r4, [sp, #120]	; 0x78
c0d055f8:	4034      	ands	r4, r6
c0d055fa:	191b      	adds	r3, r3, r4
c0d055fc:	416a      	adcs	r2, r5
        }
    }

    uint64_t fourth32 = products[0][3] & 0xffffffff;
    uint64_t third32 = (products[0][2] & 0xffffffff) + (products[0][3] >> 32);
    uint64_t second32 = (products[0][1] & 0xffffffff) + (products[0][2] >> 32);
c0d055fe:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
    uint64_t first32 = (products[0][0] & 0xffffffff) + (products[0][1] >> 32);
c0d05600:	9d08      	ldr	r5, [sp, #32]
    third32 += products[1][3] & 0xffffffff;
    second32 += (products[1][2] & 0xffffffff) + (products[1][3] >> 32);
    first32 += (products[1][1] & 0xffffffff) + (products[1][2] >> 32);

    second32 += products[2][3] & 0xffffffff;
    first32 += (products[2][2] & 0xffffffff) + (products[2][3] >> 32);
c0d05602:	192c      	adds	r4, r5, r4
    uint64_t third32 = (products[0][2] & 0xffffffff) + (products[0][3] >> 32);
    uint64_t second32 = (products[0][1] & 0xffffffff) + (products[0][2] >> 32);
    uint64_t first32 = (products[0][0] & 0xffffffff) + (products[0][1] >> 32);

    third32 += products[1][3] & 0xffffffff;
    second32 += (products[1][2] & 0xffffffff) + (products[1][3] >> 32);
c0d05604:	9d15      	ldr	r5, [sp, #84]	; 0x54
    first32 += (products[1][1] & 0xffffffff) + (products[1][2] >> 32);
c0d05606:	1964      	adds	r4, r4, r5
c0d05608:	9d12      	ldr	r5, [sp, #72]	; 0x48
    }

    uint64_t fourth32 = products[0][3] & 0xffffffff;
    uint64_t third32 = (products[0][2] & 0xffffffff) + (products[0][3] >> 32);
    uint64_t second32 = (products[0][1] & 0xffffffff) + (products[0][2] >> 32);
    uint64_t first32 = (products[0][0] & 0xffffffff) + (products[0][1] >> 32);
c0d0560a:	1964      	adds	r4, r4, r5

    third32 += products[1][3] & 0xffffffff;
    second32 += (products[1][2] & 0xffffffff) + (products[1][3] >> 32);
    first32 += (products[1][1] & 0xffffffff) + (products[1][2] >> 32);

    second32 += products[2][3] & 0xffffffff;
c0d0560c:	9d1f      	ldr	r5, [sp, #124]	; 0x7c
    uint64_t second32 = (products[0][1] & 0xffffffff) + (products[0][2] >> 32);
    uint64_t first32 = (products[0][0] & 0xffffffff) + (products[0][1] >> 32);

    third32 += products[1][3] & 0xffffffff;
    second32 += (products[1][2] & 0xffffffff) + (products[1][3] >> 32);
    first32 += (products[1][1] & 0xffffffff) + (products[1][2] >> 32);
c0d0560e:	1964      	adds	r4, r4, r5

    second32 += products[2][3] & 0xffffffff;
    first32 += (products[2][2] & 0xffffffff) + (products[2][3] >> 32);
c0d05610:	9d1c      	ldr	r5, [sp, #112]	; 0x70
c0d05612:	1964      	adds	r4, r4, r5

    first32 += products[3][3] & 0xffffffff;
c0d05614:	9d26      	ldr	r5, [sp, #152]	; 0x98
c0d05616:	1964      	adds	r4, r4, r5
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
c0d05618:	1859      	adds	r1, r3, r1
c0d0561a:	4154      	adcs	r4, r2
        for (int x = 3; x > -1; x--) {
            products[3 - x][y] = top[x] * bottom[y];
        }
    }

    uint64_t fourth32 = products[0][3] & 0xffffffff;
c0d0561c:	9a0e      	ldr	r2, [sp, #56]	; 0x38
c0d0561e:	4032      	ands	r2, r6
c0d05620:	9b02      	ldr	r3, [sp, #8]
bool gte256(uint256_t *number1, uint256_t *number2) {
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
c0d05622:	c312      	stmia	r3!, {r1, r4}
        UPPER_P(number1) + UPPER_P(number2) +
        ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
    LOWER_P(target) = LOWER_P(number1) + LOWER_P(number2);
c0d05624:	601a      	str	r2, [r3, #0]
c0d05626:	6058      	str	r0, [r3, #4]
    LOWER(tmp) = 0;
    add128(&tmp, target, &tmp2);
    UPPER(tmp) = 0;
    LOWER(tmp) = fourth32;
    add128(&tmp, &tmp2, target);
}
c0d05628:	b039      	add	sp, #228	; 0xe4
c0d0562a:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d0562c <mul256>:

void mul256(uint256_t *number1, uint256_t *number2, uint256_t *target) {
c0d0562c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0562e:	b0ff      	sub	sp, #508	; 0x1fc
c0d05630:	b08e      	sub	sp, #56	; 0x38
c0d05632:	9216      	str	r2, [sp, #88]	; 0x58
    uint128_t top[4];
    uint128_t bottom[4];
    uint128_t products[4][4];
    uint128_t tmp, tmp2, fourth64, third64, second64, first64;
    uint256_t target1, target2;
    UPPER(top[0]) = 0;
c0d05634:	2400      	movs	r4, #0
c0d05636:	947d      	str	r4, [sp, #500]	; 0x1f4
c0d05638:	947c      	str	r4, [sp, #496]	; 0x1f0
    LOWER(top[0]) = UPPER(UPPER_P(number1));
c0d0563a:	c80c      	ldmia	r0!, {r2, r3}
c0d0563c:	937f      	str	r3, [sp, #508]	; 0x1fc
c0d0563e:	927e      	str	r2, [sp, #504]	; 0x1f8
    UPPER(top[1]) = 0;
c0d05640:	9481      	str	r4, [sp, #516]	; 0x204
c0d05642:	9480      	str	r4, [sp, #512]	; 0x200
    LOWER(top[1]) = LOWER(UPPER_P(number1));
c0d05644:	6802      	ldr	r2, [r0, #0]
c0d05646:	6843      	ldr	r3, [r0, #4]
c0d05648:	9383      	str	r3, [sp, #524]	; 0x20c
c0d0564a:	9282      	str	r2, [sp, #520]	; 0x208
    UPPER(top[2]) = 0;
c0d0564c:	9485      	str	r4, [sp, #532]	; 0x214
c0d0564e:	9484      	str	r4, [sp, #528]	; 0x210
    LOWER(top[2]) = UPPER(LOWER_P(number1));
c0d05650:	6882      	ldr	r2, [r0, #8]
c0d05652:	68c3      	ldr	r3, [r0, #12]
c0d05654:	9387      	str	r3, [sp, #540]	; 0x21c
c0d05656:	9286      	str	r2, [sp, #536]	; 0x218
    UPPER(top[3]) = 0;
c0d05658:	9489      	str	r4, [sp, #548]	; 0x224
c0d0565a:	9488      	str	r4, [sp, #544]	; 0x220
    LOWER(top[3]) = LOWER(LOWER_P(number1));
c0d0565c:	6902      	ldr	r2, [r0, #16]
c0d0565e:	6940      	ldr	r0, [r0, #20]
c0d05660:	908b      	str	r0, [sp, #556]	; 0x22c
c0d05662:	928a      	str	r2, [sp, #552]	; 0x228
    UPPER(bottom[0]) = 0;
c0d05664:	946d      	str	r4, [sp, #436]	; 0x1b4
c0d05666:	946c      	str	r4, [sp, #432]	; 0x1b0
    LOWER(bottom[0]) = UPPER(UPPER_P(number2));
c0d05668:	6808      	ldr	r0, [r1, #0]
c0d0566a:	684a      	ldr	r2, [r1, #4]
c0d0566c:	926f      	str	r2, [sp, #444]	; 0x1bc
c0d0566e:	906e      	str	r0, [sp, #440]	; 0x1b8
    UPPER(bottom[1]) = 0;
c0d05670:	9471      	str	r4, [sp, #452]	; 0x1c4
c0d05672:	9470      	str	r4, [sp, #448]	; 0x1c0
    LOWER(bottom[1]) = LOWER(UPPER_P(number2));
c0d05674:	6888      	ldr	r0, [r1, #8]
c0d05676:	68ca      	ldr	r2, [r1, #12]
c0d05678:	9273      	str	r2, [sp, #460]	; 0x1cc
c0d0567a:	9072      	str	r0, [sp, #456]	; 0x1c8
    UPPER(bottom[2]) = 0;
c0d0567c:	9475      	str	r4, [sp, #468]	; 0x1d4
c0d0567e:	9474      	str	r4, [sp, #464]	; 0x1d0
    LOWER(bottom[2]) = UPPER(LOWER_P(number2));
c0d05680:	6908      	ldr	r0, [r1, #16]
c0d05682:	694a      	ldr	r2, [r1, #20]
c0d05684:	9277      	str	r2, [sp, #476]	; 0x1dc
c0d05686:	9076      	str	r0, [sp, #472]	; 0x1d8
    UPPER(bottom[3]) = 0;
c0d05688:	9479      	str	r4, [sp, #484]	; 0x1e4
c0d0568a:	9418      	str	r4, [sp, #96]	; 0x60
c0d0568c:	9478      	str	r4, [sp, #480]	; 0x1e0
    LOWER(bottom[3]) = LOWER(LOWER_P(number2));
c0d0568e:	6988      	ldr	r0, [r1, #24]
c0d05690:	69c9      	ldr	r1, [r1, #28]
c0d05692:	917b      	str	r1, [sp, #492]	; 0x1ec
c0d05694:	907a      	str	r0, [sp, #488]	; 0x1e8
c0d05696:	ae2c      	add	r6, sp, #176	; 0xb0

    for (int y = 3; y > -1; y--) {
c0d05698:	3630      	adds	r6, #48	; 0x30
c0d0569a:	a87c      	add	r0, sp, #496	; 0x1f0
    LOWER(top[0]) = UPPER(UPPER_P(number1));
    UPPER(top[1]) = 0;
    LOWER(top[1]) = LOWER(UPPER_P(number1));
    UPPER(top[2]) = 0;
    LOWER(top[2]) = UPPER(LOWER_P(number1));
    UPPER(top[3]) = 0;
c0d0569c:	3030      	adds	r0, #48	; 0x30
c0d0569e:	9017      	str	r0, [sp, #92]	; 0x5c
c0d056a0:	2003      	movs	r0, #3
c0d056a2:	9019      	str	r0, [sp, #100]	; 0x64
c0d056a4:	0100      	lsls	r0, r0, #4
c0d056a6:	a96c      	add	r1, sp, #432	; 0x1b0
c0d056a8:	1808      	adds	r0, r1, r0
c0d056aa:	901b      	str	r0, [sp, #108]	; 0x6c
c0d056ac:	9818      	ldr	r0, [sp, #96]	; 0x60
c0d056ae:	43c4      	mvns	r4, r0
c0d056b0:	2504      	movs	r5, #4
c0d056b2:	961a      	str	r6, [sp, #104]	; 0x68
c0d056b4:	9f17      	ldr	r7, [sp, #92]	; 0x5c
    UPPER(bottom[3]) = 0;
    LOWER(bottom[3]) = LOWER(LOWER_P(number2));

    for (int y = 3; y > -1; y--) {
        for (int x = 3; x > -1; x--) {
            mul128(&top[x], &bottom[y], &products[3 - x][y]);
c0d056b6:	4638      	mov	r0, r7
c0d056b8:	991b      	ldr	r1, [sp, #108]	; 0x6c
c0d056ba:	4632      	mov	r2, r6
c0d056bc:	f7ff ff3b 	bl	c0d05536 <mul128>
    LOWER(bottom[2]) = UPPER(LOWER_P(number2));
    UPPER(bottom[3]) = 0;
    LOWER(bottom[3]) = LOWER(LOWER_P(number2));

    for (int y = 3; y > -1; y--) {
        for (int x = 3; x > -1; x--) {
c0d056c0:	0120      	lsls	r0, r4, #4
c0d056c2:	183f      	adds	r7, r7, r0
c0d056c4:	3640      	adds	r6, #64	; 0x40
c0d056c6:	1e6d      	subs	r5, r5, #1
c0d056c8:	2d00      	cmp	r5, #0
c0d056ca:	dcf4      	bgt.n	c0d056b6 <mul256+0x8a>
c0d056cc:	9e1a      	ldr	r6, [sp, #104]	; 0x68
    UPPER(bottom[2]) = 0;
    LOWER(bottom[2]) = UPPER(LOWER_P(number2));
    UPPER(bottom[3]) = 0;
    LOWER(bottom[3]) = LOWER(LOWER_P(number2));

    for (int y = 3; y > -1; y--) {
c0d056ce:	1836      	adds	r6, r6, r0
c0d056d0:	9919      	ldr	r1, [sp, #100]	; 0x64
c0d056d2:	1e48      	subs	r0, r1, #1
c0d056d4:	2900      	cmp	r1, #0
c0d056d6:	dce4      	bgt.n	c0d056a2 <mul256+0x76>
            mul128(&top[x], &bottom[y], &products[3 - x][y]);
        }
    }

    UPPER(fourth64) = 0;
    LOWER(fourth64) = LOWER(products[0][3]);
c0d056d8:	983a      	ldr	r0, [sp, #232]	; 0xe8
c0d056da:	9015      	str	r0, [sp, #84]	; 0x54
c0d056dc:	983b      	ldr	r0, [sp, #236]	; 0xec
    UPPER(tmp) = 0;
    LOWER(tmp) = UPPER(products[1][2]);
    add128(&tmp, &tmp2, &first64);

    UPPER(tmp) = 0;
    LOWER(tmp) = LOWER(products[2][3]);
c0d056de:	9014      	str	r0, [sp, #80]	; 0x50
c0d056e0:	985b      	ldr	r0, [sp, #364]	; 0x16c
c0d056e2:	9012      	str	r0, [sp, #72]	; 0x48
c0d056e4:	985a      	ldr	r0, [sp, #360]	; 0x168
    copy128(&third64, &tmp2);
    UPPER(tmp) = 0;
    LOWER(tmp) = LOWER(products[1][2]);
    add128(&tmp, &second64, &tmp2);
    UPPER(tmp) = 0;
    LOWER(tmp) = UPPER(products[1][3]);
c0d056e6:	9011      	str	r0, [sp, #68]	; 0x44
c0d056e8:	9849      	ldr	r0, [sp, #292]	; 0x124
c0d056ea:	9013      	str	r0, [sp, #76]	; 0x4c
c0d056ec:	9848      	ldr	r0, [sp, #288]	; 0x120
    UPPER(tmp) = 0;
    LOWER(tmp) = LOWER(products[1][3]);
    add128(&tmp, &third64, &tmp2);
    copy128(&third64, &tmp2);
    UPPER(tmp) = 0;
    LOWER(tmp) = LOWER(products[1][2]);
c0d056ee:	9010      	str	r0, [sp, #64]	; 0x40
c0d056f0:	9847      	ldr	r0, [sp, #284]	; 0x11c
c0d056f2:	901b      	str	r0, [sp, #108]	; 0x6c
c0d056f4:	9846      	ldr	r0, [sp, #280]	; 0x118
    LOWER(tmp2) = UPPER(products[0][3]);
    add128(&tmp, &tmp2, &third64);
    UPPER(tmp) = 0;
    LOWER(tmp) = LOWER(products[0][1]);
    UPPER(tmp2) = 0;
    LOWER(tmp2) = UPPER(products[0][2]);
c0d056f6:	900d      	str	r0, [sp, #52]	; 0x34
c0d056f8:	9835      	ldr	r0, [sp, #212]	; 0xd4
c0d056fa:	900f      	str	r0, [sp, #60]	; 0x3c
c0d056fc:	9834      	ldr	r0, [sp, #208]	; 0xd0
    LOWER(tmp) = LOWER(products[0][2]);
    UPPER(tmp2) = 0;
    LOWER(tmp2) = UPPER(products[0][3]);
    add128(&tmp, &tmp2, &third64);
    UPPER(tmp) = 0;
    LOWER(tmp) = LOWER(products[0][1]);
c0d056fe:	901a      	str	r0, [sp, #104]	; 0x68
c0d05700:	9833      	ldr	r0, [sp, #204]	; 0xcc
c0d05702:	900e      	str	r0, [sp, #56]	; 0x38
c0d05704:	9832      	ldr	r0, [sp, #200]	; 0xc8
    UPPER(tmp2) = 0;
    LOWER(tmp2) = UPPER(products[0][1]);
    add128(&tmp, &tmp2, &first64);

    UPPER(tmp) = 0;
    LOWER(tmp) = LOWER(products[1][3]);
c0d05706:	900c      	str	r0, [sp, #48]	; 0x30
c0d05708:	984b      	ldr	r0, [sp, #300]	; 0x12c
c0d0570a:	900a      	str	r0, [sp, #40]	; 0x28
c0d0570c:	984a      	ldr	r0, [sp, #296]	; 0x128
    UPPER(fourth64) = 0;
    LOWER(fourth64) = LOWER(products[0][3]);
    UPPER(tmp) = 0;
    LOWER(tmp) = LOWER(products[0][2]);
    UPPER(tmp2) = 0;
    LOWER(tmp2) = UPPER(products[0][3]);
c0d0570e:	9009      	str	r0, [sp, #36]	; 0x24
c0d05710:	9839      	ldr	r0, [sp, #228]	; 0xe4
c0d05712:	9008      	str	r0, [sp, #32]
c0d05714:	9838      	ldr	r0, [sp, #224]	; 0xe0
    }

    UPPER(fourth64) = 0;
    LOWER(fourth64) = LOWER(products[0][3]);
    UPPER(tmp) = 0;
    LOWER(tmp) = LOWER(products[0][2]);
c0d05716:	9017      	str	r0, [sp, #92]	; 0x5c
c0d05718:	9b37      	ldr	r3, [sp, #220]	; 0xdc
c0d0571a:	9836      	ldr	r0, [sp, #216]	; 0xd8
    UPPER(tmp) = 0;
    LOWER(tmp) = UPPER(products[2][3]);
    add128(&tmp, &tmp2, &first64);

    UPPER(tmp) = 0;
    LOWER(tmp) = LOWER(products[3][3]);
c0d0571c:	9019      	str	r0, [sp, #100]	; 0x64
c0d0571e:	986b      	ldr	r0, [sp, #428]	; 0x1ac
c0d05720:	900b      	str	r0, [sp, #44]	; 0x2c
c0d05722:	986a      	ldr	r0, [sp, #424]	; 0x1a8
    copy128(&second64, &tmp2);
    UPPER(tmp) = 0;
    LOWER(tmp) = LOWER(products[2][2]);
    add128(&tmp, &first64, &tmp2);
    UPPER(tmp) = 0;
    LOWER(tmp) = UPPER(products[2][3]);
c0d05724:	9007      	str	r0, [sp, #28]
c0d05726:	9859      	ldr	r0, [sp, #356]	; 0x164
c0d05728:	9006      	str	r0, [sp, #24]
c0d0572a:	9858      	ldr	r0, [sp, #352]	; 0x160
    UPPER(tmp) = 0;
    LOWER(tmp) = LOWER(products[2][3]);
    add128(&tmp, &second64, &tmp2);
    copy128(&second64, &tmp2);
    UPPER(tmp) = 0;
    LOWER(tmp) = LOWER(products[2][2]);
c0d0572c:	9005      	str	r0, [sp, #20]
c0d0572e:	9857      	ldr	r0, [sp, #348]	; 0x15c
c0d05730:	9004      	str	r0, [sp, #16]
c0d05732:	9856      	ldr	r0, [sp, #344]	; 0x158
    add128(&tmp, &tmp2, &second64);
    UPPER(tmp) = 0;
    LOWER(tmp) = LOWER(products[1][1]);
    add128(&tmp, &first64, &tmp2);
    UPPER(tmp) = 0;
    LOWER(tmp) = UPPER(products[1][2]);
c0d05734:	9003      	str	r0, [sp, #12]
c0d05736:	9845      	ldr	r0, [sp, #276]	; 0x114
c0d05738:	9002      	str	r0, [sp, #8]
c0d0573a:	9844      	ldr	r0, [sp, #272]	; 0x110
    add128(&tmp, &second64, &tmp2);
    UPPER(tmp) = 0;
    LOWER(tmp) = UPPER(products[1][3]);
    add128(&tmp, &tmp2, &second64);
    UPPER(tmp) = 0;
    LOWER(tmp) = LOWER(products[1][1]);
c0d0573c:	9001      	str	r0, [sp, #4]
c0d0573e:	9f43      	ldr	r7, [sp, #268]	; 0x10c
c0d05740:	9d42      	ldr	r5, [sp, #264]	; 0x108
    LOWER(tmp2) = UPPER(products[0][2]);
    add128(&tmp, &tmp2, &second64);
    UPPER(tmp) = 0;
    LOWER(tmp) = LOWER(products[0][0]);
    UPPER(tmp2) = 0;
    LOWER(tmp2) = UPPER(products[0][1]);
c0d05742:	9c31      	ldr	r4, [sp, #196]	; 0xc4
c0d05744:	9e30      	ldr	r6, [sp, #192]	; 0xc0
    LOWER(tmp) = LOWER(products[0][1]);
    UPPER(tmp2) = 0;
    LOWER(tmp2) = UPPER(products[0][2]);
    add128(&tmp, &tmp2, &second64);
    UPPER(tmp) = 0;
    LOWER(tmp) = LOWER(products[0][0]);
c0d05746:	982f      	ldr	r0, [sp, #188]	; 0xbc
c0d05748:	9a2e      	ldr	r2, [sp, #184]	; 0xb8
c0d0574a:	9918      	ldr	r1, [sp, #96]	; 0x60
    copy128(&LOWER_P(target), &LOWER_P(number));
}

void clear128(uint128_t *target) {
    UPPER_P(target) = 0;
    LOWER_P(target) = 0;
c0d0574c:	912b      	str	r1, [sp, #172]	; 0xac
c0d0574e:	912a      	str	r1, [sp, #168]	; 0xa8
c0d05750:	9129      	str	r1, [sp, #164]	; 0xa4
c0d05752:	9128      	str	r1, [sp, #160]	; 0xa0
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
        ((LOWER_P(number1) + LOWER_P(number2)) < LOWER_P(number1));
c0d05754:	18b2      	adds	r2, r6, r2
c0d05756:	4160      	adcs	r0, r4
c0d05758:	1952      	adds	r2, r2, r5
c0d0575a:	4178      	adcs	r0, r7
c0d0575c:	9c01      	ldr	r4, [sp, #4]
c0d0575e:	1912      	adds	r2, r2, r4
c0d05760:	9c02      	ldr	r4, [sp, #8]
c0d05762:	4160      	adcs	r0, r4
c0d05764:	9c03      	ldr	r4, [sp, #12]
c0d05766:	1912      	adds	r2, r2, r4
c0d05768:	9c04      	ldr	r4, [sp, #16]
c0d0576a:	4160      	adcs	r0, r4
c0d0576c:	9c05      	ldr	r4, [sp, #20]
c0d0576e:	1912      	adds	r2, r2, r4
c0d05770:	9c06      	ldr	r4, [sp, #24]
c0d05772:	4160      	adcs	r0, r4
c0d05774:	9c07      	ldr	r4, [sp, #28]
c0d05776:	1912      	adds	r2, r2, r4
c0d05778:	9c0b      	ldr	r4, [sp, #44]	; 0x2c
c0d0577a:	4160      	adcs	r0, r4

void shiftl128(uint128_t *number, uint32_t value, uint128_t *target) {
    if (value >= 128) {
        clear128(target);
    } else if (value == 64) {
        UPPER_P(target) = LOWER_P(number);
c0d0577c:	9025      	str	r0, [sp, #148]	; 0x94
c0d0577e:	9224      	str	r2, [sp, #144]	; 0x90
        LOWER_P(target) = 0;
c0d05780:	9127      	str	r1, [sp, #156]	; 0x9c
c0d05782:	9126      	str	r1, [sp, #152]	; 0x98
    copy128(&LOWER_P(target), &LOWER_P(number));
}

void clear128(uint128_t *target) {
    UPPER_P(target) = 0;
    LOWER_P(target) = 0;
c0d05784:	911f      	str	r1, [sp, #124]	; 0x7c
c0d05786:	911e      	str	r1, [sp, #120]	; 0x78
c0d05788:	9908      	ldr	r1, [sp, #32]
c0d0578a:	9a19      	ldr	r2, [sp, #100]	; 0x64
c0d0578c:	9817      	ldr	r0, [sp, #92]	; 0x5c
c0d0578e:	1885      	adds	r5, r0, r2
c0d05790:	414b      	adcs	r3, r1
c0d05792:	9a09      	ldr	r2, [sp, #36]	; 0x24
c0d05794:	1954      	adds	r4, r2, r5
c0d05796:	9f0a      	ldr	r7, [sp, #40]	; 0x28
c0d05798:	4638      	mov	r0, r7
c0d0579a:	9319      	str	r3, [sp, #100]	; 0x64
c0d0579c:	415f      	adcs	r7, r3
c0d0579e:	2601      	movs	r6, #1
c0d057a0:	940b      	str	r4, [sp, #44]	; 0x2c
c0d057a2:	4294      	cmp	r4, r2
c0d057a4:	4634      	mov	r4, r6
c0d057a6:	d300      	bcc.n	c0d057aa <mul256+0x17e>
c0d057a8:	9c18      	ldr	r4, [sp, #96]	; 0x60
c0d057aa:	4603      	mov	r3, r0
c0d057ac:	429f      	cmp	r7, r3
c0d057ae:	4630      	mov	r0, r6
c0d057b0:	d300      	bcc.n	c0d057b4 <mul256+0x188>
c0d057b2:	9818      	ldr	r0, [sp, #96]	; 0x60
c0d057b4:	429f      	cmp	r7, r3
c0d057b6:	d000      	beq.n	c0d057ba <mul256+0x18e>
c0d057b8:	4604      	mov	r4, r0
c0d057ba:	9817      	ldr	r0, [sp, #92]	; 0x5c
c0d057bc:	4285      	cmp	r5, r0
c0d057be:	4632      	mov	r2, r6
c0d057c0:	d300      	bcc.n	c0d057c4 <mul256+0x198>
c0d057c2:	9a18      	ldr	r2, [sp, #96]	; 0x60
c0d057c4:	9819      	ldr	r0, [sp, #100]	; 0x64
c0d057c6:	4288      	cmp	r0, r1
c0d057c8:	4630      	mov	r0, r6
c0d057ca:	9d0f      	ldr	r5, [sp, #60]	; 0x3c
c0d057cc:	d300      	bcc.n	c0d057d0 <mul256+0x1a4>
c0d057ce:	9818      	ldr	r0, [sp, #96]	; 0x60
c0d057d0:	9b19      	ldr	r3, [sp, #100]	; 0x64
c0d057d2:	428b      	cmp	r3, r1
c0d057d4:	d000      	beq.n	c0d057d8 <mul256+0x1ac>
c0d057d6:	4602      	mov	r2, r0
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
c0d057d8:	1c50      	adds	r0, r2, #1
c0d057da:	9918      	ldr	r1, [sp, #96]	; 0x60
c0d057dc:	4149      	adcs	r1, r1
c0d057de:	2c00      	cmp	r4, #0
c0d057e0:	d100      	bne.n	c0d057e4 <mul256+0x1b8>
c0d057e2:	4621      	mov	r1, r4
    copy128(&first64, &tmp2);

    clear256(&target1);
    shiftl128(&first64, 64, &UPPER(target1));
    clear256(&target2);
    UPPER(UPPER(target2)) = UPPER(third64);
c0d057e4:	911d      	str	r1, [sp, #116]	; 0x74
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
c0d057e6:	2c00      	cmp	r4, #0
c0d057e8:	d100      	bne.n	c0d057ec <mul256+0x1c0>
c0d057ea:	4610      	mov	r0, r2
    copy128(&first64, &tmp2);

    clear256(&target1);
    shiftl128(&first64, 64, &UPPER(target1));
    clear256(&target2);
    UPPER(UPPER(target2)) = UPPER(third64);
c0d057ec:	901c      	str	r0, [sp, #112]	; 0x70

void shiftl128(uint128_t *number, uint32_t value, uint128_t *target) {
    if (value >= 128) {
        clear128(target);
    } else if (value == 64) {
        UPPER_P(target) = LOWER_P(number);
c0d057ee:	9721      	str	r7, [sp, #132]	; 0x84
c0d057f0:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d057f2:	9020      	str	r0, [sp, #128]	; 0x80
c0d057f4:	9c18      	ldr	r4, [sp, #96]	; 0x60
        LOWER_P(target) = 0;
c0d057f6:	9423      	str	r4, [sp, #140]	; 0x8c
c0d057f8:	9422      	str	r4, [sp, #136]	; 0x88
c0d057fa:	a824      	add	r0, sp, #144	; 0x90
c0d057fc:	a91c      	add	r1, sp, #112	; 0x70
c0d057fe:	9019      	str	r0, [sp, #100]	; 0x64
c0d05800:	9117      	str	r1, [sp, #92]	; 0x5c
    clear256(&target1);
    shiftl128(&first64, 64, &UPPER(target1));
    clear256(&target2);
    UPPER(UPPER(target2)) = UPPER(third64);
    shiftl128(&third64, 64, &LOWER(target2));
    add256(&target1, &target2, target);
c0d05802:	9a16      	ldr	r2, [sp, #88]	; 0x58
c0d05804:	f7ff fcb0 	bl	c0d05168 <add256>
    copy128(&LOWER_P(target), &LOWER_P(number));
}

void clear128(uint128_t *target) {
    UPPER_P(target) = 0;
    LOWER_P(target) = 0;
c0d05808:	942b      	str	r4, [sp, #172]	; 0xac
c0d0580a:	942a      	str	r4, [sp, #168]	; 0xa8
c0d0580c:	9429      	str	r4, [sp, #164]	; 0xa4
c0d0580e:	9428      	str	r4, [sp, #160]	; 0xa0
c0d05810:	981a      	ldr	r0, [sp, #104]	; 0x68
c0d05812:	990c      	ldr	r1, [sp, #48]	; 0x30
c0d05814:	1842      	adds	r2, r0, r1
c0d05816:	990e      	ldr	r1, [sp, #56]	; 0x38
c0d05818:	4169      	adcs	r1, r5
c0d0581a:	9c0d      	ldr	r4, [sp, #52]	; 0x34
c0d0581c:	18a3      	adds	r3, r4, r2
c0d0581e:	981b      	ldr	r0, [sp, #108]	; 0x6c
c0d05820:	460f      	mov	r7, r1
c0d05822:	4148      	adcs	r0, r1
c0d05824:	930e      	str	r3, [sp, #56]	; 0x38
c0d05826:	42a3      	cmp	r3, r4
c0d05828:	4631      	mov	r1, r6
c0d0582a:	d300      	bcc.n	c0d0582e <mul256+0x202>
c0d0582c:	9918      	ldr	r1, [sp, #96]	; 0x60
c0d0582e:	462b      	mov	r3, r5
c0d05830:	9c1b      	ldr	r4, [sp, #108]	; 0x6c
c0d05832:	42a0      	cmp	r0, r4
c0d05834:	4634      	mov	r4, r6
c0d05836:	d300      	bcc.n	c0d0583a <mul256+0x20e>
c0d05838:	9c18      	ldr	r4, [sp, #96]	; 0x60
c0d0583a:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
c0d0583c:	42a8      	cmp	r0, r5
c0d0583e:	d000      	beq.n	c0d05842 <mul256+0x216>
c0d05840:	4621      	mov	r1, r4
c0d05842:	9c1a      	ldr	r4, [sp, #104]	; 0x68
c0d05844:	42a2      	cmp	r2, r4
c0d05846:	4632      	mov	r2, r6
c0d05848:	d300      	bcc.n	c0d0584c <mul256+0x220>
c0d0584a:	9a18      	ldr	r2, [sp, #96]	; 0x60
c0d0584c:	429f      	cmp	r7, r3
c0d0584e:	4634      	mov	r4, r6
c0d05850:	d300      	bcc.n	c0d05854 <mul256+0x228>
c0d05852:	9c18      	ldr	r4, [sp, #96]	; 0x60
c0d05854:	429f      	cmp	r7, r3
c0d05856:	d000      	beq.n	c0d0585a <mul256+0x22e>
c0d05858:	4622      	mov	r2, r4
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
c0d0585a:	1c54      	adds	r4, r2, #1
c0d0585c:	9d18      	ldr	r5, [sp, #96]	; 0x60
c0d0585e:	416d      	adcs	r5, r5
c0d05860:	2900      	cmp	r1, #0
c0d05862:	9f13      	ldr	r7, [sp, #76]	; 0x4c
c0d05864:	d100      	bne.n	c0d05868 <mul256+0x23c>
c0d05866:	4614      	mov	r4, r2
c0d05868:	2900      	cmp	r1, #0
c0d0586a:	d100      	bne.n	c0d0586e <mul256+0x242>
c0d0586c:	460d      	mov	r5, r1
c0d0586e:	1c61      	adds	r1, r4, #1
c0d05870:	911a      	str	r1, [sp, #104]	; 0x68
c0d05872:	462a      	mov	r2, r5
c0d05874:	9918      	ldr	r1, [sp, #96]	; 0x60
c0d05876:	414a      	adcs	r2, r1
c0d05878:	9910      	ldr	r1, [sp, #64]	; 0x40
c0d0587a:	9b0e      	ldr	r3, [sp, #56]	; 0x38
c0d0587c:	1859      	adds	r1, r3, r1
c0d0587e:	4147      	adcs	r7, r0
c0d05880:	4299      	cmp	r1, r3
c0d05882:	961b      	str	r6, [sp, #108]	; 0x6c
c0d05884:	4633      	mov	r3, r6
c0d05886:	d300      	bcc.n	c0d0588a <mul256+0x25e>
c0d05888:	9b18      	ldr	r3, [sp, #96]	; 0x60
c0d0588a:	463e      	mov	r6, r7
c0d0588c:	4287      	cmp	r7, r0
c0d0588e:	9f1b      	ldr	r7, [sp, #108]	; 0x6c
c0d05890:	d300      	bcc.n	c0d05894 <mul256+0x268>
c0d05892:	9f18      	ldr	r7, [sp, #96]	; 0x60
c0d05894:	4286      	cmp	r6, r0
c0d05896:	d000      	beq.n	c0d0589a <mul256+0x26e>
c0d05898:	463b      	mov	r3, r7
c0d0589a:	2b00      	cmp	r3, #0
c0d0589c:	d100      	bne.n	c0d058a0 <mul256+0x274>
c0d0589e:	941a      	str	r4, [sp, #104]	; 0x68
c0d058a0:	2b00      	cmp	r3, #0
c0d058a2:	d100      	bne.n	c0d058a6 <mul256+0x27a>
c0d058a4:	462a      	mov	r2, r5
c0d058a6:	981a      	ldr	r0, [sp, #104]	; 0x68
c0d058a8:	1c43      	adds	r3, r0, #1
c0d058aa:	4614      	mov	r4, r2
c0d058ac:	9818      	ldr	r0, [sp, #96]	; 0x60
c0d058ae:	4144      	adcs	r4, r0
c0d058b0:	9d11      	ldr	r5, [sp, #68]	; 0x44
c0d058b2:	1868      	adds	r0, r5, r1
c0d058b4:	9912      	ldr	r1, [sp, #72]	; 0x48
c0d058b6:	414e      	adcs	r6, r1
c0d058b8:	42a8      	cmp	r0, r5
c0d058ba:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
c0d058bc:	d300      	bcc.n	c0d058c0 <mul256+0x294>
c0d058be:	9d18      	ldr	r5, [sp, #96]	; 0x60
c0d058c0:	428e      	cmp	r6, r1
c0d058c2:	d301      	bcc.n	c0d058c8 <mul256+0x29c>
c0d058c4:	9f18      	ldr	r7, [sp, #96]	; 0x60
c0d058c6:	971b      	str	r7, [sp, #108]	; 0x6c
c0d058c8:	428e      	cmp	r6, r1
c0d058ca:	d000      	beq.n	c0d058ce <mul256+0x2a2>
c0d058cc:	9d1b      	ldr	r5, [sp, #108]	; 0x6c
c0d058ce:	2d00      	cmp	r5, #0
c0d058d0:	d100      	bne.n	c0d058d4 <mul256+0x2a8>
c0d058d2:	4614      	mov	r4, r2
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d058d4:	9425      	str	r4, [sp, #148]	; 0x94
    return gt256(number1, number2) || equal256(number1, number2);
}

void add128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) =
        UPPER_P(number1) + UPPER_P(number2) +
c0d058d6:	2d00      	cmp	r5, #0
c0d058d8:	d100      	bne.n	c0d058dc <mul256+0x2b0>
c0d058da:	9b1a      	ldr	r3, [sp, #104]	; 0x68
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d058dc:	9324      	str	r3, [sp, #144]	; 0x90
    LOWER_P(target) = LOWER_P(number);
c0d058de:	9627      	str	r6, [sp, #156]	; 0x9c
c0d058e0:	9026      	str	r0, [sp, #152]	; 0x98
c0d058e2:	9d19      	ldr	r5, [sp, #100]	; 0x64
    UPPER(UPPER(target2)) = UPPER(third64);
    shiftl128(&third64, 64, &LOWER(target2));
    add256(&target1, &target2, target);
    clear256(&target1);
    copy128(&UPPER(target1), &second64);
    add256(&target1, target, &target2);
c0d058e4:	4628      	mov	r0, r5
c0d058e6:	9c16      	ldr	r4, [sp, #88]	; 0x58
c0d058e8:	4621      	mov	r1, r4
c0d058ea:	9e17      	ldr	r6, [sp, #92]	; 0x5c
c0d058ec:	4632      	mov	r2, r6
c0d058ee:	f7ff fc3b 	bl	c0d05168 <add256>
c0d058f2:	2118      	movs	r1, #24
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d058f4:	4628      	mov	r0, r5
c0d058f6:	f001 facb 	bl	c0d06e90 <__aeabi_memclr>
    LOWER_P(target) = LOWER_P(number);
c0d058fa:	9814      	ldr	r0, [sp, #80]	; 0x50
c0d058fc:	902b      	str	r0, [sp, #172]	; 0xac
c0d058fe:	9815      	ldr	r0, [sp, #84]	; 0x54
c0d05900:	902a      	str	r0, [sp, #168]	; 0xa8
    clear256(&target1);
    copy128(&UPPER(target1), &second64);
    add256(&target1, target, &target2);
    clear256(&target1);
    copy128(&LOWER(target1), &fourth64);
    add256(&target1, &target2, target);
c0d05902:	4628      	mov	r0, r5
c0d05904:	4631      	mov	r1, r6
c0d05906:	4622      	mov	r2, r4
c0d05908:	f7ff fc2e 	bl	c0d05168 <add256>
}
c0d0590c:	b07f      	add	sp, #508	; 0x1fc
c0d0590e:	b00e      	add	sp, #56	; 0x38
c0d05910:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d05912 <divmod256>:
        copy128(retMod, &resMod);
    }
}

void divmod256(uint256_t *l, uint256_t *r, uint256_t *retDiv,
               uint256_t *retMod) {
c0d05912:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05914:	b0b7      	sub	sp, #220	; 0xdc
c0d05916:	461e      	mov	r6, r3
c0d05918:	9209      	str	r2, [sp, #36]	; 0x24
c0d0591a:	460c      	mov	r4, r1
c0d0591c:	4607      	mov	r7, r0
c0d0591e:	a816      	add	r0, sp, #88	; 0x58
c0d05920:	2118      	movs	r1, #24
    uint256_t copyd, adder, resDiv, resMod;
    uint256_t one;
    clear256(&one);
    UPPER(LOWER(one)) = 0;
c0d05922:	f001 fab5 	bl	c0d06e90 <__aeabi_memclr>
c0d05926:	2000      	movs	r0, #0
c0d05928:	9010      	str	r0, [sp, #64]	; 0x40
    LOWER(LOWER(one)) = 1;
c0d0592a:	901d      	str	r0, [sp, #116]	; 0x74
c0d0592c:	2001      	movs	r0, #1
c0d0592e:	9013      	str	r0, [sp, #76]	; 0x4c
c0d05930:	901c      	str	r0, [sp, #112]	; 0x70
    uint32_t diffBits = bits256(l) - bits256(r);
c0d05932:	4638      	mov	r0, r7
c0d05934:	f7ff fb57 	bl	c0d04fe6 <bits256>
c0d05938:	4605      	mov	r5, r0
c0d0593a:	4620      	mov	r0, r4
c0d0593c:	f7ff fb53 	bl	c0d04fe6 <bits256>
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d05940:	cf06      	ldmia	r7!, {r1, r2}
c0d05942:	920a      	str	r2, [sp, #40]	; 0x28
c0d05944:	921f      	str	r2, [sp, #124]	; 0x7c
c0d05946:	910b      	str	r1, [sp, #44]	; 0x2c
c0d05948:	911e      	str	r1, [sp, #120]	; 0x78
    LOWER_P(target) = LOWER_P(number);
c0d0594a:	6839      	ldr	r1, [r7, #0]
c0d0594c:	687a      	ldr	r2, [r7, #4]
c0d0594e:	9207      	str	r2, [sp, #28]
c0d05950:	9221      	str	r2, [sp, #132]	; 0x84
c0d05952:	9108      	str	r1, [sp, #32]
c0d05954:	9120      	str	r1, [sp, #128]	; 0x80
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d05956:	68b9      	ldr	r1, [r7, #8]
c0d05958:	68fa      	ldr	r2, [r7, #12]
c0d0595a:	9205      	str	r2, [sp, #20]
c0d0595c:	9223      	str	r2, [sp, #140]	; 0x8c
c0d0595e:	9106      	str	r1, [sp, #24]
c0d05960:	9122      	str	r1, [sp, #136]	; 0x88
    LOWER_P(target) = LOWER_P(number);
c0d05962:	6939      	ldr	r1, [r7, #16]
c0d05964:	697a      	ldr	r2, [r7, #20]
c0d05966:	9203      	str	r2, [sp, #12]
c0d05968:	9225      	str	r2, [sp, #148]	; 0x94
c0d0596a:	9104      	str	r1, [sp, #16]
c0d0596c:	9124      	str	r1, [sp, #144]	; 0x90
    uint256_t copyd, adder, resDiv, resMod;
    uint256_t one;
    clear256(&one);
    UPPER(LOWER(one)) = 0;
    LOWER(LOWER(one)) = 1;
    uint32_t diffBits = bits256(l) - bits256(r);
c0d0596e:	1a28      	subs	r0, r5, r0
    clear256(&resDiv);
    copy256(&resMod, l);
    if (gt256(r, l)) {
c0d05970:	9014      	str	r0, [sp, #80]	; 0x50
c0d05972:	9415      	str	r4, [sp, #84]	; 0x54
c0d05974:	4620      	mov	r0, r4
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d05976:	3f08      	subs	r7, #8
    UPPER(LOWER(one)) = 0;
    LOWER(LOWER(one)) = 1;
    uint32_t diffBits = bits256(l) - bits256(r);
    clear256(&resDiv);
    copy256(&resMod, l);
    if (gt256(r, l)) {
c0d05978:	4639      	mov	r1, r7
c0d0597a:	f7ff fb78 	bl	c0d0506e <gt256>
c0d0597e:	ab1e      	add	r3, sp, #120	; 0x78
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
    LOWER_P(target) = LOWER_P(number);
c0d05980:	461d      	mov	r5, r3
c0d05982:	3518      	adds	r5, #24
c0d05984:	4639      	mov	r1, r7
c0d05986:	3118      	adds	r1, #24
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d05988:	461c      	mov	r4, r3
c0d0598a:	3410      	adds	r4, #16
c0d0598c:	463a      	mov	r2, r7
c0d0598e:	3210      	adds	r2, #16
    LOWER_P(target) = LOWER_P(number);
c0d05990:	3308      	adds	r3, #8
c0d05992:	3708      	adds	r7, #8
    UPPER(LOWER(one)) = 0;
    LOWER(LOWER(one)) = 1;
    uint32_t diffBits = bits256(l) - bits256(r);
    clear256(&resDiv);
    copy256(&resMod, l);
    if (gt256(r, l)) {
c0d05994:	2801      	cmp	r0, #1
c0d05996:	d111      	bne.n	c0d059bc <divmod256+0xaa>
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d05998:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d0599a:	6030      	str	r0, [r6, #0]
c0d0599c:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d0599e:	6070      	str	r0, [r6, #4]
    LOWER_P(target) = LOWER_P(number);
c0d059a0:	cf09      	ldmia	r7!, {r0, r3}
c0d059a2:	60f3      	str	r3, [r6, #12]
c0d059a4:	60b0      	str	r0, [r6, #8]
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d059a6:	ca05      	ldmia	r2, {r0, r2}
c0d059a8:	6172      	str	r2, [r6, #20]
c0d059aa:	6130      	str	r0, [r6, #16]
    LOWER_P(target) = LOWER_P(number);
c0d059ac:	c903      	ldmia	r1, {r0, r1}
c0d059ae:	61f1      	str	r1, [r6, #28]
c0d059b0:	61b0      	str	r0, [r6, #24]
    copy128(&LOWER_P(target), &LOWER_P(number));
}

void clear128(uint128_t *target) {
    UPPER_P(target) = 0;
    LOWER_P(target) = 0;
c0d059b2:	2120      	movs	r1, #32
c0d059b4:	9809      	ldr	r0, [sp, #36]	; 0x24
c0d059b6:	f001 fa6b 	bl	c0d06e90 <__aeabi_memclr>
c0d059ba:	e0ff      	b.n	c0d05bbc <divmod256+0x2aa>
c0d059bc:	9411      	str	r4, [sp, #68]	; 0x44
c0d059be:	9512      	str	r5, [sp, #72]	; 0x48
c0d059c0:	9301      	str	r3, [sp, #4]
c0d059c2:	9602      	str	r6, [sp, #8]
c0d059c4:	aa2e      	add	r2, sp, #184	; 0xb8
c0d059c6:	9f15      	ldr	r7, [sp, #84]	; 0x54
    copy256(&resMod, l);
    if (gt256(r, l)) {
        copy256(retMod, l);
        clear256(retDiv);
    } else {
        shiftl256(r, diffBits, &copyd);
c0d059c8:	4638      	mov	r0, r7
c0d059ca:	9d14      	ldr	r5, [sp, #80]	; 0x50
c0d059cc:	4629      	mov	r1, r5
c0d059ce:	f7ff f970 	bl	c0d04cb2 <shiftl256>
c0d059d2:	a816      	add	r0, sp, #88	; 0x58
c0d059d4:	aa26      	add	r2, sp, #152	; 0x98
        shiftl256(&one, diffBits, &adder);
c0d059d6:	4629      	mov	r1, r5
c0d059d8:	f7ff f96b 	bl	c0d04cb2 <shiftl256>
    }
    return result;
}

bool equal128(uint128_t *number1, uint128_t *number2) {
    return (UPPER_P(number1) == UPPER_P(number2)) &&
c0d059dc:	982f      	ldr	r0, [sp, #188]	; 0xbc
c0d059de:	4602      	mov	r2, r0
c0d059e0:	9d0a      	ldr	r5, [sp, #40]	; 0x28
c0d059e2:	406a      	eors	r2, r5
c0d059e4:	992e      	ldr	r1, [sp, #184]	; 0xb8
c0d059e6:	460b      	mov	r3, r1
c0d059e8:	9e0b      	ldr	r6, [sp, #44]	; 0x2c
c0d059ea:	4073      	eors	r3, r6
c0d059ec:	4313      	orrs	r3, r2
c0d059ee:	2b00      	cmp	r3, #0
c0d059f0:	4632      	mov	r2, r6
c0d059f2:	d129      	bne.n	c0d05a48 <divmod256+0x136>
           (LOWER_P(number1) == LOWER_P(number2));
c0d059f4:	9a30      	ldr	r2, [sp, #192]	; 0xc0
    }
    return (UPPER_P(number1) > UPPER_P(number2));
}

bool gt256(uint256_t *number1, uint256_t *number2) {
    if (equal128(&UPPER_P(number1), &UPPER_P(number2))) {
c0d059f6:	4611      	mov	r1, r2
c0d059f8:	9e08      	ldr	r6, [sp, #32]
c0d059fa:	4071      	eors	r1, r6
    return result;
}

bool equal128(uint128_t *number1, uint128_t *number2) {
    return (UPPER_P(number1) == UPPER_P(number2)) &&
           (LOWER_P(number1) == LOWER_P(number2));
c0d059fc:	9831      	ldr	r0, [sp, #196]	; 0xc4
    }
    return (UPPER_P(number1) > UPPER_P(number2));
}

bool gt256(uint256_t *number1, uint256_t *number2) {
    if (equal128(&UPPER_P(number1), &UPPER_P(number2))) {
c0d059fe:	4603      	mov	r3, r0
c0d05a00:	9f07      	ldr	r7, [sp, #28]
c0d05a02:	407b      	eors	r3, r7
c0d05a04:	430b      	orrs	r3, r1
c0d05a06:	2b00      	cmp	r3, #0
c0d05a08:	d12f      	bne.n	c0d05a6a <divmod256+0x158>
    return (equal128(&UPPER_P(number1), &UPPER_P(number2)) &&
            equal128(&LOWER_P(number1), &LOWER_P(number2)));
}

bool gt128(uint128_t *number1, uint128_t *number2) {
    if (UPPER_P(number1) == UPPER_P(number2)) {
c0d05a0a:	9a32      	ldr	r2, [sp, #200]	; 0xc8
c0d05a0c:	4611      	mov	r1, r2
c0d05a0e:	9e06      	ldr	r6, [sp, #24]
c0d05a10:	4071      	eors	r1, r6
c0d05a12:	9833      	ldr	r0, [sp, #204]	; 0xcc
c0d05a14:	4603      	mov	r3, r0
c0d05a16:	9f05      	ldr	r7, [sp, #20]
c0d05a18:	407b      	eors	r3, r7
c0d05a1a:	430b      	orrs	r3, r1
c0d05a1c:	2b00      	cmp	r3, #0
c0d05a1e:	d124      	bne.n	c0d05a6a <divmod256+0x158>
        return (LOWER_P(number1) > LOWER_P(number2));
c0d05a20:	9934      	ldr	r1, [sp, #208]	; 0xd0
c0d05a22:	2001      	movs	r0, #1
c0d05a24:	2200      	movs	r2, #0
c0d05a26:	9b04      	ldr	r3, [sp, #16]
c0d05a28:	4299      	cmp	r1, r3
c0d05a2a:	4601      	mov	r1, r0
c0d05a2c:	d800      	bhi.n	c0d05a30 <divmod256+0x11e>
c0d05a2e:	4611      	mov	r1, r2
c0d05a30:	9b35      	ldr	r3, [sp, #212]	; 0xd4
c0d05a32:	9f03      	ldr	r7, [sp, #12]
c0d05a34:	42bb      	cmp	r3, r7
c0d05a36:	9c02      	ldr	r4, [sp, #8]
c0d05a38:	9e09      	ldr	r6, [sp, #36]	; 0x24
c0d05a3a:	d800      	bhi.n	c0d05a3e <divmod256+0x12c>
c0d05a3c:	4610      	mov	r0, r2
c0d05a3e:	42bb      	cmp	r3, r7
c0d05a40:	d000      	beq.n	c0d05a44 <divmod256+0x132>
c0d05a42:	4601      	mov	r1, r0
        copy256(retMod, l);
        clear256(retDiv);
    } else {
        shiftl256(r, diffBits, &copyd);
        shiftl256(&one, diffBits, &adder);
        if (gt256(&copyd, &resMod)) {
c0d05a44:	2900      	cmp	r1, #0
c0d05a46:	e01f      	b.n	c0d05a88 <divmod256+0x176>
c0d05a48:	4291      	cmp	r1, r2
c0d05a4a:	9a13      	ldr	r2, [sp, #76]	; 0x4c
c0d05a4c:	4611      	mov	r1, r2
c0d05a4e:	9b10      	ldr	r3, [sp, #64]	; 0x40
c0d05a50:	d900      	bls.n	c0d05a54 <divmod256+0x142>
c0d05a52:	4619      	mov	r1, r3
c0d05a54:	42a8      	cmp	r0, r5
c0d05a56:	9e09      	ldr	r6, [sp, #36]	; 0x24
c0d05a58:	d900      	bls.n	c0d05a5c <divmod256+0x14a>
c0d05a5a:	461a      	mov	r2, r3
c0d05a5c:	42a8      	cmp	r0, r5
c0d05a5e:	d000      	beq.n	c0d05a62 <divmod256+0x150>
c0d05a60:	4611      	mov	r1, r2
c0d05a62:	2900      	cmp	r1, #0
c0d05a64:	9c02      	ldr	r4, [sp, #8]
c0d05a66:	d011      	beq.n	c0d05a8c <divmod256+0x17a>
c0d05a68:	e01c      	b.n	c0d05aa4 <divmod256+0x192>
c0d05a6a:	2101      	movs	r1, #1
c0d05a6c:	2300      	movs	r3, #0
c0d05a6e:	42b2      	cmp	r2, r6
c0d05a70:	460a      	mov	r2, r1
c0d05a72:	d800      	bhi.n	c0d05a76 <divmod256+0x164>
c0d05a74:	461a      	mov	r2, r3
c0d05a76:	42b8      	cmp	r0, r7
c0d05a78:	9c02      	ldr	r4, [sp, #8]
c0d05a7a:	9e09      	ldr	r6, [sp, #36]	; 0x24
c0d05a7c:	d800      	bhi.n	c0d05a80 <divmod256+0x16e>
c0d05a7e:	4619      	mov	r1, r3
c0d05a80:	42b8      	cmp	r0, r7
c0d05a82:	d000      	beq.n	c0d05a86 <divmod256+0x174>
c0d05a84:	460a      	mov	r2, r1
c0d05a86:	2a00      	cmp	r2, #0
c0d05a88:	9f15      	ldr	r7, [sp, #84]	; 0x54
c0d05a8a:	d00b      	beq.n	c0d05aa4 <divmod256+0x192>
            shiftr256(&copyd, 1, &copyd);
c0d05a8c:	2501      	movs	r5, #1
c0d05a8e:	a82e      	add	r0, sp, #184	; 0xb8
c0d05a90:	4629      	mov	r1, r5
c0d05a92:	4602      	mov	r2, r0
c0d05a94:	f7ff fa25 	bl	c0d04ee2 <shiftr256>
c0d05a98:	a826      	add	r0, sp, #152	; 0x98
            shiftr256(&adder, 1, &adder);
c0d05a9a:	4629      	mov	r1, r5
c0d05a9c:	9f15      	ldr	r7, [sp, #84]	; 0x54
c0d05a9e:	4602      	mov	r2, r0
c0d05aa0:	f7ff fa1f 	bl	c0d04ee2 <shiftr256>
c0d05aa4:	a81e      	add	r0, sp, #120	; 0x78
        }
        while (gte256(&resMod, r)) {
c0d05aa6:	4639      	mov	r1, r7
c0d05aa8:	f7ff fb2c 	bl	c0d05104 <gte256>
c0d05aac:	2700      	movs	r7, #0
c0d05aae:	2801      	cmp	r0, #1
c0d05ab0:	463d      	mov	r5, r7
c0d05ab2:	463b      	mov	r3, r7
c0d05ab4:	4638      	mov	r0, r7
c0d05ab6:	463a      	mov	r2, r7
c0d05ab8:	4639      	mov	r1, r7
c0d05aba:	9714      	str	r7, [sp, #80]	; 0x50
c0d05abc:	9713      	str	r7, [sp, #76]	; 0x4c
c0d05abe:	d163      	bne.n	c0d05b88 <divmod256+0x276>
c0d05ac0:	ae26      	add	r6, sp, #152	; 0x98
c0d05ac2:	4630      	mov	r0, r6
c0d05ac4:	3018      	adds	r0, #24
c0d05ac6:	900b      	str	r0, [sp, #44]	; 0x2c
c0d05ac8:	4634      	mov	r4, r6
c0d05aca:	3410      	adds	r4, #16
c0d05acc:	3608      	adds	r6, #8
c0d05ace:	2000      	movs	r0, #0
c0d05ad0:	9013      	str	r0, [sp, #76]	; 0x4c
c0d05ad2:	9010      	str	r0, [sp, #64]	; 0x40
c0d05ad4:	900f      	str	r0, [sp, #60]	; 0x3c
c0d05ad6:	900e      	str	r0, [sp, #56]	; 0x38
c0d05ad8:	900d      	str	r0, [sp, #52]	; 0x34
c0d05ada:	4607      	mov	r7, r0
c0d05adc:	9014      	str	r0, [sp, #80]	; 0x50
c0d05ade:	900c      	str	r0, [sp, #48]	; 0x30
c0d05ae0:	a81e      	add	r0, sp, #120	; 0x78
c0d05ae2:	a92e      	add	r1, sp, #184	; 0xb8
            if (gte256(&resMod, &copyd)) {
c0d05ae4:	f7ff fb0e 	bl	c0d05104 <gte256>
c0d05ae8:	2801      	cmp	r0, #1
c0d05aea:	d122      	bne.n	c0d05b32 <divmod256+0x220>
c0d05aec:	a92e      	add	r1, sp, #184	; 0xb8
c0d05aee:	a81e      	add	r0, sp, #120	; 0x78
                minus256(&resMod, &copyd, &resMod);
c0d05af0:	4602      	mov	r2, r0
c0d05af2:	f7ff fc27 	bl	c0d05344 <minus256>
c0d05af6:	990b      	ldr	r1, [sp, #44]	; 0x2c
    minus128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void or128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) = UPPER_P(number1) | UPPER_P(number2);
    LOWER_P(target) = LOWER_P(number1) | LOWER_P(number2);
c0d05af8:	c903      	ldmia	r1, {r0, r1}
c0d05afa:	9a13      	ldr	r2, [sp, #76]	; 0x4c
c0d05afc:	430a      	orrs	r2, r1
c0d05afe:	9213      	str	r2, [sp, #76]	; 0x4c
c0d05b00:	9914      	ldr	r1, [sp, #80]	; 0x50
c0d05b02:	4301      	orrs	r1, r0
    }
    minus128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void or128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) = UPPER_P(number1) | UPPER_P(number2);
c0d05b04:	9114      	str	r1, [sp, #80]	; 0x50
c0d05b06:	cc03      	ldmia	r4!, {r0, r1}
c0d05b08:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
c0d05b0a:	430a      	orrs	r2, r1
c0d05b0c:	920f      	str	r2, [sp, #60]	; 0x3c
c0d05b0e:	9910      	ldr	r1, [sp, #64]	; 0x40
c0d05b10:	4301      	orrs	r1, r0
    LOWER_P(target) = LOWER_P(number1) | LOWER_P(number2);
c0d05b12:	9110      	str	r1, [sp, #64]	; 0x40
c0d05b14:	ce03      	ldmia	r6!, {r0, r1}
c0d05b16:	9a0d      	ldr	r2, [sp, #52]	; 0x34
c0d05b18:	430a      	orrs	r2, r1
c0d05b1a:	920d      	str	r2, [sp, #52]	; 0x34
c0d05b1c:	990e      	ldr	r1, [sp, #56]	; 0x38
c0d05b1e:	4301      	orrs	r1, r0
    }
    minus128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void or128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) = UPPER_P(number1) | UPPER_P(number2);
c0d05b20:	910e      	str	r1, [sp, #56]	; 0x38
c0d05b22:	9827      	ldr	r0, [sp, #156]	; 0x9c
c0d05b24:	990c      	ldr	r1, [sp, #48]	; 0x30
c0d05b26:	4301      	orrs	r1, r0
c0d05b28:	910c      	str	r1, [sp, #48]	; 0x30
c0d05b2a:	9826      	ldr	r0, [sp, #152]	; 0x98
c0d05b2c:	4307      	orrs	r7, r0
    LOWER_P(target) = LOWER_P(number1) | LOWER_P(number2);
c0d05b2e:	3e08      	subs	r6, #8
    }
    minus128(&LOWER_P(number1), &LOWER_P(number2), &LOWER_P(target));
}

void or128(uint128_t *number1, uint128_t *number2, uint128_t *target) {
    UPPER_P(target) = UPPER_P(number1) | UPPER_P(number2);
c0d05b30:	3c08      	subs	r4, #8
c0d05b32:	2501      	movs	r5, #1
c0d05b34:	a82e      	add	r0, sp, #184	; 0xb8
        while (gte256(&resMod, r)) {
            if (gte256(&resMod, &copyd)) {
                minus256(&resMod, &copyd, &resMod);
                or256(&resDiv, &adder, &resDiv);
            }
            shiftr256(&copyd, 1, &copyd);
c0d05b36:	4629      	mov	r1, r5
c0d05b38:	4602      	mov	r2, r0
c0d05b3a:	f7ff f9d2 	bl	c0d04ee2 <shiftr256>
c0d05b3e:	a826      	add	r0, sp, #152	; 0x98
            shiftr256(&adder, 1, &adder);
c0d05b40:	4629      	mov	r1, r5
c0d05b42:	4602      	mov	r2, r0
c0d05b44:	f7ff f9cd 	bl	c0d04ee2 <shiftr256>
c0d05b48:	a81e      	add	r0, sp, #120	; 0x78
        shiftl256(&one, diffBits, &adder);
        if (gt256(&copyd, &resMod)) {
            shiftr256(&copyd, 1, &copyd);
            shiftr256(&adder, 1, &adder);
        }
        while (gte256(&resMod, r)) {
c0d05b4a:	9915      	ldr	r1, [sp, #84]	; 0x54
c0d05b4c:	f7ff fada 	bl	c0d05104 <gte256>
c0d05b50:	2800      	cmp	r0, #0
c0d05b52:	9812      	ldr	r0, [sp, #72]	; 0x48
c0d05b54:	9911      	ldr	r1, [sp, #68]	; 0x44
c0d05b56:	d1c3      	bne.n	c0d05ae0 <divmod256+0x1ce>
c0d05b58:	6802      	ldr	r2, [r0, #0]
c0d05b5a:	9204      	str	r2, [sp, #16]
c0d05b5c:	6840      	ldr	r0, [r0, #4]
c0d05b5e:	9003      	str	r0, [sp, #12]
c0d05b60:	6808      	ldr	r0, [r1, #0]
c0d05b62:	9006      	str	r0, [sp, #24]
c0d05b64:	6848      	ldr	r0, [r1, #4]
c0d05b66:	9005      	str	r0, [sp, #20]
c0d05b68:	9801      	ldr	r0, [sp, #4]
c0d05b6a:	6801      	ldr	r1, [r0, #0]
c0d05b6c:	9108      	str	r1, [sp, #32]
c0d05b6e:	6840      	ldr	r0, [r0, #4]
c0d05b70:	9007      	str	r0, [sp, #28]
c0d05b72:	981f      	ldr	r0, [sp, #124]	; 0x7c
c0d05b74:	900a      	str	r0, [sp, #40]	; 0x28
c0d05b76:	981e      	ldr	r0, [sp, #120]	; 0x78
c0d05b78:	900b      	str	r0, [sp, #44]	; 0x2c
c0d05b7a:	9c02      	ldr	r4, [sp, #8]
c0d05b7c:	9e09      	ldr	r6, [sp, #36]	; 0x24
c0d05b7e:	9a10      	ldr	r2, [sp, #64]	; 0x40
c0d05b80:	990f      	ldr	r1, [sp, #60]	; 0x3c
c0d05b82:	9b0e      	ldr	r3, [sp, #56]	; 0x38
c0d05b84:	980d      	ldr	r0, [sp, #52]	; 0x34
c0d05b86:	9d0c      	ldr	r5, [sp, #48]	; 0x30
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d05b88:	6037      	str	r7, [r6, #0]
c0d05b8a:	6075      	str	r5, [r6, #4]
    LOWER_P(target) = LOWER_P(number);
c0d05b8c:	60b3      	str	r3, [r6, #8]
c0d05b8e:	60f0      	str	r0, [r6, #12]
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d05b90:	6132      	str	r2, [r6, #16]
c0d05b92:	6171      	str	r1, [r6, #20]
    LOWER_P(target) = LOWER_P(number);
c0d05b94:	9814      	ldr	r0, [sp, #80]	; 0x50
c0d05b96:	61b0      	str	r0, [r6, #24]
c0d05b98:	9813      	ldr	r0, [sp, #76]	; 0x4c
c0d05b9a:	61f0      	str	r0, [r6, #28]
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d05b9c:	980b      	ldr	r0, [sp, #44]	; 0x2c
c0d05b9e:	6020      	str	r0, [r4, #0]
c0d05ba0:	980a      	ldr	r0, [sp, #40]	; 0x28
c0d05ba2:	6060      	str	r0, [r4, #4]
    LOWER_P(target) = LOWER_P(number);
c0d05ba4:	9808      	ldr	r0, [sp, #32]
c0d05ba6:	60a0      	str	r0, [r4, #8]
c0d05ba8:	9807      	ldr	r0, [sp, #28]
c0d05baa:	60e0      	str	r0, [r4, #12]
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d05bac:	9806      	ldr	r0, [sp, #24]
c0d05bae:	6120      	str	r0, [r4, #16]
c0d05bb0:	9805      	ldr	r0, [sp, #20]
c0d05bb2:	6160      	str	r0, [r4, #20]
    LOWER_P(target) = LOWER_P(number);
c0d05bb4:	9804      	ldr	r0, [sp, #16]
c0d05bb6:	61a0      	str	r0, [r4, #24]
c0d05bb8:	9803      	ldr	r0, [sp, #12]
c0d05bba:	61e0      	str	r0, [r4, #28]
            shiftr256(&adder, 1, &adder);
        }
        copy256(retDiv, &resDiv);
        copy256(retMod, &resMod);
    }
}
c0d05bbc:	b037      	add	sp, #220	; 0xdc
c0d05bbe:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d05bc0 <tostring256>:
    reverseString(out, offset);
    return true;
}

bool tostring256(uint256_t *number, uint32_t baseParam, char *out,
                 uint32_t outLength) {
c0d05bc0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d05bc2:	b09f      	sub	sp, #124	; 0x7c
c0d05bc4:	461c      	mov	r4, r3
c0d05bc6:	4615      	mov	r5, r2
c0d05bc8:	460e      	mov	r6, r1
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d05bca:	c806      	ldmia	r0!, {r1, r2}
c0d05bcc:	9217      	str	r2, [sp, #92]	; 0x5c
c0d05bce:	9116      	str	r1, [sp, #88]	; 0x58
    LOWER_P(target) = LOWER_P(number);
c0d05bd0:	6801      	ldr	r1, [r0, #0]
c0d05bd2:	6842      	ldr	r2, [r0, #4]
c0d05bd4:	9219      	str	r2, [sp, #100]	; 0x64
c0d05bd6:	9118      	str	r1, [sp, #96]	; 0x60
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d05bd8:	6881      	ldr	r1, [r0, #8]
c0d05bda:	68c2      	ldr	r2, [r0, #12]
c0d05bdc:	921b      	str	r2, [sp, #108]	; 0x6c
c0d05bde:	911a      	str	r1, [sp, #104]	; 0x68
    LOWER_P(target) = LOWER_P(number);
c0d05be0:	6901      	ldr	r1, [r0, #16]
c0d05be2:	6940      	ldr	r0, [r0, #20]
c0d05be4:	901d      	str	r0, [sp, #116]	; 0x74
c0d05be6:	911c      	str	r1, [sp, #112]	; 0x70
c0d05be8:	a80e      	add	r0, sp, #56	; 0x38
    copy128(&LOWER_P(target), &LOWER_P(number));
}

void clear128(uint128_t *target) {
    UPPER_P(target) = 0;
    LOWER_P(target) = 0;
c0d05bea:	2120      	movs	r1, #32
c0d05bec:	f001 f950 	bl	c0d06e90 <__aeabi_memclr>
c0d05bf0:	a806      	add	r0, sp, #24
c0d05bf2:	2118      	movs	r1, #24
    uint256_t rMod;
    uint256_t base;
    copy256(&rDiv, number);
    clear256(&rMod);
    clear256(&base);
    UPPER(LOWER(base)) = 0;
c0d05bf4:	f001 f94c 	bl	c0d06e90 <__aeabi_memclr>
c0d05bf8:	2000      	movs	r0, #0
    LOWER(LOWER(base)) = baseParam;
c0d05bfa:	900d      	str	r0, [sp, #52]	; 0x34
c0d05bfc:	a916      	add	r1, sp, #88	; 0x58
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
    LOWER_P(target) = LOWER_P(number);
c0d05bfe:	460a      	mov	r2, r1
c0d05c00:	3218      	adds	r2, #24
c0d05c02:	9204      	str	r2, [sp, #16]
bool zero256(uint256_t *number) {
    return (zero128(&LOWER_P(number)) && zero128(&UPPER_P(number)));
}

void copy128(uint128_t *target, uint128_t *number) {
    UPPER_P(target) = UPPER_P(number);
c0d05c04:	460a      	mov	r2, r1
c0d05c06:	3210      	adds	r2, #16
c0d05c08:	9203      	str	r2, [sp, #12]
    LOWER_P(target) = LOWER_P(number);
c0d05c0a:	3108      	adds	r1, #8
c0d05c0c:	9105      	str	r1, [sp, #20]
    uint256_t base;
    copy256(&rDiv, number);
    clear256(&rMod);
    clear256(&base);
    UPPER(LOWER(base)) = 0;
    LOWER(LOWER(base)) = baseParam;
c0d05c0e:	960c      	str	r6, [sp, #48]	; 0x30
    uint32_t offset = 0;
    if ((baseParam < 2) || (baseParam > 16)) {
c0d05c10:	1eb1      	subs	r1, r6, #2
c0d05c12:	290e      	cmp	r1, #14
c0d05c14:	d852      	bhi.n	c0d05cbc <tostring256+0xfc>
c0d05c16:	a80e      	add	r0, sp, #56	; 0x38
c0d05c18:	3018      	adds	r0, #24
c0d05c1a:	9001      	str	r0, [sp, #4]
c0d05c1c:	1e60      	subs	r0, r4, #1
c0d05c1e:	9002      	str	r0, [sp, #8]
c0d05c20:	2000      	movs	r0, #0
c0d05c22:	9000      	str	r0, [sp, #0]
c0d05c24:	4604      	mov	r4, r0
        return false;
    }
    do {
        if (offset > (outLength - 1)) {
c0d05c26:	9802      	ldr	r0, [sp, #8]
c0d05c28:	4284      	cmp	r4, r0
c0d05c2a:	d846      	bhi.n	c0d05cba <tostring256+0xfa>
c0d05c2c:	a906      	add	r1, sp, #24
c0d05c2e:	a816      	add	r0, sp, #88	; 0x58
c0d05c30:	ab0e      	add	r3, sp, #56	; 0x38
            return false;
        }
        divmod256(&rDiv, &base, &rDiv, &rMod);
c0d05c32:	4602      	mov	r2, r0
c0d05c34:	f7ff fe6d 	bl	c0d05912 <divmod256>
        out[offset++] = HEXDIGITS[(uint8_t)LOWER(LOWER(rMod))];
c0d05c38:	9801      	ldr	r0, [sp, #4]
c0d05c3a:	7800      	ldrb	r0, [r0, #0]
c0d05c3c:	4920      	ldr	r1, [pc, #128]	; (c0d05cc0 <tostring256+0x100>)
c0d05c3e:	4479      	add	r1, pc
c0d05c40:	5c09      	ldrb	r1, [r1, r0]
c0d05c42:	5529      	strb	r1, [r5, r4]
c0d05c44:	9804      	ldr	r0, [sp, #16]
    readu128BE(buffer, &UPPER_P(target));
    readu128BE(buffer + 16, &LOWER_P(target));
}

bool zero128(uint128_t *number) {
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d05c46:	c80c      	ldmia	r0!, {r2, r3}
c0d05c48:	9f03      	ldr	r7, [sp, #12]
c0d05c4a:	6838      	ldr	r0, [r7, #0]
c0d05c4c:	462e      	mov	r6, r5
c0d05c4e:	687d      	ldr	r5, [r7, #4]
c0d05c50:	431d      	orrs	r5, r3
c0d05c52:	9f05      	ldr	r7, [sp, #20]
c0d05c54:	cf88      	ldmia	r7, {r3, r7}
c0d05c56:	432f      	orrs	r7, r5
c0d05c58:	9d17      	ldr	r5, [sp, #92]	; 0x5c
c0d05c5a:	433d      	orrs	r5, r7
c0d05c5c:	4310      	orrs	r0, r2
c0d05c5e:	4318      	orrs	r0, r3
c0d05c60:	9a16      	ldr	r2, [sp, #88]	; 0x58
c0d05c62:	4302      	orrs	r2, r0
c0d05c64:	432a      	orrs	r2, r5
c0d05c66:	4635      	mov	r5, r6
    do {
        if (offset > (outLength - 1)) {
            return false;
        }
        divmod256(&rDiv, &base, &rDiv, &rMod);
        out[offset++] = HEXDIGITS[(uint8_t)LOWER(LOWER(rMod))];
c0d05c68:	1c60      	adds	r0, r4, #1
    readu128BE(buffer, &UPPER_P(target));
    readu128BE(buffer + 16, &LOWER_P(target));
}

bool zero128(uint128_t *number) {
    return ((LOWER_P(number) == 0) && (UPPER_P(number) == 0));
c0d05c6a:	2a00      	cmp	r2, #0
c0d05c6c:	d1da      	bne.n	c0d05c24 <tostring256+0x64>
c0d05c6e:	2200      	movs	r2, #0
            return false;
        }
        divmod256(&rDiv, &base, &rDiv, &rMod);
        out[offset++] = HEXDIGITS[(uint8_t)LOWER(LOWER(rMod))];
    } while (!zero256(&rDiv));
    out[offset] = '\0';
c0d05c70:	542a      	strb	r2, [r5, r0]
c0d05c72:	2301      	movs	r3, #1
    }
}

static void reverseString(char *str, uint32_t length) {
    uint32_t i, j;
    for (i = 0, j = length - 1; i < j; i++, j--) {
c0d05c74:	9300      	str	r3, [sp, #0]
c0d05c76:	2c00      	cmp	r4, #0
c0d05c78:	d01f      	beq.n	c0d05cba <tostring256+0xfa>
        uint8_t c;
        c = str[i];
c0d05c7a:	782b      	ldrb	r3, [r5, #0]
        str[i] = str[j];
c0d05c7c:	7029      	strb	r1, [r5, #0]
        str[j] = c;
c0d05c7e:	552b      	strb	r3, [r5, r4]
c0d05c80:	1e61      	subs	r1, r4, #1
    }
}

static void reverseString(char *str, uint32_t length) {
    uint32_t i, j;
    for (i = 0, j = length - 1; i < j; i++, j--) {
c0d05c82:	2902      	cmp	r1, #2
c0d05c84:	d319      	bcc.n	c0d05cba <tostring256+0xfa>
c0d05c86:	1829      	adds	r1, r5, r0
c0d05c88:	9104      	str	r1, [sp, #16]
c0d05c8a:	43d3      	mvns	r3, r2
c0d05c8c:	2402      	movs	r4, #2
c0d05c8e:	9303      	str	r3, [sp, #12]
c0d05c90:	9502      	str	r5, [sp, #8]
c0d05c92:	9e02      	ldr	r6, [sp, #8]
c0d05c94:	9903      	ldr	r1, [sp, #12]
        uint8_t c;
        c = str[i];
c0d05c96:	460d      	mov	r5, r1
c0d05c98:	435d      	muls	r5, r3
c0d05c9a:	5d72      	ldrb	r2, [r6, r5]
c0d05c9c:	9205      	str	r2, [sp, #20]
c0d05c9e:	460f      	mov	r7, r1
c0d05ca0:	4367      	muls	r7, r4
c0d05ca2:	9a04      	ldr	r2, [sp, #16]
c0d05ca4:	5dd1      	ldrb	r1, [r2, r7]
        str[i] = str[j];
c0d05ca6:	5571      	strb	r1, [r6, r5]
        str[j] = c;
c0d05ca8:	9905      	ldr	r1, [sp, #20]
c0d05caa:	55d1      	strb	r1, [r2, r7]
    }
}

static void reverseString(char *str, uint32_t length) {
    uint32_t i, j;
    for (i = 0, j = length - 1; i < j; i++, j--) {
c0d05cac:	1e5b      	subs	r3, r3, #1
c0d05cae:	18c1      	adds	r1, r0, r3
c0d05cb0:	1e49      	subs	r1, r1, #1
c0d05cb2:	1c65      	adds	r5, r4, #1
c0d05cb4:	428c      	cmp	r4, r1
c0d05cb6:	462c      	mov	r4, r5
c0d05cb8:	d3ec      	bcc.n	c0d05c94 <tostring256+0xd4>
c0d05cba:	9800      	ldr	r0, [sp, #0]
        out[offset++] = HEXDIGITS[(uint8_t)LOWER(LOWER(rMod))];
    } while (!zero256(&rDiv));
    out[offset] = '\0';
    reverseString(out, offset);
    return true;
}
c0d05cbc:	b01f      	add	sp, #124	; 0x7c
c0d05cbe:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d05cc0:	0000aa47 	.word	0x0000aa47

c0d05cc4 <USBD_LL_Init>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Init (USBD_HandleTypeDef *pdev)
{ 
  UNUSED(pdev);
  ep_in_stall = 0;
c0d05cc4:	4902      	ldr	r1, [pc, #8]	; (c0d05cd0 <USBD_LL_Init+0xc>)
c0d05cc6:	2000      	movs	r0, #0
c0d05cc8:	6008      	str	r0, [r1, #0]
  ep_out_stall = 0;
c0d05cca:	4902      	ldr	r1, [pc, #8]	; (c0d05cd4 <USBD_LL_Init+0x10>)
c0d05ccc:	6008      	str	r0, [r1, #0]
  return USBD_OK;
c0d05cce:	4770      	bx	lr
c0d05cd0:	20001f9c 	.word	0x20001f9c
c0d05cd4:	20001fa0 	.word	0x20001fa0

c0d05cd8 <USBD_LL_DeInit>:
  * @brief  De-Initializes the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_DeInit (USBD_HandleTypeDef *pdev)
{
c0d05cd8:	b510      	push	{r4, lr}
  UNUSED(pdev);
  // usb off
  G_io_seproxyhal_spi_buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d05cda:	4807      	ldr	r0, [pc, #28]	; (c0d05cf8 <USBD_LL_DeInit+0x20>)
c0d05cdc:	214f      	movs	r1, #79	; 0x4f
c0d05cde:	7001      	strb	r1, [r0, #0]
c0d05ce0:	2400      	movs	r4, #0
  G_io_seproxyhal_spi_buffer[1] = 0;
c0d05ce2:	7044      	strb	r4, [r0, #1]
c0d05ce4:	2101      	movs	r1, #1
  G_io_seproxyhal_spi_buffer[2] = 1;
c0d05ce6:	7081      	strb	r1, [r0, #2]
c0d05ce8:	2102      	movs	r1, #2
  G_io_seproxyhal_spi_buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_DISCONNECT;
c0d05cea:	70c1      	strb	r1, [r0, #3]
  io_seproxyhal_spi_send(G_io_seproxyhal_spi_buffer, 4);
c0d05cec:	2104      	movs	r1, #4
c0d05cee:	f7fe f9f1 	bl	c0d040d4 <io_seproxyhal_spi_send>

  return USBD_OK; 
c0d05cf2:	4620      	mov	r0, r4
c0d05cf4:	bd10      	pop	{r4, pc}
c0d05cf6:	46c0      	nop			; (mov r8, r8)
c0d05cf8:	20001cc0 	.word	0x20001cc0

c0d05cfc <USBD_LL_Start>:
  * @brief  Starts the Low Level portion of the Device driver. 
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Start(USBD_HandleTypeDef *pdev)
{
c0d05cfc:	b570      	push	{r4, r5, r6, lr}
c0d05cfe:	b082      	sub	sp, #8
c0d05d00:	466d      	mov	r5, sp
  uint8_t buffer[5];
  UNUSED(pdev);

  // reset address
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d05d02:	264f      	movs	r6, #79	; 0x4f
c0d05d04:	702e      	strb	r6, [r5, #0]
c0d05d06:	2400      	movs	r4, #0
  buffer[1] = 0;
c0d05d08:	706c      	strb	r4, [r5, #1]
c0d05d0a:	2002      	movs	r0, #2
  buffer[2] = 2;
c0d05d0c:	70a8      	strb	r0, [r5, #2]
c0d05d0e:	2003      	movs	r0, #3
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ADDR;
c0d05d10:	70e8      	strb	r0, [r5, #3]
  buffer[4] = 0;
c0d05d12:	712c      	strb	r4, [r5, #4]
  io_seproxyhal_spi_send(buffer, 5);
c0d05d14:	2105      	movs	r1, #5
c0d05d16:	4628      	mov	r0, r5
c0d05d18:	f7fe f9dc 	bl	c0d040d4 <io_seproxyhal_spi_send>
  
  // start usb operation
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d05d1c:	702e      	strb	r6, [r5, #0]
  buffer[1] = 0;
c0d05d1e:	706c      	strb	r4, [r5, #1]
c0d05d20:	2001      	movs	r0, #1
  buffer[2] = 1;
c0d05d22:	70a8      	strb	r0, [r5, #2]
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_CONNECT;
c0d05d24:	70e8      	strb	r0, [r5, #3]
c0d05d26:	2104      	movs	r1, #4
  io_seproxyhal_spi_send(buffer, 4);
c0d05d28:	4628      	mov	r0, r5
c0d05d2a:	f7fe f9d3 	bl	c0d040d4 <io_seproxyhal_spi_send>
  return USBD_OK; 
c0d05d2e:	4620      	mov	r0, r4
c0d05d30:	b002      	add	sp, #8
c0d05d32:	bd70      	pop	{r4, r5, r6, pc}

c0d05d34 <USBD_LL_Stop>:
  * @brief  Stops the Low Level portion of the Device driver.
  * @param  pdev: Device handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_Stop (USBD_HandleTypeDef *pdev)
{
c0d05d34:	b510      	push	{r4, lr}
c0d05d36:	b082      	sub	sp, #8
c0d05d38:	a801      	add	r0, sp, #4
  UNUSED(pdev);
  uint8_t buffer[4];
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d05d3a:	214f      	movs	r1, #79	; 0x4f
c0d05d3c:	7001      	strb	r1, [r0, #0]
c0d05d3e:	2400      	movs	r4, #0
  buffer[1] = 0;
c0d05d40:	7044      	strb	r4, [r0, #1]
c0d05d42:	2101      	movs	r1, #1
  buffer[2] = 1;
c0d05d44:	7081      	strb	r1, [r0, #2]
c0d05d46:	2102      	movs	r1, #2
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_DISCONNECT;
c0d05d48:	70c1      	strb	r1, [r0, #3]
  io_seproxyhal_spi_send(buffer, 4);
c0d05d4a:	2104      	movs	r1, #4
c0d05d4c:	f7fe f9c2 	bl	c0d040d4 <io_seproxyhal_spi_send>
  return USBD_OK; 
c0d05d50:	4620      	mov	r0, r4
c0d05d52:	b002      	add	sp, #8
c0d05d54:	bd10      	pop	{r4, pc}
	...

c0d05d58 <USBD_LL_OpenEP>:
  */
USBD_StatusTypeDef  USBD_LL_OpenEP  (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  ep_type,
                                      uint16_t ep_mps)
{
c0d05d58:	b5b0      	push	{r4, r5, r7, lr}
c0d05d5a:	b082      	sub	sp, #8
  uint8_t buffer[8];
  UNUSED(pdev);

  ep_in_stall = 0;
c0d05d5c:	480e      	ldr	r0, [pc, #56]	; (c0d05d98 <USBD_LL_OpenEP+0x40>)
c0d05d5e:	2400      	movs	r4, #0
c0d05d60:	6004      	str	r4, [r0, #0]
  ep_out_stall = 0;
c0d05d62:	480e      	ldr	r0, [pc, #56]	; (c0d05d9c <USBD_LL_OpenEP+0x44>)
c0d05d64:	6004      	str	r4, [r0, #0]
c0d05d66:	4668      	mov	r0, sp

  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d05d68:	254f      	movs	r5, #79	; 0x4f
c0d05d6a:	7005      	strb	r5, [r0, #0]
  buffer[1] = 0;
c0d05d6c:	7044      	strb	r4, [r0, #1]
c0d05d6e:	2505      	movs	r5, #5
  buffer[2] = 5;
c0d05d70:	7085      	strb	r5, [r0, #2]
c0d05d72:	2504      	movs	r5, #4
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS;
c0d05d74:	70c5      	strb	r5, [r0, #3]
c0d05d76:	2501      	movs	r5, #1
  buffer[4] = 1;
c0d05d78:	7105      	strb	r5, [r0, #4]
  buffer[5] = ep_addr;
c0d05d7a:	7141      	strb	r1, [r0, #5]
  buffer[6] = 0;
  switch(ep_type) {
c0d05d7c:	2a03      	cmp	r2, #3
c0d05d7e:	d802      	bhi.n	c0d05d86 <USBD_LL_OpenEP+0x2e>
c0d05d80:	00d0      	lsls	r0, r2, #3
c0d05d82:	4c07      	ldr	r4, [pc, #28]	; (c0d05da0 <USBD_LL_OpenEP+0x48>)
c0d05d84:	40c4      	lsrs	r4, r0
c0d05d86:	4668      	mov	r0, sp
  buffer[1] = 0;
  buffer[2] = 5;
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS;
  buffer[4] = 1;
  buffer[5] = ep_addr;
  buffer[6] = 0;
c0d05d88:	7184      	strb	r4, [r0, #6]
      break;
    case USBD_EP_TYPE_INTR:
      buffer[6] = SEPROXYHAL_TAG_USB_CONFIG_TYPE_INTERRUPT;
      break;
  }
  buffer[7] = ep_mps;
c0d05d8a:	71c3      	strb	r3, [r0, #7]
  io_seproxyhal_spi_send(buffer, 8);
c0d05d8c:	2108      	movs	r1, #8
c0d05d8e:	f7fe f9a1 	bl	c0d040d4 <io_seproxyhal_spi_send>
c0d05d92:	2000      	movs	r0, #0
  return USBD_OK; 
c0d05d94:	b002      	add	sp, #8
c0d05d96:	bdb0      	pop	{r4, r5, r7, pc}
c0d05d98:	20001f9c 	.word	0x20001f9c
c0d05d9c:	20001fa0 	.word	0x20001fa0
c0d05da0:	02030401 	.word	0x02030401

c0d05da4 <USBD_LL_CloseEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_CloseEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
c0d05da4:	b510      	push	{r4, lr}
c0d05da6:	b082      	sub	sp, #8
c0d05da8:	4668      	mov	r0, sp
  UNUSED(pdev);
  uint8_t buffer[8];
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d05daa:	224f      	movs	r2, #79	; 0x4f
c0d05dac:	7002      	strb	r2, [r0, #0]
c0d05dae:	2400      	movs	r4, #0
  buffer[1] = 0;
c0d05db0:	7044      	strb	r4, [r0, #1]
c0d05db2:	2205      	movs	r2, #5
  buffer[2] = 5;
c0d05db4:	7082      	strb	r2, [r0, #2]
c0d05db6:	2204      	movs	r2, #4
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ENDPOINTS;
c0d05db8:	70c2      	strb	r2, [r0, #3]
c0d05dba:	2201      	movs	r2, #1
  buffer[4] = 1;
c0d05dbc:	7102      	strb	r2, [r0, #4]
  buffer[5] = ep_addr;
c0d05dbe:	7141      	strb	r1, [r0, #5]
  buffer[6] = SEPROXYHAL_TAG_USB_CONFIG_TYPE_DISABLED;
c0d05dc0:	7184      	strb	r4, [r0, #6]
  buffer[7] = 0;
c0d05dc2:	71c4      	strb	r4, [r0, #7]
  io_seproxyhal_spi_send(buffer, 8);
c0d05dc4:	2108      	movs	r1, #8
c0d05dc6:	f7fe f985 	bl	c0d040d4 <io_seproxyhal_spi_send>
  return USBD_OK; 
c0d05dca:	4620      	mov	r0, r4
c0d05dcc:	b002      	add	sp, #8
c0d05dce:	bd10      	pop	{r4, pc}

c0d05dd0 <USBD_LL_StallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_StallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{ 
c0d05dd0:	b5b0      	push	{r4, r5, r7, lr}
c0d05dd2:	b082      	sub	sp, #8
c0d05dd4:	460d      	mov	r5, r1
c0d05dd6:	4668      	mov	r0, sp
  UNUSED(pdev);
  uint8_t buffer[6];
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0d05dd8:	2150      	movs	r1, #80	; 0x50
c0d05dda:	7001      	strb	r1, [r0, #0]
c0d05ddc:	2400      	movs	r4, #0
  buffer[1] = 0;
c0d05dde:	7044      	strb	r4, [r0, #1]
c0d05de0:	2103      	movs	r1, #3
  buffer[2] = 3;
c0d05de2:	7081      	strb	r1, [r0, #2]
  buffer[3] = ep_addr;
c0d05de4:	70c5      	strb	r5, [r0, #3]
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_STALL;
c0d05de6:	2140      	movs	r1, #64	; 0x40
c0d05de8:	7101      	strb	r1, [r0, #4]
  buffer[5] = 0;
c0d05dea:	7144      	strb	r4, [r0, #5]
  io_seproxyhal_spi_send(buffer, 6);
c0d05dec:	2106      	movs	r1, #6
c0d05dee:	f7fe f971 	bl	c0d040d4 <io_seproxyhal_spi_send>
  if (ep_addr & 0x80) {
c0d05df2:	2080      	movs	r0, #128	; 0x80
c0d05df4:	4205      	tst	r5, r0
c0d05df6:	d101      	bne.n	c0d05dfc <USBD_LL_StallEP+0x2c>
c0d05df8:	4807      	ldr	r0, [pc, #28]	; (c0d05e18 <USBD_LL_StallEP+0x48>)
c0d05dfa:	e000      	b.n	c0d05dfe <USBD_LL_StallEP+0x2e>
c0d05dfc:	4805      	ldr	r0, [pc, #20]	; (c0d05e14 <USBD_LL_StallEP+0x44>)
c0d05dfe:	6801      	ldr	r1, [r0, #0]
c0d05e00:	227f      	movs	r2, #127	; 0x7f
c0d05e02:	4015      	ands	r5, r2
c0d05e04:	2201      	movs	r2, #1
c0d05e06:	40aa      	lsls	r2, r5
c0d05e08:	430a      	orrs	r2, r1
c0d05e0a:	6002      	str	r2, [r0, #0]
    ep_in_stall |= (1<<(ep_addr&0x7F));
  }
  else {
    ep_out_stall |= (1<<(ep_addr&0x7F)); 
  }
  return USBD_OK; 
c0d05e0c:	4620      	mov	r0, r4
c0d05e0e:	b002      	add	sp, #8
c0d05e10:	bdb0      	pop	{r4, r5, r7, pc}
c0d05e12:	46c0      	nop			; (mov r8, r8)
c0d05e14:	20001f9c 	.word	0x20001f9c
c0d05e18:	20001fa0 	.word	0x20001fa0

c0d05e1c <USBD_LL_ClearStallEP>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_ClearStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
c0d05e1c:	b570      	push	{r4, r5, r6, lr}
c0d05e1e:	b082      	sub	sp, #8
c0d05e20:	460d      	mov	r5, r1
c0d05e22:	4668      	mov	r0, sp
  UNUSED(pdev);
  uint8_t buffer[6];
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0d05e24:	2150      	movs	r1, #80	; 0x50
c0d05e26:	7001      	strb	r1, [r0, #0]
c0d05e28:	2400      	movs	r4, #0
  buffer[1] = 0;
c0d05e2a:	7044      	strb	r4, [r0, #1]
c0d05e2c:	2103      	movs	r1, #3
  buffer[2] = 3;
c0d05e2e:	7081      	strb	r1, [r0, #2]
  buffer[3] = ep_addr;
c0d05e30:	70c5      	strb	r5, [r0, #3]
c0d05e32:	2680      	movs	r6, #128	; 0x80
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_UNSTALL;
c0d05e34:	7106      	strb	r6, [r0, #4]
  buffer[5] = 0;
c0d05e36:	7144      	strb	r4, [r0, #5]
  io_seproxyhal_spi_send(buffer, 6);
c0d05e38:	2106      	movs	r1, #6
c0d05e3a:	f7fe f94b 	bl	c0d040d4 <io_seproxyhal_spi_send>
  if (ep_addr & 0x80) {
c0d05e3e:	4235      	tst	r5, r6
c0d05e40:	d101      	bne.n	c0d05e46 <USBD_LL_ClearStallEP+0x2a>
c0d05e42:	4807      	ldr	r0, [pc, #28]	; (c0d05e60 <USBD_LL_ClearStallEP+0x44>)
c0d05e44:	e000      	b.n	c0d05e48 <USBD_LL_ClearStallEP+0x2c>
c0d05e46:	4805      	ldr	r0, [pc, #20]	; (c0d05e5c <USBD_LL_ClearStallEP+0x40>)
c0d05e48:	6801      	ldr	r1, [r0, #0]
c0d05e4a:	227f      	movs	r2, #127	; 0x7f
c0d05e4c:	4015      	ands	r5, r2
c0d05e4e:	2201      	movs	r2, #1
c0d05e50:	40aa      	lsls	r2, r5
c0d05e52:	4391      	bics	r1, r2
c0d05e54:	6001      	str	r1, [r0, #0]
    ep_in_stall &= ~(1<<(ep_addr&0x7F));
  }
  else {
    ep_out_stall &= ~(1<<(ep_addr&0x7F)); 
  }
  return USBD_OK; 
c0d05e56:	4620      	mov	r0, r4
c0d05e58:	b002      	add	sp, #8
c0d05e5a:	bd70      	pop	{r4, r5, r6, pc}
c0d05e5c:	20001f9c 	.word	0x20001f9c
c0d05e60:	20001fa0 	.word	0x20001fa0

c0d05e64 <USBD_LL_IsStallEP>:
  * @retval Stall (1: Yes, 0: No)
  */
uint8_t USBD_LL_IsStallEP (USBD_HandleTypeDef *pdev, uint8_t ep_addr)   
{
  UNUSED(pdev);
  if((ep_addr & 0x80) == 0x80)
c0d05e64:	2080      	movs	r0, #128	; 0x80
c0d05e66:	4201      	tst	r1, r0
c0d05e68:	d001      	beq.n	c0d05e6e <USBD_LL_IsStallEP+0xa>
c0d05e6a:	4806      	ldr	r0, [pc, #24]	; (c0d05e84 <USBD_LL_IsStallEP+0x20>)
c0d05e6c:	e000      	b.n	c0d05e70 <USBD_LL_IsStallEP+0xc>
c0d05e6e:	4804      	ldr	r0, [pc, #16]	; (c0d05e80 <USBD_LL_IsStallEP+0x1c>)
c0d05e70:	6800      	ldr	r0, [r0, #0]
c0d05e72:	227f      	movs	r2, #127	; 0x7f
c0d05e74:	4011      	ands	r1, r2
c0d05e76:	2201      	movs	r2, #1
c0d05e78:	408a      	lsls	r2, r1
c0d05e7a:	4002      	ands	r2, r0
  }
  else
  {
    return ep_out_stall & (1<<(ep_addr&0x7F));
  }
}
c0d05e7c:	b2d0      	uxtb	r0, r2
c0d05e7e:	4770      	bx	lr
c0d05e80:	20001fa0 	.word	0x20001fa0
c0d05e84:	20001f9c 	.word	0x20001f9c

c0d05e88 <USBD_LL_SetUSBAddress>:
  * @param  pdev: Device handle
  * @param  ep_addr: Endpoint Number
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_SetUSBAddress (USBD_HandleTypeDef *pdev, uint8_t dev_addr)   
{
c0d05e88:	b510      	push	{r4, lr}
c0d05e8a:	b082      	sub	sp, #8
c0d05e8c:	4668      	mov	r0, sp
  UNUSED(pdev);
  uint8_t buffer[5];
  buffer[0] = SEPROXYHAL_TAG_USB_CONFIG;
c0d05e8e:	224f      	movs	r2, #79	; 0x4f
c0d05e90:	7002      	strb	r2, [r0, #0]
c0d05e92:	2400      	movs	r4, #0
  buffer[1] = 0;
c0d05e94:	7044      	strb	r4, [r0, #1]
c0d05e96:	2202      	movs	r2, #2
  buffer[2] = 2;
c0d05e98:	7082      	strb	r2, [r0, #2]
c0d05e9a:	2203      	movs	r2, #3
  buffer[3] = SEPROXYHAL_TAG_USB_CONFIG_ADDR;
c0d05e9c:	70c2      	strb	r2, [r0, #3]
  buffer[4] = dev_addr;
c0d05e9e:	7101      	strb	r1, [r0, #4]
  io_seproxyhal_spi_send(buffer, 5);
c0d05ea0:	2105      	movs	r1, #5
c0d05ea2:	f7fe f917 	bl	c0d040d4 <io_seproxyhal_spi_send>
  return USBD_OK; 
c0d05ea6:	4620      	mov	r0, r4
c0d05ea8:	b002      	add	sp, #8
c0d05eaa:	bd10      	pop	{r4, pc}

c0d05eac <USBD_LL_Transmit>:
  */
USBD_StatusTypeDef  USBD_LL_Transmit (USBD_HandleTypeDef *pdev, 
                                      uint8_t  ep_addr,                                      
                                      uint8_t  *pbuf,
                                      uint16_t  size)
{
c0d05eac:	b5b0      	push	{r4, r5, r7, lr}
c0d05eae:	b082      	sub	sp, #8
c0d05eb0:	461c      	mov	r4, r3
c0d05eb2:	4615      	mov	r5, r2
c0d05eb4:	4668      	mov	r0, sp
  UNUSED(pdev);
  uint8_t buffer[6];
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0d05eb6:	2250      	movs	r2, #80	; 0x50
c0d05eb8:	7002      	strb	r2, [r0, #0]
  buffer[1] = (3+size)>>8;
c0d05eba:	1ce2      	adds	r2, r4, #3
c0d05ebc:	0a13      	lsrs	r3, r2, #8
c0d05ebe:	7043      	strb	r3, [r0, #1]
  buffer[2] = (3+size);
c0d05ec0:	7082      	strb	r2, [r0, #2]
  buffer[3] = ep_addr;
c0d05ec2:	70c1      	strb	r1, [r0, #3]
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_IN;
c0d05ec4:	2120      	movs	r1, #32
c0d05ec6:	7101      	strb	r1, [r0, #4]
  buffer[5] = size;
c0d05ec8:	7144      	strb	r4, [r0, #5]
  io_seproxyhal_spi_send(buffer, 6);
c0d05eca:	2106      	movs	r1, #6
c0d05ecc:	f7fe f902 	bl	c0d040d4 <io_seproxyhal_spi_send>
  io_seproxyhal_spi_send(pbuf, size);
c0d05ed0:	4628      	mov	r0, r5
c0d05ed2:	4621      	mov	r1, r4
c0d05ed4:	f7fe f8fe 	bl	c0d040d4 <io_seproxyhal_spi_send>
c0d05ed8:	2000      	movs	r0, #0
  return USBD_OK;   
c0d05eda:	b002      	add	sp, #8
c0d05edc:	bdb0      	pop	{r4, r5, r7, pc}

c0d05ede <USBD_LL_PrepareReceive>:
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_LL_PrepareReceive(USBD_HandleTypeDef *pdev, 
                                           uint8_t  ep_addr,
                                           uint16_t  size)
{
c0d05ede:	b510      	push	{r4, lr}
c0d05ee0:	b082      	sub	sp, #8
c0d05ee2:	4668      	mov	r0, sp
  UNUSED(pdev);
  uint8_t buffer[6];
  buffer[0] = SEPROXYHAL_TAG_USB_EP_PREPARE;
c0d05ee4:	2350      	movs	r3, #80	; 0x50
c0d05ee6:	7003      	strb	r3, [r0, #0]
c0d05ee8:	2400      	movs	r4, #0
  buffer[1] = (3/*+size*/)>>8;
c0d05eea:	7044      	strb	r4, [r0, #1]
c0d05eec:	2303      	movs	r3, #3
  buffer[2] = (3/*+size*/);
c0d05eee:	7083      	strb	r3, [r0, #2]
  buffer[3] = ep_addr;
c0d05ef0:	70c1      	strb	r1, [r0, #3]
  buffer[4] = SEPROXYHAL_TAG_USB_EP_PREPARE_DIR_OUT;
c0d05ef2:	2130      	movs	r1, #48	; 0x30
c0d05ef4:	7101      	strb	r1, [r0, #4]
  buffer[5] = size; // expected size, not transmitted here !
c0d05ef6:	7142      	strb	r2, [r0, #5]
  io_seproxyhal_spi_send(buffer, 6);
c0d05ef8:	2106      	movs	r1, #6
c0d05efa:	f7fe f8eb 	bl	c0d040d4 <io_seproxyhal_spi_send>
  return USBD_OK;   
c0d05efe:	4620      	mov	r0, r4
c0d05f00:	b002      	add	sp, #8
c0d05f02:	bd10      	pop	{r4, pc}

c0d05f04 <USBD_Init>:
* @param  pdesc: Descriptor structure address
* @param  id: Low level core index
* @retval None
*/
USBD_StatusTypeDef USBD_Init(USBD_HandleTypeDef *pdev, USBD_DescriptorsTypeDef *pdesc, uint8_t id)
{
c0d05f04:	b570      	push	{r4, r5, r6, lr}
c0d05f06:	4615      	mov	r5, r2
c0d05f08:	460e      	mov	r6, r1
c0d05f0a:	4604      	mov	r4, r0
c0d05f0c:	2002      	movs	r0, #2
  /* Check whether the USB Host handle is valid */
  if(pdev == NULL)
c0d05f0e:	2c00      	cmp	r4, #0
c0d05f10:	d010      	beq.n	c0d05f34 <USBD_Init+0x30>
  {
    USBD_ErrLog("Invalid Device handle");
    return USBD_FAIL; 
  }

  memset(pdev, 0, sizeof(USBD_HandleTypeDef));
c0d05f12:	2045      	movs	r0, #69	; 0x45
c0d05f14:	0081      	lsls	r1, r0, #2
c0d05f16:	4620      	mov	r0, r4
c0d05f18:	f000 ffba 	bl	c0d06e90 <__aeabi_memclr>
  
  /* Assign USBD Descriptors */
  if(pdesc != NULL)
c0d05f1c:	2e00      	cmp	r6, #0
c0d05f1e:	d001      	beq.n	c0d05f24 <USBD_Init+0x20>
  {
    pdev->pDesc = pdesc;
c0d05f20:	20f0      	movs	r0, #240	; 0xf0
c0d05f22:	5026      	str	r6, [r4, r0]
  }
  
  /* Set Device initial State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
c0d05f24:	20dc      	movs	r0, #220	; 0xdc
c0d05f26:	2101      	movs	r1, #1
c0d05f28:	5421      	strb	r1, [r4, r0]
  pdev->id = id;
c0d05f2a:	7025      	strb	r5, [r4, #0]
  /* Initialize low level driver */
  USBD_LL_Init(pdev);
c0d05f2c:	4620      	mov	r0, r4
c0d05f2e:	f7ff fec9 	bl	c0d05cc4 <USBD_LL_Init>
c0d05f32:	2000      	movs	r0, #0
  
  return USBD_OK; 
}
c0d05f34:	b2c0      	uxtb	r0, r0
c0d05f36:	bd70      	pop	{r4, r5, r6, pc}

c0d05f38 <USBD_DeInit>:
*         Re-Initialize th device library
* @param  pdev: device instance
* @retval status: status
*/
USBD_StatusTypeDef USBD_DeInit(USBD_HandleTypeDef *pdev)
{
c0d05f38:	b5b0      	push	{r4, r5, r7, lr}
c0d05f3a:	4604      	mov	r4, r0
  /* Set Default State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
c0d05f3c:	20dc      	movs	r0, #220	; 0xdc
c0d05f3e:	2101      	movs	r1, #1
c0d05f40:	5421      	strb	r1, [r4, r0]
c0d05f42:	2500      	movs	r5, #0
  
  /* Free Class Resources */
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
    if(pdev->interfacesClass[intf].pClass != NULL) {
c0d05f44:	00e8      	lsls	r0, r5, #3
c0d05f46:	1820      	adds	r0, r4, r0
c0d05f48:	21f4      	movs	r1, #244	; 0xf4
c0d05f4a:	5840      	ldr	r0, [r0, r1]
c0d05f4c:	2800      	cmp	r0, #0
c0d05f4e:	d006      	beq.n	c0d05f5e <USBD_DeInit+0x26>
      ((DeInit_t)PIC(pdev->interfacesClass[intf].pClass->DeInit))(pdev, pdev->dev_config);  
c0d05f50:	6840      	ldr	r0, [r0, #4]
c0d05f52:	f7fd fec7 	bl	c0d03ce4 <pic>
c0d05f56:	4602      	mov	r2, r0
c0d05f58:	7921      	ldrb	r1, [r4, #4]
c0d05f5a:	4620      	mov	r0, r4
c0d05f5c:	4790      	blx	r2
  /* Set Default State */
  pdev->dev_state  = USBD_STATE_DEFAULT;
  
  /* Free Class Resources */
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d05f5e:	1c6d      	adds	r5, r5, #1
c0d05f60:	2d03      	cmp	r5, #3
c0d05f62:	d1ef      	bne.n	c0d05f44 <USBD_DeInit+0xc>
      ((DeInit_t)PIC(pdev->interfacesClass[intf].pClass->DeInit))(pdev, pdev->dev_config);  
    }
  }
  
    /* Stop the low level driver  */
  USBD_LL_Stop(pdev); 
c0d05f64:	4620      	mov	r0, r4
c0d05f66:	f7ff fee5 	bl	c0d05d34 <USBD_LL_Stop>
  
  /* Initialize low level driver */
  USBD_LL_DeInit(pdev);
c0d05f6a:	4620      	mov	r0, r4
c0d05f6c:	f7ff feb4 	bl	c0d05cd8 <USBD_LL_DeInit>
  
  return USBD_OK;
c0d05f70:	2000      	movs	r0, #0
c0d05f72:	bdb0      	pop	{r4, r5, r7, pc}

c0d05f74 <USBD_RegisterClassForInterface>:
  * @param  pDevice : Device Handle
  * @param  pclass: Class handle
  * @retval USBD Status
  */
USBD_StatusTypeDef USBD_RegisterClassForInterface(uint8_t interfaceidx, USBD_HandleTypeDef *pdev, USBD_ClassTypeDef *pclass)
{
c0d05f74:	2302      	movs	r3, #2
  USBD_StatusTypeDef   status = USBD_OK;
  if(pclass != 0)
c0d05f76:	2a00      	cmp	r2, #0
c0d05f78:	d006      	beq.n	c0d05f88 <USBD_RegisterClassForInterface+0x14>
c0d05f7a:	2300      	movs	r3, #0
  {
    if (interfaceidx < USBD_MAX_NUM_INTERFACES) {
c0d05f7c:	2802      	cmp	r0, #2
c0d05f7e:	d803      	bhi.n	c0d05f88 <USBD_RegisterClassForInterface+0x14>
      /* link the class to the USB Device handle */
      pdev->interfacesClass[interfaceidx].pClass = pclass;
c0d05f80:	00c0      	lsls	r0, r0, #3
c0d05f82:	1808      	adds	r0, r1, r0
c0d05f84:	21f4      	movs	r1, #244	; 0xf4
c0d05f86:	5042      	str	r2, [r0, r1]
  {
    USBD_ErrLog("Invalid Class handle");
    status = USBD_FAIL; 
  }
  
  return status;
c0d05f88:	b2d8      	uxtb	r0, r3
c0d05f8a:	4770      	bx	lr

c0d05f8c <USBD_Start>:
  *         Start the USB Device Core.
  * @param  pdev: Device Handle
  * @retval USBD Status
  */
USBD_StatusTypeDef  USBD_Start  (USBD_HandleTypeDef *pdev)
{
c0d05f8c:	b580      	push	{r7, lr}
  
  /* Start the low level driver  */
  USBD_LL_Start(pdev); 
c0d05f8e:	f7ff feb5 	bl	c0d05cfc <USBD_LL_Start>
  
  return USBD_OK;  
c0d05f92:	2000      	movs	r0, #0
c0d05f94:	bd80      	pop	{r7, pc}

c0d05f96 <USBD_SetClassConfig>:
* @param  cfgidx: configuration index
* @retval status
*/

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
c0d05f96:	b570      	push	{r4, r5, r6, lr}
c0d05f98:	460c      	mov	r4, r1
c0d05f9a:	4605      	mov	r5, r0
c0d05f9c:	2600      	movs	r6, #0
  /* Set configuration  and Start the Class*/
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
    if(usbd_is_valid_intf(pdev, intf)) {
c0d05f9e:	4628      	mov	r0, r5
c0d05fa0:	4631      	mov	r1, r6
c0d05fa2:	f000 f96f 	bl	c0d06284 <usbd_is_valid_intf>
c0d05fa6:	2800      	cmp	r0, #0
c0d05fa8:	d00a      	beq.n	c0d05fc0 <USBD_SetClassConfig+0x2a>
      ((Init_t)PIC(pdev->interfacesClass[intf].pClass->Init))(pdev, cfgidx);
c0d05faa:	00f0      	lsls	r0, r6, #3
c0d05fac:	1828      	adds	r0, r5, r0
c0d05fae:	21f4      	movs	r1, #244	; 0xf4
c0d05fb0:	5840      	ldr	r0, [r0, r1]
c0d05fb2:	6800      	ldr	r0, [r0, #0]
c0d05fb4:	f7fd fe96 	bl	c0d03ce4 <pic>
c0d05fb8:	4602      	mov	r2, r0
c0d05fba:	4628      	mov	r0, r5
c0d05fbc:	4621      	mov	r1, r4
c0d05fbe:	4790      	blx	r2

USBD_StatusTypeDef USBD_SetClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
  /* Set configuration  and Start the Class*/
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d05fc0:	1c76      	adds	r6, r6, #1
c0d05fc2:	2e03      	cmp	r6, #3
c0d05fc4:	d1eb      	bne.n	c0d05f9e <USBD_SetClassConfig+0x8>
    if(usbd_is_valid_intf(pdev, intf)) {
      ((Init_t)PIC(pdev->interfacesClass[intf].pClass->Init))(pdev, cfgidx);
    }
  }

  return USBD_OK; 
c0d05fc6:	2000      	movs	r0, #0
c0d05fc8:	bd70      	pop	{r4, r5, r6, pc}

c0d05fca <USBD_ClrClassConfig>:
* @param  pdev: device instance
* @param  cfgidx: configuration index
* @retval status: USBD_StatusTypeDef
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
c0d05fca:	b570      	push	{r4, r5, r6, lr}
c0d05fcc:	460c      	mov	r4, r1
c0d05fce:	4605      	mov	r5, r0
c0d05fd0:	2600      	movs	r6, #0
  /* Clear configuration  and De-initialize the Class process*/
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
    if(usbd_is_valid_intf(pdev, intf)) {
c0d05fd2:	4628      	mov	r0, r5
c0d05fd4:	4631      	mov	r1, r6
c0d05fd6:	f000 f955 	bl	c0d06284 <usbd_is_valid_intf>
c0d05fda:	2800      	cmp	r0, #0
c0d05fdc:	d00a      	beq.n	c0d05ff4 <USBD_ClrClassConfig+0x2a>
      ((DeInit_t)PIC(pdev->interfacesClass[intf].pClass->DeInit))(pdev, cfgidx);  
c0d05fde:	00f0      	lsls	r0, r6, #3
c0d05fe0:	1828      	adds	r0, r5, r0
c0d05fe2:	21f4      	movs	r1, #244	; 0xf4
c0d05fe4:	5840      	ldr	r0, [r0, r1]
c0d05fe6:	6840      	ldr	r0, [r0, #4]
c0d05fe8:	f7fd fe7c 	bl	c0d03ce4 <pic>
c0d05fec:	4602      	mov	r2, r0
c0d05fee:	4628      	mov	r0, r5
c0d05ff0:	4621      	mov	r1, r4
c0d05ff2:	4790      	blx	r2
*/
USBD_StatusTypeDef USBD_ClrClassConfig(USBD_HandleTypeDef  *pdev, uint8_t cfgidx)
{
  /* Clear configuration  and De-initialize the Class process*/
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d05ff4:	1c76      	adds	r6, r6, #1
c0d05ff6:	2e03      	cmp	r6, #3
c0d05ff8:	d1eb      	bne.n	c0d05fd2 <USBD_ClrClassConfig+0x8>
    if(usbd_is_valid_intf(pdev, intf)) {
      ((DeInit_t)PIC(pdev->interfacesClass[intf].pClass->DeInit))(pdev, cfgidx);  
    }
  }
  return USBD_OK;
c0d05ffa:	2000      	movs	r0, #0
c0d05ffc:	bd70      	pop	{r4, r5, r6, pc}

c0d05ffe <USBD_LL_SetupStage>:
*         Handle the setup stage
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetupStage(USBD_HandleTypeDef *pdev, uint8_t *psetup)
{
c0d05ffe:	b5b0      	push	{r4, r5, r7, lr}
c0d06000:	4604      	mov	r4, r0
  USBD_ParseSetupRequest(&pdev->request, psetup);
c0d06002:	4625      	mov	r5, r4
c0d06004:	35e8      	adds	r5, #232	; 0xe8
c0d06006:	4628      	mov	r0, r5
c0d06008:	f000 fb7f 	bl	c0d0670a <USBD_ParseSetupRequest>
  
  pdev->ep0_state = USBD_EP0_SETUP;
c0d0600c:	20d4      	movs	r0, #212	; 0xd4
c0d0600e:	2101      	movs	r1, #1
c0d06010:	5021      	str	r1, [r4, r0]
  pdev->ep0_data_len = pdev->request.wLength;
c0d06012:	20ee      	movs	r0, #238	; 0xee
c0d06014:	5a20      	ldrh	r0, [r4, r0]
c0d06016:	21d8      	movs	r1, #216	; 0xd8
c0d06018:	5060      	str	r0, [r4, r1]
c0d0601a:	20e8      	movs	r0, #232	; 0xe8
  
  switch (pdev->request.bmRequest & 0x1F) 
c0d0601c:	5c21      	ldrb	r1, [r4, r0]
c0d0601e:	201f      	movs	r0, #31
c0d06020:	4008      	ands	r0, r1
c0d06022:	2802      	cmp	r0, #2
c0d06024:	d008      	beq.n	c0d06038 <USBD_LL_SetupStage+0x3a>
c0d06026:	2801      	cmp	r0, #1
c0d06028:	d00b      	beq.n	c0d06042 <USBD_LL_SetupStage+0x44>
c0d0602a:	2800      	cmp	r0, #0
c0d0602c:	d10e      	bne.n	c0d0604c <USBD_LL_SetupStage+0x4e>
  {
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &pdev->request);
c0d0602e:	4620      	mov	r0, r4
c0d06030:	4629      	mov	r1, r5
c0d06032:	f000 f934 	bl	c0d0629e <USBD_StdDevReq>
c0d06036:	e00e      	b.n	c0d06056 <USBD_LL_SetupStage+0x58>
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
    break;
    
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
c0d06038:	4620      	mov	r0, r4
c0d0603a:	4629      	mov	r1, r5
c0d0603c:	f000 fadc 	bl	c0d065f8 <USBD_StdEPReq>
c0d06040:	e009      	b.n	c0d06056 <USBD_LL_SetupStage+0x58>
  case USB_REQ_RECIPIENT_DEVICE:   
    USBD_StdDevReq (pdev, &pdev->request);
    break;
    
  case USB_REQ_RECIPIENT_INTERFACE:     
    USBD_StdItfReq(pdev, &pdev->request);
c0d06042:	4620      	mov	r0, r4
c0d06044:	4629      	mov	r1, r5
c0d06046:	f000 fab3 	bl	c0d065b0 <USBD_StdItfReq>
c0d0604a:	e004      	b.n	c0d06056 <USBD_LL_SetupStage+0x58>
  case USB_REQ_RECIPIENT_ENDPOINT:        
    USBD_StdEPReq(pdev, &pdev->request);   
    break;
    
  default:           
    USBD_LL_StallEP(pdev , pdev->request.bmRequest & 0x80);
c0d0604c:	2080      	movs	r0, #128	; 0x80
c0d0604e:	4001      	ands	r1, r0
c0d06050:	4620      	mov	r0, r4
c0d06052:	f7ff febd 	bl	c0d05dd0 <USBD_LL_StallEP>
    break;
  }  
  return USBD_OK;  
c0d06056:	2000      	movs	r0, #0
c0d06058:	bdb0      	pop	{r4, r5, r7, pc}

c0d0605a <USBD_LL_DataOutStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataOutStage(USBD_HandleTypeDef *pdev , uint8_t epnum, uint8_t *pdata)
{
c0d0605a:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0605c:	b081      	sub	sp, #4
c0d0605e:	9200      	str	r2, [sp, #0]
c0d06060:	460e      	mov	r6, r1
c0d06062:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
  
  if(epnum == 0) 
c0d06064:	2e00      	cmp	r6, #0
c0d06066:	d01d      	beq.n	c0d060a4 <USBD_LL_DataOutStage+0x4a>
c0d06068:	4625      	mov	r5, r4
c0d0606a:	35dc      	adds	r5, #220	; 0xdc
c0d0606c:	2700      	movs	r7, #0
  }
  else {

    uint8_t intf;
    for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
      if( usbd_is_valid_intf(pdev, intf) &&  (pdev->interfacesClass[intf].pClass->DataOut != NULL)&&
c0d0606e:	4620      	mov	r0, r4
c0d06070:	4639      	mov	r1, r7
c0d06072:	f000 f907 	bl	c0d06284 <usbd_is_valid_intf>
c0d06076:	2800      	cmp	r0, #0
c0d06078:	d010      	beq.n	c0d0609c <USBD_LL_DataOutStage+0x42>
c0d0607a:	00f8      	lsls	r0, r7, #3
c0d0607c:	1820      	adds	r0, r4, r0
c0d0607e:	21f4      	movs	r1, #244	; 0xf4
c0d06080:	5840      	ldr	r0, [r0, r1]
c0d06082:	6980      	ldr	r0, [r0, #24]
c0d06084:	2800      	cmp	r0, #0
c0d06086:	d009      	beq.n	c0d0609c <USBD_LL_DataOutStage+0x42>
         (pdev->dev_state == USBD_STATE_CONFIGURED))
c0d06088:	7829      	ldrb	r1, [r5, #0]
  }
  else {

    uint8_t intf;
    for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
      if( usbd_is_valid_intf(pdev, intf) &&  (pdev->interfacesClass[intf].pClass->DataOut != NULL)&&
c0d0608a:	2903      	cmp	r1, #3
c0d0608c:	d106      	bne.n	c0d0609c <USBD_LL_DataOutStage+0x42>
         (pdev->dev_state == USBD_STATE_CONFIGURED))
      {
        ((DataOut_t)PIC(pdev->interfacesClass[intf].pClass->DataOut))(pdev, epnum, pdata); 
c0d0608e:	f7fd fe29 	bl	c0d03ce4 <pic>
c0d06092:	4603      	mov	r3, r0
c0d06094:	4620      	mov	r0, r4
c0d06096:	4631      	mov	r1, r6
c0d06098:	9a00      	ldr	r2, [sp, #0]
c0d0609a:	4798      	blx	r3
    }
  }
  else {

    uint8_t intf;
    for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d0609c:	1c7f      	adds	r7, r7, #1
c0d0609e:	2f03      	cmp	r7, #3
c0d060a0:	d1e5      	bne.n	c0d0606e <USBD_LL_DataOutStage+0x14>
c0d060a2:	e031      	b.n	c0d06108 <USBD_LL_DataOutStage+0xae>
  
  if(epnum == 0) 
  {
    pep = &pdev->ep_out[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_OUT)
c0d060a4:	20d4      	movs	r0, #212	; 0xd4
c0d060a6:	5820      	ldr	r0, [r4, r0]
c0d060a8:	2803      	cmp	r0, #3
c0d060aa:	d12d      	bne.n	c0d06108 <USBD_LL_DataOutStage+0xae>
    {
      if(pep->rem_length > pep->maxpacket)
c0d060ac:	2080      	movs	r0, #128	; 0x80
c0d060ae:	5820      	ldr	r0, [r4, r0]
c0d060b0:	6fe1      	ldr	r1, [r4, #124]	; 0x7c
c0d060b2:	4281      	cmp	r1, r0
c0d060b4:	d90a      	bls.n	c0d060cc <USBD_LL_DataOutStage+0x72>
      {
        pep->rem_length -=  pep->maxpacket;
c0d060b6:	1a09      	subs	r1, r1, r0
c0d060b8:	67e1      	str	r1, [r4, #124]	; 0x7c
c0d060ba:	4281      	cmp	r1, r0
c0d060bc:	d300      	bcc.n	c0d060c0 <USBD_LL_DataOutStage+0x66>
c0d060be:	4601      	mov	r1, r0
       
        USBD_CtlContinueRx (pdev, 
c0d060c0:	b28a      	uxth	r2, r1
c0d060c2:	4620      	mov	r0, r4
c0d060c4:	9900      	ldr	r1, [sp, #0]
c0d060c6:	f000 fd9f 	bl	c0d06c08 <USBD_CtlContinueRx>
c0d060ca:	e01d      	b.n	c0d06108 <USBD_LL_DataOutStage+0xae>
c0d060cc:	4626      	mov	r6, r4
c0d060ce:	36dc      	adds	r6, #220	; 0xdc
c0d060d0:	2500      	movs	r5, #0
      }
      else
      {
        uint8_t intf;
        for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
          if(usbd_is_valid_intf(pdev, intf) &&  (pdev->interfacesClass[intf].pClass->EP0_RxReady != NULL)&&
c0d060d2:	4620      	mov	r0, r4
c0d060d4:	4629      	mov	r1, r5
c0d060d6:	f000 f8d5 	bl	c0d06284 <usbd_is_valid_intf>
c0d060da:	2800      	cmp	r0, #0
c0d060dc:	d00e      	beq.n	c0d060fc <USBD_LL_DataOutStage+0xa2>
c0d060de:	00e8      	lsls	r0, r5, #3
c0d060e0:	1820      	adds	r0, r4, r0
c0d060e2:	21f4      	movs	r1, #244	; 0xf4
c0d060e4:	5840      	ldr	r0, [r0, r1]
c0d060e6:	6900      	ldr	r0, [r0, #16]
c0d060e8:	2800      	cmp	r0, #0
c0d060ea:	d007      	beq.n	c0d060fc <USBD_LL_DataOutStage+0xa2>
             (pdev->dev_state == USBD_STATE_CONFIGURED))
c0d060ec:	7831      	ldrb	r1, [r6, #0]
      }
      else
      {
        uint8_t intf;
        for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
          if(usbd_is_valid_intf(pdev, intf) &&  (pdev->interfacesClass[intf].pClass->EP0_RxReady != NULL)&&
c0d060ee:	2903      	cmp	r1, #3
c0d060f0:	d104      	bne.n	c0d060fc <USBD_LL_DataOutStage+0xa2>
             (pdev->dev_state == USBD_STATE_CONFIGURED))
          {
            ((EP0_RxReady_t)PIC(pdev->interfacesClass[intf].pClass->EP0_RxReady))(pdev); 
c0d060f2:	f7fd fdf7 	bl	c0d03ce4 <pic>
c0d060f6:	4601      	mov	r1, r0
c0d060f8:	4620      	mov	r0, r4
c0d060fa:	4788      	blx	r1
                            MIN(pep->rem_length ,pep->maxpacket));
      }
      else
      {
        uint8_t intf;
        for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d060fc:	1c6d      	adds	r5, r5, #1
c0d060fe:	2d03      	cmp	r5, #3
c0d06100:	d1e7      	bne.n	c0d060d2 <USBD_LL_DataOutStage+0x78>
             (pdev->dev_state == USBD_STATE_CONFIGURED))
          {
            ((EP0_RxReady_t)PIC(pdev->interfacesClass[intf].pClass->EP0_RxReady))(pdev); 
          }
        }
        USBD_CtlSendStatus(pdev);
c0d06102:	4620      	mov	r0, r4
c0d06104:	f000 fd87 	bl	c0d06c16 <USBD_CtlSendStatus>
      {
        ((DataOut_t)PIC(pdev->interfacesClass[intf].pClass->DataOut))(pdev, epnum, pdata); 
      }
    }
  }  
  return USBD_OK;
c0d06108:	2000      	movs	r0, #0
c0d0610a:	b001      	add	sp, #4
c0d0610c:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d0610e <USBD_LL_DataInStage>:
* @param  pdev: device instance
* @param  epnum: endpoint index
* @retval status
*/
USBD_StatusTypeDef USBD_LL_DataInStage(USBD_HandleTypeDef *pdev ,uint8_t epnum, uint8_t *pdata)
{
c0d0610e:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d06110:	b081      	sub	sp, #4
c0d06112:	460d      	mov	r5, r1
c0d06114:	4604      	mov	r4, r0
  USBD_EndpointTypeDef    *pep;
  UNUSED(pdata);
    
  if(epnum == 0) 
c0d06116:	2d00      	cmp	r5, #0
c0d06118:	d01c      	beq.n	c0d06154 <USBD_LL_DataInStage+0x46>
c0d0611a:	4627      	mov	r7, r4
c0d0611c:	37dc      	adds	r7, #220	; 0xdc
c0d0611e:	2600      	movs	r6, #0
    }
  }
  else {
    uint8_t intf;
    for (intf = 0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
      if( usbd_is_valid_intf(pdev, intf) && (pdev->interfacesClass[intf].pClass->DataIn != NULL)&&
c0d06120:	4620      	mov	r0, r4
c0d06122:	4631      	mov	r1, r6
c0d06124:	f000 f8ae 	bl	c0d06284 <usbd_is_valid_intf>
c0d06128:	2800      	cmp	r0, #0
c0d0612a:	d00f      	beq.n	c0d0614c <USBD_LL_DataInStage+0x3e>
c0d0612c:	00f0      	lsls	r0, r6, #3
c0d0612e:	1820      	adds	r0, r4, r0
c0d06130:	21f4      	movs	r1, #244	; 0xf4
c0d06132:	5840      	ldr	r0, [r0, r1]
c0d06134:	6940      	ldr	r0, [r0, #20]
c0d06136:	2800      	cmp	r0, #0
c0d06138:	d008      	beq.n	c0d0614c <USBD_LL_DataInStage+0x3e>
         (pdev->dev_state == USBD_STATE_CONFIGURED))
c0d0613a:	7839      	ldrb	r1, [r7, #0]
    }
  }
  else {
    uint8_t intf;
    for (intf = 0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
      if( usbd_is_valid_intf(pdev, intf) && (pdev->interfacesClass[intf].pClass->DataIn != NULL)&&
c0d0613c:	2903      	cmp	r1, #3
c0d0613e:	d105      	bne.n	c0d0614c <USBD_LL_DataInStage+0x3e>
         (pdev->dev_state == USBD_STATE_CONFIGURED))
      {
        ((DataIn_t)PIC(pdev->interfacesClass[intf].pClass->DataIn))(pdev, epnum); 
c0d06140:	f7fd fdd0 	bl	c0d03ce4 <pic>
c0d06144:	4602      	mov	r2, r0
c0d06146:	4620      	mov	r0, r4
c0d06148:	4629      	mov	r1, r5
c0d0614a:	4790      	blx	r2
      pdev->dev_test_mode = 0;
    }
  }
  else {
    uint8_t intf;
    for (intf = 0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d0614c:	1c76      	adds	r6, r6, #1
c0d0614e:	2e03      	cmp	r6, #3
c0d06150:	d1e6      	bne.n	c0d06120 <USBD_LL_DataInStage+0x12>
c0d06152:	e04f      	b.n	c0d061f4 <USBD_LL_DataInStage+0xe6>
    
  if(epnum == 0) 
  {
    pep = &pdev->ep_in[0];
    
    if ( pdev->ep0_state == USBD_EP0_DATA_IN)
c0d06154:	20d4      	movs	r0, #212	; 0xd4
c0d06156:	5820      	ldr	r0, [r4, r0]
c0d06158:	2802      	cmp	r0, #2
c0d0615a:	d144      	bne.n	c0d061e6 <USBD_LL_DataInStage+0xd8>
    {
      if(pep->rem_length > pep->maxpacket)
c0d0615c:	69e0      	ldr	r0, [r4, #28]
c0d0615e:	6a25      	ldr	r5, [r4, #32]
c0d06160:	42a8      	cmp	r0, r5
c0d06162:	d90b      	bls.n	c0d0617c <USBD_LL_DataInStage+0x6e>
      {
        pep->rem_length -=  pep->maxpacket;
c0d06164:	1b40      	subs	r0, r0, r5
c0d06166:	61e0      	str	r0, [r4, #28]
        pdev->pData += pep->maxpacket;
c0d06168:	2111      	movs	r1, #17
c0d0616a:	010a      	lsls	r2, r1, #4
c0d0616c:	58a1      	ldr	r1, [r4, r2]
c0d0616e:	1949      	adds	r1, r1, r5
c0d06170:	50a1      	str	r1, [r4, r2]
        USBD_LL_PrepareReceive (pdev,
                                0,
                                0);  
        */
        
        USBD_CtlContinueSendData (pdev, 
c0d06172:	b282      	uxth	r2, r0
c0d06174:	4620      	mov	r0, r4
c0d06176:	f000 fd39 	bl	c0d06bec <USBD_CtlContinueSendData>
c0d0617a:	e034      	b.n	c0d061e6 <USBD_LL_DataInStage+0xd8>
                                  pep->rem_length);
        
      }
      else
      { /* last packet is MPS multiple, so send ZLP packet */
        if((pep->total_length % pep->maxpacket == 0) &&
c0d0617c:	69a6      	ldr	r6, [r4, #24]
c0d0617e:	4630      	mov	r0, r6
c0d06180:	4629      	mov	r1, r5
c0d06182:	f000 fe53 	bl	c0d06e2c <__aeabi_uidivmod>
c0d06186:	42ae      	cmp	r6, r5
c0d06188:	d30f      	bcc.n	c0d061aa <USBD_LL_DataInStage+0x9c>
c0d0618a:	2900      	cmp	r1, #0
c0d0618c:	d10d      	bne.n	c0d061aa <USBD_LL_DataInStage+0x9c>
           (pep->total_length >= pep->maxpacket) &&
             (pep->total_length < pdev->ep0_data_len ))
c0d0618e:	20d8      	movs	r0, #216	; 0xd8
c0d06190:	5820      	ldr	r0, [r4, r0]
c0d06192:	4627      	mov	r7, r4
c0d06194:	37d8      	adds	r7, #216	; 0xd8
                                  pep->rem_length);
        
      }
      else
      { /* last packet is MPS multiple, so send ZLP packet */
        if((pep->total_length % pep->maxpacket == 0) &&
c0d06196:	4286      	cmp	r6, r0
c0d06198:	d207      	bcs.n	c0d061aa <USBD_LL_DataInStage+0x9c>
c0d0619a:	2500      	movs	r5, #0
          USBD_LL_PrepareReceive (pdev,
                                  0,
                                  0);
          */

          USBD_CtlContinueSendData(pdev , NULL, 0);
c0d0619c:	4620      	mov	r0, r4
c0d0619e:	4629      	mov	r1, r5
c0d061a0:	462a      	mov	r2, r5
c0d061a2:	f000 fd23 	bl	c0d06bec <USBD_CtlContinueSendData>
          pdev->ep0_data_len = 0;
c0d061a6:	603d      	str	r5, [r7, #0]
c0d061a8:	e01d      	b.n	c0d061e6 <USBD_LL_DataInStage+0xd8>
c0d061aa:	4626      	mov	r6, r4
c0d061ac:	36dc      	adds	r6, #220	; 0xdc
c0d061ae:	2500      	movs	r5, #0
        }
        else
        {
          uint8_t intf;
          for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
            if(usbd_is_valid_intf(pdev, intf) && (pdev->interfacesClass[intf].pClass->EP0_TxSent != NULL)&&
c0d061b0:	4620      	mov	r0, r4
c0d061b2:	4629      	mov	r1, r5
c0d061b4:	f000 f866 	bl	c0d06284 <usbd_is_valid_intf>
c0d061b8:	2800      	cmp	r0, #0
c0d061ba:	d00e      	beq.n	c0d061da <USBD_LL_DataInStage+0xcc>
c0d061bc:	00e8      	lsls	r0, r5, #3
c0d061be:	1820      	adds	r0, r4, r0
c0d061c0:	21f4      	movs	r1, #244	; 0xf4
c0d061c2:	5840      	ldr	r0, [r0, r1]
c0d061c4:	68c0      	ldr	r0, [r0, #12]
c0d061c6:	2800      	cmp	r0, #0
c0d061c8:	d007      	beq.n	c0d061da <USBD_LL_DataInStage+0xcc>
               (pdev->dev_state == USBD_STATE_CONFIGURED))
c0d061ca:	7831      	ldrb	r1, [r6, #0]
        }
        else
        {
          uint8_t intf;
          for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
            if(usbd_is_valid_intf(pdev, intf) && (pdev->interfacesClass[intf].pClass->EP0_TxSent != NULL)&&
c0d061cc:	2903      	cmp	r1, #3
c0d061ce:	d104      	bne.n	c0d061da <USBD_LL_DataInStage+0xcc>
               (pdev->dev_state == USBD_STATE_CONFIGURED))
            {
              ((EP0_RxReady_t)PIC(pdev->interfacesClass[intf].pClass->EP0_TxSent))(pdev); 
c0d061d0:	f7fd fd88 	bl	c0d03ce4 <pic>
c0d061d4:	4601      	mov	r1, r0
c0d061d6:	4620      	mov	r0, r4
c0d061d8:	4788      	blx	r1
          
        }
        else
        {
          uint8_t intf;
          for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d061da:	1c6d      	adds	r5, r5, #1
c0d061dc:	2d03      	cmp	r5, #3
c0d061de:	d1e7      	bne.n	c0d061b0 <USBD_LL_DataInStage+0xa2>
               (pdev->dev_state == USBD_STATE_CONFIGURED))
            {
              ((EP0_RxReady_t)PIC(pdev->interfacesClass[intf].pClass->EP0_TxSent))(pdev); 
            }
          }
          USBD_CtlReceiveStatus(pdev);
c0d061e0:	4620      	mov	r0, r4
c0d061e2:	f000 fd24 	bl	c0d06c2e <USBD_CtlReceiveStatus>
        }
      }
    }
    if (pdev->dev_test_mode == 1)
c0d061e6:	20e0      	movs	r0, #224	; 0xe0
c0d061e8:	5c20      	ldrb	r0, [r4, r0]
c0d061ea:	34e0      	adds	r4, #224	; 0xe0
c0d061ec:	2801      	cmp	r0, #1
c0d061ee:	d101      	bne.n	c0d061f4 <USBD_LL_DataInStage+0xe6>
    {
      USBD_RunTestMode(pdev); 
      pdev->dev_test_mode = 0;
c0d061f0:	2000      	movs	r0, #0
c0d061f2:	7020      	strb	r0, [r4, #0]
      {
        ((DataIn_t)PIC(pdev->interfacesClass[intf].pClass->DataIn))(pdev, epnum); 
      }
    }
  }
  return USBD_OK;
c0d061f4:	2000      	movs	r0, #0
c0d061f6:	b001      	add	sp, #4
c0d061f8:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d061fa <USBD_LL_Reset>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_Reset(USBD_HandleTypeDef  *pdev)
{
c0d061fa:	b5b0      	push	{r4, r5, r7, lr}
c0d061fc:	4604      	mov	r4, r0
  pdev->ep_out[0].maxpacket = USB_MAX_EP0_SIZE;
c0d061fe:	2080      	movs	r0, #128	; 0x80
c0d06200:	2140      	movs	r1, #64	; 0x40
c0d06202:	5021      	str	r1, [r4, r0]
  

  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
c0d06204:	6221      	str	r1, [r4, #32]
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
c0d06206:	20dc      	movs	r0, #220	; 0xdc
c0d06208:	2101      	movs	r1, #1
c0d0620a:	5421      	strb	r1, [r4, r0]
c0d0620c:	2500      	movs	r5, #0
 
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
    if( usbd_is_valid_intf(pdev, intf))
c0d0620e:	4620      	mov	r0, r4
c0d06210:	4629      	mov	r1, r5
c0d06212:	f000 f837 	bl	c0d06284 <usbd_is_valid_intf>
c0d06216:	2800      	cmp	r0, #0
c0d06218:	d00a      	beq.n	c0d06230 <USBD_LL_Reset+0x36>
    {
      ((DeInit_t)PIC(pdev->interfacesClass[intf].pClass->DeInit))(pdev, pdev->dev_config); 
c0d0621a:	00e8      	lsls	r0, r5, #3
c0d0621c:	1820      	adds	r0, r4, r0
c0d0621e:	21f4      	movs	r1, #244	; 0xf4
c0d06220:	5840      	ldr	r0, [r0, r1]
c0d06222:	6840      	ldr	r0, [r0, #4]
c0d06224:	f7fd fd5e 	bl	c0d03ce4 <pic>
c0d06228:	4602      	mov	r2, r0
c0d0622a:	7921      	ldrb	r1, [r4, #4]
c0d0622c:	4620      	mov	r0, r4
c0d0622e:	4790      	blx	r2
  pdev->ep_in[0].maxpacket = USB_MAX_EP0_SIZE;
  /* Upon Reset call user call back */
  pdev->dev_state = USBD_STATE_DEFAULT;
 
  uint8_t intf;
  for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d06230:	1c6d      	adds	r5, r5, #1
c0d06232:	2d03      	cmp	r5, #3
c0d06234:	d1eb      	bne.n	c0d0620e <USBD_LL_Reset+0x14>
    {
      ((DeInit_t)PIC(pdev->interfacesClass[intf].pClass->DeInit))(pdev, pdev->dev_config); 
    }
  }
  
  return USBD_OK;
c0d06236:	2000      	movs	r0, #0
c0d06238:	bdb0      	pop	{r4, r5, r7, pc}

c0d0623a <USBD_LL_SetSpeed>:
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef USBD_LL_SetSpeed(USBD_HandleTypeDef  *pdev, USBD_SpeedTypeDef speed)
{
  pdev->dev_speed = speed;
c0d0623a:	7401      	strb	r1, [r0, #16]
c0d0623c:	2000      	movs	r0, #0
  return USBD_OK;
c0d0623e:	4770      	bx	lr

c0d06240 <USBD_LL_Suspend>:
{
  UNUSED(pdev);
  // Ignored, gently
  //pdev->dev_old_state =  pdev->dev_state;
  //pdev->dev_state  = USBD_STATE_SUSPENDED;
  return USBD_OK;
c0d06240:	2000      	movs	r0, #0
c0d06242:	4770      	bx	lr

c0d06244 <USBD_LL_Resume>:
USBD_StatusTypeDef USBD_LL_Resume(USBD_HandleTypeDef  *pdev)
{
  UNUSED(pdev);
  // Ignored, gently
  //pdev->dev_state = pdev->dev_old_state;  
  return USBD_OK;
c0d06244:	2000      	movs	r0, #0
c0d06246:	4770      	bx	lr

c0d06248 <USBD_LL_SOF>:
* @param  pdev: device instance
* @retval status
*/

USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
c0d06248:	b5b0      	push	{r4, r5, r7, lr}
c0d0624a:	4604      	mov	r4, r0
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
c0d0624c:	20dc      	movs	r0, #220	; 0xdc
c0d0624e:	5c20      	ldrb	r0, [r4, r0]
c0d06250:	2803      	cmp	r0, #3
c0d06252:	d115      	bne.n	c0d06280 <USBD_LL_SOF+0x38>
c0d06254:	2500      	movs	r5, #0
  {
    uint8_t intf;
    for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
      if( usbd_is_valid_intf(pdev, intf) && pdev->interfacesClass[intf].pClass->SOF != NULL)
c0d06256:	4620      	mov	r0, r4
c0d06258:	4629      	mov	r1, r5
c0d0625a:	f000 f813 	bl	c0d06284 <usbd_is_valid_intf>
c0d0625e:	2800      	cmp	r0, #0
c0d06260:	d00b      	beq.n	c0d0627a <USBD_LL_SOF+0x32>
c0d06262:	00e8      	lsls	r0, r5, #3
c0d06264:	1820      	adds	r0, r4, r0
c0d06266:	21f4      	movs	r1, #244	; 0xf4
c0d06268:	5840      	ldr	r0, [r0, r1]
c0d0626a:	69c0      	ldr	r0, [r0, #28]
c0d0626c:	2800      	cmp	r0, #0
c0d0626e:	d004      	beq.n	c0d0627a <USBD_LL_SOF+0x32>
      {
        ((SOF_t)PIC(pdev->interfacesClass[intf].pClass->SOF))(pdev); 
c0d06270:	f7fd fd38 	bl	c0d03ce4 <pic>
c0d06274:	4601      	mov	r1, r0
c0d06276:	4620      	mov	r0, r4
c0d06278:	4788      	blx	r1
USBD_StatusTypeDef USBD_LL_SOF(USBD_HandleTypeDef  *pdev)
{
  if(pdev->dev_state == USBD_STATE_CONFIGURED)
  {
    uint8_t intf;
    for (intf =0; intf < USBD_MAX_NUM_INTERFACES; intf++) {
c0d0627a:	1c6d      	adds	r5, r5, #1
c0d0627c:	2d03      	cmp	r5, #3
c0d0627e:	d1ea      	bne.n	c0d06256 <USBD_LL_SOF+0xe>
      {
        ((SOF_t)PIC(pdev->interfacesClass[intf].pClass->SOF))(pdev); 
      }
    }
  }
  return USBD_OK;
c0d06280:	2000      	movs	r0, #0
c0d06282:	bdb0      	pop	{r4, r5, r7, pc}

c0d06284 <usbd_is_valid_intf>:

/** @defgroup USBD_REQ_Private_Functions
  * @{
  */ 

unsigned int usbd_is_valid_intf(USBD_HandleTypeDef *pdev , unsigned int intf) {
c0d06284:	4602      	mov	r2, r0
c0d06286:	2000      	movs	r0, #0
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d06288:	2902      	cmp	r1, #2
c0d0628a:	d807      	bhi.n	c0d0629c <usbd_is_valid_intf+0x18>
c0d0628c:	00c8      	lsls	r0, r1, #3
c0d0628e:	1810      	adds	r0, r2, r0
c0d06290:	21f4      	movs	r1, #244	; 0xf4
c0d06292:	5841      	ldr	r1, [r0, r1]
c0d06294:	2001      	movs	r0, #1
c0d06296:	2900      	cmp	r1, #0
c0d06298:	d100      	bne.n	c0d0629c <usbd_is_valid_intf+0x18>
c0d0629a:	4608      	mov	r0, r1
c0d0629c:	4770      	bx	lr

c0d0629e <USBD_StdDevReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdDevReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
c0d0629e:	b580      	push	{r7, lr}
c0d062a0:	784a      	ldrb	r2, [r1, #1]
  USBD_StatusTypeDef ret = USBD_OK;  
  
  switch (req->bRequest) 
c0d062a2:	2a04      	cmp	r2, #4
c0d062a4:	dd08      	ble.n	c0d062b8 <USBD_StdDevReq+0x1a>
c0d062a6:	2a07      	cmp	r2, #7
c0d062a8:	dc0f      	bgt.n	c0d062ca <USBD_StdDevReq+0x2c>
c0d062aa:	2a05      	cmp	r2, #5
c0d062ac:	d014      	beq.n	c0d062d8 <USBD_StdDevReq+0x3a>
c0d062ae:	2a06      	cmp	r2, #6
c0d062b0:	d11b      	bne.n	c0d062ea <USBD_StdDevReq+0x4c>
  {
  case USB_REQ_GET_DESCRIPTOR: 
    
    USBD_GetDescriptor (pdev, req) ;
c0d062b2:	f000 f821 	bl	c0d062f8 <USBD_GetDescriptor>
c0d062b6:	e01d      	b.n	c0d062f4 <USBD_StdDevReq+0x56>
c0d062b8:	2a00      	cmp	r2, #0
c0d062ba:	d010      	beq.n	c0d062de <USBD_StdDevReq+0x40>
c0d062bc:	2a01      	cmp	r2, #1
c0d062be:	d017      	beq.n	c0d062f0 <USBD_StdDevReq+0x52>
c0d062c0:	2a03      	cmp	r2, #3
c0d062c2:	d112      	bne.n	c0d062ea <USBD_StdDevReq+0x4c>
    USBD_GetStatus (pdev , req);
    break;
    
    
  case USB_REQ_SET_FEATURE:   
    USBD_SetFeature (pdev , req);    
c0d062c4:	f000 f92f 	bl	c0d06526 <USBD_SetFeature>
c0d062c8:	e014      	b.n	c0d062f4 <USBD_StdDevReq+0x56>
c0d062ca:	2a08      	cmp	r2, #8
c0d062cc:	d00a      	beq.n	c0d062e4 <USBD_StdDevReq+0x46>
c0d062ce:	2a09      	cmp	r2, #9
c0d062d0:	d10b      	bne.n	c0d062ea <USBD_StdDevReq+0x4c>
  case USB_REQ_SET_ADDRESS:                      
    USBD_SetAddress(pdev, req);
    break;
    
  case USB_REQ_SET_CONFIGURATION:                    
    USBD_SetConfig (pdev , req);
c0d062d2:	f000 f8b8 	bl	c0d06446 <USBD_SetConfig>
c0d062d6:	e00d      	b.n	c0d062f4 <USBD_StdDevReq+0x56>
    
    USBD_GetDescriptor (pdev, req) ;
    break;
    
  case USB_REQ_SET_ADDRESS:                      
    USBD_SetAddress(pdev, req);
c0d062d8:	f000 f890 	bl	c0d063fc <USBD_SetAddress>
c0d062dc:	e00a      	b.n	c0d062f4 <USBD_StdDevReq+0x56>
  case USB_REQ_GET_CONFIGURATION:                 
    USBD_GetConfig (pdev , req);
    break;
    
  case USB_REQ_GET_STATUS:                                  
    USBD_GetStatus (pdev , req);
c0d062de:	f000 f900 	bl	c0d064e2 <USBD_GetStatus>
c0d062e2:	e007      	b.n	c0d062f4 <USBD_StdDevReq+0x56>
  case USB_REQ_SET_CONFIGURATION:                    
    USBD_SetConfig (pdev , req);
    break;
    
  case USB_REQ_GET_CONFIGURATION:                 
    USBD_GetConfig (pdev , req);
c0d062e4:	f000 f8e6 	bl	c0d064b4 <USBD_GetConfig>
c0d062e8:	e004      	b.n	c0d062f4 <USBD_StdDevReq+0x56>
  case USB_REQ_CLEAR_FEATURE:                                   
    USBD_ClrFeature (pdev , req);
    break;
    
  default:  
    USBD_CtlError(pdev , req);
c0d062ea:	f000 fbe7 	bl	c0d06abc <USBD_CtlError>
c0d062ee:	e001      	b.n	c0d062f4 <USBD_StdDevReq+0x56>
  case USB_REQ_SET_FEATURE:   
    USBD_SetFeature (pdev , req);    
    break;
    
  case USB_REQ_CLEAR_FEATURE:                                   
    USBD_ClrFeature (pdev , req);
c0d062f0:	f000 f936 	bl	c0d06560 <USBD_ClrFeature>
  default:  
    USBD_CtlError(pdev , req);
    break;
  }
  
  return ret;
c0d062f4:	2000      	movs	r0, #0
c0d062f6:	bd80      	pop	{r7, pc}

c0d062f8 <USBD_GetDescriptor>:
* @param  req: usb request
* @retval status
*/
void USBD_GetDescriptor(USBD_HandleTypeDef *pdev , 
                               USBD_SetupReqTypedef *req)
{
c0d062f8:	b5b0      	push	{r4, r5, r7, lr}
c0d062fa:	b082      	sub	sp, #8
c0d062fc:	460d      	mov	r5, r1
c0d062fe:	4604      	mov	r4, r0
  uint16_t len;
  uint8_t *pbuf = NULL;
  
    
  switch (req->wValue >> 8)
c0d06300:	8869      	ldrh	r1, [r5, #2]
c0d06302:	0a08      	lsrs	r0, r1, #8
c0d06304:	2805      	cmp	r0, #5
c0d06306:	dc12      	bgt.n	c0d0632e <USBD_GetDescriptor+0x36>
c0d06308:	2801      	cmp	r0, #1
c0d0630a:	d01a      	beq.n	c0d06342 <USBD_GetDescriptor+0x4a>
c0d0630c:	2802      	cmp	r0, #2
c0d0630e:	d022      	beq.n	c0d06356 <USBD_GetDescriptor+0x5e>
c0d06310:	2803      	cmp	r0, #3
c0d06312:	d136      	bne.n	c0d06382 <USBD_GetDescriptor+0x8a>
c0d06314:	b2c8      	uxtb	r0, r1
      }
    }
    break;
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
c0d06316:	2802      	cmp	r0, #2
c0d06318:	dc38      	bgt.n	c0d0638c <USBD_GetDescriptor+0x94>
c0d0631a:	2800      	cmp	r0, #0
c0d0631c:	d05e      	beq.n	c0d063dc <USBD_GetDescriptor+0xe4>
c0d0631e:	2801      	cmp	r0, #1
c0d06320:	d064      	beq.n	c0d063ec <USBD_GetDescriptor+0xf4>
c0d06322:	2802      	cmp	r0, #2
c0d06324:	d12d      	bne.n	c0d06382 <USBD_GetDescriptor+0x8a>
    case USBD_IDX_MFC_STR:
      pbuf = ((GetManufacturerStrDescriptor_t)PIC(pdev->pDesc->GetManufacturerStrDescriptor))(pdev->dev_speed, &len);
      break;
      
    case USBD_IDX_PRODUCT_STR:
      pbuf = ((GetProductStrDescriptor_t)PIC(pdev->pDesc->GetProductStrDescriptor))(pdev->dev_speed, &len);
c0d06326:	20f0      	movs	r0, #240	; 0xf0
c0d06328:	5820      	ldr	r0, [r4, r0]
c0d0632a:	68c0      	ldr	r0, [r0, #12]
c0d0632c:	e00c      	b.n	c0d06348 <USBD_GetDescriptor+0x50>
c0d0632e:	2806      	cmp	r0, #6
c0d06330:	d01b      	beq.n	c0d0636a <USBD_GetDescriptor+0x72>
c0d06332:	2807      	cmp	r0, #7
c0d06334:	d022      	beq.n	c0d0637c <USBD_GetDescriptor+0x84>
c0d06336:	280f      	cmp	r0, #15
c0d06338:	d123      	bne.n	c0d06382 <USBD_GetDescriptor+0x8a>
    
  switch (req->wValue >> 8)
  { 
#if (USBD_LPM_ENABLED == 1)
  case USB_DESC_TYPE_BOS:
    pbuf = ((GetBOSDescriptor_t)PIC(pdev->pDesc->GetBOSDescriptor))(pdev->dev_speed, &len);
c0d0633a:	20f0      	movs	r0, #240	; 0xf0
c0d0633c:	5820      	ldr	r0, [r4, r0]
c0d0633e:	69c0      	ldr	r0, [r0, #28]
c0d06340:	e002      	b.n	c0d06348 <USBD_GetDescriptor+0x50>
    break;
#endif    
  case USB_DESC_TYPE_DEVICE:
    pbuf = ((GetDeviceDescriptor_t)PIC(pdev->pDesc->GetDeviceDescriptor))(pdev->dev_speed, &len);
c0d06342:	20f0      	movs	r0, #240	; 0xf0
c0d06344:	5820      	ldr	r0, [r4, r0]
c0d06346:	6800      	ldr	r0, [r0, #0]
c0d06348:	f7fd fccc 	bl	c0d03ce4 <pic>
c0d0634c:	4602      	mov	r2, r0
c0d0634e:	7c20      	ldrb	r0, [r4, #16]
c0d06350:	a901      	add	r1, sp, #4
c0d06352:	4790      	blx	r2
c0d06354:	e030      	b.n	c0d063b8 <USBD_GetDescriptor+0xc0>
    break;
    
  case USB_DESC_TYPE_CONFIGURATION:     
    if(pdev->interfacesClass[0].pClass != NULL) {
c0d06356:	20f4      	movs	r0, #244	; 0xf4
c0d06358:	5820      	ldr	r0, [r4, r0]
c0d0635a:	2100      	movs	r1, #0
c0d0635c:	2800      	cmp	r0, #0
c0d0635e:	d02c      	beq.n	c0d063ba <USBD_GetDescriptor+0xc2>
      if(pdev->dev_speed == USBD_SPEED_HIGH )   
c0d06360:	7c21      	ldrb	r1, [r4, #16]
c0d06362:	2900      	cmp	r1, #0
c0d06364:	d022      	beq.n	c0d063ac <USBD_GetDescriptor+0xb4>
        pbuf   = (uint8_t *)((GetHSConfigDescriptor_t)PIC(pdev->interfacesClass[0].pClass->GetHSConfigDescriptor))(&len);
        //pbuf[1] = USB_DESC_TYPE_CONFIGURATION; CONST BUFFER KTHX
      }
      else
      {
        pbuf   = (uint8_t *)((GetFSConfigDescriptor_t)PIC(pdev->interfacesClass[0].pClass->GetFSConfigDescriptor))(&len);
c0d06366:	6ac0      	ldr	r0, [r0, #44]	; 0x2c
c0d06368:	e021      	b.n	c0d063ae <USBD_GetDescriptor+0xb6>
#endif   
    }
    break;
  case USB_DESC_TYPE_DEVICE_QUALIFIER:                   

    if(pdev->dev_speed == USBD_SPEED_HIGH && pdev->interfacesClass[0].pClass != NULL )   
c0d0636a:	7c20      	ldrb	r0, [r4, #16]
c0d0636c:	2800      	cmp	r0, #0
c0d0636e:	d108      	bne.n	c0d06382 <USBD_GetDescriptor+0x8a>
c0d06370:	20f4      	movs	r0, #244	; 0xf4
c0d06372:	5820      	ldr	r0, [r4, r0]
c0d06374:	2800      	cmp	r0, #0
c0d06376:	d004      	beq.n	c0d06382 <USBD_GetDescriptor+0x8a>
    {
      pbuf   = (uint8_t *)((GetDeviceQualifierDescriptor_t)PIC(pdev->interfacesClass[0].pClass->GetDeviceQualifierDescriptor))(&len);
c0d06378:	6b40      	ldr	r0, [r0, #52]	; 0x34
c0d0637a:	e018      	b.n	c0d063ae <USBD_GetDescriptor+0xb6>
      USBD_CtlError(pdev , req);
      return;
    } 

  case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    if(pdev->dev_speed == USBD_SPEED_HIGH && pdev->interfacesClass[0].pClass != NULL)   
c0d0637c:	7c20      	ldrb	r0, [r4, #16]
c0d0637e:	2800      	cmp	r0, #0
c0d06380:	d00e      	beq.n	c0d063a0 <USBD_GetDescriptor+0xa8>
c0d06382:	4620      	mov	r0, r4
c0d06384:	4629      	mov	r1, r5
c0d06386:	f000 fb99 	bl	c0d06abc <USBD_CtlError>
c0d0638a:	e025      	b.n	c0d063d8 <USBD_GetDescriptor+0xe0>
c0d0638c:	2803      	cmp	r0, #3
c0d0638e:	d029      	beq.n	c0d063e4 <USBD_GetDescriptor+0xec>
c0d06390:	2804      	cmp	r0, #4
c0d06392:	d02f      	beq.n	c0d063f4 <USBD_GetDescriptor+0xfc>
c0d06394:	2805      	cmp	r0, #5
c0d06396:	d1f4      	bne.n	c0d06382 <USBD_GetDescriptor+0x8a>
    case USBD_IDX_CONFIG_STR:
      pbuf = ((GetConfigurationStrDescriptor_t)PIC(pdev->pDesc->GetConfigurationStrDescriptor))(pdev->dev_speed, &len);
      break;
      
    case USBD_IDX_INTERFACE_STR:
      pbuf = ((GetInterfaceStrDescriptor_t)PIC(pdev->pDesc->GetInterfaceStrDescriptor))(pdev->dev_speed, &len);
c0d06398:	20f0      	movs	r0, #240	; 0xf0
c0d0639a:	5820      	ldr	r0, [r4, r0]
c0d0639c:	6980      	ldr	r0, [r0, #24]
c0d0639e:	e7d3      	b.n	c0d06348 <USBD_GetDescriptor+0x50>
      USBD_CtlError(pdev , req);
      return;
    } 

  case USB_DESC_TYPE_OTHER_SPEED_CONFIGURATION:
    if(pdev->dev_speed == USBD_SPEED_HIGH && pdev->interfacesClass[0].pClass != NULL)   
c0d063a0:	20f4      	movs	r0, #244	; 0xf4
c0d063a2:	5820      	ldr	r0, [r4, r0]
c0d063a4:	2800      	cmp	r0, #0
c0d063a6:	d0ec      	beq.n	c0d06382 <USBD_GetDescriptor+0x8a>
    {
      pbuf   = (uint8_t *)((GetOtherSpeedConfigDescriptor_t)PIC(pdev->interfacesClass[0].pClass->GetOtherSpeedConfigDescriptor))(&len);
c0d063a8:	6b00      	ldr	r0, [r0, #48]	; 0x30
c0d063aa:	e000      	b.n	c0d063ae <USBD_GetDescriptor+0xb6>
    
  case USB_DESC_TYPE_CONFIGURATION:     
    if(pdev->interfacesClass[0].pClass != NULL) {
      if(pdev->dev_speed == USBD_SPEED_HIGH )   
      {
        pbuf   = (uint8_t *)((GetHSConfigDescriptor_t)PIC(pdev->interfacesClass[0].pClass->GetHSConfigDescriptor))(&len);
c0d063ac:	6a80      	ldr	r0, [r0, #40]	; 0x28
c0d063ae:	f7fd fc99 	bl	c0d03ce4 <pic>
c0d063b2:	4601      	mov	r1, r0
c0d063b4:	a801      	add	r0, sp, #4
c0d063b6:	4788      	blx	r1
c0d063b8:	4601      	mov	r1, r0
c0d063ba:	a801      	add	r0, sp, #4
  default: 
     USBD_CtlError(pdev , req);
    return;
  }
  
  if((len != 0)&& (req->wLength != 0))
c0d063bc:	8802      	ldrh	r2, [r0, #0]
c0d063be:	2a00      	cmp	r2, #0
c0d063c0:	d00a      	beq.n	c0d063d8 <USBD_GetDescriptor+0xe0>
c0d063c2:	88e8      	ldrh	r0, [r5, #6]
c0d063c4:	2800      	cmp	r0, #0
c0d063c6:	d007      	beq.n	c0d063d8 <USBD_GetDescriptor+0xe0>
  {
    
    len = MIN(len , req->wLength);
c0d063c8:	4282      	cmp	r2, r0
c0d063ca:	d300      	bcc.n	c0d063ce <USBD_GetDescriptor+0xd6>
c0d063cc:	4602      	mov	r2, r0
c0d063ce:	a801      	add	r0, sp, #4
c0d063d0:	8002      	strh	r2, [r0, #0]
    
    // prepare abort if host does not read the whole data
    //USBD_CtlReceiveStatus(pdev);

    // start transfer
    USBD_CtlSendData (pdev, 
c0d063d2:	4620      	mov	r0, r4
c0d063d4:	f000 fbf4 	bl	c0d06bc0 <USBD_CtlSendData>
                      pbuf,
                      len);
  }
  
}
c0d063d8:	b002      	add	sp, #8
c0d063da:	bdb0      	pop	{r4, r5, r7, pc}
    
  case USB_DESC_TYPE_STRING:
    switch ((uint8_t)(req->wValue))
    {
    case USBD_IDX_LANGID_STR:
     pbuf = ((GetLangIDStrDescriptor_t)PIC(pdev->pDesc->GetLangIDStrDescriptor))(pdev->dev_speed, &len);        
c0d063dc:	20f0      	movs	r0, #240	; 0xf0
c0d063de:	5820      	ldr	r0, [r4, r0]
c0d063e0:	6840      	ldr	r0, [r0, #4]
c0d063e2:	e7b1      	b.n	c0d06348 <USBD_GetDescriptor+0x50>
    case USBD_IDX_PRODUCT_STR:
      pbuf = ((GetProductStrDescriptor_t)PIC(pdev->pDesc->GetProductStrDescriptor))(pdev->dev_speed, &len);
      break;
      
    case USBD_IDX_SERIAL_STR:
      pbuf = ((GetSerialStrDescriptor_t)PIC(pdev->pDesc->GetSerialStrDescriptor))(pdev->dev_speed, &len);
c0d063e4:	20f0      	movs	r0, #240	; 0xf0
c0d063e6:	5820      	ldr	r0, [r4, r0]
c0d063e8:	6900      	ldr	r0, [r0, #16]
c0d063ea:	e7ad      	b.n	c0d06348 <USBD_GetDescriptor+0x50>
    case USBD_IDX_LANGID_STR:
     pbuf = ((GetLangIDStrDescriptor_t)PIC(pdev->pDesc->GetLangIDStrDescriptor))(pdev->dev_speed, &len);        
      break;
      
    case USBD_IDX_MFC_STR:
      pbuf = ((GetManufacturerStrDescriptor_t)PIC(pdev->pDesc->GetManufacturerStrDescriptor))(pdev->dev_speed, &len);
c0d063ec:	20f0      	movs	r0, #240	; 0xf0
c0d063ee:	5820      	ldr	r0, [r4, r0]
c0d063f0:	6880      	ldr	r0, [r0, #8]
c0d063f2:	e7a9      	b.n	c0d06348 <USBD_GetDescriptor+0x50>
    case USBD_IDX_SERIAL_STR:
      pbuf = ((GetSerialStrDescriptor_t)PIC(pdev->pDesc->GetSerialStrDescriptor))(pdev->dev_speed, &len);
      break;
      
    case USBD_IDX_CONFIG_STR:
      pbuf = ((GetConfigurationStrDescriptor_t)PIC(pdev->pDesc->GetConfigurationStrDescriptor))(pdev->dev_speed, &len);
c0d063f4:	20f0      	movs	r0, #240	; 0xf0
c0d063f6:	5820      	ldr	r0, [r4, r0]
c0d063f8:	6940      	ldr	r0, [r0, #20]
c0d063fa:	e7a5      	b.n	c0d06348 <USBD_GetDescriptor+0x50>

c0d063fc <USBD_SetAddress>:
* @param  req: usb request
* @retval status
*/
void USBD_SetAddress(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
c0d063fc:	b570      	push	{r4, r5, r6, lr}
c0d063fe:	4604      	mov	r4, r0
  uint8_t  dev_addr; 
  
  if ((req->wIndex == 0) && (req->wLength == 0)) 
c0d06400:	8888      	ldrh	r0, [r1, #4]
c0d06402:	2800      	cmp	r0, #0
c0d06404:	d10b      	bne.n	c0d0641e <USBD_SetAddress+0x22>
c0d06406:	88c8      	ldrh	r0, [r1, #6]
c0d06408:	2800      	cmp	r0, #0
c0d0640a:	d108      	bne.n	c0d0641e <USBD_SetAddress+0x22>
  {
    dev_addr = (uint8_t)(req->wValue) & 0x7F;     
c0d0640c:	8848      	ldrh	r0, [r1, #2]
c0d0640e:	267f      	movs	r6, #127	; 0x7f
c0d06410:	4006      	ands	r6, r0
    
    if (pdev->dev_state == USBD_STATE_CONFIGURED) 
c0d06412:	20dc      	movs	r0, #220	; 0xdc
c0d06414:	5c20      	ldrb	r0, [r4, r0]
c0d06416:	4625      	mov	r5, r4
c0d06418:	35dc      	adds	r5, #220	; 0xdc
c0d0641a:	2803      	cmp	r0, #3
c0d0641c:	d103      	bne.n	c0d06426 <USBD_SetAddress+0x2a>
c0d0641e:	4620      	mov	r0, r4
c0d06420:	f000 fb4c 	bl	c0d06abc <USBD_CtlError>
  } 
  else 
  {
     USBD_CtlError(pdev , req);                        
  } 
}
c0d06424:	bd70      	pop	{r4, r5, r6, pc}
    {
      USBD_CtlError(pdev , req);
    } 
    else 
    {
      pdev->dev_address = dev_addr;
c0d06426:	20de      	movs	r0, #222	; 0xde
c0d06428:	5426      	strb	r6, [r4, r0]
      USBD_LL_SetUSBAddress(pdev, dev_addr);               
c0d0642a:	b2f1      	uxtb	r1, r6
c0d0642c:	4620      	mov	r0, r4
c0d0642e:	f7ff fd2b 	bl	c0d05e88 <USBD_LL_SetUSBAddress>
      USBD_CtlSendStatus(pdev);                         
c0d06432:	4620      	mov	r0, r4
c0d06434:	f000 fbef 	bl	c0d06c16 <USBD_CtlSendStatus>
      
      if (dev_addr != 0) 
c0d06438:	2002      	movs	r0, #2
c0d0643a:	2101      	movs	r1, #1
c0d0643c:	2e00      	cmp	r6, #0
c0d0643e:	d100      	bne.n	c0d06442 <USBD_SetAddress+0x46>
c0d06440:	4608      	mov	r0, r1
c0d06442:	7028      	strb	r0, [r5, #0]
  } 
  else 
  {
     USBD_CtlError(pdev , req);                        
  } 
}
c0d06444:	bd70      	pop	{r4, r5, r6, pc}

c0d06446 <USBD_SetConfig>:
* @param  req: usb request
* @retval status
*/
void USBD_SetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
c0d06446:	b570      	push	{r4, r5, r6, lr}
c0d06448:	460d      	mov	r5, r1
c0d0644a:	4604      	mov	r4, r0
  
  uint8_t  cfgidx;
  
  cfgidx = (uint8_t)(req->wValue);                 
c0d0644c:	78ae      	ldrb	r6, [r5, #2]
  
  if (cfgidx > USBD_MAX_NUM_CONFIGURATION ) 
c0d0644e:	2e02      	cmp	r6, #2
c0d06450:	d21d      	bcs.n	c0d0648e <USBD_SetConfig+0x48>
  {            
     USBD_CtlError(pdev , req);                              
  } 
  else 
  {
    switch (pdev->dev_state) 
c0d06452:	20dc      	movs	r0, #220	; 0xdc
c0d06454:	5c21      	ldrb	r1, [r4, r0]
c0d06456:	4620      	mov	r0, r4
c0d06458:	30dc      	adds	r0, #220	; 0xdc
c0d0645a:	2903      	cmp	r1, #3
c0d0645c:	d007      	beq.n	c0d0646e <USBD_SetConfig+0x28>
c0d0645e:	2902      	cmp	r1, #2
c0d06460:	d115      	bne.n	c0d0648e <USBD_SetConfig+0x48>
    {
    case USBD_STATE_ADDRESSED:
      if (cfgidx) 
c0d06462:	2e00      	cmp	r6, #0
c0d06464:	d022      	beq.n	c0d064ac <USBD_SetConfig+0x66>
      {                                			   							   							   				
        pdev->dev_config = cfgidx;
c0d06466:	6066      	str	r6, [r4, #4]
        pdev->dev_state = USBD_STATE_CONFIGURED;
c0d06468:	2103      	movs	r1, #3
c0d0646a:	7001      	strb	r1, [r0, #0]
c0d0646c:	e009      	b.n	c0d06482 <USBD_SetConfig+0x3c>
      }
      USBD_CtlSendStatus(pdev);
      break;
      
    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0) 
c0d0646e:	2e00      	cmp	r6, #0
c0d06470:	d012      	beq.n	c0d06498 <USBD_SetConfig+0x52>
        pdev->dev_state = USBD_STATE_ADDRESSED;
        pdev->dev_config = cfgidx;          
        USBD_ClrClassConfig(pdev , cfgidx);
        USBD_CtlSendStatus(pdev);
      } 
      else  if (cfgidx != pdev->dev_config) 
c0d06472:	6860      	ldr	r0, [r4, #4]
c0d06474:	4286      	cmp	r6, r0
c0d06476:	d019      	beq.n	c0d064ac <USBD_SetConfig+0x66>
      {
        /* Clear old configuration */
        USBD_ClrClassConfig(pdev , pdev->dev_config);
c0d06478:	b2c1      	uxtb	r1, r0
c0d0647a:	4620      	mov	r0, r4
c0d0647c:	f7ff fda5 	bl	c0d05fca <USBD_ClrClassConfig>
        
        /* set new configuration */
        pdev->dev_config = cfgidx;
c0d06480:	6066      	str	r6, [r4, #4]
c0d06482:	4620      	mov	r0, r4
c0d06484:	4631      	mov	r1, r6
c0d06486:	f7ff fd86 	bl	c0d05f96 <USBD_SetClassConfig>
c0d0648a:	2802      	cmp	r0, #2
c0d0648c:	d10e      	bne.n	c0d064ac <USBD_SetConfig+0x66>
c0d0648e:	4620      	mov	r0, r4
c0d06490:	4629      	mov	r1, r5
c0d06492:	f000 fb13 	bl	c0d06abc <USBD_CtlError>
    default:					
       USBD_CtlError(pdev , req);                     
      break;
    }
  }
}
c0d06496:	bd70      	pop	{r4, r5, r6, pc}
      break;
      
    case USBD_STATE_CONFIGURED:
      if (cfgidx == 0) 
      {                           
        pdev->dev_state = USBD_STATE_ADDRESSED;
c0d06498:	2102      	movs	r1, #2
c0d0649a:	7001      	strb	r1, [r0, #0]
        pdev->dev_config = cfgidx;          
c0d0649c:	6066      	str	r6, [r4, #4]
        USBD_ClrClassConfig(pdev , cfgidx);
c0d0649e:	4620      	mov	r0, r4
c0d064a0:	4631      	mov	r1, r6
c0d064a2:	f7ff fd92 	bl	c0d05fca <USBD_ClrClassConfig>
        USBD_CtlSendStatus(pdev);
c0d064a6:	4620      	mov	r0, r4
c0d064a8:	f000 fbb5 	bl	c0d06c16 <USBD_CtlSendStatus>
c0d064ac:	4620      	mov	r0, r4
c0d064ae:	f000 fbb2 	bl	c0d06c16 <USBD_CtlSendStatus>
    default:					
       USBD_CtlError(pdev , req);                     
      break;
    }
  }
}
c0d064b2:	bd70      	pop	{r4, r5, r6, pc}

c0d064b4 <USBD_GetConfig>:
* @param  req: usb request
* @retval status
*/
void USBD_GetConfig(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
c0d064b4:	b580      	push	{r7, lr}

  if (req->wLength != 1) 
c0d064b6:	88ca      	ldrh	r2, [r1, #6]
c0d064b8:	2a01      	cmp	r2, #1
c0d064ba:	d10a      	bne.n	c0d064d2 <USBD_GetConfig+0x1e>
  {                   
     USBD_CtlError(pdev , req);
  }
  else 
  {
    switch (pdev->dev_state )  
c0d064bc:	22dc      	movs	r2, #220	; 0xdc
c0d064be:	5c82      	ldrb	r2, [r0, r2]
c0d064c0:	2a03      	cmp	r2, #3
c0d064c2:	d009      	beq.n	c0d064d8 <USBD_GetConfig+0x24>
c0d064c4:	2a02      	cmp	r2, #2
c0d064c6:	d104      	bne.n	c0d064d2 <USBD_GetConfig+0x1e>
    {
    case USBD_STATE_ADDRESSED:                     
      pdev->dev_default_config = 0;
c0d064c8:	2100      	movs	r1, #0
c0d064ca:	6081      	str	r1, [r0, #8]
c0d064cc:	4601      	mov	r1, r0
c0d064ce:	3108      	adds	r1, #8
c0d064d0:	e003      	b.n	c0d064da <USBD_GetConfig+0x26>
c0d064d2:	f000 faf3 	bl	c0d06abc <USBD_CtlError>
    default:
       USBD_CtlError(pdev , req);
      break;
    }
  }
}
c0d064d6:	bd80      	pop	{r7, pc}
                        1);
      break;
      
    case USBD_STATE_CONFIGURED:   
      USBD_CtlSendData (pdev, 
                        (uint8_t *)&pdev->dev_config,
c0d064d8:	1d01      	adds	r1, r0, #4
c0d064da:	2201      	movs	r2, #1
c0d064dc:	f000 fb70 	bl	c0d06bc0 <USBD_CtlSendData>
    default:
       USBD_CtlError(pdev , req);
      break;
    }
  }
}
c0d064e0:	bd80      	pop	{r7, pc}

c0d064e2 <USBD_GetStatus>:
* @param  req: usb request
* @retval status
*/
void USBD_GetStatus(USBD_HandleTypeDef *pdev , 
                           USBD_SetupReqTypedef *req)
{
c0d064e2:	b5b0      	push	{r4, r5, r7, lr}
c0d064e4:	4604      	mov	r4, r0
  
    
  switch (pdev->dev_state) 
c0d064e6:	20dc      	movs	r0, #220	; 0xdc
c0d064e8:	5c20      	ldrb	r0, [r4, r0]
c0d064ea:	22fe      	movs	r2, #254	; 0xfe
c0d064ec:	4002      	ands	r2, r0
c0d064ee:	2a02      	cmp	r2, #2
c0d064f0:	d115      	bne.n	c0d0651e <USBD_GetStatus+0x3c>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    
#if ( USBD_SELF_POWERED == 1)
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
c0d064f2:	2001      	movs	r0, #1
c0d064f4:	60e0      	str	r0, [r4, #12]
#else
    pdev->dev_config_status = 0;                                   
#endif
                      
    if (pdev->dev_remote_wakeup) USBD_CtlReceiveStatus(pdev);
c0d064f6:	20e4      	movs	r0, #228	; 0xe4
c0d064f8:	5821      	ldr	r1, [r4, r0]
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    
#if ( USBD_SELF_POWERED == 1)
    pdev->dev_config_status = USB_CONFIG_SELF_POWERED;                                  
c0d064fa:	4625      	mov	r5, r4
c0d064fc:	350c      	adds	r5, #12
c0d064fe:	2003      	movs	r0, #3
#else
    pdev->dev_config_status = 0;                                   
#endif
                      
    if (pdev->dev_remote_wakeup) USBD_CtlReceiveStatus(pdev);
c0d06500:	2900      	cmp	r1, #0
c0d06502:	d005      	beq.n	c0d06510 <USBD_GetStatus+0x2e>
c0d06504:	4620      	mov	r0, r4
c0d06506:	f000 fb92 	bl	c0d06c2e <USBD_CtlReceiveStatus>
c0d0650a:	68e1      	ldr	r1, [r4, #12]
c0d0650c:	2002      	movs	r0, #2
c0d0650e:	4308      	orrs	r0, r1
    {
       pdev->dev_config_status |= USB_CONFIG_REMOTE_WAKEUP;                                
c0d06510:	60e0      	str	r0, [r4, #12]
    }
    
    USBD_CtlSendData (pdev, 
c0d06512:	2202      	movs	r2, #2
c0d06514:	4620      	mov	r0, r4
c0d06516:	4629      	mov	r1, r5
c0d06518:	f000 fb52 	bl	c0d06bc0 <USBD_CtlSendData>
    
  default :
    USBD_CtlError(pdev , req);                        
    break;
  }
}
c0d0651c:	bdb0      	pop	{r4, r5, r7, pc}
                      (uint8_t *)& pdev->dev_config_status,
                      2);
    break;
    
  default :
    USBD_CtlError(pdev , req);                        
c0d0651e:	4620      	mov	r0, r4
c0d06520:	f000 facc 	bl	c0d06abc <USBD_CtlError>
    break;
  }
}
c0d06524:	bdb0      	pop	{r4, r5, r7, pc}

c0d06526 <USBD_SetFeature>:
* @param  req: usb request
* @retval status
*/
void USBD_SetFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
c0d06526:	b5b0      	push	{r4, r5, r7, lr}
c0d06528:	460d      	mov	r5, r1
c0d0652a:	4604      	mov	r4, r0

  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
c0d0652c:	8868      	ldrh	r0, [r5, #2]
c0d0652e:	2801      	cmp	r0, #1
c0d06530:	d115      	bne.n	c0d0655e <USBD_SetFeature+0x38>
  {
    pdev->dev_remote_wakeup = 1;  
c0d06532:	20e4      	movs	r0, #228	; 0xe4
c0d06534:	2101      	movs	r1, #1
c0d06536:	5021      	str	r1, [r4, r0]
    if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0d06538:	7928      	ldrb	r0, [r5, #4]
/** @defgroup USBD_REQ_Private_Functions
  * @{
  */ 

unsigned int usbd_is_valid_intf(USBD_HandleTypeDef *pdev , unsigned int intf) {
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d0653a:	2802      	cmp	r0, #2
c0d0653c:	d80c      	bhi.n	c0d06558 <USBD_SetFeature+0x32>
c0d0653e:	00c0      	lsls	r0, r0, #3
c0d06540:	1820      	adds	r0, r4, r0
c0d06542:	21f4      	movs	r1, #244	; 0xf4
c0d06544:	5840      	ldr	r0, [r0, r1]
{

  if (req->wValue == USB_FEATURE_REMOTE_WAKEUP)
  {
    pdev->dev_remote_wakeup = 1;  
    if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0d06546:	2800      	cmp	r0, #0
c0d06548:	d006      	beq.n	c0d06558 <USBD_SetFeature+0x32>
      ((Setup_t)PIC(pdev->interfacesClass[LOBYTE(req->wIndex)].pClass->Setup)) (pdev, req);   
c0d0654a:	6880      	ldr	r0, [r0, #8]
c0d0654c:	f7fd fbca 	bl	c0d03ce4 <pic>
c0d06550:	4602      	mov	r2, r0
c0d06552:	4620      	mov	r0, r4
c0d06554:	4629      	mov	r1, r5
c0d06556:	4790      	blx	r2
    }
    USBD_CtlSendStatus(pdev);
c0d06558:	4620      	mov	r0, r4
c0d0655a:	f000 fb5c 	bl	c0d06c16 <USBD_CtlSendStatus>
  }

}
c0d0655e:	bdb0      	pop	{r4, r5, r7, pc}

c0d06560 <USBD_ClrFeature>:
* @param  req: usb request
* @retval status
*/
void USBD_ClrFeature(USBD_HandleTypeDef *pdev , 
                            USBD_SetupReqTypedef *req)
{
c0d06560:	b5b0      	push	{r4, r5, r7, lr}
c0d06562:	460d      	mov	r5, r1
c0d06564:	4604      	mov	r4, r0
  switch (pdev->dev_state)
c0d06566:	20dc      	movs	r0, #220	; 0xdc
c0d06568:	5c20      	ldrb	r0, [r4, r0]
c0d0656a:	21fe      	movs	r1, #254	; 0xfe
c0d0656c:	4001      	ands	r1, r0
c0d0656e:	2902      	cmp	r1, #2
c0d06570:	d119      	bne.n	c0d065a6 <USBD_ClrFeature+0x46>
  {
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
c0d06572:	8868      	ldrh	r0, [r5, #2]
c0d06574:	2801      	cmp	r0, #1
c0d06576:	d11a      	bne.n	c0d065ae <USBD_ClrFeature+0x4e>
    {
      pdev->dev_remote_wakeup = 0; 
c0d06578:	20e4      	movs	r0, #228	; 0xe4
c0d0657a:	2100      	movs	r1, #0
c0d0657c:	5021      	str	r1, [r4, r0]
      if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0d0657e:	7928      	ldrb	r0, [r5, #4]
/** @defgroup USBD_REQ_Private_Functions
  * @{
  */ 

unsigned int usbd_is_valid_intf(USBD_HandleTypeDef *pdev , unsigned int intf) {
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d06580:	2802      	cmp	r0, #2
c0d06582:	d80c      	bhi.n	c0d0659e <USBD_ClrFeature+0x3e>
c0d06584:	00c0      	lsls	r0, r0, #3
c0d06586:	1820      	adds	r0, r4, r0
c0d06588:	21f4      	movs	r1, #244	; 0xf4
c0d0658a:	5840      	ldr	r0, [r0, r1]
  case USBD_STATE_ADDRESSED:
  case USBD_STATE_CONFIGURED:
    if (req->wValue == USB_FEATURE_REMOTE_WAKEUP) 
    {
      pdev->dev_remote_wakeup = 0; 
      if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0d0658c:	2800      	cmp	r0, #0
c0d0658e:	d006      	beq.n	c0d0659e <USBD_ClrFeature+0x3e>
        ((Setup_t)PIC(pdev->interfacesClass[LOBYTE(req->wIndex)].pClass->Setup)) (pdev, req);   
c0d06590:	6880      	ldr	r0, [r0, #8]
c0d06592:	f7fd fba7 	bl	c0d03ce4 <pic>
c0d06596:	4602      	mov	r2, r0
c0d06598:	4620      	mov	r0, r4
c0d0659a:	4629      	mov	r1, r5
c0d0659c:	4790      	blx	r2
      }
      USBD_CtlSendStatus(pdev);
c0d0659e:	4620      	mov	r0, r4
c0d065a0:	f000 fb39 	bl	c0d06c16 <USBD_CtlSendStatus>
    
  default :
     USBD_CtlError(pdev , req);
    break;
  }
}
c0d065a4:	bdb0      	pop	{r4, r5, r7, pc}
      USBD_CtlSendStatus(pdev);
    }
    break;
    
  default :
     USBD_CtlError(pdev , req);
c0d065a6:	4620      	mov	r0, r4
c0d065a8:	4629      	mov	r1, r5
c0d065aa:	f000 fa87 	bl	c0d06abc <USBD_CtlError>
    break;
  }
}
c0d065ae:	bdb0      	pop	{r4, r5, r7, pc}

c0d065b0 <USBD_StdItfReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdItfReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
c0d065b0:	b5b0      	push	{r4, r5, r7, lr}
c0d065b2:	460d      	mov	r5, r1
c0d065b4:	4604      	mov	r4, r0
  USBD_StatusTypeDef ret = USBD_OK; 
  
  switch (pdev->dev_state) 
c0d065b6:	20dc      	movs	r0, #220	; 0xdc
c0d065b8:	5c20      	ldrb	r0, [r4, r0]
c0d065ba:	2803      	cmp	r0, #3
c0d065bc:	d116      	bne.n	c0d065ec <USBD_StdItfReq+0x3c>
  {
  case USBD_STATE_CONFIGURED:
    
    if (usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) 
c0d065be:	7928      	ldrb	r0, [r5, #4]
/** @defgroup USBD_REQ_Private_Functions
  * @{
  */ 

unsigned int usbd_is_valid_intf(USBD_HandleTypeDef *pdev , unsigned int intf) {
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d065c0:	2802      	cmp	r0, #2
c0d065c2:	d813      	bhi.n	c0d065ec <USBD_StdItfReq+0x3c>
c0d065c4:	00c0      	lsls	r0, r0, #3
c0d065c6:	1820      	adds	r0, r4, r0
c0d065c8:	21f4      	movs	r1, #244	; 0xf4
c0d065ca:	5840      	ldr	r0, [r0, r1]
  
  switch (pdev->dev_state) 
  {
  case USBD_STATE_CONFIGURED:
    
    if (usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) 
c0d065cc:	2800      	cmp	r0, #0
c0d065ce:	d00d      	beq.n	c0d065ec <USBD_StdItfReq+0x3c>
    {
      ((Setup_t)PIC(pdev->interfacesClass[LOBYTE(req->wIndex)].pClass->Setup)) (pdev, req);
c0d065d0:	6880      	ldr	r0, [r0, #8]
c0d065d2:	f7fd fb87 	bl	c0d03ce4 <pic>
c0d065d6:	4602      	mov	r2, r0
c0d065d8:	4620      	mov	r0, r4
c0d065da:	4629      	mov	r1, r5
c0d065dc:	4790      	blx	r2
      
      if((req->wLength == 0)&& (ret == USBD_OK))
c0d065de:	88e8      	ldrh	r0, [r5, #6]
c0d065e0:	2800      	cmp	r0, #0
c0d065e2:	d107      	bne.n	c0d065f4 <USBD_StdItfReq+0x44>
      {
         USBD_CtlSendStatus(pdev);
c0d065e4:	4620      	mov	r0, r4
c0d065e6:	f000 fb16 	bl	c0d06c16 <USBD_CtlSendStatus>
c0d065ea:	e003      	b.n	c0d065f4 <USBD_StdItfReq+0x44>
c0d065ec:	4620      	mov	r0, r4
c0d065ee:	4629      	mov	r1, r5
c0d065f0:	f000 fa64 	bl	c0d06abc <USBD_CtlError>
    
  default:
     USBD_CtlError(pdev , req);
    break;
  }
  return USBD_OK;
c0d065f4:	2000      	movs	r0, #0
c0d065f6:	bdb0      	pop	{r4, r5, r7, pc}

c0d065f8 <USBD_StdEPReq>:
* @param  pdev: device instance
* @param  req: usb request
* @retval status
*/
USBD_StatusTypeDef  USBD_StdEPReq (USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef  *req)
{
c0d065f8:	b570      	push	{r4, r5, r6, lr}
c0d065fa:	460d      	mov	r5, r1
c0d065fc:	4604      	mov	r4, r0
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20 && usbd_is_valid_intf(pdev, LOBYTE(req->wIndex)))
c0d065fe:	7828      	ldrb	r0, [r5, #0]
c0d06600:	2160      	movs	r1, #96	; 0x60
c0d06602:	4001      	ands	r1, r0
{
  
  uint8_t   ep_addr;
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
c0d06604:	792e      	ldrb	r6, [r5, #4]
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20 && usbd_is_valid_intf(pdev, LOBYTE(req->wIndex)))
c0d06606:	2920      	cmp	r1, #32
c0d06608:	d10f      	bne.n	c0d0662a <USBD_StdEPReq+0x32>
/** @defgroup USBD_REQ_Private_Functions
  * @{
  */ 

unsigned int usbd_is_valid_intf(USBD_HandleTypeDef *pdev , unsigned int intf) {
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d0660a:	2e02      	cmp	r6, #2
c0d0660c:	d80d      	bhi.n	c0d0662a <USBD_StdEPReq+0x32>
c0d0660e:	00f0      	lsls	r0, r6, #3
c0d06610:	1820      	adds	r0, r4, r0
c0d06612:	21f4      	movs	r1, #244	; 0xf4
c0d06614:	5840      	ldr	r0, [r0, r1]
  USBD_StatusTypeDef ret = USBD_OK; 
  USBD_EndpointTypeDef   *pep;
  ep_addr  = LOBYTE(req->wIndex);   
  
  /* Check if it is a class request */
  if ((req->bmRequest & 0x60) == 0x20 && usbd_is_valid_intf(pdev, LOBYTE(req->wIndex)))
c0d06616:	2800      	cmp	r0, #0
c0d06618:	d007      	beq.n	c0d0662a <USBD_StdEPReq+0x32>
  {
    ((Setup_t)PIC(pdev->interfacesClass[LOBYTE(req->wIndex)].pClass->Setup)) (pdev, req);
c0d0661a:	6880      	ldr	r0, [r0, #8]
c0d0661c:	f7fd fb62 	bl	c0d03ce4 <pic>
c0d06620:	4602      	mov	r2, r0
c0d06622:	4620      	mov	r0, r4
c0d06624:	4629      	mov	r1, r5
c0d06626:	4790      	blx	r2
c0d06628:	e06d      	b.n	c0d06706 <USBD_StdEPReq+0x10e>
    
    return USBD_OK;
  }
  
  switch (req->bRequest) 
c0d0662a:	7868      	ldrb	r0, [r5, #1]
c0d0662c:	2800      	cmp	r0, #0
c0d0662e:	d017      	beq.n	c0d06660 <USBD_StdEPReq+0x68>
c0d06630:	2801      	cmp	r0, #1
c0d06632:	d01e      	beq.n	c0d06672 <USBD_StdEPReq+0x7a>
c0d06634:	2803      	cmp	r0, #3
c0d06636:	d166      	bne.n	c0d06706 <USBD_StdEPReq+0x10e>
  {
    
  case USB_REQ_SET_FEATURE :
    
    switch (pdev->dev_state) 
c0d06638:	20dc      	movs	r0, #220	; 0xdc
c0d0663a:	5c20      	ldrb	r0, [r4, r0]
c0d0663c:	2803      	cmp	r0, #3
c0d0663e:	d11c      	bne.n	c0d0667a <USBD_StdEPReq+0x82>
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
c0d06640:	8868      	ldrh	r0, [r5, #2]
c0d06642:	2800      	cmp	r0, #0
c0d06644:	d108      	bne.n	c0d06658 <USBD_StdEPReq+0x60>
      {
        if ((ep_addr != 0x00) && (ep_addr != 0x80)) 
c0d06646:	2080      	movs	r0, #128	; 0x80
c0d06648:	4330      	orrs	r0, r6
c0d0664a:	2880      	cmp	r0, #128	; 0x80
c0d0664c:	d004      	beq.n	c0d06658 <USBD_StdEPReq+0x60>
        { 
          USBD_LL_StallEP(pdev , ep_addr);
c0d0664e:	4620      	mov	r0, r4
c0d06650:	4631      	mov	r1, r6
c0d06652:	f7ff fbbd 	bl	c0d05dd0 <USBD_LL_StallEP>
          
        }
c0d06656:	792e      	ldrb	r6, [r5, #4]
/** @defgroup USBD_REQ_Private_Functions
  * @{
  */ 

unsigned int usbd_is_valid_intf(USBD_HandleTypeDef *pdev , unsigned int intf) {
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d06658:	2e02      	cmp	r6, #2
c0d0665a:	d851      	bhi.n	c0d06700 <USBD_StdEPReq+0x108>
c0d0665c:	00f0      	lsls	r0, r6, #3
c0d0665e:	e043      	b.n	c0d066e8 <USBD_StdEPReq+0xf0>
      break;    
    }
    break;
    
  case USB_REQ_GET_STATUS:                  
    switch (pdev->dev_state) 
c0d06660:	20dc      	movs	r0, #220	; 0xdc
c0d06662:	5c20      	ldrb	r0, [r4, r0]
c0d06664:	2803      	cmp	r0, #3
c0d06666:	d018      	beq.n	c0d0669a <USBD_StdEPReq+0xa2>
c0d06668:	2802      	cmp	r0, #2
c0d0666a:	d111      	bne.n	c0d06690 <USBD_StdEPReq+0x98>
    {
    case USBD_STATE_ADDRESSED:          
      if ((ep_addr & 0x7F) != 0x00) 
c0d0666c:	0670      	lsls	r0, r6, #25
c0d0666e:	d10a      	bne.n	c0d06686 <USBD_StdEPReq+0x8e>
c0d06670:	e049      	b.n	c0d06706 <USBD_StdEPReq+0x10e>
    }
    break;
    
  case USB_REQ_CLEAR_FEATURE :
    
    switch (pdev->dev_state) 
c0d06672:	20dc      	movs	r0, #220	; 0xdc
c0d06674:	5c20      	ldrb	r0, [r4, r0]
c0d06676:	2803      	cmp	r0, #3
c0d06678:	d029      	beq.n	c0d066ce <USBD_StdEPReq+0xd6>
c0d0667a:	2802      	cmp	r0, #2
c0d0667c:	d108      	bne.n	c0d06690 <USBD_StdEPReq+0x98>
c0d0667e:	2080      	movs	r0, #128	; 0x80
c0d06680:	4330      	orrs	r0, r6
c0d06682:	2880      	cmp	r0, #128	; 0x80
c0d06684:	d03f      	beq.n	c0d06706 <USBD_StdEPReq+0x10e>
c0d06686:	4620      	mov	r0, r4
c0d06688:	4631      	mov	r1, r6
c0d0668a:	f7ff fba1 	bl	c0d05dd0 <USBD_LL_StallEP>
c0d0668e:	e03a      	b.n	c0d06706 <USBD_StdEPReq+0x10e>
c0d06690:	4620      	mov	r0, r4
c0d06692:	4629      	mov	r1, r5
c0d06694:	f000 fa12 	bl	c0d06abc <USBD_CtlError>
c0d06698:	e035      	b.n	c0d06706 <USBD_StdEPReq+0x10e>
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
c0d0669a:	4625      	mov	r5, r4
c0d0669c:	3514      	adds	r5, #20
                                         &pdev->ep_out[ep_addr & 0x7F];
c0d0669e:	4620      	mov	r0, r4
c0d066a0:	3074      	adds	r0, #116	; 0x74
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:
      pep = ((ep_addr & 0x80) == 0x80) ? &pdev->ep_in[ep_addr & 0x7F]:\
c0d066a2:	2180      	movs	r1, #128	; 0x80
c0d066a4:	420e      	tst	r6, r1
c0d066a6:	d100      	bne.n	c0d066aa <USBD_StdEPReq+0xb2>
c0d066a8:	4605      	mov	r5, r0
                                         &pdev->ep_out[ep_addr & 0x7F];
      if(USBD_LL_IsStallEP(pdev, ep_addr))
c0d066aa:	4620      	mov	r0, r4
c0d066ac:	4631      	mov	r1, r6
c0d066ae:	f7ff fbd9 	bl	c0d05e64 <USBD_LL_IsStallEP>
c0d066b2:	2101      	movs	r1, #1
c0d066b4:	2800      	cmp	r0, #0
c0d066b6:	d100      	bne.n	c0d066ba <USBD_StdEPReq+0xc2>
c0d066b8:	4601      	mov	r1, r0
c0d066ba:	207f      	movs	r0, #127	; 0x7f
c0d066bc:	4006      	ands	r6, r0
c0d066be:	0130      	lsls	r0, r6, #4
c0d066c0:	5029      	str	r1, [r5, r0]
c0d066c2:	1829      	adds	r1, r5, r0
      else
      {
        pep->status = 0x0000;  
      }
      
      USBD_CtlSendData (pdev,
c0d066c4:	2202      	movs	r2, #2
c0d066c6:	4620      	mov	r0, r4
c0d066c8:	f000 fa7a 	bl	c0d06bc0 <USBD_CtlSendData>
c0d066cc:	e01b      	b.n	c0d06706 <USBD_StdEPReq+0x10e>
        USBD_LL_StallEP(pdev , ep_addr);
      }
      break;	
      
    case USBD_STATE_CONFIGURED:   
      if (req->wValue == USB_FEATURE_EP_HALT)
c0d066ce:	8868      	ldrh	r0, [r5, #2]
c0d066d0:	2800      	cmp	r0, #0
c0d066d2:	d118      	bne.n	c0d06706 <USBD_StdEPReq+0x10e>
      {
        if ((ep_addr & 0x7F) != 0x00) 
c0d066d4:	0670      	lsls	r0, r6, #25
c0d066d6:	d013      	beq.n	c0d06700 <USBD_StdEPReq+0x108>
        {        
          USBD_LL_ClearStallEP(pdev , ep_addr);
c0d066d8:	4620      	mov	r0, r4
c0d066da:	4631      	mov	r1, r6
c0d066dc:	f7ff fb9e 	bl	c0d05e1c <USBD_LL_ClearStallEP>
          if(usbd_is_valid_intf(pdev, LOBYTE(req->wIndex))) {
c0d066e0:	7928      	ldrb	r0, [r5, #4]
/** @defgroup USBD_REQ_Private_Functions
  * @{
  */ 

unsigned int usbd_is_valid_intf(USBD_HandleTypeDef *pdev , unsigned int intf) {
  return intf < USBD_MAX_NUM_INTERFACES && pdev->interfacesClass[intf].pClass != NULL;
c0d066e2:	2802      	cmp	r0, #2
c0d066e4:	d80c      	bhi.n	c0d06700 <USBD_StdEPReq+0x108>
c0d066e6:	00c0      	lsls	r0, r0, #3
c0d066e8:	1820      	adds	r0, r4, r0
c0d066ea:	21f4      	movs	r1, #244	; 0xf4
c0d066ec:	5840      	ldr	r0, [r0, r1]
c0d066ee:	2800      	cmp	r0, #0
c0d066f0:	d006      	beq.n	c0d06700 <USBD_StdEPReq+0x108>
c0d066f2:	6880      	ldr	r0, [r0, #8]
c0d066f4:	f7fd faf6 	bl	c0d03ce4 <pic>
c0d066f8:	4602      	mov	r2, r0
c0d066fa:	4620      	mov	r0, r4
c0d066fc:	4629      	mov	r1, r5
c0d066fe:	4790      	blx	r2
c0d06700:	4620      	mov	r0, r4
c0d06702:	f000 fa88 	bl	c0d06c16 <USBD_CtlSendStatus>
    
  default:
    break;
  }
  return ret;
}
c0d06706:	2000      	movs	r0, #0
c0d06708:	bd70      	pop	{r4, r5, r6, pc}

c0d0670a <USBD_ParseSetupRequest>:
* @retval None
*/

void USBD_ParseSetupRequest(USBD_SetupReqTypedef *req, uint8_t *pdata)
{
  req->bmRequest     = *(uint8_t *)  (pdata);
c0d0670a:	780a      	ldrb	r2, [r1, #0]
c0d0670c:	7002      	strb	r2, [r0, #0]
  req->bRequest      = *(uint8_t *)  (pdata +  1);
c0d0670e:	784a      	ldrb	r2, [r1, #1]
c0d06710:	7042      	strb	r2, [r0, #1]
  req->wValue        = SWAPBYTE      (pdata +  2);
c0d06712:	788a      	ldrb	r2, [r1, #2]
c0d06714:	78cb      	ldrb	r3, [r1, #3]
c0d06716:	021b      	lsls	r3, r3, #8
c0d06718:	4313      	orrs	r3, r2
c0d0671a:	8043      	strh	r3, [r0, #2]
  req->wIndex        = SWAPBYTE      (pdata +  4);
c0d0671c:	790a      	ldrb	r2, [r1, #4]
c0d0671e:	794b      	ldrb	r3, [r1, #5]
c0d06720:	021b      	lsls	r3, r3, #8
c0d06722:	4313      	orrs	r3, r2
c0d06724:	8083      	strh	r3, [r0, #4]
  req->wLength       = SWAPBYTE      (pdata +  6);
c0d06726:	798a      	ldrb	r2, [r1, #6]
c0d06728:	79c9      	ldrb	r1, [r1, #7]
c0d0672a:	0209      	lsls	r1, r1, #8
c0d0672c:	4311      	orrs	r1, r2
c0d0672e:	80c1      	strh	r1, [r0, #6]

}
c0d06730:	4770      	bx	lr

c0d06732 <USBD_CtlStall>:
* @param  pdev: device instance
* @param  req: usb request
* @retval None
*/
void USBD_CtlStall( USBD_HandleTypeDef *pdev)
{
c0d06732:	b510      	push	{r4, lr}
c0d06734:	4604      	mov	r4, r0
  USBD_LL_StallEP(pdev , 0x80);
c0d06736:	2180      	movs	r1, #128	; 0x80
c0d06738:	f7ff fb4a 	bl	c0d05dd0 <USBD_LL_StallEP>
  USBD_LL_StallEP(pdev , 0);
c0d0673c:	2100      	movs	r1, #0
c0d0673e:	4620      	mov	r0, r4
c0d06740:	f7ff fb46 	bl	c0d05dd0 <USBD_LL_StallEP>
}
c0d06744:	bd10      	pop	{r4, pc}

c0d06746 <USBD_HID_Setup>:
  * @param  req: usb requests
  * @retval status
  */
uint8_t  USBD_HID_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
c0d06746:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d06748:	b083      	sub	sp, #12
c0d0674a:	460d      	mov	r5, r1
c0d0674c:	4604      	mov	r4, r0
c0d0674e:	a802      	add	r0, sp, #8
c0d06750:	2700      	movs	r7, #0
  uint16_t len = 0;
c0d06752:	8007      	strh	r7, [r0, #0]
c0d06754:	a801      	add	r0, sp, #4
  uint8_t  *pbuf = NULL;

  uint8_t val = 0;
c0d06756:	7007      	strb	r7, [r0, #0]

  switch (req->bmRequest & USB_REQ_TYPE_MASK)
c0d06758:	7829      	ldrb	r1, [r5, #0]
c0d0675a:	2060      	movs	r0, #96	; 0x60
c0d0675c:	4008      	ands	r0, r1
c0d0675e:	2800      	cmp	r0, #0
c0d06760:	d010      	beq.n	c0d06784 <USBD_HID_Setup+0x3e>
c0d06762:	2820      	cmp	r0, #32
c0d06764:	d138      	bne.n	c0d067d8 <USBD_HID_Setup+0x92>
c0d06766:	7868      	ldrb	r0, [r5, #1]
  {
  case USB_REQ_TYPE_CLASS :  
    switch (req->bRequest)
c0d06768:	4601      	mov	r1, r0
c0d0676a:	390a      	subs	r1, #10
c0d0676c:	2902      	cmp	r1, #2
c0d0676e:	d333      	bcc.n	c0d067d8 <USBD_HID_Setup+0x92>
c0d06770:	2802      	cmp	r0, #2
c0d06772:	d01c      	beq.n	c0d067ae <USBD_HID_Setup+0x68>
c0d06774:	2803      	cmp	r0, #3
c0d06776:	d01a      	beq.n	c0d067ae <USBD_HID_Setup+0x68>
                        (uint8_t *)&val,
                        1);      
      break;      
      
    default:
      USBD_CtlError (pdev, req);
c0d06778:	4620      	mov	r0, r4
c0d0677a:	4629      	mov	r1, r5
c0d0677c:	f000 f99e 	bl	c0d06abc <USBD_CtlError>
c0d06780:	2702      	movs	r7, #2
c0d06782:	e029      	b.n	c0d067d8 <USBD_HID_Setup+0x92>
      return USBD_FAIL; 
    }
    break;
    
  case USB_REQ_TYPE_STANDARD:
    switch (req->bRequest)
c0d06784:	7868      	ldrb	r0, [r5, #1]
c0d06786:	280b      	cmp	r0, #11
c0d06788:	d014      	beq.n	c0d067b4 <USBD_HID_Setup+0x6e>
c0d0678a:	280a      	cmp	r0, #10
c0d0678c:	d00f      	beq.n	c0d067ae <USBD_HID_Setup+0x68>
c0d0678e:	2806      	cmp	r0, #6
c0d06790:	d122      	bne.n	c0d067d8 <USBD_HID_Setup+0x92>
    {
    case USB_REQ_GET_DESCRIPTOR: 
      // 0x22
      if( req->wValue >> 8 == HID_REPORT_DESC)
c0d06792:	8868      	ldrh	r0, [r5, #2]
c0d06794:	0a00      	lsrs	r0, r0, #8
c0d06796:	2700      	movs	r7, #0
c0d06798:	2821      	cmp	r0, #33	; 0x21
c0d0679a:	d00f      	beq.n	c0d067bc <USBD_HID_Setup+0x76>
c0d0679c:	2822      	cmp	r0, #34	; 0x22
      
      //USBD_CtlReceiveStatus(pdev);
      
      USBD_CtlSendData (pdev, 
                        pbuf,
                        len);
c0d0679e:	463a      	mov	r2, r7
c0d067a0:	4639      	mov	r1, r7
c0d067a2:	d116      	bne.n	c0d067d2 <USBD_HID_Setup+0x8c>
c0d067a4:	ae02      	add	r6, sp, #8
    {
    case USB_REQ_GET_DESCRIPTOR: 
      // 0x22
      if( req->wValue >> 8 == HID_REPORT_DESC)
      {
        pbuf =  USBD_HID_GetReportDescriptor_impl(&len);
c0d067a6:	4630      	mov	r0, r6
c0d067a8:	f000 f858 	bl	c0d0685c <USBD_HID_GetReportDescriptor_impl>
c0d067ac:	e00a      	b.n	c0d067c4 <USBD_HID_Setup+0x7e>
c0d067ae:	a901      	add	r1, sp, #4
c0d067b0:	2201      	movs	r2, #1
c0d067b2:	e00e      	b.n	c0d067d2 <USBD_HID_Setup+0x8c>
                        len);
      break;

    case USB_REQ_SET_INTERFACE :
      //hhid->AltSetting = (uint8_t)(req->wValue);
      USBD_CtlSendStatus(pdev);
c0d067b4:	4620      	mov	r0, r4
c0d067b6:	f000 fa2e 	bl	c0d06c16 <USBD_CtlSendStatus>
c0d067ba:	e00d      	b.n	c0d067d8 <USBD_HID_Setup+0x92>
c0d067bc:	ae02      	add	r6, sp, #8
        len = MIN(len , req->wLength);
      }
      // 0x21
      else if( req->wValue >> 8 == HID_DESCRIPTOR_TYPE)
      {
        pbuf = USBD_HID_GetHidDescriptor_impl(&len);
c0d067be:	4630      	mov	r0, r6
c0d067c0:	f000 f832 	bl	c0d06828 <USBD_HID_GetHidDescriptor_impl>
c0d067c4:	4601      	mov	r1, r0
c0d067c6:	8832      	ldrh	r2, [r6, #0]
c0d067c8:	88e8      	ldrh	r0, [r5, #6]
c0d067ca:	4282      	cmp	r2, r0
c0d067cc:	d300      	bcc.n	c0d067d0 <USBD_HID_Setup+0x8a>
c0d067ce:	4602      	mov	r2, r0
c0d067d0:	8032      	strh	r2, [r6, #0]
c0d067d2:	4620      	mov	r0, r4
c0d067d4:	f000 f9f4 	bl	c0d06bc0 <USBD_CtlSendData>
      
    }
  }

  return USBD_OK;
}
c0d067d8:	b2f8      	uxtb	r0, r7
c0d067da:	b003      	add	sp, #12
c0d067dc:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d067de <USBD_HID_Init>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
uint8_t  USBD_HID_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
c0d067de:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d067e0:	b081      	sub	sp, #4
c0d067e2:	4604      	mov	r4, r0
  UNUSED(cfgidx);

  /* Open EP IN */
  USBD_LL_OpenEP(pdev,
c0d067e4:	2182      	movs	r1, #130	; 0x82
c0d067e6:	2603      	movs	r6, #3
c0d067e8:	2540      	movs	r5, #64	; 0x40
c0d067ea:	4632      	mov	r2, r6
c0d067ec:	462b      	mov	r3, r5
c0d067ee:	f7ff fab3 	bl	c0d05d58 <USBD_LL_OpenEP>
c0d067f2:	2702      	movs	r7, #2
                 HID_EPIN_ADDR,
                 USBD_EP_TYPE_INTR,
                 HID_EPIN_SIZE);
  
  /* Open EP OUT */
  USBD_LL_OpenEP(pdev,
c0d067f4:	4620      	mov	r0, r4
c0d067f6:	4639      	mov	r1, r7
c0d067f8:	4632      	mov	r2, r6
c0d067fa:	462b      	mov	r3, r5
c0d067fc:	f7ff faac 	bl	c0d05d58 <USBD_LL_OpenEP>
                 HID_EPOUT_ADDR,
                 USBD_EP_TYPE_INTR,
                 HID_EPOUT_SIZE);

        /* Prepare Out endpoint to receive 1st packet */ 
  USBD_LL_PrepareReceive(pdev, HID_EPOUT_ADDR, HID_EPOUT_SIZE);
c0d06800:	4620      	mov	r0, r4
c0d06802:	4639      	mov	r1, r7
c0d06804:	462a      	mov	r2, r5
c0d06806:	f7ff fb6a 	bl	c0d05ede <USBD_LL_PrepareReceive>
  USBD_LL_Transmit (pdev, 
                    HID_EPIN_ADDR,                                      
                    NULL,
                    0);
  */
  return USBD_OK;
c0d0680a:	2000      	movs	r0, #0
c0d0680c:	b001      	add	sp, #4
c0d0680e:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d06810 <USBD_HID_DeInit>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
uint8_t  USBD_HID_DeInit (USBD_HandleTypeDef *pdev, 
                                 uint8_t cfgidx)
{
c0d06810:	b510      	push	{r4, lr}
c0d06812:	4604      	mov	r4, r0
  UNUSED(cfgidx);
  /* Close HID EP IN */
  USBD_LL_CloseEP(pdev,
c0d06814:	2182      	movs	r1, #130	; 0x82
c0d06816:	f7ff fac5 	bl	c0d05da4 <USBD_LL_CloseEP>
                  HID_EPIN_ADDR);
  
  /* Close HID EP OUT */
  USBD_LL_CloseEP(pdev,
c0d0681a:	2102      	movs	r1, #2
c0d0681c:	4620      	mov	r0, r4
c0d0681e:	f7ff fac1 	bl	c0d05da4 <USBD_LL_CloseEP>
                  HID_EPOUT_ADDR);
  
  return USBD_OK;
c0d06822:	2000      	movs	r0, #0
c0d06824:	bd10      	pop	{r4, pc}
	...

c0d06828 <USBD_HID_GetHidDescriptor_impl>:
  *length = sizeof (USBD_CfgDesc);
  return (uint8_t*)USBD_CfgDesc;
}

uint8_t* USBD_HID_GetHidDescriptor_impl(uint16_t* len) {
  switch (USBD_Device.request.wIndex&0xFF) {
c0d06828:	21ec      	movs	r1, #236	; 0xec
c0d0682a:	4a09      	ldr	r2, [pc, #36]	; (c0d06850 <USBD_HID_GetHidDescriptor_impl+0x28>)
c0d0682c:	5c51      	ldrb	r1, [r2, r1]
c0d0682e:	2209      	movs	r2, #9
c0d06830:	2900      	cmp	r1, #0
c0d06832:	d004      	beq.n	c0d0683e <USBD_HID_GetHidDescriptor_impl+0x16>
c0d06834:	2901      	cmp	r1, #1
c0d06836:	d105      	bne.n	c0d06844 <USBD_HID_GetHidDescriptor_impl+0x1c>
c0d06838:	4907      	ldr	r1, [pc, #28]	; (c0d06858 <USBD_HID_GetHidDescriptor_impl+0x30>)
c0d0683a:	4479      	add	r1, pc
c0d0683c:	e004      	b.n	c0d06848 <USBD_HID_GetHidDescriptor_impl+0x20>
c0d0683e:	4905      	ldr	r1, [pc, #20]	; (c0d06854 <USBD_HID_GetHidDescriptor_impl+0x2c>)
c0d06840:	4479      	add	r1, pc
c0d06842:	e001      	b.n	c0d06848 <USBD_HID_GetHidDescriptor_impl+0x20>
c0d06844:	2200      	movs	r2, #0
c0d06846:	4611      	mov	r1, r2
c0d06848:	8002      	strh	r2, [r0, #0]
      *len = sizeof(USBD_HID_Desc);
      return (uint8_t*)USBD_HID_Desc; 
  }
  *len = 0;
  return 0;
}
c0d0684a:	4608      	mov	r0, r1
c0d0684c:	4770      	bx	lr
c0d0684e:	46c0      	nop			; (mov r8, r8)
c0d06850:	20001fa4 	.word	0x20001fa4
c0d06854:	00009e64 	.word	0x00009e64
c0d06858:	00009e5e 	.word	0x00009e5e

c0d0685c <USBD_HID_GetReportDescriptor_impl>:

uint8_t* USBD_HID_GetReportDescriptor_impl(uint16_t* len) {
c0d0685c:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d0685e:	b081      	sub	sp, #4
c0d06860:	4602      	mov	r2, r0
  switch (USBD_Device.request.wIndex&0xFF) {
c0d06862:	20ec      	movs	r0, #236	; 0xec
c0d06864:	4913      	ldr	r1, [pc, #76]	; (c0d068b4 <USBD_HID_GetReportDescriptor_impl+0x58>)
c0d06866:	5c08      	ldrb	r0, [r1, r0]
c0d06868:	2422      	movs	r4, #34	; 0x22
c0d0686a:	2800      	cmp	r0, #0
c0d0686c:	d01a      	beq.n	c0d068a4 <USBD_HID_GetReportDescriptor_impl+0x48>
c0d0686e:	2801      	cmp	r0, #1
c0d06870:	d11b      	bne.n	c0d068aa <USBD_HID_GetReportDescriptor_impl+0x4e>
#ifdef HAVE_IO_U2F
  case U2F_INTF:

    // very dirty work due to lack of callback when USB_HID_Init is called
    USBD_LL_OpenEP(&USBD_Device,
c0d06872:	4810      	ldr	r0, [pc, #64]	; (c0d068b4 <USBD_HID_GetReportDescriptor_impl+0x58>)
c0d06874:	2181      	movs	r1, #129	; 0x81
c0d06876:	2703      	movs	r7, #3
c0d06878:	2640      	movs	r6, #64	; 0x40
c0d0687a:	9200      	str	r2, [sp, #0]
c0d0687c:	463a      	mov	r2, r7
c0d0687e:	4633      	mov	r3, r6
c0d06880:	f7ff fa6a 	bl	c0d05d58 <USBD_LL_OpenEP>
c0d06884:	2501      	movs	r5, #1
                   U2F_EPIN_ADDR,
                   USBD_EP_TYPE_INTR,
                   U2F_EPIN_SIZE);
    
    USBD_LL_OpenEP(&USBD_Device,
c0d06886:	480b      	ldr	r0, [pc, #44]	; (c0d068b4 <USBD_HID_GetReportDescriptor_impl+0x58>)
c0d06888:	4629      	mov	r1, r5
c0d0688a:	463a      	mov	r2, r7
c0d0688c:	4633      	mov	r3, r6
c0d0688e:	f7ff fa63 	bl	c0d05d58 <USBD_LL_OpenEP>
                   U2F_EPOUT_ADDR,
                   USBD_EP_TYPE_INTR,
                   U2F_EPOUT_SIZE);

    /* Prepare Out endpoint to receive 1st packet */ 
    USBD_LL_PrepareReceive(&USBD_Device, U2F_EPOUT_ADDR, U2F_EPOUT_SIZE);
c0d06892:	4808      	ldr	r0, [pc, #32]	; (c0d068b4 <USBD_HID_GetReportDescriptor_impl+0x58>)
c0d06894:	4629      	mov	r1, r5
c0d06896:	4632      	mov	r2, r6
c0d06898:	f7ff fb21 	bl	c0d05ede <USBD_LL_PrepareReceive>
c0d0689c:	9a00      	ldr	r2, [sp, #0]
c0d0689e:	4807      	ldr	r0, [pc, #28]	; (c0d068bc <USBD_HID_GetReportDescriptor_impl+0x60>)
c0d068a0:	4478      	add	r0, pc
c0d068a2:	e004      	b.n	c0d068ae <USBD_HID_GetReportDescriptor_impl+0x52>
c0d068a4:	4804      	ldr	r0, [pc, #16]	; (c0d068b8 <USBD_HID_GetReportDescriptor_impl+0x5c>)
c0d068a6:	4478      	add	r0, pc
c0d068a8:	e001      	b.n	c0d068ae <USBD_HID_GetReportDescriptor_impl+0x52>
c0d068aa:	2400      	movs	r4, #0
c0d068ac:	4620      	mov	r0, r4
c0d068ae:	8014      	strh	r4, [r2, #0]
    *len = sizeof(HID_ReportDesc);
    return (uint8_t*)HID_ReportDesc;
  }
  *len = 0;
  return 0;
}
c0d068b0:	b001      	add	sp, #4
c0d068b2:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d068b4:	20001fa4 	.word	0x20001fa4
c0d068b8:	00009e29 	.word	0x00009e29
c0d068bc:	00009e0d 	.word	0x00009e0d

c0d068c0 <USBD_U2F_Init>:
  * @param  cfgidx: Configuration index
  * @retval status
  */
uint8_t  USBD_U2F_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
c0d068c0:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d068c2:	b081      	sub	sp, #4
c0d068c4:	4604      	mov	r4, r0
  UNUSED(cfgidx);

  /* Open EP IN */
  USBD_LL_OpenEP(pdev,
c0d068c6:	2181      	movs	r1, #129	; 0x81
c0d068c8:	2603      	movs	r6, #3
c0d068ca:	2540      	movs	r5, #64	; 0x40
c0d068cc:	4632      	mov	r2, r6
c0d068ce:	462b      	mov	r3, r5
c0d068d0:	f7ff fa42 	bl	c0d05d58 <USBD_LL_OpenEP>
c0d068d4:	2701      	movs	r7, #1
                 U2F_EPIN_ADDR,
                 USBD_EP_TYPE_INTR,
                 U2F_EPIN_SIZE);
  
  /* Open EP OUT */
  USBD_LL_OpenEP(pdev,
c0d068d6:	4620      	mov	r0, r4
c0d068d8:	4639      	mov	r1, r7
c0d068da:	4632      	mov	r2, r6
c0d068dc:	462b      	mov	r3, r5
c0d068de:	f7ff fa3b 	bl	c0d05d58 <USBD_LL_OpenEP>
                 U2F_EPOUT_ADDR,
                 USBD_EP_TYPE_INTR,
                 U2F_EPOUT_SIZE);

        /* Prepare Out endpoint to receive 1st packet */ 
  USBD_LL_PrepareReceive(pdev, U2F_EPOUT_ADDR, U2F_EPOUT_SIZE);
c0d068e2:	4620      	mov	r0, r4
c0d068e4:	4639      	mov	r1, r7
c0d068e6:	462a      	mov	r2, r5
c0d068e8:	f7ff faf9 	bl	c0d05ede <USBD_LL_PrepareReceive>

  return USBD_OK;
c0d068ec:	2000      	movs	r0, #0
c0d068ee:	b001      	add	sp, #4
c0d068f0:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

c0d068f4 <USBD_U2F_DataIn_impl>:
}

uint8_t  USBD_U2F_DataIn_impl (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum)
{
c0d068f4:	b580      	push	{r7, lr}
  UNUSED(pdev);
  // only the data hid endpoint will receive data
  switch (epnum) {
c0d068f6:	2901      	cmp	r1, #1
c0d068f8:	d103      	bne.n	c0d06902 <USBD_U2F_DataIn_impl+0xe>
  // FIDO endpoint
  case (U2F_EPIN_ADDR&0x7F):
    // advance the u2f sending machine state
    u2f_transport_sent(&G_io_u2f, U2F_MEDIA_USB);
c0d068fa:	4803      	ldr	r0, [pc, #12]	; (c0d06908 <USBD_U2F_DataIn_impl+0x14>)
c0d068fc:	2101      	movs	r1, #1
c0d068fe:	f7fd fd9d 	bl	c0d0443c <u2f_transport_sent>
    break;
  } 
  return USBD_OK;
c0d06902:	2000      	movs	r0, #0
c0d06904:	bd80      	pop	{r7, pc}
c0d06906:	46c0      	nop			; (mov r8, r8)
c0d06908:	20001ecc 	.word	0x20001ecc

c0d0690c <USBD_U2F_DataOut_impl>:
}

uint8_t  USBD_U2F_DataOut_impl (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum, uint8_t* buffer)
{
c0d0690c:	b5b0      	push	{r4, r5, r7, lr}
c0d0690e:	4614      	mov	r4, r2
  switch (epnum) {
c0d06910:	2901      	cmp	r1, #1
c0d06912:	d10d      	bne.n	c0d06930 <USBD_U2F_DataOut_impl+0x24>
c0d06914:	2501      	movs	r5, #1
  // FIDO endpoint
  case (U2F_EPOUT_ADDR&0x7F):
      USBD_LL_PrepareReceive(pdev, U2F_EPOUT_ADDR , U2F_EPOUT_SIZE);
c0d06916:	2240      	movs	r2, #64	; 0x40
c0d06918:	4629      	mov	r1, r5
c0d0691a:	f7ff fae0 	bl	c0d05ede <USBD_LL_PrepareReceive>
      u2f_transport_received(&G_io_u2f, buffer, io_seproxyhal_get_ep_rx_size(U2F_EPOUT_ADDR), U2F_MEDIA_USB);
c0d0691e:	4628      	mov	r0, r5
c0d06920:	f7fc f99a 	bl	c0d02c58 <io_seproxyhal_get_ep_rx_size>
c0d06924:	4602      	mov	r2, r0
c0d06926:	4803      	ldr	r0, [pc, #12]	; (c0d06934 <USBD_U2F_DataOut_impl+0x28>)
c0d06928:	4621      	mov	r1, r4
c0d0692a:	462b      	mov	r3, r5
c0d0692c:	f7fd fec6 	bl	c0d046bc <u2f_transport_received>
    break;
  }

  return USBD_OK;
c0d06930:	2000      	movs	r0, #0
c0d06932:	bdb0      	pop	{r4, r5, r7, pc}
c0d06934:	20001ecc 	.word	0x20001ecc

c0d06938 <USBD_HID_DataIn_impl>:
}
#endif // HAVE_IO_U2F

uint8_t  USBD_HID_DataIn_impl (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum)
{
c0d06938:	b580      	push	{r7, lr}
  UNUSED(pdev);
  switch (epnum) {
c0d0693a:	2902      	cmp	r1, #2
c0d0693c:	d103      	bne.n	c0d06946 <USBD_HID_DataIn_impl+0xe>
    // HID gen endpoint
    case (HID_EPIN_ADDR&0x7F):
      io_usb_hid_sent(io_usb_send_apdu_data);
c0d0693e:	4803      	ldr	r0, [pc, #12]	; (c0d0694c <USBD_HID_DataIn_impl+0x14>)
c0d06940:	4478      	add	r0, pc
c0d06942:	f7fc f897 	bl	c0d02a74 <io_usb_hid_sent>
      break;
  }

  return USBD_OK;
c0d06946:	2000      	movs	r0, #0
c0d06948:	bd80      	pop	{r7, pc}
c0d0694a:	46c0      	nop			; (mov r8, r8)
c0d0694c:	ffffc3d9 	.word	0xffffc3d9

c0d06950 <USBD_HID_DataOut_impl>:
}

uint8_t  USBD_HID_DataOut_impl (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum, uint8_t* buffer)
{
c0d06950:	b5b0      	push	{r4, r5, r7, lr}
c0d06952:	4614      	mov	r4, r2
  // only the data hid endpoint will receive data
  switch (epnum) {
c0d06954:	2902      	cmp	r1, #2
c0d06956:	d11b      	bne.n	c0d06990 <USBD_HID_DataOut_impl+0x40>

  // HID gen endpoint
  case (HID_EPOUT_ADDR&0x7F):
    // prepare receiving the next chunk (masked time)
    USBD_LL_PrepareReceive(pdev, HID_EPOUT_ADDR , HID_EPOUT_SIZE);
c0d06958:	2102      	movs	r1, #2
c0d0695a:	2240      	movs	r2, #64	; 0x40
c0d0695c:	f7ff fabf 	bl	c0d05ede <USBD_LL_PrepareReceive>

    // avoid troubles when an apdu has not been replied yet
    if (G_io_apdu_media == IO_APDU_MEDIA_NONE) {      
c0d06960:	4d0c      	ldr	r5, [pc, #48]	; (c0d06994 <USBD_HID_DataOut_impl+0x44>)
c0d06962:	7828      	ldrb	r0, [r5, #0]
c0d06964:	2800      	cmp	r0, #0
c0d06966:	d113      	bne.n	c0d06990 <USBD_HID_DataOut_impl+0x40>
      // add to the hid transport
      switch(io_usb_hid_receive(io_usb_send_apdu_data, buffer, io_seproxyhal_get_ep_rx_size(HID_EPOUT_ADDR))) {
c0d06968:	2002      	movs	r0, #2
c0d0696a:	f7fc f975 	bl	c0d02c58 <io_seproxyhal_get_ep_rx_size>
c0d0696e:	4602      	mov	r2, r0
c0d06970:	480c      	ldr	r0, [pc, #48]	; (c0d069a4 <USBD_HID_DataOut_impl+0x54>)
c0d06972:	4478      	add	r0, pc
c0d06974:	4621      	mov	r1, r4
c0d06976:	f7fb ffab 	bl	c0d028d0 <io_usb_hid_receive>
c0d0697a:	2802      	cmp	r0, #2
c0d0697c:	d108      	bne.n	c0d06990 <USBD_HID_DataOut_impl+0x40>
        default:
          break;

        case IO_USB_APDU_RECEIVED:
          G_io_apdu_media = IO_APDU_MEDIA_USB_HID; // for application code
c0d0697e:	2001      	movs	r0, #1
c0d06980:	7028      	strb	r0, [r5, #0]
          G_io_apdu_state = APDU_USB_HID; // for next call to io_exchange
c0d06982:	4805      	ldr	r0, [pc, #20]	; (c0d06998 <USBD_HID_DataOut_impl+0x48>)
c0d06984:	2107      	movs	r1, #7
c0d06986:	7001      	strb	r1, [r0, #0]
          G_io_apdu_length = G_io_usb_hid_total_length;
c0d06988:	4804      	ldr	r0, [pc, #16]	; (c0d0699c <USBD_HID_DataOut_impl+0x4c>)
c0d0698a:	6800      	ldr	r0, [r0, #0]
c0d0698c:	4904      	ldr	r1, [pc, #16]	; (c0d069a0 <USBD_HID_DataOut_impl+0x50>)
c0d0698e:	8008      	strh	r0, [r1, #0]
      }
    }
    break;
  }

  return USBD_OK;
c0d06990:	2000      	movs	r0, #0
c0d06992:	bdb0      	pop	{r4, r5, r7, pc}
c0d06994:	20001ea8 	.word	0x20001ea8
c0d06998:	20001ebc 	.word	0x20001ebc
c0d0699c:	20001d44 	.word	0x20001d44
c0d069a0:	20001ebe 	.word	0x20001ebe
c0d069a4:	ffffc3a7 	.word	0xffffc3a7

c0d069a8 <USBD_WEBUSB_Init>:

#ifdef HAVE_WEBUSB

uint8_t  USBD_WEBUSB_Init (USBD_HandleTypeDef *pdev, 
                               uint8_t cfgidx)
{
c0d069a8:	b570      	push	{r4, r5, r6, lr}
c0d069aa:	4604      	mov	r4, r0
  UNUSED(cfgidx);

  /* Open EP IN */
  USBD_LL_OpenEP(pdev,
c0d069ac:	2183      	movs	r1, #131	; 0x83
c0d069ae:	2503      	movs	r5, #3
c0d069b0:	2640      	movs	r6, #64	; 0x40
c0d069b2:	462a      	mov	r2, r5
c0d069b4:	4633      	mov	r3, r6
c0d069b6:	f7ff f9cf 	bl	c0d05d58 <USBD_LL_OpenEP>
                 WEBUSB_EPIN_ADDR,
                 USBD_EP_TYPE_INTR,
                 WEBUSB_EPIN_SIZE);
  
  /* Open EP OUT */
  USBD_LL_OpenEP(pdev,
c0d069ba:	4620      	mov	r0, r4
c0d069bc:	4629      	mov	r1, r5
c0d069be:	462a      	mov	r2, r5
c0d069c0:	4633      	mov	r3, r6
c0d069c2:	f7ff f9c9 	bl	c0d05d58 <USBD_LL_OpenEP>
                 WEBUSB_EPOUT_ADDR,
                 USBD_EP_TYPE_INTR,
                 WEBUSB_EPOUT_SIZE);

        /* Prepare Out endpoint to receive 1st packet */ 
  USBD_LL_PrepareReceive(pdev, WEBUSB_EPOUT_ADDR, WEBUSB_EPOUT_SIZE);
c0d069c6:	4620      	mov	r0, r4
c0d069c8:	4629      	mov	r1, r5
c0d069ca:	4632      	mov	r2, r6
c0d069cc:	f7ff fa87 	bl	c0d05ede <USBD_LL_PrepareReceive>

  return USBD_OK;
c0d069d0:	2000      	movs	r0, #0
c0d069d2:	bd70      	pop	{r4, r5, r6, pc}

c0d069d4 <USBD_WEBUSB_DeInit>:

uint8_t  USBD_WEBUSB_DeInit (USBD_HandleTypeDef *pdev, 
                                 uint8_t cfgidx) {
  UNUSED(pdev);
  UNUSED(cfgidx);
  return USBD_OK;
c0d069d4:	2000      	movs	r0, #0
c0d069d6:	4770      	bx	lr

c0d069d8 <USBD_WEBUSB_Setup>:
uint8_t  USBD_WEBUSB_Setup (USBD_HandleTypeDef *pdev, 
                                USBD_SetupReqTypedef *req)
{
  UNUSED(pdev);
  UNUSED(req);
  return USBD_OK;
c0d069d8:	2000      	movs	r0, #0
c0d069da:	4770      	bx	lr

c0d069dc <USBD_WEBUSB_DataIn>:
}

uint8_t  USBD_WEBUSB_DataIn (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum)
{
c0d069dc:	b580      	push	{r7, lr}
  UNUSED(pdev);
  switch (epnum) {
c0d069de:	2903      	cmp	r1, #3
c0d069e0:	d103      	bne.n	c0d069ea <USBD_WEBUSB_DataIn+0xe>
    // HID gen endpoint
    case (WEBUSB_EPIN_ADDR&0x7F):
      io_usb_hid_sent(io_usb_send_apdu_data_ep0x83);
c0d069e2:	4803      	ldr	r0, [pc, #12]	; (c0d069f0 <USBD_WEBUSB_DataIn+0x14>)
c0d069e4:	4478      	add	r0, pc
c0d069e6:	f7fc f845 	bl	c0d02a74 <io_usb_hid_sent>
      break;
  }
  return USBD_OK;
c0d069ea:	2000      	movs	r0, #0
c0d069ec:	bd80      	pop	{r7, pc}
c0d069ee:	46c0      	nop			; (mov r8, r8)
c0d069f0:	ffffc345 	.word	0xffffc345

c0d069f4 <USBD_WEBUSB_DataOut>:
}

uint8_t USBD_WEBUSB_DataOut (USBD_HandleTypeDef *pdev, 
                              uint8_t epnum, uint8_t* buffer)
{
c0d069f4:	b5b0      	push	{r4, r5, r7, lr}
c0d069f6:	4614      	mov	r4, r2
  // only the data hid endpoint will receive data
  switch (epnum) {
c0d069f8:	2903      	cmp	r1, #3
c0d069fa:	d11b      	bne.n	c0d06a34 <USBD_WEBUSB_DataOut+0x40>

  // HID gen endpoint
  case (WEBUSB_EPOUT_ADDR&0x7F):
    // prepare receiving the next chunk (masked time)
    USBD_LL_PrepareReceive(pdev, WEBUSB_EPOUT_ADDR, WEBUSB_EPOUT_SIZE);
c0d069fc:	2103      	movs	r1, #3
c0d069fe:	2240      	movs	r2, #64	; 0x40
c0d06a00:	f7ff fa6d 	bl	c0d05ede <USBD_LL_PrepareReceive>

    // avoid troubles when an apdu has not been replied yet
    if (G_io_apdu_media == IO_APDU_MEDIA_NONE) {      
c0d06a04:	4d0c      	ldr	r5, [pc, #48]	; (c0d06a38 <USBD_WEBUSB_DataOut+0x44>)
c0d06a06:	7828      	ldrb	r0, [r5, #0]
c0d06a08:	2800      	cmp	r0, #0
c0d06a0a:	d113      	bne.n	c0d06a34 <USBD_WEBUSB_DataOut+0x40>
      // add to the hid transport
      switch(io_usb_hid_receive(io_usb_send_apdu_data_ep0x83, buffer, io_seproxyhal_get_ep_rx_size(WEBUSB_EPOUT_ADDR))) {
c0d06a0c:	2003      	movs	r0, #3
c0d06a0e:	f7fc f923 	bl	c0d02c58 <io_seproxyhal_get_ep_rx_size>
c0d06a12:	4602      	mov	r2, r0
c0d06a14:	480c      	ldr	r0, [pc, #48]	; (c0d06a48 <USBD_WEBUSB_DataOut+0x54>)
c0d06a16:	4478      	add	r0, pc
c0d06a18:	4621      	mov	r1, r4
c0d06a1a:	f7fb ff59 	bl	c0d028d0 <io_usb_hid_receive>
c0d06a1e:	2802      	cmp	r0, #2
c0d06a20:	d108      	bne.n	c0d06a34 <USBD_WEBUSB_DataOut+0x40>
        default:
          break;

        case IO_USB_APDU_RECEIVED:
          G_io_apdu_media = IO_APDU_MEDIA_USB_WEBUSB; // for application code
c0d06a22:	2005      	movs	r0, #5
c0d06a24:	7028      	strb	r0, [r5, #0]
          G_io_apdu_state = APDU_USB_WEBUSB; // for next call to io_exchange
c0d06a26:	4805      	ldr	r0, [pc, #20]	; (c0d06a3c <USBD_WEBUSB_DataOut+0x48>)
c0d06a28:	210b      	movs	r1, #11
c0d06a2a:	7001      	strb	r1, [r0, #0]
          G_io_apdu_length = G_io_usb_hid_total_length;
c0d06a2c:	4804      	ldr	r0, [pc, #16]	; (c0d06a40 <USBD_WEBUSB_DataOut+0x4c>)
c0d06a2e:	6800      	ldr	r0, [r0, #0]
c0d06a30:	4904      	ldr	r1, [pc, #16]	; (c0d06a44 <USBD_WEBUSB_DataOut+0x50>)
c0d06a32:	8008      	strh	r0, [r1, #0]
      }
    }
    break;
  }

  return USBD_OK;
c0d06a34:	2000      	movs	r0, #0
c0d06a36:	bdb0      	pop	{r4, r5, r7, pc}
c0d06a38:	20001ea8 	.word	0x20001ea8
c0d06a3c:	20001ebc 	.word	0x20001ebc
c0d06a40:	20001d44 	.word	0x20001d44
c0d06a44:	20001ebe 	.word	0x20001ebe
c0d06a48:	ffffc313 	.word	0xffffc313

c0d06a4c <USBD_DeviceDescriptor>:
  * @retval Pointer to descriptor buffer
  */
static uint8_t *USBD_DeviceDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_DeviceDesc);
c0d06a4c:	2012      	movs	r0, #18
c0d06a4e:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_DeviceDesc;
c0d06a50:	4801      	ldr	r0, [pc, #4]	; (c0d06a58 <USBD_DeviceDescriptor+0xc>)
c0d06a52:	4478      	add	r0, pc
c0d06a54:	4770      	bx	lr
c0d06a56:	46c0      	nop			; (mov r8, r8)
c0d06a58:	00009d9e 	.word	0x00009d9e

c0d06a5c <USBD_LangIDStrDescriptor>:
  * @retval Pointer to descriptor buffer
  */
static uint8_t *USBD_LangIDStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_LangIDDesc);  
c0d06a5c:	2004      	movs	r0, #4
c0d06a5e:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_LangIDDesc;
c0d06a60:	4801      	ldr	r0, [pc, #4]	; (c0d06a68 <USBD_LangIDStrDescriptor+0xc>)
c0d06a62:	4478      	add	r0, pc
c0d06a64:	4770      	bx	lr
c0d06a66:	46c0      	nop			; (mov r8, r8)
c0d06a68:	00009da0 	.word	0x00009da0

c0d06a6c <USBD_ManufacturerStrDescriptor>:
  * @retval Pointer to descriptor buffer
  */
static uint8_t *USBD_ManufacturerStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_MANUFACTURER_STRING);
c0d06a6c:	200e      	movs	r0, #14
c0d06a6e:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_MANUFACTURER_STRING;
c0d06a70:	4801      	ldr	r0, [pc, #4]	; (c0d06a78 <USBD_ManufacturerStrDescriptor+0xc>)
c0d06a72:	4478      	add	r0, pc
c0d06a74:	4770      	bx	lr
c0d06a76:	46c0      	nop			; (mov r8, r8)
c0d06a78:	00009d94 	.word	0x00009d94

c0d06a7c <USBD_ProductStrDescriptor>:
  * @retval Pointer to descriptor buffer
  */
static uint8_t *USBD_ProductStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_PRODUCT_FS_STRING);
c0d06a7c:	200e      	movs	r0, #14
c0d06a7e:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_PRODUCT_FS_STRING;
c0d06a80:	4801      	ldr	r0, [pc, #4]	; (c0d06a88 <USBD_ProductStrDescriptor+0xc>)
c0d06a82:	4478      	add	r0, pc
c0d06a84:	4770      	bx	lr
c0d06a86:	46c0      	nop			; (mov r8, r8)
c0d06a88:	00009d92 	.word	0x00009d92

c0d06a8c <USBD_SerialStrDescriptor>:
  * @retval Pointer to descriptor buffer
  */
static uint8_t *USBD_SerialStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USB_SERIAL_STRING);
c0d06a8c:	200a      	movs	r0, #10
c0d06a8e:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USB_SERIAL_STRING;
c0d06a90:	4801      	ldr	r0, [pc, #4]	; (c0d06a98 <USBD_SerialStrDescriptor+0xc>)
c0d06a92:	4478      	add	r0, pc
c0d06a94:	4770      	bx	lr
c0d06a96:	46c0      	nop			; (mov r8, r8)
c0d06a98:	00009d90 	.word	0x00009d90

c0d06a9c <USBD_ConfigStrDescriptor>:
  * @retval Pointer to descriptor buffer
  */
static uint8_t *USBD_ConfigStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_CONFIGURATION_FS_STRING);
c0d06a9c:	200e      	movs	r0, #14
c0d06a9e:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_CONFIGURATION_FS_STRING;
c0d06aa0:	4801      	ldr	r0, [pc, #4]	; (c0d06aa8 <USBD_ConfigStrDescriptor+0xc>)
c0d06aa2:	4478      	add	r0, pc
c0d06aa4:	4770      	bx	lr
c0d06aa6:	46c0      	nop			; (mov r8, r8)
c0d06aa8:	00009d72 	.word	0x00009d72

c0d06aac <USBD_InterfaceStrDescriptor>:
  * @retval Pointer to descriptor buffer
  */
static uint8_t *USBD_InterfaceStrDescriptor(USBD_SpeedTypeDef speed, uint16_t *length)
{
  UNUSED(speed);
  *length = sizeof(USBD_INTERFACE_FS_STRING);
c0d06aac:	200e      	movs	r0, #14
c0d06aae:	8008      	strh	r0, [r1, #0]
  return (uint8_t*)USBD_INTERFACE_FS_STRING;
c0d06ab0:	4801      	ldr	r0, [pc, #4]	; (c0d06ab8 <USBD_InterfaceStrDescriptor+0xc>)
c0d06ab2:	4478      	add	r0, pc
c0d06ab4:	4770      	bx	lr
c0d06ab6:	46c0      	nop			; (mov r8, r8)
c0d06ab8:	00009d62 	.word	0x00009d62

c0d06abc <USBD_CtlError>:
  WEBUSB_VENDOR_CODE, // bVencordCode
  1 // iLanding
};

// upon unsupported request, check for webusb request
void USBD_CtlError( USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef *req) {
c0d06abc:	b580      	push	{r7, lr}
  if ((req->bmRequest & 0x80) && req->bRequest == WEBUSB_VENDOR_CODE && req->wIndex == WEBUSB_REQ_GET_URL
c0d06abe:	780a      	ldrb	r2, [r1, #0]
c0d06ac0:	b252      	sxtb	r2, r2
c0d06ac2:	2a00      	cmp	r2, #0
c0d06ac4:	db02      	blt.n	c0d06acc <USBD_CtlError+0x10>
  }
  else if ((req->bmRequest & 0x80) && req->bRequest == USB_REQ_GET_DESCRIPTOR && (req->wValue>>8) == USB_DT_BOS) {
    USBD_CtlSendData(pdev, (unsigned char*)C_usb_bos, sizeof(C_usb_bos));
  }
  else {
    USBD_CtlStall(pdev);
c0d06ac6:	f7ff fe34 	bl	c0d06732 <USBD_CtlStall>
  }
}
c0d06aca:	bd80      	pop	{r7, pc}
  1 // iLanding
};

// upon unsupported request, check for webusb request
void USBD_CtlError( USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef *req) {
  if ((req->bmRequest & 0x80) && req->bRequest == WEBUSB_VENDOR_CODE && req->wIndex == WEBUSB_REQ_GET_URL
c0d06acc:	784a      	ldrb	r2, [r1, #1]
c0d06ace:	2a06      	cmp	r2, #6
c0d06ad0:	d00d      	beq.n	c0d06aee <USBD_CtlError+0x32>
c0d06ad2:	2a1e      	cmp	r2, #30
c0d06ad4:	d1f7      	bne.n	c0d06ac6 <USBD_CtlError+0xa>
c0d06ad6:	888a      	ldrh	r2, [r1, #4]
    // HTTPS url
    && req->wValue == 1) {
c0d06ad8:	2a02      	cmp	r2, #2
c0d06ada:	d1f4      	bne.n	c0d06ac6 <USBD_CtlError+0xa>
c0d06adc:	8849      	ldrh	r1, [r1, #2]
  1 // iLanding
};

// upon unsupported request, check for webusb request
void USBD_CtlError( USBD_HandleTypeDef *pdev , USBD_SetupReqTypedef *req) {
  if ((req->bmRequest & 0x80) && req->bRequest == WEBUSB_VENDOR_CODE && req->wIndex == WEBUSB_REQ_GET_URL
c0d06ade:	2901      	cmp	r1, #1
c0d06ae0:	d1f1      	bne.n	c0d06ac6 <USBD_CtlError+0xa>
    // HTTPS url
    && req->wValue == 1) {
    // return the URL descriptor
    USBD_CtlSendData (pdev, (unsigned char*)C_webusb_url_descriptor, sizeof(C_webusb_url_descriptor));
c0d06ae2:	4907      	ldr	r1, [pc, #28]	; (c0d06b00 <USBD_CtlError+0x44>)
c0d06ae4:	4479      	add	r1, pc
c0d06ae6:	2217      	movs	r2, #23
c0d06ae8:	f000 f86a 	bl	c0d06bc0 <USBD_CtlSendData>
    USBD_CtlSendData(pdev, (unsigned char*)C_usb_bos, sizeof(C_usb_bos));
  }
  else {
    USBD_CtlStall(pdev);
  }
}
c0d06aec:	bd80      	pop	{r7, pc}
    // HTTPS url
    && req->wValue == 1) {
    // return the URL descriptor
    USBD_CtlSendData (pdev, (unsigned char*)C_webusb_url_descriptor, sizeof(C_webusb_url_descriptor));
  }
  else if ((req->bmRequest & 0x80) && req->bRequest == USB_REQ_GET_DESCRIPTOR && (req->wValue>>8) == USB_DT_BOS) {
c0d06aee:	78c9      	ldrb	r1, [r1, #3]
c0d06af0:	290f      	cmp	r1, #15
c0d06af2:	d1e8      	bne.n	c0d06ac6 <USBD_CtlError+0xa>
    USBD_CtlSendData(pdev, (unsigned char*)C_usb_bos, sizeof(C_usb_bos));
c0d06af4:	4903      	ldr	r1, [pc, #12]	; (c0d06b04 <USBD_CtlError+0x48>)
c0d06af6:	4479      	add	r1, pc
c0d06af8:	221d      	movs	r2, #29
c0d06afa:	f000 f861 	bl	c0d06bc0 <USBD_CtlSendData>
  }
  else {
    USBD_CtlStall(pdev);
  }
}
c0d06afe:	bd80      	pop	{r7, pc}
c0d06b00:	00009c30 	.word	0x00009c30
c0d06b04:	00009c35 	.word	0x00009c35

c0d06b08 <USB_power>:
  // nothing to do ?
  return 0;
}
#endif // HAVE_USB_CLASS_CCID

void USB_power(unsigned char enabled) {
c0d06b08:	b570      	push	{r4, r5, r6, lr}
c0d06b0a:	4604      	mov	r4, r0
c0d06b0c:	2045      	movs	r0, #69	; 0x45
c0d06b0e:	0085      	lsls	r5, r0, #2
  os_memset(&USBD_Device, 0, sizeof(USBD_Device));
c0d06b10:	481c      	ldr	r0, [pc, #112]	; (c0d06b84 <USB_power+0x7c>)
c0d06b12:	2100      	movs	r1, #0
c0d06b14:	462a      	mov	r2, r5
c0d06b16:	f7fb ff83 	bl	c0d02a20 <os_memset>

  if (enabled) {
c0d06b1a:	2c00      	cmp	r4, #0
c0d06b1c:	d02d      	beq.n	c0d06b7a <USB_power+0x72>
    os_memset(&USBD_Device, 0, sizeof(USBD_Device));
c0d06b1e:	4c19      	ldr	r4, [pc, #100]	; (c0d06b84 <USB_power+0x7c>)
c0d06b20:	2600      	movs	r6, #0
c0d06b22:	4620      	mov	r0, r4
c0d06b24:	4631      	mov	r1, r6
c0d06b26:	462a      	mov	r2, r5
c0d06b28:	f7fb ff7a 	bl	c0d02a20 <os_memset>
    /* Init Device Library */
    USBD_Init(&USBD_Device, (USBD_DescriptorsTypeDef*)&HID_Desc, 0);
c0d06b2c:	4918      	ldr	r1, [pc, #96]	; (c0d06b90 <USB_power+0x88>)
c0d06b2e:	4479      	add	r1, pc
c0d06b30:	4620      	mov	r0, r4
c0d06b32:	4632      	mov	r2, r6
c0d06b34:	f7ff f9e6 	bl	c0d05f04 <USBD_Init>
    
    /* Register the HID class */
    USBD_RegisterClassForInterface(HID_INTF,  &USBD_Device, (USBD_ClassTypeDef*)&USBD_HID);
c0d06b38:	4a16      	ldr	r2, [pc, #88]	; (c0d06b94 <USB_power+0x8c>)
c0d06b3a:	447a      	add	r2, pc
c0d06b3c:	4630      	mov	r0, r6
c0d06b3e:	4621      	mov	r1, r4
c0d06b40:	f7ff fa18 	bl	c0d05f74 <USBD_RegisterClassForInterface>
#ifdef HAVE_IO_U2F
    USBD_RegisterClassForInterface(U2F_INTF,  &USBD_Device, (USBD_ClassTypeDef*)&USBD_U2F);
c0d06b44:	2001      	movs	r0, #1
c0d06b46:	4a14      	ldr	r2, [pc, #80]	; (c0d06b98 <USB_power+0x90>)
c0d06b48:	447a      	add	r2, pc
c0d06b4a:	4621      	mov	r1, r4
c0d06b4c:	f7ff fa12 	bl	c0d05f74 <USBD_RegisterClassForInterface>
    // initialize the U2F tunnel transport
    u2f_transport_init(&G_io_u2f, G_io_apdu_buffer, IO_APDU_BUFFER_SIZE);
c0d06b50:	22ff      	movs	r2, #255	; 0xff
c0d06b52:	3252      	adds	r2, #82	; 0x52
c0d06b54:	480c      	ldr	r0, [pc, #48]	; (c0d06b88 <USB_power+0x80>)
c0d06b56:	490d      	ldr	r1, [pc, #52]	; (c0d06b8c <USB_power+0x84>)
c0d06b58:	f7fd fc62 	bl	c0d04420 <u2f_transport_init>
#ifdef HAVE_USB_CLASS_CCID
    USBD_RegisterClassForInterface(CCID_INTF, &USBD_Device, (USBD_ClassTypeDef*)&USBD_CCID);
#endif // HAVE_USB_CLASS_CCID

#ifdef HAVE_WEBUSB
    USBD_RegisterClassForInterface(WEBUSB_INTF, &USBD_Device, (USBD_ClassTypeDef*)&USBD_WEBUSB);
c0d06b5c:	2002      	movs	r0, #2
c0d06b5e:	4a0f      	ldr	r2, [pc, #60]	; (c0d06b9c <USB_power+0x94>)
c0d06b60:	447a      	add	r2, pc
c0d06b62:	4621      	mov	r1, r4
c0d06b64:	f7ff fa06 	bl	c0d05f74 <USBD_RegisterClassForInterface>
    USBD_LL_PrepareReceive(&USBD_Device, WEBUSB_EPOUT_ADDR , WEBUSB_EPOUT_SIZE);
c0d06b68:	2103      	movs	r1, #3
c0d06b6a:	2240      	movs	r2, #64	; 0x40
c0d06b6c:	4620      	mov	r0, r4
c0d06b6e:	f7ff f9b6 	bl	c0d05ede <USBD_LL_PrepareReceive>
#endif // HAVE_WEBUSB

    /* Start Device Process */
    USBD_Start(&USBD_Device);
c0d06b72:	4620      	mov	r0, r4
c0d06b74:	f7ff fa0a 	bl	c0d05f8c <USBD_Start>
  }
  else {
    USBD_DeInit(&USBD_Device);
  }
}
c0d06b78:	bd70      	pop	{r4, r5, r6, pc}

    /* Start Device Process */
    USBD_Start(&USBD_Device);
  }
  else {
    USBD_DeInit(&USBD_Device);
c0d06b7a:	4802      	ldr	r0, [pc, #8]	; (c0d06b84 <USB_power+0x7c>)
c0d06b7c:	f7ff f9dc 	bl	c0d05f38 <USBD_DeInit>
  }
}
c0d06b80:	bd70      	pop	{r4, r5, r6, pc}
c0d06b82:	46c0      	nop			; (mov r8, r8)
c0d06b84:	20001fa4 	.word	0x20001fa4
c0d06b88:	20001ecc 	.word	0x20001ecc
c0d06b8c:	20001d4c 	.word	0x20001d4c
c0d06b90:	00009bc6 	.word	0x00009bc6
c0d06b94:	00009c0e 	.word	0x00009c0e
c0d06b98:	00009c38 	.word	0x00009c38
c0d06b9c:	00009c58 	.word	0x00009c58

c0d06ba0 <USBD_GetCfgDesc_impl>:
  * @param  length : pointer data length
  * @retval pointer to descriptor buffer
  */
static uint8_t  *USBD_GetCfgDesc_impl (uint16_t *length)
{
  *length = sizeof (USBD_CfgDesc);
c0d06ba0:	2160      	movs	r1, #96	; 0x60
c0d06ba2:	8001      	strh	r1, [r0, #0]
  return (uint8_t*)USBD_CfgDesc;
c0d06ba4:	4801      	ldr	r0, [pc, #4]	; (c0d06bac <USBD_GetCfgDesc_impl+0xc>)
c0d06ba6:	4478      	add	r0, pc
c0d06ba8:	4770      	bx	lr
c0d06baa:	46c0      	nop			; (mov r8, r8)
c0d06bac:	00009c86 	.word	0x00009c86

c0d06bb0 <USBD_GetDeviceQualifierDesc_impl>:
* @param  length : pointer data length
* @retval pointer to descriptor buffer
*/
static uint8_t  *USBD_GetDeviceQualifierDesc_impl (uint16_t *length)
{
  *length = sizeof (USBD_DeviceQualifierDesc);
c0d06bb0:	210a      	movs	r1, #10
c0d06bb2:	8001      	strh	r1, [r0, #0]
  return (uint8_t*)USBD_DeviceQualifierDesc;
c0d06bb4:	4801      	ldr	r0, [pc, #4]	; (c0d06bbc <USBD_GetDeviceQualifierDesc_impl+0xc>)
c0d06bb6:	4478      	add	r0, pc
c0d06bb8:	4770      	bx	lr
c0d06bba:	46c0      	nop			; (mov r8, r8)
c0d06bbc:	00009cd6 	.word	0x00009cd6

c0d06bc0 <USBD_CtlSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendData (USBD_HandleTypeDef  *pdev, 
                               uint8_t *pbuf,
                               uint16_t len)
{
c0d06bc0:	b5b0      	push	{r4, r5, r7, lr}
c0d06bc2:	460c      	mov	r4, r1
  /* Set EP0 State */
  pdev->ep0_state          = USBD_EP0_DATA_IN;                                      
c0d06bc4:	21d4      	movs	r1, #212	; 0xd4
c0d06bc6:	2302      	movs	r3, #2
c0d06bc8:	5043      	str	r3, [r0, r1]
  pdev->ep_in[0].total_length = len;
c0d06bca:	6182      	str	r2, [r0, #24]
  pdev->ep_in[0].rem_length   = len;
c0d06bcc:	61c2      	str	r2, [r0, #28]
  // store the continuation data if needed
  pdev->pData = pbuf;
c0d06bce:	2111      	movs	r1, #17
c0d06bd0:	0109      	lsls	r1, r1, #4
c0d06bd2:	5044      	str	r4, [r0, r1]
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, MIN(len, pdev->ep_in[0].maxpacket));  
c0d06bd4:	6a01      	ldr	r1, [r0, #32]
c0d06bd6:	428a      	cmp	r2, r1
c0d06bd8:	d300      	bcc.n	c0d06bdc <USBD_CtlSendData+0x1c>
c0d06bda:	460a      	mov	r2, r1
c0d06bdc:	b293      	uxth	r3, r2
c0d06bde:	2500      	movs	r5, #0
c0d06be0:	4629      	mov	r1, r5
c0d06be2:	4622      	mov	r2, r4
c0d06be4:	f7ff f962 	bl	c0d05eac <USBD_LL_Transmit>
  
  return USBD_OK;
c0d06be8:	4628      	mov	r0, r5
c0d06bea:	bdb0      	pop	{r4, r5, r7, pc}

c0d06bec <USBD_CtlContinueSendData>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueSendData (USBD_HandleTypeDef  *pdev, 
                                       uint8_t *pbuf,
                                       uint16_t len)
{
c0d06bec:	b5b0      	push	{r4, r5, r7, lr}
c0d06bee:	460c      	mov	r4, r1
 /* Start the next transfer */
  USBD_LL_Transmit (pdev, 0x00, pbuf, MIN(len, pdev->ep_in[0].maxpacket));   
c0d06bf0:	6a01      	ldr	r1, [r0, #32]
c0d06bf2:	428a      	cmp	r2, r1
c0d06bf4:	d300      	bcc.n	c0d06bf8 <USBD_CtlContinueSendData+0xc>
c0d06bf6:	460a      	mov	r2, r1
c0d06bf8:	b293      	uxth	r3, r2
c0d06bfa:	2500      	movs	r5, #0
c0d06bfc:	4629      	mov	r1, r5
c0d06bfe:	4622      	mov	r2, r4
c0d06c00:	f7ff f954 	bl	c0d05eac <USBD_LL_Transmit>
  return USBD_OK;
c0d06c04:	4628      	mov	r0, r5
c0d06c06:	bdb0      	pop	{r4, r5, r7, pc}

c0d06c08 <USBD_CtlContinueRx>:
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlContinueRx (USBD_HandleTypeDef  *pdev, 
                                          uint8_t *pbuf,                                          
                                          uint16_t len)
{
c0d06c08:	b510      	push	{r4, lr}
c0d06c0a:	2400      	movs	r4, #0
  UNUSED(pbuf);
  USBD_LL_PrepareReceive (pdev,
c0d06c0c:	4621      	mov	r1, r4
c0d06c0e:	f7ff f966 	bl	c0d05ede <USBD_LL_PrepareReceive>
                          0,                                            
                          len);
  return USBD_OK;
c0d06c12:	4620      	mov	r0, r4
c0d06c14:	bd10      	pop	{r4, pc}

c0d06c16 <USBD_CtlSendStatus>:
*         send zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlSendStatus (USBD_HandleTypeDef  *pdev)
{
c0d06c16:	b510      	push	{r4, lr}

  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_IN;
c0d06c18:	21d4      	movs	r1, #212	; 0xd4
c0d06c1a:	2204      	movs	r2, #4
c0d06c1c:	5042      	str	r2, [r0, r1]
c0d06c1e:	2400      	movs	r4, #0
  
 /* Start the transfer */
  USBD_LL_Transmit (pdev, 0x00, NULL, 0);   
c0d06c20:	4621      	mov	r1, r4
c0d06c22:	4622      	mov	r2, r4
c0d06c24:	4623      	mov	r3, r4
c0d06c26:	f7ff f941 	bl	c0d05eac <USBD_LL_Transmit>
  
  return USBD_OK;
c0d06c2a:	4620      	mov	r0, r4
c0d06c2c:	bd10      	pop	{r4, pc}

c0d06c2e <USBD_CtlReceiveStatus>:
*         receive zero lzngth packet on the ctl pipe
* @param  pdev: device instance
* @retval status
*/
USBD_StatusTypeDef  USBD_CtlReceiveStatus (USBD_HandleTypeDef  *pdev)
{
c0d06c2e:	b510      	push	{r4, lr}
  /* Set EP0 State */
  pdev->ep0_state = USBD_EP0_STATUS_OUT; 
c0d06c30:	21d4      	movs	r1, #212	; 0xd4
c0d06c32:	2205      	movs	r2, #5
c0d06c34:	5042      	str	r2, [r0, r1]
c0d06c36:	2400      	movs	r4, #0
  
 /* Start the transfer */  
  USBD_LL_PrepareReceive ( pdev,
c0d06c38:	4621      	mov	r1, r4
c0d06c3a:	4622      	mov	r2, r4
c0d06c3c:	f7ff f94f 	bl	c0d05ede <USBD_LL_PrepareReceive>
                    0,
                    0);  

  return USBD_OK;
c0d06c40:	4620      	mov	r0, r4
c0d06c42:	bd10      	pop	{r4, pc}

c0d06c44 <array_hexstr>:
#include "uint256.h"

static const unsigned char hex_digits[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                                           '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

void array_hexstr(char *strbuf, const void *bin, unsigned int len) {
c0d06c44:	b5f0      	push	{r4, r5, r6, r7, lr}
    while (len--) {
c0d06c46:	2a00      	cmp	r2, #0
c0d06c48:	d010      	beq.n	c0d06c6c <array_hexstr+0x28>
c0d06c4a:	0053      	lsls	r3, r2, #1
c0d06c4c:	a409      	add	r4, pc, #36	; (adr r4, c0d06c74 <hex_digits>)
c0d06c4e:	4605      	mov	r5, r0
        *strbuf++ = hex_digits[((*((char *)bin)) >> 4) & 0xF];
c0d06c50:	780e      	ldrb	r6, [r1, #0]
c0d06c52:	0936      	lsrs	r6, r6, #4
c0d06c54:	5da6      	ldrb	r6, [r4, r6]
c0d06c56:	702e      	strb	r6, [r5, #0]
        *strbuf++ = hex_digits[(*((char *)bin)) & 0xF];
c0d06c58:	780e      	ldrb	r6, [r1, #0]
c0d06c5a:	270f      	movs	r7, #15
c0d06c5c:	4037      	ands	r7, r6
c0d06c5e:	5de6      	ldrb	r6, [r4, r7]
c0d06c60:	706e      	strb	r6, [r5, #1]

static const unsigned char hex_digits[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                                           '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

void array_hexstr(char *strbuf, const void *bin, unsigned int len) {
    while (len--) {
c0d06c62:	1cad      	adds	r5, r5, #2
        *strbuf++ = hex_digits[((*((char *)bin)) >> 4) & 0xF];
        *strbuf++ = hex_digits[(*((char *)bin)) & 0xF];
        bin = (const void *)((unsigned int)bin + 1);
c0d06c64:	1c49      	adds	r1, r1, #1

static const unsigned char hex_digits[] = {'0', '1', '2', '3', '4', '5', '6', '7',
                                           '8', '9', 'A', 'B', 'C', 'D', 'E', 'F'};

void array_hexstr(char *strbuf, const void *bin, unsigned int len) {
    while (len--) {
c0d06c66:	1e52      	subs	r2, r2, #1
c0d06c68:	d1f2      	bne.n	c0d06c50 <array_hexstr+0xc>
c0d06c6a:	18c0      	adds	r0, r0, r3
        *strbuf++ = hex_digits[((*((char *)bin)) >> 4) & 0xF];
        *strbuf++ = hex_digits[(*((char *)bin)) & 0xF];
        bin = (const void *)((unsigned int)bin + 1);
    }
    *strbuf = 0; // EOS
c0d06c6c:	2100      	movs	r1, #0
c0d06c6e:	7001      	strb	r1, [r0, #0]
}
c0d06c70:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d06c72:	46c0      	nop			; (mov r8, r8)

c0d06c74 <hex_digits>:
c0d06c74:	33323130 	.word	0x33323130
c0d06c78:	37363534 	.word	0x37363534
c0d06c7c:	42413938 	.word	0x42413938
c0d06c80:	46454443 	.word	0x46454443

c0d06c84 <convertUint256BE>:

void convertUint256BE(uint8_t *data, uint32_t length, uint256_t *target) {
c0d06c84:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d06c86:	b089      	sub	sp, #36	; 0x24
c0d06c88:	4614      	mov	r4, r2
c0d06c8a:	460e      	mov	r6, r1
c0d06c8c:	4607      	mov	r7, r0
c0d06c8e:	ad01      	add	r5, sp, #4
c0d06c90:	2100      	movs	r1, #0
c0d06c92:	2220      	movs	r2, #32
    uint8_t tmp[32];
    os_memset(tmp, 0, 32);
c0d06c94:	4628      	mov	r0, r5
c0d06c96:	f7fb fec3 	bl	c0d02a20 <os_memset>
    os_memmove(tmp + 32 - length, data, length);
c0d06c9a:	1ba8      	subs	r0, r5, r6
c0d06c9c:	3020      	adds	r0, #32
c0d06c9e:	4639      	mov	r1, r7
c0d06ca0:	4632      	mov	r2, r6
c0d06ca2:	f7fb fec6 	bl	c0d02a32 <os_memmove>
    readu256BE(tmp, target);
c0d06ca6:	4628      	mov	r0, r5
c0d06ca8:	4621      	mov	r1, r4
c0d06caa:	f7fd ff5d 	bl	c0d04b68 <readu256BE>
}
c0d06cae:	b009      	add	sp, #36	; 0x24
c0d06cb0:	bdf0      	pop	{r4, r5, r6, r7, pc}

c0d06cb2 <getV>:
        }
    }
    return -1;
}

uint32_t getV(txContent_t *txContent) {
c0d06cb2:	b580      	push	{r7, lr}
    uint32_t v = 0;
    if (txContent->vLength == 1) {
c0d06cb4:	217c      	movs	r1, #124	; 0x7c
c0d06cb6:	5c42      	ldrb	r2, [r0, r1]
c0d06cb8:	2100      	movs	r1, #0
c0d06cba:	2a01      	cmp	r2, #1
c0d06cbc:	dd14      	ble.n	c0d06ce8 <getV+0x36>
c0d06cbe:	2a02      	cmp	r2, #2
c0d06cc0:	d019      	beq.n	c0d06cf6 <getV+0x44>
c0d06cc2:	2a03      	cmp	r2, #3
c0d06cc4:	d01d      	beq.n	c0d06d02 <getV+0x50>
c0d06cc6:	2a04      	cmp	r2, #4
c0d06cc8:	d127      	bne.n	c0d06d1a <getV+0x68>
c0d06cca:	2178      	movs	r1, #120	; 0x78
    if (txContent->vLength == 3) {
      v = (txContent->v[0] << 16) | (txContent->v[1] << 8) | txContent->v[2];
    }
    else
    if (txContent->vLength == 4) {
      v = (txContent->v[0] << 24) | (txContent->v[1] << 16) |
c0d06ccc:	5c41      	ldrb	r1, [r0, r1]
c0d06cce:	0609      	lsls	r1, r1, #24
c0d06cd0:	2279      	movs	r2, #121	; 0x79
c0d06cd2:	5c82      	ldrb	r2, [r0, r2]
c0d06cd4:	0412      	lsls	r2, r2, #16
c0d06cd6:	430a      	orrs	r2, r1
          (txContent->v[2] << 8) | txContent->v[3];
c0d06cd8:	217a      	movs	r1, #122	; 0x7a
c0d06cda:	5c41      	ldrb	r1, [r0, r1]
c0d06cdc:	020b      	lsls	r3, r1, #8
    if (txContent->vLength == 3) {
      v = (txContent->v[0] << 16) | (txContent->v[1] << 8) | txContent->v[2];
    }
    else
    if (txContent->vLength == 4) {
      v = (txContent->v[0] << 24) | (txContent->v[1] << 16) |
c0d06cde:	4313      	orrs	r3, r2
          (txContent->v[2] << 8) | txContent->v[3];
c0d06ce0:	217b      	movs	r1, #123	; 0x7b
c0d06ce2:	5c41      	ldrb	r1, [r0, r1]
c0d06ce4:	4319      	orrs	r1, r3
c0d06ce6:	e016      	b.n	c0d06d16 <getV+0x64>
c0d06ce8:	2a00      	cmp	r2, #0
c0d06cea:	d014      	beq.n	c0d06d16 <getV+0x64>
c0d06cec:	2a01      	cmp	r2, #1
c0d06cee:	d114      	bne.n	c0d06d1a <getV+0x68>
}

uint32_t getV(txContent_t *txContent) {
    uint32_t v = 0;
    if (txContent->vLength == 1) {
      v = txContent->v[0];
c0d06cf0:	2178      	movs	r1, #120	; 0x78
c0d06cf2:	5c41      	ldrb	r1, [r0, r1]
c0d06cf4:	e00f      	b.n	c0d06d16 <getV+0x64>
    }
    else
    if (txContent->vLength == 2) {
      v = (txContent->v[0] << 8) | txContent->v[1];
c0d06cf6:	2179      	movs	r1, #121	; 0x79
c0d06cf8:	5c42      	ldrb	r2, [r0, r1]
c0d06cfa:	2178      	movs	r1, #120	; 0x78
c0d06cfc:	5c40      	ldrb	r0, [r0, r1]
c0d06cfe:	0201      	lsls	r1, r0, #8
c0d06d00:	e008      	b.n	c0d06d14 <getV+0x62>
c0d06d02:	2178      	movs	r1, #120	; 0x78
    }
    else
    if (txContent->vLength == 3) {
      v = (txContent->v[0] << 16) | (txContent->v[1] << 8) | txContent->v[2];
c0d06d04:	5c41      	ldrb	r1, [r0, r1]
c0d06d06:	0409      	lsls	r1, r1, #16
c0d06d08:	2279      	movs	r2, #121	; 0x79
c0d06d0a:	5c82      	ldrb	r2, [r0, r2]
c0d06d0c:	0212      	lsls	r2, r2, #8
c0d06d0e:	430a      	orrs	r2, r1
c0d06d10:	217a      	movs	r1, #122	; 0x7a
c0d06d12:	5c41      	ldrb	r1, [r0, r1]
c0d06d14:	4311      	orrs	r1, r2
    else
    if (txContent->vLength != 0) {
        PRINTF("Unexpected v format\n");
        THROW(EXCEPTION);
    }
    return v;
c0d06d16:	4608      	mov	r0, r1
c0d06d18:	bd80      	pop	{r7, pc}
          (txContent->v[2] << 8) | txContent->v[3];
    }
    else
    if (txContent->vLength != 0) {
        PRINTF("Unexpected v format\n");
        THROW(EXCEPTION);
c0d06d1a:	2001      	movs	r0, #1
c0d06d1c:	f7fb ff3d 	bl	c0d02b9a <os_longjmp>

c0d06d20 <__aeabi_uidiv>:
c0d06d20:	2200      	movs	r2, #0
c0d06d22:	0843      	lsrs	r3, r0, #1
c0d06d24:	428b      	cmp	r3, r1
c0d06d26:	d374      	bcc.n	c0d06e12 <__aeabi_uidiv+0xf2>
c0d06d28:	0903      	lsrs	r3, r0, #4
c0d06d2a:	428b      	cmp	r3, r1
c0d06d2c:	d35f      	bcc.n	c0d06dee <__aeabi_uidiv+0xce>
c0d06d2e:	0a03      	lsrs	r3, r0, #8
c0d06d30:	428b      	cmp	r3, r1
c0d06d32:	d344      	bcc.n	c0d06dbe <__aeabi_uidiv+0x9e>
c0d06d34:	0b03      	lsrs	r3, r0, #12
c0d06d36:	428b      	cmp	r3, r1
c0d06d38:	d328      	bcc.n	c0d06d8c <__aeabi_uidiv+0x6c>
c0d06d3a:	0c03      	lsrs	r3, r0, #16
c0d06d3c:	428b      	cmp	r3, r1
c0d06d3e:	d30d      	bcc.n	c0d06d5c <__aeabi_uidiv+0x3c>
c0d06d40:	22ff      	movs	r2, #255	; 0xff
c0d06d42:	0209      	lsls	r1, r1, #8
c0d06d44:	ba12      	rev	r2, r2
c0d06d46:	0c03      	lsrs	r3, r0, #16
c0d06d48:	428b      	cmp	r3, r1
c0d06d4a:	d302      	bcc.n	c0d06d52 <__aeabi_uidiv+0x32>
c0d06d4c:	1212      	asrs	r2, r2, #8
c0d06d4e:	0209      	lsls	r1, r1, #8
c0d06d50:	d065      	beq.n	c0d06e1e <__aeabi_uidiv+0xfe>
c0d06d52:	0b03      	lsrs	r3, r0, #12
c0d06d54:	428b      	cmp	r3, r1
c0d06d56:	d319      	bcc.n	c0d06d8c <__aeabi_uidiv+0x6c>
c0d06d58:	e000      	b.n	c0d06d5c <__aeabi_uidiv+0x3c>
c0d06d5a:	0a09      	lsrs	r1, r1, #8
c0d06d5c:	0bc3      	lsrs	r3, r0, #15
c0d06d5e:	428b      	cmp	r3, r1
c0d06d60:	d301      	bcc.n	c0d06d66 <__aeabi_uidiv+0x46>
c0d06d62:	03cb      	lsls	r3, r1, #15
c0d06d64:	1ac0      	subs	r0, r0, r3
c0d06d66:	4152      	adcs	r2, r2
c0d06d68:	0b83      	lsrs	r3, r0, #14
c0d06d6a:	428b      	cmp	r3, r1
c0d06d6c:	d301      	bcc.n	c0d06d72 <__aeabi_uidiv+0x52>
c0d06d6e:	038b      	lsls	r3, r1, #14
c0d06d70:	1ac0      	subs	r0, r0, r3
c0d06d72:	4152      	adcs	r2, r2
c0d06d74:	0b43      	lsrs	r3, r0, #13
c0d06d76:	428b      	cmp	r3, r1
c0d06d78:	d301      	bcc.n	c0d06d7e <__aeabi_uidiv+0x5e>
c0d06d7a:	034b      	lsls	r3, r1, #13
c0d06d7c:	1ac0      	subs	r0, r0, r3
c0d06d7e:	4152      	adcs	r2, r2
c0d06d80:	0b03      	lsrs	r3, r0, #12
c0d06d82:	428b      	cmp	r3, r1
c0d06d84:	d301      	bcc.n	c0d06d8a <__aeabi_uidiv+0x6a>
c0d06d86:	030b      	lsls	r3, r1, #12
c0d06d88:	1ac0      	subs	r0, r0, r3
c0d06d8a:	4152      	adcs	r2, r2
c0d06d8c:	0ac3      	lsrs	r3, r0, #11
c0d06d8e:	428b      	cmp	r3, r1
c0d06d90:	d301      	bcc.n	c0d06d96 <__aeabi_uidiv+0x76>
c0d06d92:	02cb      	lsls	r3, r1, #11
c0d06d94:	1ac0      	subs	r0, r0, r3
c0d06d96:	4152      	adcs	r2, r2
c0d06d98:	0a83      	lsrs	r3, r0, #10
c0d06d9a:	428b      	cmp	r3, r1
c0d06d9c:	d301      	bcc.n	c0d06da2 <__aeabi_uidiv+0x82>
c0d06d9e:	028b      	lsls	r3, r1, #10
c0d06da0:	1ac0      	subs	r0, r0, r3
c0d06da2:	4152      	adcs	r2, r2
c0d06da4:	0a43      	lsrs	r3, r0, #9
c0d06da6:	428b      	cmp	r3, r1
c0d06da8:	d301      	bcc.n	c0d06dae <__aeabi_uidiv+0x8e>
c0d06daa:	024b      	lsls	r3, r1, #9
c0d06dac:	1ac0      	subs	r0, r0, r3
c0d06dae:	4152      	adcs	r2, r2
c0d06db0:	0a03      	lsrs	r3, r0, #8
c0d06db2:	428b      	cmp	r3, r1
c0d06db4:	d301      	bcc.n	c0d06dba <__aeabi_uidiv+0x9a>
c0d06db6:	020b      	lsls	r3, r1, #8
c0d06db8:	1ac0      	subs	r0, r0, r3
c0d06dba:	4152      	adcs	r2, r2
c0d06dbc:	d2cd      	bcs.n	c0d06d5a <__aeabi_uidiv+0x3a>
c0d06dbe:	09c3      	lsrs	r3, r0, #7
c0d06dc0:	428b      	cmp	r3, r1
c0d06dc2:	d301      	bcc.n	c0d06dc8 <__aeabi_uidiv+0xa8>
c0d06dc4:	01cb      	lsls	r3, r1, #7
c0d06dc6:	1ac0      	subs	r0, r0, r3
c0d06dc8:	4152      	adcs	r2, r2
c0d06dca:	0983      	lsrs	r3, r0, #6
c0d06dcc:	428b      	cmp	r3, r1
c0d06dce:	d301      	bcc.n	c0d06dd4 <__aeabi_uidiv+0xb4>
c0d06dd0:	018b      	lsls	r3, r1, #6
c0d06dd2:	1ac0      	subs	r0, r0, r3
c0d06dd4:	4152      	adcs	r2, r2
c0d06dd6:	0943      	lsrs	r3, r0, #5
c0d06dd8:	428b      	cmp	r3, r1
c0d06dda:	d301      	bcc.n	c0d06de0 <__aeabi_uidiv+0xc0>
c0d06ddc:	014b      	lsls	r3, r1, #5
c0d06dde:	1ac0      	subs	r0, r0, r3
c0d06de0:	4152      	adcs	r2, r2
c0d06de2:	0903      	lsrs	r3, r0, #4
c0d06de4:	428b      	cmp	r3, r1
c0d06de6:	d301      	bcc.n	c0d06dec <__aeabi_uidiv+0xcc>
c0d06de8:	010b      	lsls	r3, r1, #4
c0d06dea:	1ac0      	subs	r0, r0, r3
c0d06dec:	4152      	adcs	r2, r2
c0d06dee:	08c3      	lsrs	r3, r0, #3
c0d06df0:	428b      	cmp	r3, r1
c0d06df2:	d301      	bcc.n	c0d06df8 <__aeabi_uidiv+0xd8>
c0d06df4:	00cb      	lsls	r3, r1, #3
c0d06df6:	1ac0      	subs	r0, r0, r3
c0d06df8:	4152      	adcs	r2, r2
c0d06dfa:	0883      	lsrs	r3, r0, #2
c0d06dfc:	428b      	cmp	r3, r1
c0d06dfe:	d301      	bcc.n	c0d06e04 <__aeabi_uidiv+0xe4>
c0d06e00:	008b      	lsls	r3, r1, #2
c0d06e02:	1ac0      	subs	r0, r0, r3
c0d06e04:	4152      	adcs	r2, r2
c0d06e06:	0843      	lsrs	r3, r0, #1
c0d06e08:	428b      	cmp	r3, r1
c0d06e0a:	d301      	bcc.n	c0d06e10 <__aeabi_uidiv+0xf0>
c0d06e0c:	004b      	lsls	r3, r1, #1
c0d06e0e:	1ac0      	subs	r0, r0, r3
c0d06e10:	4152      	adcs	r2, r2
c0d06e12:	1a41      	subs	r1, r0, r1
c0d06e14:	d200      	bcs.n	c0d06e18 <__aeabi_uidiv+0xf8>
c0d06e16:	4601      	mov	r1, r0
c0d06e18:	4152      	adcs	r2, r2
c0d06e1a:	4610      	mov	r0, r2
c0d06e1c:	4770      	bx	lr
c0d06e1e:	e7ff      	b.n	c0d06e20 <__aeabi_uidiv+0x100>
c0d06e20:	b501      	push	{r0, lr}
c0d06e22:	2000      	movs	r0, #0
c0d06e24:	f000 f806 	bl	c0d06e34 <__aeabi_idiv0>
c0d06e28:	bd02      	pop	{r1, pc}
c0d06e2a:	46c0      	nop			; (mov r8, r8)

c0d06e2c <__aeabi_uidivmod>:
c0d06e2c:	2900      	cmp	r1, #0
c0d06e2e:	d0f7      	beq.n	c0d06e20 <__aeabi_uidiv+0x100>
c0d06e30:	e776      	b.n	c0d06d20 <__aeabi_uidiv>
c0d06e32:	4770      	bx	lr

c0d06e34 <__aeabi_idiv0>:
c0d06e34:	4770      	bx	lr
c0d06e36:	46c0      	nop			; (mov r8, r8)

c0d06e38 <__aeabi_lmul>:
c0d06e38:	b5f0      	push	{r4, r5, r6, r7, lr}
c0d06e3a:	464f      	mov	r7, r9
c0d06e3c:	4646      	mov	r6, r8
c0d06e3e:	b4c0      	push	{r6, r7}
c0d06e40:	0416      	lsls	r6, r2, #16
c0d06e42:	0c36      	lsrs	r6, r6, #16
c0d06e44:	4699      	mov	r9, r3
c0d06e46:	0033      	movs	r3, r6
c0d06e48:	0405      	lsls	r5, r0, #16
c0d06e4a:	0c2c      	lsrs	r4, r5, #16
c0d06e4c:	0c07      	lsrs	r7, r0, #16
c0d06e4e:	0c15      	lsrs	r5, r2, #16
c0d06e50:	4363      	muls	r3, r4
c0d06e52:	437e      	muls	r6, r7
c0d06e54:	436f      	muls	r7, r5
c0d06e56:	4365      	muls	r5, r4
c0d06e58:	0c1c      	lsrs	r4, r3, #16
c0d06e5a:	19ad      	adds	r5, r5, r6
c0d06e5c:	1964      	adds	r4, r4, r5
c0d06e5e:	469c      	mov	ip, r3
c0d06e60:	42a6      	cmp	r6, r4
c0d06e62:	d903      	bls.n	c0d06e6c <__aeabi_lmul+0x34>
c0d06e64:	2380      	movs	r3, #128	; 0x80
c0d06e66:	025b      	lsls	r3, r3, #9
c0d06e68:	4698      	mov	r8, r3
c0d06e6a:	4447      	add	r7, r8
c0d06e6c:	4663      	mov	r3, ip
c0d06e6e:	0c25      	lsrs	r5, r4, #16
c0d06e70:	19ef      	adds	r7, r5, r7
c0d06e72:	041d      	lsls	r5, r3, #16
c0d06e74:	464b      	mov	r3, r9
c0d06e76:	434a      	muls	r2, r1
c0d06e78:	4343      	muls	r3, r0
c0d06e7a:	0c2d      	lsrs	r5, r5, #16
c0d06e7c:	0424      	lsls	r4, r4, #16
c0d06e7e:	1964      	adds	r4, r4, r5
c0d06e80:	1899      	adds	r1, r3, r2
c0d06e82:	19c9      	adds	r1, r1, r7
c0d06e84:	0020      	movs	r0, r4
c0d06e86:	bc0c      	pop	{r2, r3}
c0d06e88:	4690      	mov	r8, r2
c0d06e8a:	4699      	mov	r9, r3
c0d06e8c:	bdf0      	pop	{r4, r5, r6, r7, pc}
c0d06e8e:	46c0      	nop			; (mov r8, r8)

c0d06e90 <__aeabi_memclr>:
c0d06e90:	b510      	push	{r4, lr}
c0d06e92:	2200      	movs	r2, #0
c0d06e94:	f000 f806 	bl	c0d06ea4 <__aeabi_memset>
c0d06e98:	bd10      	pop	{r4, pc}
c0d06e9a:	46c0      	nop			; (mov r8, r8)

c0d06e9c <__aeabi_memcpy>:
c0d06e9c:	b510      	push	{r4, lr}
c0d06e9e:	f000 f809 	bl	c0d06eb4 <memcpy>
c0d06ea2:	bd10      	pop	{r4, pc}

c0d06ea4 <__aeabi_memset>:
c0d06ea4:	0013      	movs	r3, r2
c0d06ea6:	b510      	push	{r4, lr}
c0d06ea8:	000a      	movs	r2, r1
c0d06eaa:	0019      	movs	r1, r3
c0d06eac:	f000 f840 	bl	c0d06f30 <memset>
c0d06eb0:	bd10      	pop	{r4, pc}
c0d06eb2:	46c0      	nop			; (mov r8, r8)

c0d06eb4 <memcpy>:
c0d06eb4:	b570      	push	{r4, r5, r6, lr}
c0d06eb6:	2a0f      	cmp	r2, #15
c0d06eb8:	d932      	bls.n	c0d06f20 <memcpy+0x6c>
c0d06eba:	000c      	movs	r4, r1
c0d06ebc:	4304      	orrs	r4, r0
c0d06ebe:	000b      	movs	r3, r1
c0d06ec0:	07a4      	lsls	r4, r4, #30
c0d06ec2:	d131      	bne.n	c0d06f28 <memcpy+0x74>
c0d06ec4:	0015      	movs	r5, r2
c0d06ec6:	0004      	movs	r4, r0
c0d06ec8:	3d10      	subs	r5, #16
c0d06eca:	092d      	lsrs	r5, r5, #4
c0d06ecc:	3501      	adds	r5, #1
c0d06ece:	012d      	lsls	r5, r5, #4
c0d06ed0:	1949      	adds	r1, r1, r5
c0d06ed2:	681e      	ldr	r6, [r3, #0]
c0d06ed4:	6026      	str	r6, [r4, #0]
c0d06ed6:	685e      	ldr	r6, [r3, #4]
c0d06ed8:	6066      	str	r6, [r4, #4]
c0d06eda:	689e      	ldr	r6, [r3, #8]
c0d06edc:	60a6      	str	r6, [r4, #8]
c0d06ede:	68de      	ldr	r6, [r3, #12]
c0d06ee0:	3310      	adds	r3, #16
c0d06ee2:	60e6      	str	r6, [r4, #12]
c0d06ee4:	3410      	adds	r4, #16
c0d06ee6:	4299      	cmp	r1, r3
c0d06ee8:	d1f3      	bne.n	c0d06ed2 <memcpy+0x1e>
c0d06eea:	230f      	movs	r3, #15
c0d06eec:	1945      	adds	r5, r0, r5
c0d06eee:	4013      	ands	r3, r2
c0d06ef0:	2b03      	cmp	r3, #3
c0d06ef2:	d91b      	bls.n	c0d06f2c <memcpy+0x78>
c0d06ef4:	1f1c      	subs	r4, r3, #4
c0d06ef6:	2300      	movs	r3, #0
c0d06ef8:	08a4      	lsrs	r4, r4, #2
c0d06efa:	3401      	adds	r4, #1
c0d06efc:	00a4      	lsls	r4, r4, #2
c0d06efe:	58ce      	ldr	r6, [r1, r3]
c0d06f00:	50ee      	str	r6, [r5, r3]
c0d06f02:	3304      	adds	r3, #4
c0d06f04:	429c      	cmp	r4, r3
c0d06f06:	d1fa      	bne.n	c0d06efe <memcpy+0x4a>
c0d06f08:	2303      	movs	r3, #3
c0d06f0a:	192d      	adds	r5, r5, r4
c0d06f0c:	1909      	adds	r1, r1, r4
c0d06f0e:	401a      	ands	r2, r3
c0d06f10:	d005      	beq.n	c0d06f1e <memcpy+0x6a>
c0d06f12:	2300      	movs	r3, #0
c0d06f14:	5ccc      	ldrb	r4, [r1, r3]
c0d06f16:	54ec      	strb	r4, [r5, r3]
c0d06f18:	3301      	adds	r3, #1
c0d06f1a:	429a      	cmp	r2, r3
c0d06f1c:	d1fa      	bne.n	c0d06f14 <memcpy+0x60>
c0d06f1e:	bd70      	pop	{r4, r5, r6, pc}
c0d06f20:	0005      	movs	r5, r0
c0d06f22:	2a00      	cmp	r2, #0
c0d06f24:	d1f5      	bne.n	c0d06f12 <memcpy+0x5e>
c0d06f26:	e7fa      	b.n	c0d06f1e <memcpy+0x6a>
c0d06f28:	0005      	movs	r5, r0
c0d06f2a:	e7f2      	b.n	c0d06f12 <memcpy+0x5e>
c0d06f2c:	001a      	movs	r2, r3
c0d06f2e:	e7f8      	b.n	c0d06f22 <memcpy+0x6e>

c0d06f30 <memset>:
c0d06f30:	b570      	push	{r4, r5, r6, lr}
c0d06f32:	0783      	lsls	r3, r0, #30
c0d06f34:	d03f      	beq.n	c0d06fb6 <memset+0x86>
c0d06f36:	1e54      	subs	r4, r2, #1
c0d06f38:	2a00      	cmp	r2, #0
c0d06f3a:	d03b      	beq.n	c0d06fb4 <memset+0x84>
c0d06f3c:	b2ce      	uxtb	r6, r1
c0d06f3e:	0003      	movs	r3, r0
c0d06f40:	2503      	movs	r5, #3
c0d06f42:	e003      	b.n	c0d06f4c <memset+0x1c>
c0d06f44:	1e62      	subs	r2, r4, #1
c0d06f46:	2c00      	cmp	r4, #0
c0d06f48:	d034      	beq.n	c0d06fb4 <memset+0x84>
c0d06f4a:	0014      	movs	r4, r2
c0d06f4c:	3301      	adds	r3, #1
c0d06f4e:	1e5a      	subs	r2, r3, #1
c0d06f50:	7016      	strb	r6, [r2, #0]
c0d06f52:	422b      	tst	r3, r5
c0d06f54:	d1f6      	bne.n	c0d06f44 <memset+0x14>
c0d06f56:	2c03      	cmp	r4, #3
c0d06f58:	d924      	bls.n	c0d06fa4 <memset+0x74>
c0d06f5a:	25ff      	movs	r5, #255	; 0xff
c0d06f5c:	400d      	ands	r5, r1
c0d06f5e:	022a      	lsls	r2, r5, #8
c0d06f60:	4315      	orrs	r5, r2
c0d06f62:	042a      	lsls	r2, r5, #16
c0d06f64:	4315      	orrs	r5, r2
c0d06f66:	2c0f      	cmp	r4, #15
c0d06f68:	d911      	bls.n	c0d06f8e <memset+0x5e>
c0d06f6a:	0026      	movs	r6, r4
c0d06f6c:	3e10      	subs	r6, #16
c0d06f6e:	0936      	lsrs	r6, r6, #4
c0d06f70:	3601      	adds	r6, #1
c0d06f72:	0136      	lsls	r6, r6, #4
c0d06f74:	001a      	movs	r2, r3
c0d06f76:	199b      	adds	r3, r3, r6
c0d06f78:	6015      	str	r5, [r2, #0]
c0d06f7a:	6055      	str	r5, [r2, #4]
c0d06f7c:	6095      	str	r5, [r2, #8]
c0d06f7e:	60d5      	str	r5, [r2, #12]
c0d06f80:	3210      	adds	r2, #16
c0d06f82:	4293      	cmp	r3, r2
c0d06f84:	d1f8      	bne.n	c0d06f78 <memset+0x48>
c0d06f86:	220f      	movs	r2, #15
c0d06f88:	4014      	ands	r4, r2
c0d06f8a:	2c03      	cmp	r4, #3
c0d06f8c:	d90a      	bls.n	c0d06fa4 <memset+0x74>
c0d06f8e:	1f26      	subs	r6, r4, #4
c0d06f90:	08b6      	lsrs	r6, r6, #2
c0d06f92:	3601      	adds	r6, #1
c0d06f94:	00b6      	lsls	r6, r6, #2
c0d06f96:	001a      	movs	r2, r3
c0d06f98:	199b      	adds	r3, r3, r6
c0d06f9a:	c220      	stmia	r2!, {r5}
c0d06f9c:	4293      	cmp	r3, r2
c0d06f9e:	d1fc      	bne.n	c0d06f9a <memset+0x6a>
c0d06fa0:	2203      	movs	r2, #3
c0d06fa2:	4014      	ands	r4, r2
c0d06fa4:	2c00      	cmp	r4, #0
c0d06fa6:	d005      	beq.n	c0d06fb4 <memset+0x84>
c0d06fa8:	b2c9      	uxtb	r1, r1
c0d06faa:	191c      	adds	r4, r3, r4
c0d06fac:	7019      	strb	r1, [r3, #0]
c0d06fae:	3301      	adds	r3, #1
c0d06fb0:	429c      	cmp	r4, r3
c0d06fb2:	d1fb      	bne.n	c0d06fac <memset+0x7c>
c0d06fb4:	bd70      	pop	{r4, r5, r6, pc}
c0d06fb6:	0014      	movs	r4, r2
c0d06fb8:	0003      	movs	r3, r0
c0d06fba:	e7cc      	b.n	c0d06f56 <memset+0x26>

c0d06fbc <setjmp>:
c0d06fbc:	c0f0      	stmia	r0!, {r4, r5, r6, r7}
c0d06fbe:	4641      	mov	r1, r8
c0d06fc0:	464a      	mov	r2, r9
c0d06fc2:	4653      	mov	r3, sl
c0d06fc4:	465c      	mov	r4, fp
c0d06fc6:	466d      	mov	r5, sp
c0d06fc8:	4676      	mov	r6, lr
c0d06fca:	c07e      	stmia	r0!, {r1, r2, r3, r4, r5, r6}
c0d06fcc:	3828      	subs	r0, #40	; 0x28
c0d06fce:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
c0d06fd0:	2000      	movs	r0, #0
c0d06fd2:	4770      	bx	lr

c0d06fd4 <longjmp>:
c0d06fd4:	3010      	adds	r0, #16
c0d06fd6:	c87c      	ldmia	r0!, {r2, r3, r4, r5, r6}
c0d06fd8:	4690      	mov	r8, r2
c0d06fda:	4699      	mov	r9, r3
c0d06fdc:	46a2      	mov	sl, r4
c0d06fde:	46ab      	mov	fp, r5
c0d06fe0:	46b5      	mov	sp, r6
c0d06fe2:	c808      	ldmia	r0!, {r3}
c0d06fe4:	3828      	subs	r0, #40	; 0x28
c0d06fe6:	c8f0      	ldmia	r0!, {r4, r5, r6, r7}
c0d06fe8:	1c08      	adds	r0, r1, #0
c0d06fea:	d100      	bne.n	c0d06fee <longjmp+0x1a>
c0d06fec:	2001      	movs	r0, #1
c0d06fee:	4718      	bx	r3

c0d06ff0 <strlen>:
c0d06ff0:	b510      	push	{r4, lr}
c0d06ff2:	0783      	lsls	r3, r0, #30
c0d06ff4:	d027      	beq.n	c0d07046 <strlen+0x56>
c0d06ff6:	7803      	ldrb	r3, [r0, #0]
c0d06ff8:	2b00      	cmp	r3, #0
c0d06ffa:	d026      	beq.n	c0d0704a <strlen+0x5a>
c0d06ffc:	0003      	movs	r3, r0
c0d06ffe:	2103      	movs	r1, #3
c0d07000:	e002      	b.n	c0d07008 <strlen+0x18>
c0d07002:	781a      	ldrb	r2, [r3, #0]
c0d07004:	2a00      	cmp	r2, #0
c0d07006:	d01c      	beq.n	c0d07042 <strlen+0x52>
c0d07008:	3301      	adds	r3, #1
c0d0700a:	420b      	tst	r3, r1
c0d0700c:	d1f9      	bne.n	c0d07002 <strlen+0x12>
c0d0700e:	6819      	ldr	r1, [r3, #0]
c0d07010:	4a0f      	ldr	r2, [pc, #60]	; (c0d07050 <strlen+0x60>)
c0d07012:	4c10      	ldr	r4, [pc, #64]	; (c0d07054 <strlen+0x64>)
c0d07014:	188a      	adds	r2, r1, r2
c0d07016:	438a      	bics	r2, r1
c0d07018:	4222      	tst	r2, r4
c0d0701a:	d10f      	bne.n	c0d0703c <strlen+0x4c>
c0d0701c:	3304      	adds	r3, #4
c0d0701e:	6819      	ldr	r1, [r3, #0]
c0d07020:	4a0b      	ldr	r2, [pc, #44]	; (c0d07050 <strlen+0x60>)
c0d07022:	188a      	adds	r2, r1, r2
c0d07024:	438a      	bics	r2, r1
c0d07026:	4222      	tst	r2, r4
c0d07028:	d108      	bne.n	c0d0703c <strlen+0x4c>
c0d0702a:	3304      	adds	r3, #4
c0d0702c:	6819      	ldr	r1, [r3, #0]
c0d0702e:	4a08      	ldr	r2, [pc, #32]	; (c0d07050 <strlen+0x60>)
c0d07030:	188a      	adds	r2, r1, r2
c0d07032:	438a      	bics	r2, r1
c0d07034:	4222      	tst	r2, r4
c0d07036:	d0f1      	beq.n	c0d0701c <strlen+0x2c>
c0d07038:	e000      	b.n	c0d0703c <strlen+0x4c>
c0d0703a:	3301      	adds	r3, #1
c0d0703c:	781a      	ldrb	r2, [r3, #0]
c0d0703e:	2a00      	cmp	r2, #0
c0d07040:	d1fb      	bne.n	c0d0703a <strlen+0x4a>
c0d07042:	1a18      	subs	r0, r3, r0
c0d07044:	bd10      	pop	{r4, pc}
c0d07046:	0003      	movs	r3, r0
c0d07048:	e7e1      	b.n	c0d0700e <strlen+0x1e>
c0d0704a:	2000      	movs	r0, #0
c0d0704c:	e7fa      	b.n	c0d07044 <strlen+0x54>
c0d0704e:	46c0      	nop			; (mov r8, r8)
c0d07050:	fefefeff 	.word	0xfefefeff
c0d07054:	80808080 	.word	0x80808080

c0d07058 <C_icon_back_colors>:
c0d07058:	00000000 00ffffff                       ........

c0d07060 <C_icon_back_bitmap>:
c0d07060:	c1fe01e0 067f38fd c4ff81df bcfff37f     .....8..........
c0d07070:	f1e7e71f 7807f83f 00000000              ....?..x....

c0d0707c <C_icon_back>:
c0d0707c:	0000000e 0000000e 00000001 c0d07058     ............Xp..
c0d0708c:	c0d07060                                `p..

c0d07090 <C_icon_dashboard_colors>:
c0d07090:	00000000 00ffffff                       ........

c0d07098 <C_icon_dashboard_bitmap>:
c0d07098:	c1fe01e0 067038ff 9e7e79d8 b9e7e79f     .....8p..y~.....
c0d070a8:	f1c0e601 7807f83f 00000000              ....?..x....

c0d070b4 <C_icon_dashboard>:
c0d070b4:	0000000e 0000000e 00000001 c0d07090     .............p..
c0d070c4:	c0d07098 59006f4e 43007365 72746e6f     .p..No.Yes.Contr
c0d070d4:	20746361 61746164 73694400 79616c70     act data.Display
c0d070e4:	74616420 61420061 56006b63 69737265      data.Back.Versi
c0d070f4:	31006e6f 312e322e 65735500 6c617720     on.1.2.1.Use wal
c0d07104:	2074656c 76006f74 20776569 6f636361     let to.view acco
c0d07114:	73746e75 74655300 676e6974 62410073     unts.Settings.Ab
c0d07124:	0074756f 74697551 70706120 6e6f4300     out.Quit app.Con
c0d07134:	6d726966 64646100 73736572 64644100     firm.address.Add
c0d07144:	73736572 61727400 6361736e 6e6f6974     ress.transaction
c0d07154:	52415700 474e494e 74614400 72702061     .WARNING.Data pr
c0d07164:	6e657365 6d410074 746e756f 78614d00     esent.Amount.Max
c0d07174:	6d756d69 65656620 69530073 74206e67     imum fees.Sign t
c0d07184:	6d006568 61737365 4d006567 61737365     he.message.Messa
c0d07194:	68206567 00687361 656c6573 726f7463     ge hash.selector
c0d071a4:	6c655300 6f746365 61700072 656d6172     .Selector.parame
c0d071b4:	00726574 20485445 00000000              ter.ETH ....

c0d071c0 <menu_settings_data>:
c0d071c0:	00000000 c0d00a01 00000000 00000000     ................
c0d071d0:	c0d070c8 00000000 00000000 00000000     .p..............
c0d071e0:	c0d00a01 00000001 00000000 c0d070cb     .............p..
	...

c0d07214 <menu_settings_details>:
c0d07214:	00000000 c0d00a31 00000000 00000000     ....1...........
c0d07224:	c0d070c8 00000000 00000000 00000000     .p..............
c0d07234:	c0d00a31 00000001 00000000 c0d070cb     1............p..
	...

c0d07268 <menu_settings>:
c0d07268:	00000000 c0d00a65 00000000 00000000     ....e...........
c0d07278:	c0d070cf 00000000 00000000 00000000     .p..............
c0d07288:	c0d00a8d 00000000 00000000 c0d070dd     .............p..
	...
c0d072a0:	c0d0732c 00000000 00000001 c0d0707c     ,s..........|p..
c0d072b0:	c0d070ea 00000000 0000283d 00000000     .p......=(......
	...

c0d072d8 <menu_about>:
	...
c0d072e8:	c0d070ef c0d070f7 00000000 c0d0732c     .p...p......,s..
c0d072f8:	00000000 00000002 c0d0707c c0d070ea     ........|p...p..
c0d07308:	00000000 0000283d 00000000 00000000     ....=(..........
	...

c0d0732c <menu_main>:
	...
c0d0733c:	c0d070fd c0d0710b 00000000 c0d07268     .p...q......hr..
	...
c0d07358:	c0d07119 00000000 00000000 c0d072d8     .q...........r..
	...
c0d07374:	c0d07122 00000000 00000000 00000000     "q..............
c0d07384:	c0d03ff5 00000000 c0d070b4 c0d07128     .?.......p..(q..
c0d07394:	00000000 00001d32 00000000 00000000     ....2...........
	...

c0d073b8 <ui_address_nanos>:
c0d073b8:	00000003 00800000 00000020 00000001     ........ .......
c0d073c8:	00000000 00ffffff 00000000 00000000     ................
	...
c0d073f0:	00030005 0007000c 00000007 00000000     ................
c0d07400:	00ffffff 00000000 00070000 00000000     ................
	...
c0d07428:	00750005 0008000d 00000006 00000000     ..u.............
c0d07438:	00ffffff 00000000 00060000 00000000     ................
	...
c0d07460:	00000107 0080000c 0000000c 00000000     ................
c0d07470:	00ffffff 00000000 00008008 c0d07131     ............1q..
	...
c0d07498:	00000107 0080001a 0000000c 00000000     ................
c0d074a8:	00ffffff 00000000 00008008 c0d07139     ............9q..
	...
c0d074d0:	00000207 0080000c 0000000c 00000000     ................
c0d074e0:	00ffffff 00000000 0000800a c0d07141     ............Aq..
	...
c0d07508:	00170207 0052001a 008a000c 00000000     ......R.........
c0d07518:	00ffffff 00000000 001a8008 20001802     ............... 
	...

c0d07540 <ui_approval_nanos>:
c0d07540:	00000003 00800000 00000020 00000001     ........ .......
c0d07550:	00000000 00ffffff 00000000 00000000     ................
	...
c0d07578:	00030005 0007000c 00000007 00000000     ................
c0d07588:	00ffffff 00000000 00070000 00000000     ................
	...
c0d075b0:	00750005 0008000d 00000006 00000000     ..u.............
c0d075c0:	00ffffff 00000000 00060000 00000000     ................
	...
c0d075e8:	00000107 0080000c 00000020 00000000     ........ .......
c0d075f8:	00ffffff 00000000 00008008 c0d07131     ............1q..
	...
c0d07620:	00000107 0080001a 00000020 00000000     ........ .......
c0d07630:	00ffffff 00000000 00008008 c0d07149     ............Iq..
	...
c0d07658:	00000207 0080000c 00000020 00000000     ........ .......
c0d07668:	00ffffff 00000000 0000800a c0d07155     ............Uq..
	...
c0d07690:	00170207 0052001a 0000000c 00000000     ......R.........
c0d076a0:	00ffffff 00000000 00008008 c0d0715d     ............]q..
	...
c0d076c8:	00000307 0080000c 00000020 00000000     ........ .......
c0d076d8:	00ffffff 00000000 0000800a c0d0716a     ............jq..
	...
c0d07700:	00170307 0052001a 008a000c 00000000     ......R.........
c0d07710:	00ffffff 00000000 001a8008 2000182d     ............-.. 
	...
c0d07738:	00000407 0080000c 00000020 00000000     ........ .......
c0d07748:	00ffffff 00000000 0000800a c0d07141     ............Aq..
	...
c0d07770:	00170407 0052001a 008a000c 00000000     ......R.........
c0d07780:	00ffffff 00000000 00328008 20001802     ..........2.... 
	...
c0d077a8:	00000507 0080000c 00000020 00000000     ........ .......
c0d077b8:	00ffffff 00000000 0000800a c0d07171     ............qq..
	...
c0d077e0:	00170507 0052001a 008a000c 00000000     ......R.........
c0d077f0:	00ffffff 00000000 001a8008 2000185f     ............_.. 
	...

c0d07818 <ui_approval_signMessage_nanos>:
c0d07818:	00000003 00800000 00000020 00000001     ........ .......
c0d07828:	00000000 00ffffff 00000000 00000000     ................
	...
c0d07850:	00030005 0007000c 00000007 00000000     ................
c0d07860:	00ffffff 00000000 00070000 00000000     ................
	...
c0d07888:	00750005 0008000d 00000006 00000000     ..u.............
c0d07898:	00ffffff 00000000 00060000 00000000     ................
	...
c0d078c0:	00000107 0080000c 00000020 00000000     ........ .......
c0d078d0:	00ffffff 00000000 00008008 c0d0717e     ............~q..
	...
c0d078f8:	00000107 0080001a 00000020 00000000     ........ .......
c0d07908:	00ffffff 00000000 00008008 c0d07187     .............q..
	...
c0d07930:	00000207 0080000c 00000020 00000000     ........ .......
c0d07940:	00ffffff 00000000 0000800a c0d0718f     .............q..
	...
c0d07968:	00000207 0080001a 00000020 00000000     ........ .......
c0d07978:	00ffffff 00000000 00008008 20001802     ............... 
	...

c0d079a0 <ui_data_selector_nanos>:
c0d079a0:	00000003 00800000 00000020 00000001     ........ .......
c0d079b0:	00000000 00ffffff 00000000 00000000     ................
	...
c0d079d8:	00030005 0007000c 00000007 00000000     ................
c0d079e8:	00ffffff 00000000 00070000 00000000     ................
	...
c0d07a10:	00750005 0008000d 00000006 00000000     ..u.............
c0d07a20:	00ffffff 00000000 00060000 00000000     ................
	...
c0d07a48:	00000107 0080000c 0000000c 00000000     ................
c0d07a58:	00ffffff 00000000 00008008 c0d07131     ............1q..
	...
c0d07a80:	00000107 0080001a 0000000c 00000000     ................
c0d07a90:	00ffffff 00000000 00008008 c0d0719c     .............q..
	...
c0d07ab8:	00000207 0080000c 0000000c 00000000     ................
c0d07ac8:	00ffffff 00000000 0000800a c0d071a5     .............q..
	...
c0d07af0:	00170207 0052001a 008a000c 00000000     ......R.........
c0d07b00:	00ffffff 00000000 001a8008 20001802     ............... 
	...

c0d07b28 <ui_data_parameter_nanos>:
c0d07b28:	00000003 00800000 00000020 00000001     ........ .......
c0d07b38:	00000000 00ffffff 00000000 00000000     ................
	...
c0d07b60:	00030005 0007000c 00000007 00000000     ................
c0d07b70:	00ffffff 00000000 00070000 00000000     ................
	...
c0d07b98:	00750005 0008000d 00000006 00000000     ..u.............
c0d07ba8:	00ffffff 00000000 00060000 00000000     ................
	...
c0d07bd0:	00000107 0080000c 0000000c 00000000     ................
c0d07be0:	00ffffff 00000000 00008008 c0d07131     ............1q..
	...
c0d07c08:	00000107 0080001a 0000000c 00000000     ................
c0d07c18:	00ffffff 00000000 00008008 c0d071ae     .............q..
	...
c0d07c40:	00000207 0080000c 0000000c 00000000     ................
c0d07c50:	00ffffff 00000000 0000800a 20001866     ............f.. 
	...
c0d07c78:	00170207 0052001a 008a000c 00000000     ......R.........
c0d07c88:	00ffffff 00000000 001a8008 20001802     ............... 
	...

c0d07cb0 <TOKEN_TRANSFER_ID>:
c0d07cb0:	bb9c05a9                                ....

c0d07cb4 <CONTRACT_ADDRESS>:
c0d07cb4:	2077654e 746e6f63 74636172 6c5e0400              New contract.

c0d07cc1 <TOKEN_SIGNATURE_PUBLIC_KEY>:
c0d07cc1:	106c5e04 c44dc120 89fe4264 680b7cf9     .^l. .M.dB...|.h
c0d07cd1:	7659b1cd 4cf224dc 307b6e31 c78c4efe     ..Yv.$.L1n{0.N..
c0d07ce1:	1589146b 4e51210c f50f44bf 3d39a5de     k....!QN.D....9=
c0d07cf1:	5853de83 ce8f09cd 1df8d08f 919794aa     ..SX............
c0d07d01:	74451983                                         .

c0d07d02 <SIGN_MAGIC>:
c0d07d02:	68744519 75657265 6953206d 64656e67     .Ethereum Signed
c0d07d12:	73654d20 65676173 00000a3a 71b80000               Message:.....

c0d07d20 <C_chain_config>:
c0d07d20:	c0d071b8 00000000 00000000 00000000     .q..............
c0d07d30:	0000044e 00000004 00000000 00000000     N...............
c0d07d40:	00000000 00000006 00000000 00000000     ................
	...
c0d07d64:	00000001 00000000 00000000 00000000     ................
	...

c0d07d8c <ux_menu_elements>:
c0d07d8c:	00008003 00800000 00000020 00000001     ........ .......
c0d07d9c:	00000000 00ffffff 00000000 00000000     ................
	...
c0d07dc4:	00038105 0007000e 00000004 00000000     ................
c0d07dd4:	00ffffff 00000000 000b0000 00000000     ................
	...
c0d07dfc:	00768205 0007000e 00000004 00000000     ..v.............
c0d07e0c:	00ffffff 00000000 000c0000 00000000     ................
	...
c0d07e34:	000e4107 00640003 0000000c 00000000     .A....d.........
c0d07e44:	00ffffff 00000000 0000800a 00000000     ................
	...
c0d07e6c:	000e4207 00640023 0000000c 00000000     .B..#.d.........
c0d07e7c:	00ffffff 00000000 0000800a 00000000     ................
	...
c0d07ea4:	000e1005 00000009 00000000 00000000     ................
c0d07eb4:	00ffffff 00000000 00000000 00000000     ................
	...
c0d07edc:	000e2007 00640013 0000000c 00000000     . ....d.........
c0d07eec:	00ffffff 00000000 00008008 00000000     ................
	...
c0d07f14:	000e2107 0064000c 0000000c 00000000     .!....d.........
c0d07f24:	00ffffff 00000000 00008008 00000000     ................
	...
c0d07f4c:	000e2207 0064001a 0000000c 00000000     ."....d.........
c0d07f5c:	00ffffff 00000000 00008008 00000000     ................
	...

c0d07f84 <UX_MENU_END_ENTRY>:
	...

c0d07fa0 <TOKENS_AKROMA>:
c0d07fa0:	e5e9844e 26970afb 6845cf28 7e1603c4     N......&(.Eh...~
c0d07fb0:	3104d4f1 43464624 00000020 a0120000     ...1$FFC .......
c0d07fc0:	7e05e824 9b4a47ec 37835623 7905dd07     $..~.GJ.#V.7...y
c0d07fd0:	24f36ee2 20585946 00000000 b7cd1200     .n.$FYX ........
c0d07fe0:	0334fdec 2c88f3ee ef61b765 8954509b     ..4....,e.a..PT.
c0d07ff0:	4824470a 00205255 00000000 d8b80d12     .G$HUR .........
c0d08000:	61c36bb7 2eb7cbba 061e492c ab975a08     .k.a....,I...Z..
c0d08010:	51492431 0000204e 12000000 6df5d77d     1$IQN ......}..m
c0d08020:	f2c07c69 5cd52bb5 8f377f05 4babe61f     i|...+.\..7....K
c0d08030:	41455424 0000204b b6120000 c64476ed     $TEAK .......vD.
c0d08040:	7bd61694 bc202e52 9b9a4a29 30315b40     ...{R. .)J..@[10
c0d08050:	43544278 00000020 30af0800 0de9a7d2     xBTC ......0....
c0d08060:	c861c37d 9b5e58c4 f1f6d2b7 5331c75b     }.a..X^.....[.1S
c0d08070:	00002054 00000000 1abcfd12 f8f026dc     T ...........&..
c0d08080:	5d6a60f8 a3d3b763 2bc221cd 4f573123     .`j]c....!.+#1WO
c0d08090:	00000020 08000000 e5e57300 e24f2b2e      ........s...+O.
c0d080a0:	995dd718 c8b3e24e ea879c2f 20783232     ..].N.../...22x 
c0d080b0:	00000000 9f080000 203258c0 eefa44eb     .........X2 .D..
c0d080c0:	e6c12d9e 4d20393f 329090dd 00204344     .-..?9 M...2DC .
c0d080d0:	00000000 c9ae1200 1088708a c3784841     .........p..AHx.
c0d080e0:	aa46dfbc 4aed1dd3 30335745 00002030     ..F....JEW300 ..
c0d080f0:	00000000 41024312 291d8c36 db21da3f     .....C.A6..)?.!.
c0d08100:	f37abba8 91c50720 544c3309 00000020     ..z. ....3LT ...
c0d08110:	08000000 a2cb7dba bc19e3ad dfb42d77     .....}......w-..
c0d08120:	a06ba775 b031fb0d 20383141 00000000     u.k...1.A18 ....
c0d08130:	cc120000 ead8267d 36bb8162 5148843c     ....}&..b..6<.HQ
c0d08140:	f7612c5f 41f019bc 20484342 00000000     _,a....ABCH ....
c0d08150:	8db91200 5d42974c 6ee60899 f6fda653     ....L.B]...nS...
c0d08160:	0bcaac73 424186e9 00002054 00000000     s.....ABT ......
c0d08170:	6b8d0e12 2f331e47 9d7d0e14 e3e599bb     ...kG.3/..}.....
c0d08180:	8d722f82 594241a6 00205353 12000000     ./r..ABYSS .....
c0d08190:	fdb7f113 66fce1fb 48566d67 ecb1213e     .......fgmVH>!..
c0d081a0:	e2580bb4 20434341 00000000 06120000     ..X.ACC ........
c0d081b0:	02107114 a88b762b 388f9af9 151af15d     .q..+v.....8]...
c0d081c0:	41c89c1a 00204543 00000000 aa2b0000     ...ACE .......+.
c0d081d0:	f90c33c9 819d47ac 4d799591 760cad79     .3...G....yMy..v
c0d081e0:	4441e316 00002042 00000000 359ae612     ..ADB .........5
c0d081f0:	dd52313b f76f707b 1dfe40dd 2d80b718     ;1R.{po..@.....-
c0d08200:	48444131 00000020 12000000 34c61088     1ADH ..........4
c0d08210:	3986d370 416b4c95 8445c5aa 4a48468c     p..9.LkA..E..FHJ
c0d08220:	20494441 00000000 66120000 3748710e     ADI .......f.qH7
c0d08230:	3361f685 f6108b54 32c36d92 41616eb0     ..a3T....m.2.naA
c0d08240:	00204c44 00000000 28421200 b0f0a866     DL .......B(f...
c0d08250:	1dcfc532 1af3defb 9550f420 4441b062     2....... .P.b.AD
c0d08260:	00205453 00000000 d6d6d000 674afec5     ST ...........Jg
c0d08270:	c43c347d b76b5333 67e1ba17 544441dd     }4<.3Sk....g.ADT
c0d08280:	00000020 09000000 87bb7044 3a967bd7      .......Dp...{.:
c0d08290:	39b93d01 922f33be 2e992b7f 20584441     .=.9.3/..+..ADX 
c0d082a0:	00000000 5c040000 1d1ba7a9 0a9c8401     .......\........
c0d082b0:	c00c4995 7f715905 411d0dcf 00002045     .I...Yq....AE ..
c0d082c0:	00000000 b28e1200 37391943 768d6616     ........C.97.f.v
c0d082d0:	93c2ce8d ff9cae56 474185e2 00002049     ....V.....AGI ..
c0d082e0:	00000000 e3215108 da97e848 23ef1eef     .....Q!.H......#
c0d082f0:	90b29a95 f27c55e5 20494174 00000000     .....U|.tAI ....
c0d08300:	12000000 9b78e837 ac6c99b9 5fcd5691     ....7.x...l..V._
c0d08310:	9925d35f 8912b9e6 20444941 00000000     _.%.....AID ....
c0d08320:	4c120000 6a90a7ed 9717d25e 403acd85     ...L...j^.....:@
c0d08330:	bce89ea6 4166c499 204e4f49 00000000     ......fAION ....
c0d08340:	dc270800 3f4dece1 57e4c372 4f3550cc     ..'...M?r..W.P5O
c0d08350:	de5d971f 494188f4 00002052 00000000     ..]...AIR ......
c0d08360:	ce631008 d5654252 f424a6a3 57cd4a91     ..c.RBe...$..J.W
c0d08370:	e99cd83d 58494188 00000020 12000000     =....AIX .......
c0d08380:	173aa41c 9361ad0b 4df5e622 507eb546     ..:...a."..MF.~P
c0d08390:	aa63b64d 20434b41 00000000 18120000     M.c.AKC ........
c0d083a0:	6d74631a 56f3dc3a ce3ac7cb fb2f8322     .ctm:..V..:."./.
c0d083b0:	415aeeb1 204f434c 00000000 89420800     ..ZALCO ......B.
c0d083c0:	23a143c0 7302f192 2758fb07 85bd8e2d     .C.#...s..X'-...
c0d083d0:	4c411239 00002049 00000000 0b61ea12     9.ALI ........a.
c0d083e0:	77475311 c18d7420 0078d33e 4fd84139     .SGw t..>.x.9A.O
c0d083f0:	494c41ab 00002053 12000000 49c18a63     .ALIS ......c..I
c0d08400:	a1f98eea b9416c28 a77a0177 fa6c9e35     ....(lA.w.z.5.l.
c0d08410:	53544c41 00000020 49120000 33bc27b1     ALTS ......I.'.3
c0d08420:	86157ece c6ce28ec 25115ba6 4122c896     .~...(...[.%.."A
c0d08430:	0020584c 00000000 c34d1200 64bc3d64     LX .......M.d=.d
c0d08440:	58c1722b ffd2f3e7 1cf62d23 4d41ceb6     +r.X....#-....AM
c0d08450:	00002042 00000000 ed9b9412 9f736c88     B ...........ls.
c0d08460:	6273321a db20339b c724500c 494d4119     .2sb.3 ..P$..AMI
c0d08470:	00002053 09000000 69720eca 3f350d60     S ........ri`.5?
c0d08480:	d14ab170 7595a418 2f0f5c45 544c4d41     p.J....uE\./AMLT
c0d08490:	00000020 73120000 8cac987f 682c9fa5      ......s......,h
c0d084a0:	3c8e65ad 63898c3d 414c0ae4 00204e4d     .e.<=..c..LAMN .
c0d084b0:	00000000 c8381200 2b9ba87a 5bb9d98c     ......8.z..+...[
c0d084c0:	a71f6e73 97ea12b6 4d416921 0000204f     sn......!iAMO ..
c0d084d0:	00000000 6c938412 a30a63f7 afd97de2     .......l.c...}..
c0d084e0:	40b168f9 9fe4aed5 544d415a 00002043     .h.@....ZAMTC ..
c0d084f0:	08000000 6a230b96 2612cf07 3330c463     ......#j...&c.03
c0d08500:	669a6050 c088b2a7 20544e41 00000000     P`.f....ANT ....
c0d08510:	9a120000 95d765b1 8b6d9b01 da1d973e     .....e....m.>...
c0d08520:	21140791 415a5e30 0020414f 00000000     ...!0^ZAOA .....
c0d08530:	0f4c1200 66b41bbe 795e9112 21c3d267     ..L....f..^yg..!
c0d08540:	72d8d43c 5041ad57 00205349 00000000     <..rW.APIS .....
c0d08550:	8b7a1a12 2b6f10d9 087e978d d2c72d58     ..z...o+..~.X-..
c0d08560:	b03a724c 505041db 00002043 12000000     Lr:..APPC ......
c0d08570:	5b3cae23 062fb139 3554e093 511eaaee     #.<[9./...T5...Q
c0d08580:	3015c6d8 20545041 00000000 af120000     ...0APT ........
c0d08590:	5bd6c4be d816b1c7 05fd0751 104912d9     ...[....Q.....I.
c0d085a0:	4146bf29 00204252 00000000 70ac1200     ).FARB ........p
c0d085b0:	a444cb9f daf0353c b163314e 377fa117     ..D.<5..N1c....7
c0d085c0:	5241f570 00002043 00000000 ef451212     p.ARC ........E.
c0d085d0:	e0d9f480 5342d92e 49f6e875 311b22b9     ......BSu..I.".1
c0d085e0:	435241d8 00002054 08000000 0d7baa75     .ARCT ......u.{.
c0d085f0:	382f5302 7f6cb633 7653d30a f8dd73d3     .S/83.l...Sv.s..
c0d08600:	20445241 00000000 ba120000 6bb1115f     ARD ........_..k
c0d08610:	cf925715 80682e3b 596870e8 41b6aea8     .W..;.h..phY...A
c0d08620:	00204e52 00000000 c0fe0800 78e07fcf     RN ............x
c0d08630:	f1ab00a5 9584125f 9c04228f 52417e2c     ...._...."..,~AR
c0d08640:	00002054 00000000 fa057712 eb164ba3     T .......w...K..
c0d08650:	c7df776d 36e22b81 24b0a67b 5852418e     mw...+.6{..$.ARX
c0d08660:	00000020 08000000 c126d9b0 06783dbc      .........&..=x.
c0d08670:	75103e4f 249abdd5 c5e65af3 54585241     O>.u...$.Z..ARXT
c0d08680:	00000020 a5120000 2109fcf8 34b70c88      ..........!...4
c0d08690:	12bd6823 0405b88e 41a1b142 00205952     #h......B..ARY .
c0d086a0:	00000000 05271200 b7b1134b b545b398     ......'.K.....E.
c0d086b0:	2ed2a491 7ed46265 53415aa7 00002054     ....eb.~.ZAST ..
c0d086c0:	00000000 93227b04 aa41a88c db932c39     .....{"...A.9,..
c0d086d0:	21c4f4b7 5ed6e378 54534188 00204f52     ...!x..^.ASTRO .
c0d086e0:	04000000 f8d04315 2ae88934 68df4413     .....C..4..*.D.h
c0d086f0:	543db227 505a231f 61676941 20616874     '.=T.#ZPAigatha 
c0d08700:	17120000 e9512d05 102c5954 230c3246     .....-Q.TY,.F2.#
c0d08710:	6cabab71 4110ef73 6e656874 206e6169     q..ls..Athenian 
c0d08720:	b7781200 a655dafa d895d84d 7957c3c8     ..x...U.M.....Wy
c0d08730:	fa678bdd 5441058a 0000204c 00000000     ..g...ATL ......
c0d08740:	ef119b12 9018aaca c652eef6 15f87cbb     ..........R..|..
c0d08750:	41d7c53a 4d544139 00000020 08000000     :..A9ATM .......
c0d08760:	06b5ae97 0e591a6e 14518b86 feb6be57     ....n.Y...Q.W...
c0d08770:	f529d399 494d5441 00000020 2d120000     ..).ATMI ......-
c0d08780:	61aae1ae 2d250ad6 496405c8 2880699a     ...a..%-..dI.i.(
c0d08790:	413a5853 00205354 00000000 78880400     SX:ATS ........x
c0d087a0:	d4b8d334 b1bab650 df52c209 d786a23d     4...P.....R.=...
c0d087b0:	5441e43c 00002054 00000000 78396312     <.ATT .......c9x
c0d087c0:	da78944d 426a1043 2a779691 172f9c02     M.x.C.jB..w*../.
c0d087d0:	5454417d 0000204e 12000000 b42a0f1a     }ATTN ........*.
c0d087e0:	f930c66e 298063fd 2a557b02 4cb964fa     n.0..c.).{U*.d.L
c0d087f0:	20585441 00000000 c1120000 e39b092d     ATX ........-...
c0d08800:	d4ad6715 d4d0e4e4 f5c39156 4163568f     .g......V....VcA
c0d08810:	00204355 00000000 cfcd1200 526cf6c0     UC ...........lR
c0d08820:	a186d02f 3cea25b7 9e9feb0e 55411488     /....%.<......AU
c0d08830:	00204152 00000000 ff2d6212 c6834ecc     RA ......b-..N..
c0d08840:	5359a94b 80555a0a 58577a68 5455411b     K.YS.ZU.hzWX.AUT
c0d08850:	0000204f 12000000 807924ed 16106b39     O .......$y.9k..
c0d08860:	6fd3b19b d18e276e 0fa60067 20415641     ...on'..g...AVA 
c0d08870:	00000000 0d040000 746eed88 b896fdbb     ..........nt....
c0d08880:	38162331 57056cb6 414f821e 00205456     1#.8.l.W..OAVT .
c0d08890:	00000000 4bcd1200 84320f4b 9cc43aa3     .......KK.2..:..
c0d088a0:	c61e9667 837011e1 5841cf18 00002031     g.....p...AX1 ..
c0d088b0:	00000000 629ec305 97c5046a 310e771d     .......bj....w.1
c0d088c0:	92d76097 5e970265 50584147 00002052     .`..e..^GAXPR ..
c0d088d0:	12000000 cefc515d 8b4a11d3 dd0ce9b5     ....]Q....J.....
c0d088e0:	2b689d0f 9353cccb 58423242 00000020     ..h+..S.B2BX ...
c0d088f0:	99120000 bc823b8b 3917ba9d fb7abe90     .....;.....9..z.
c0d08900:	b5882777 42bdb8ac 41434e41 00000020     w'.....BANCA ...
c0d08910:	7ff81200 fe53910d 28c749a5 80cb61ad     ......S..I.(.a..
c0d08920:	8ba69515 4142de73 0020584e 00000000     ....s.BANX .....
c0d08930:	d2052a12 bc79b02d 7af7c240 03f71f1d     .*..-.y.@..z....
c0d08940:	1c636ea5 534142c1 00000020 08000000     .nc..BAS .......
c0d08950:	f675870d 79064348 8de909a7 25b60c2b     ..u.HC.y....+..%
c0d08960:	ef87280d 20544142 00000000 9a120000     .(..BAT ........
c0d08970:	a3b74202 40beac3d 8327b9ed 39eb964f     .B..=..@..'.O..9
c0d08980:	42cbfbf8 00205841 00000000 d3e71200     ...BAX .........
c0d08990:	293e41e4 89b035ae 50f44031 43c76509     .A>).5..1@.P.e.C
c0d089a0:	4242e565 00002043 00000000 05d43712     e.BBC .......7..
c0d089b0:	bcf5a210 0f7aaa98 45b3f47b 0ab9cf3b     ......z.{..E;...
c0d089c0:	494242c1 00000020 12000000 6658604a     .BBI .......J`Xf
c0d089d0:	7e05f16c a5d33cac 056214a6 c99f5547     l..~.<....b.GU..
c0d089e0:	204b4242 00000000 35120000 854296a6     BBK .......5..B.
c0d089f0:	2fba8370 73abbf30 f0c7ac5d 4269c9ba     p../0..s].....iB
c0d08a00:	00204e42 00000000 f7841200 ed6f4bc4     BN ..........Ko.
c0d08a10:	47f68010 52d554e3 cce25b59 42422f60     ...G.T.RY[..`/BB
c0d08a20:	0000204f 00000000 13cb2e12 c358c4a8     O ............X.
c0d08a30:	a7d9c479 2d209e25 3d8f3ce0 20434219     y...%. -.<.=.BC 
c0d08a40:	00000000 12000000 2de4411f 0d3c9e0a     .........A.-..<.
c0d08a50:	b515bad3 83273427 a90032b4 50414342     ....'4'..2..BCAP
c0d08a60:	00000020 73000000 3980a667 304f70d4      ......sg..9.pO0
c0d08a70:	946dbfbf b0c32080 4259fc7d 20434243     ..m.. ..}.YBCBC 
c0d08a80:	00000000 791e1200 c386e97c 2f47f4cf     .......y|.....G/
c0d08a90:	c4d5387d fe5da5ab 434240fe 00204e44     }8....]..@BCDN .
c0d08aa0:	00000000 20faac0f f33bb79f b1bf5bdd     ....... ..;..[..
c0d08ab0:	c99b1b10 6290c499 444342a5 00002054     .......b.BCDT ..
c0d08ac0:	12000000 553412bc 2ba3be2e 03192151     ......4U...+Q!..
c0d08ad0:	d3a6bb56 b55b22bb 204c4342 00000000     V...."[.BCL ....
c0d08ae0:	1c120000 0d758144 21f55faa 0d49a7a2     ....D.u.._.!..I.
c0d08af0:	46ed8199 42bd5d46 20545043 00000000     ...FF].BCPT ....
c0d08b00:	14101200 3c2b3e61 50574dbc 2e98d454     ....a>+<.MWPT...
c0d08b10:	999b0d58 4342b1d7 00002056 00000000     X.....BCV ......
c0d08b20:	b3611908 ed691933 51077752 f58e71fc     ..a.3.i.Rw.Q.q..
c0d08b30:	6d8b8330 474442ee 00000020 12000000     0..m.BDG .......
c0d08b40:	45c18f4d 9e350f3a 5967c999 d856e654     M..E:.5...gYT.V.
c0d08b50:	bf6f990d 20454542 00000000 74120000     ..o.BEE .......t
c0d08b60:	cab8e4c1 ec6992e5 d4d3851d 603924f3     ......i......$9`
c0d08b70:	42acf448 43726565 206e696f eb6a0000     H..BeerCoin ..j.
c0d08b80:	da6cf095 5c34ca84 b7f3e02d a42369f9     ..l...4\-....i#.
c0d08b90:	45424c4f 20595252 00000000 3aa38a0e     OLBERRY .......:
c0d08ba0:	c8fc9978 6abe5fea 9c108a60 b8a19338     x...._.j`...8...
c0d08bb0:	544542b2 00000020 12000000 f226c914     .BET .........&.
c0d08bc0:	b6440029 20bfe147 497be672 0519ff5e     ).D.G.. r.{I^...
c0d08bd0:	48544542 00205245 76120000 8deb8631     BETHER ....v1...
c0d08be0:	36d55648 307844ed 4f217129 42a9c6eb     HV.6.Dx0)q!O...B
c0d08bf0:	20525445 00000000 74ee1200 a1b50f11     ETR .......t....
c0d08c00:	28067b00 d7e50d2e 41bf613a 4842cdd9     .{.(....:a.A..BH
c0d08c10:	00204350 00000000 905dfe12 5fd89a8c     PC .......]...._
c0d08c20:	da851165 0777a4a6 7db2e226 52484209     e.....w.&..}.BHR
c0d08c30:	00000020 12000000 66c8b408 e51b9dae      ..........f....
c0d08c40:	c3e0066a 4f4b0502 437b06fe 43544942     j.....KO..{CBITC
c0d08c50:	00205241 f3080000 8db99fd2 8ce7c52d     AR .........-...
c0d08c60:	ee8d1987 347793f9 42f1d65f 41505449     ......w4_..BITPA
c0d08c70:	00204b52 10b30800 a89d4b4b b9e82520     RK .....KK.. %..
c0d08c80:	b328fbf8 f6e23c55 49426970 00002058     ..(.U<..piBIX ..
c0d08c90:	00000000 ebbfb212 f103b970 2b7facba     ........p......+
c0d08ca0:	3429c6a2 74b9e5c7 424b42c4 00000020     ..)4...t.BKB ...
c0d08cb0:	08000000 c3e0f93c ecaba585 17a7d29f     ....<...........
c0d08cc0:	4c34aa90 70358e4e 78524b42 00000020     ..4LN.5pBKRx ...
c0d08cd0:	45120000 92c55b24 f6aaee19 2e383fcd     ...E$[.......?8.
c0d08ce0:	1f468a07 427bdef9 0020584b 00000000     ..F...{BKX .....
c0d08cf0:	29ca1200 c12142db 7e8a8811 ac2eb180     ...).B!....~....
c0d08d00:	a36d268a 4c420dee 0000204e 00000000     .&m...BLN ......
c0d08d10:	457c1012 c579cd04 a06e69d2 d48d0a03     ..|E..y..in.....
c0d08d20:	b80126e9 544c422e 00000020 12000000     .&...BLT .......
c0d08d30:	69fe9e53 a821ddbc 2291fd3e cc641a57     S..i..!.>.."W.d.
c0d08d40:	2b28e025 45554c42 00000020 ce080000     %.(+BLUE .......
c0d08d50:	099bd259 fe65e5aa 2fe5f8ee 53cdc347     Y.....e..../G..S
c0d08d60:	4263c668 6220584c 206c6c75 a7e51200     h.cBLX bull ....
c0d08d70:	f37229c1 ed70febb 891c5229 6aafb849     .)r...p.)R..I..j
c0d08d80:	4c427009 63692058 0000206f 04325712     .pBLX ico ...W2.
c0d08d90:	0437886a 4c284f40 ddfa1fe4 d67f005b     j.7.@O(L....[...
c0d08da0:	5a4c4268 00000020 12000000 43f36edf     hBLZ ........n.C
c0d08db0:	bf800735 bf10348c 010c2e06 71d61d5b     5....4......[..q
c0d08dc0:	20434d42 00000000 f0080000 51eead28     BMC ........(..Q
c0d08dd0:	471b3b53 0f89aabe 57a454eb 42891ef5     S;.G.....T.W...B
c0d08de0:	0020544d 00000000 6e981200 c444b9e2     MT ........n..D.
c0d08df0:	527f012d c6c421af eadb849b 4d42d835     -..R.!......5.BM
c0d08e00:	00002058 00000000 74c7b812 1f5fe482     X .........t.._.
c0d08e10:	4517de44 42742cf5 dd1b636c 424e4252     D..E.,tBlc..RBNB
c0d08e20:	00000020 12000000 6cf56bdd 4ca2ada2      ........k.l...L
c0d08e30:	50ac3f68 e58377e3 9faf575b 20434e42     h?.P.w..[W..BNC 
c0d08e40:	00000000 ef0c0000 7f37c951 6e8529eb     ........Q.7..).n
c0d08e50:	af5c6261 0bbd9093 4218ea67 0020434e     ab\.....g..BNC .
c0d08e60:	00000000 2cda0800 8cc94f42 4e2d1c74     .......,BO..t.-N
c0d08e70:	9728f4f2 97d8fece 4e4275ca 00205446     ..(......uBNFT .
c0d08e80:	00000000 b280da09 f9bd3800 7b30c768     .........8..h.0{
c0d08e90:	467a90b5 62cf8294 4e4e4251 00000020     ..zF...bQBNN ...
c0d08ea0:	08000000 6f3d571f 683df1b3 b444f89f     .....W=o..=h..D.
c0d08eb0:	4d7937ce 1cffa779 20544e42 00000000     .7yMy...BNT ....
c0d08ec0:	d2120000 838615d6 83cce4ae 72726780     .............grr
c0d08ed0:	f4aaa009 42e39d35 2059544e 00000000     ....5..BNTY ....
c0d08ee0:	34df1200 0b911179 86429a6c e52e8eba     ...4y...l.B.....
c0d08ef0:	eb394aea 4f423421 00002042 00000000     .J9.!4BOB ......
c0d08f00:	3634cc12 ca42386e 1f6cd31b 25154d32     ..46n8B...l.2M.%
c0d08f10:	c8fc6079 4e4f4201 00000020 12000000     y`...BON .......
c0d08f20:	7d2c1e7f 34bf696a c5724d82 e850453b     ..,}ji.4.Mr.;EP.
c0d08f30:	c2d8c095 20504f42 00000000 c2080000     ....BOP ........
c0d08f40:	ec233fc6 bdef975e 9edf6575 c7fd64c7     .?#.^...ue...d..
c0d08f50:	421de9d4 0020554f 00000000 9d131200     ...BOU .........
c0d08f60:	4b279793 9ac2e2b9 0baaa89a 0dd37458     ..'K........Xt..
c0d08f70:	4f42e362 20535455 00000000 84f56312     b.BOUTS .....c..
c0d08f80:	0ee656fa 80e80f4d e6c7272b 003eb3e3     .V..M...+'....>.
c0d08f90:	584f427f 00000020 12000000 b678a1e1     .BOX .........x.
c0d08fa0:	9605bd81 d33e3e4d 5731e73a dd969d7d     ....M>>.:.1W}...
c0d08fb0:	20584f42 00000000 78120000 1ed91601     BOX .......x....
c0d08fc0:	8ae59255 a3763c3b 391b5751 42c6ceab     U...;<v.QW.9...B
c0d08fd0:	2058584f 00000000 76320f00 ab9b7782     OXX ......2v.w..
c0d08fe0:	33d1f42b ab74897e 5a27e89d 5042a87c     +..3~.t...'Z|.BP
c0d08ff0:	00002054 00000000 d5779e12 6f1b25a1     T ........w..%.o
c0d09000:	2267457d d2c6eaa6 d80b98d5 41524291     }Eg".........BRA
c0d09010:	00002054 08000000 15c38e55 17b22e2e     T ......U.......
c0d09020:	19cd0549 4ae3a4ae d69ade23 20445242     I......J#...BRD 
c0d09030:	00000000 f2120000 54e0f56e dcb78453     ........n..TS...
c0d09040:	f297f2c0 58894167 42df3068 20434453     ....gA.Xh0.BSDC 
c0d09050:	00000000 9a501200 cca1b738 aa83cd0d     ......P.8.......
c0d09060:	4621069d 7cecd963 53424a7f 00002054     ..!Fc..|.JBST ..
c0d09070:	00000000 58720212 ecf3eb36 1cdf1cdb     ......rX6.......
c0d09080:	bbfc027b 6a73a2fa 435442f8 00002041     {.....sj.BTCA ..
c0d09090:	08000000 9c948608 28418c1b 4c26c460     ..........A(`.&L
c0d090a0:	d18380eb cf865e36 45435442 00000020     ....6^..BTCE ...
c0d090b0:	5a080000 c9b919cd 1f6b591e e3182f06     ...Z.....Yk../..
c0d090c0:	eda72dd0 42501e8d 204c4354 00000000     .-....PBTCL ....
c0d090d0:	f5870800 5242c3e8 3c7f8318 41b97db6     ......BR...<.}.A
c0d090e0:	32010caf 5442563e 454e4f43 00000020     ...2>VBTCONE ...
c0d090f0:	8cac6a12 421e86b9 f55982bf e36adcab     .j.....B..Y...j.
c0d09100:	9e9089ae 43544211 00002052 08000000     .....BTCR ......
c0d09110:	9c06dd73 695d9a29 2436981e 9cecca3b     s...).]i..6$;...
c0d09120:	34871d8c 20455442 00000000 fa080000     ...4BTE ........
c0d09130:	56db72d5 ac34526e 70d5c39f 05c0edc4     .r.VnR4....p....
c0d09140:	4292aa0e 00204854 00000000 86db1200     ...BTH .........
c0d09150:	87b4f546 9f97ddb5 508361ac f51850e8     F........a.P.P..
c0d09160:	5442d457 0000204b 00000000 abcc2a12     W.BTK .......*..
c0d09170:	8ca4b79c 6f28823e 98872f0b ecf401d2     ....>.(o./......
c0d09180:	7461423f 20656c74 12000000 935e6892     ?Battle .....h^.
c0d09190:	c2376595 5d5db75b 26a4fc47 b828d66d     .e7.[.]]G..&m.(.
c0d091a0:	6c746942 0020656c cb040000 075fe697     Bitlle ......._.
c0d091b0:	6bd424da eb78d0cd e6c6d7eb 4250d7e3     .$.k..x.......PB
c0d091c0:	00204d54 00000000 90360800 8032c95f     TM .......6._.2.
c0d091d0:	a16223f5 1f15abcb 7446dc25 5442b52f     .#b.....%.Ft/.BT
c0d091e0:	0000204f 00000000 e6b01612 2f3ac12a     O ..........*.:/
c0d091f0:	186dd3ae 6d35e2bc fa3cab25 515442d3     ..m...5m%.<..BTQ
c0d09200:	00000020 12000000 776b9a49 6bc225bc      .......I.kw.%.k
c0d09210:	e26582cf 3d1b2b10 247061d1 20525442     ..e..+.=.ap$BTR 
c0d09220:	00000000 03120000 55cd80c7 2b599845     ...........UE.Y+
c0d09230:	6d25b797 9975adda 4225b145 204e5254     ..%m..u.E.%BTRN 
c0d09240:	00000000 0a081200 712c7ea0 7e0d1585     .........~,q...~
c0d09250:	3888a94d acfed2a8 6942fc3d 74652074     M..8....=.Bit et
c0d09260:	00002068 6c45fa00 a85052f5 278b0839     h ....El.RP.9..'
c0d09270:	24a432ee 54cbdad7 6b6c42ff 64617254     .2.$...T.BlkTrad
c0d09280:	12002065 3ad883b6 b72c2e53 5e27a5df     e .....:S.,...'^
c0d09290:	439836ed 9fcc7163 20555442 00000000     .6.Ccq..BTU ....
c0d092a0:	e5120000 1ede67f8 df4613a8 b4b88151     .....g....F.Q...
c0d092b0:	bbb0d68d 42b05733 00205a54 00000000     ....3W.BTZ .....
c0d092c0:	3cca1200 805ba618 f867c22e 452580f4     ...<..[...g...%E
c0d092d0:	243df5e7 55425ec7 00002043 00000000     ..=$.^BUC ......
c0d092e0:	8c16bd12 373a9dbf 51dc385b e8b502a2     ......:7[8.Q....
c0d092f0:	6920e5a4 585742ed 00000020 12000000     .. i.BWX .......
c0d09300:	ade77543 ecb8018a 3941d03e cdd9629f     Cu......>.A9.b..
c0d09310:	63000e12 00205a42 00000000 e1120000     ...cBZ .........
c0d09320:	9584e9ae 79c15f36 b31b9c69 71fa61e7     ....6_.yi....a.q
c0d09330:	4262ee6b 20544e5a 00000000 39381200     k.bBZNT ......89
c0d09340:	2731bad8 4802aa51 baa8d6fe 8e3084cb     ..1'Q..H......0.
c0d09350:	6542ed20 0000207a 00000000 53e72612      .Bez .......&.S
c0d09360:	020cfc07 b8fe7214 958327f7 f312f131     .....r...'..1...
c0d09370:	30324317 00000020 12000000 e4eb2dd4     .C20 ........-..
c0d09380:	d52bc9ed 24b4fba3 f6cc1e3e 5d4a3ad6     ..+....$>....:J]
c0d09390:	00203843 00000000 7d120000 05ce8c4b     C8 ........}K...
c0d093a0:	4a04c991 3554ee22 972eb733 43c3366e     ...J".T53...n6.C
c0d093b0:	00204741 00000000 461d1200 14fe1424     AG ........F$...
c0d093c0:	7a9c48cf 85c7ca21 8cbff409 4143c0d7     .H.z!.........CA
c0d093d0:	0000204e 00000000 e7f20406 1bdb1f22     N .........."...
c0d093e0:	6981a652 e59357b2 03ff7814 50414329     R..i.W...x..)CAP
c0d093f0:	00002050 02000000 22433e42 1529dacd     P ......B>C"..).
c0d09400:	7da1496b c4acd2fb 0d6080b2 20524143     kI.}......`.CAR 
c0d09410:	00000000 4d090000 84a3239e 76ebe72f     .......M.#../..v
c0d09420:	5c72b982 c407c5f6 431ba424 6c627261     ..r\....$..Carbl
c0d09430:	206b636f 17a51200 d6aa6ba4 6ba754b0     ock .....k...T.k
c0d09440:	84469cd1 e67f714f 4143ea9f 00204252     ..F.Oq....CARB .
c0d09450:	00000000 894b9508 3a690407 3e6142f2     ......K...i:.Ba>
c0d09460:	03b6f1de d7fc5a82 52414308 00002044     .....Z...CARD ..
c0d09470:	12000000 46f218bf 231f30b9 b361951e     .......F.0.#..a.
c0d09480:	7679385a 7563b49b 45524143 00000020     Z8yv..cuCARE ...
c0d09490:	e8120000 bd480b78 86925fb0 15e8a597     ....x.H.._......
c0d094a0:	d92e675f 43f76214 00205341 00000000     _g...b.CAS .....
c0d094b0:	34121200 d3617456 9674dbf8 bd741758     ...4Vta...t.X.t.
c0d094c0:	d5839c86 6942931c 766c4374 00000020     ......BitClv ...
c0d094d0:	2eba5612 610489e7 bef763f4 09c3aa02     .V.....a.c......
c0d094e0:	11586d9f 6f6c42a8 61636b63 12002074     .mX..Blockcat ..
c0d094f0:	b54be168 81965ba4 e5167e32 9d4b0828     h.K..[..2~..(.K.
c0d09500:	391a2c96 43746942 3273766c 26120020     .,.9BitClvs2 ..&
c0d09510:	f63954db 91f4ca51 79487da8 191fa89d     .T9.Q....}Hy....
c0d09520:	436bdb1b 00204342 00000000 ef950800     ..kCBC .........
c0d09530:	9960fed1 d57e5af6 87f4de24 09213248     ..`..Z~.$...H2!.
c0d09540:	42434749 0000204d 00000000 976c0712     IGCBM ........l.
c0d09550:	0769c8e1 8c2fe22e 998c9791 25b0bcb4     ..i.../........%
c0d09560:	54424391 00000020 12000000 870366c1     .CBT ........f..
c0d09570:	b3baff05 b3854179 6325d9a9 7df31d2a     ....yA....%c*..}
c0d09580:	20334343 00000000 28120000 316d7a57     CC3 .......(Wzm1
c0d09590:	65d29b55 62db3ace 508545d0 43a7b8f7     U..e.:.b.E.P...C
c0d095a0:	68736172 00207343 11be1200 e686b1ee     rashCs .........
c0d095b0:	6af2b824 5a574550 05e44013 43435245     $..jPEWZ.@..ERCC
c0d095c0:	63692043 0000206f 03893712 c3b23fa0     C ico ...7...?..
c0d095d0:	52bb76ac e13c3e77 7a374013 43434332     .v.Rw><..@7z2CCC
c0d095e0:	00002058 12000000 7ae048d3 5b500628     X .......H.z(.P[
c0d095f0:	04236185 edae275d 504b9290 434c4343     .a#.]'....KPCCLC
c0d09600:	00000020 67080000 51c5ad9b b2016e62      ......g...Qbn..
c0d09610:	fbceee3c ea77b8c9 4346fc18 00204f43     <.....w...FCCO .
c0d09620:	00000000 5c311200 d3af9fe5 b762d5a8     ......1\......b.
c0d09630:	42851cec 10272d38 43436cb0 00002053     ...B8-'..lCCS ..
c0d09640:	00000000 646f3312 f6d9876f 2dd46ebc     .....3odo....n.-
c0d09650:	3f8b6ed4 5cd1dbd9 54434322 00000020     .n.?...\"CCT ...
c0d09660:	12000000 44ca958a adc0528a b34b05f0     .......D.R....K.
c0d09670:	e0c52d40 32b2d69c 204c4443 00000000     @-.....2CDL ....
c0d09680:	17120000 67ac397d 7ac6d16e d78a262b     ....}9.gn..z+&..
c0d09690:	2688e5f1 43afb0e5 00205444 00000000     ...&...CDT .....
c0d096a0:	b12c1200 0edad701 3f7da5ba d746ef2f     ..,.......}?/.F.
c0d096b0:	64bbb7ff 44432b59 24432058 00002058     ...dY+CDX C$X ..
c0d096c0:	38ff6f00 52acbb06 790d0ea2 528d53bc     .o.8...R...y.S.R
c0d096d0:	c9226a7f 5844436b 74654e20 12000020     .j".kCDX Net ...
c0d096e0:	8fc356b0 06c47d6b 3e406743 d24c4226     .V..k}..Cg@>&BL.
c0d096f0:	e15506c6 4b454543 00000020 11120000     ..U.CEEK .......
c0d09700:	e0a0b622 6305ce0d 296e2b08 43a9f353     "......c.+n)S..C
c0d09710:	431f5c85 5a4e4e45 00000020 60f61200     .\.CENNZ ......`
c0d09720:	8e221eca 8bfae17b 1483554f 7f14315e     ..".{...OU..^1..
c0d09730:	454377b5 00002054 00000000 89ff5d12     .wCET .......]..
c0d09740:	d7a4caa2 f786c26b 71bd674d da34b88e     ....k...Mg.q..4.
c0d09750:	43464361 00000020 12000000 e5f5fe12     aCFC ...........
c0d09760:	7358f47b e9629bcd b9bfd7db 3ed7329e     {.Xs..b......2.>
c0d09770:	20494643 00000000 69120000 8b3f9856     CFI .......iV.?.
c0d09780:	b473e13c 1a3684ab f352ada0 436f938d     <.s...6...R...oC
c0d09790:	20595446 00000000 dbf30800 20e86075     FTY ........u`. 
c0d097a0:	b5584683 3462c990 3dcd33c3 48435e5e     .FX...b4.3.=^^CH
c0d097b0:	00002050 00000000 419dba12 f2b4fa99     P .........A....
c0d097c0:	5135fe6e 82e390d4 35f18614 534843ba     n.5Q.......5.CHS
c0d097d0:	00002042 08000000 80a56014 500ad896     B .......`.....P
c0d097e0:	56f9f1a2 6197a4dd 65f1a41f 20584843     ...V...a...eCHX 
c0d097f0:	00000000 3a120000 f732ffbd 63e7426b     .......:..2.kB.c
c0d09800:	427edb5b a531025f 4317abf3 0020544a     [.~B_.1....CJT .
c0d09810:	00000000 01061200 7bf98c2c aeded5ea     ........,..{....
c0d09820:	f9707023 7a8e7f58 4b436d26 00000020     #pp.X..z&mCK ...
c0d09830:	00000000 721de800 16154bd1 19c38ae6     .......r.K......
c0d09840:	33c9460a d68ecc02 204c430f 00000000     .F.3.....CL ....
c0d09850:	12000000 8ccbc1b1 db92197c 8b624ea2     ........|....Nb.
c0d09860:	718ed3f7 eb6ad4da 20424c43 00000000     ...q..j.CLB ....
c0d09870:	3d120000 a72fa4c9 e07be5af 7ffd583c     ...=../...{.<X..
c0d09880:	e4b11144 4308c566 00204c4c 00000000     D...f..CLL .....
c0d09890:	62411200 d6788b17 a3805498 0e19b208     ..Ab..x..T......
c0d098a0:	607451e5 4c436d40 0000204e 00000000     .Qt`@mCLN ......
c0d098b0:	28ce7f12 689a8956 70efee06 fc857980     ...(V..h...p.y..
c0d098c0:	63c65475 504c4340 00000020 09000000     uT.c@CLP .......
c0d098d0:	5c23dd3e 1f0c843e 2e6b2829 250a3739     >.#\>...)(k.97.%
c0d098e0:	db6f7b5c 54424d43 00000020 7e080000     \{o.CMBT ......~
c0d098f0:	52257566 5213f61c 501be0e2 dfe7aafa     fu%R...R...P....
c0d09900:	439a7439 0020434d 00000000 bc471200     9t.CMC .......G.
c0d09910:	98775901 6d50d7dc c46aa3cc 3ac92f30     .Yw...Pm..j.0/.:
c0d09920:	4d43fb8c 00205443 00000000 ee5ff808     ..CMCT ......._.
c0d09930:	1dd8fda2 6b7f1751 e6f0358f 5fe44c73     ....Q..k.5..sL._
c0d09940:	544d435f 00000020 12000000 e8f9f2eb     _CMT ...........
c0d09950:	640f96de dadc0fec 4282b26c 7b343331     ...d....l..B134{
c0d09960:	20424e43 00000000 d4080000 b0f535c4     CNB .........5..
c0d09970:	335c859f 4c52c817 e486f5b1 43fa9527     ..\3..RL....'..C
c0d09980:	0020444e 00000000 13871200 cf3766d2     ND ..........f7.
c0d09990:	b4b6e149 1057cea7 32c9ab6a 4e434353     I.....W.j..2SCCN
c0d099a0:	0000204e 00000000 d2b1b412 07ec17c2     N ..............
c0d099b0:	e04c5876 8fd93d8d a4eded90 324f434b     vXL..=......KCO2
c0d099c0:	00000020 12000000 bc364b57 383344ed      .......WK6..D38
c0d099d0:	1c175d87 91e677c3 87f8d4f7 42324f43     .]...w......CO2B
c0d099e0:	00207469 b2120000 2c1febf7 e65b6437     it ........,7d[.
c0d099f0:	3095731d 760e3635 43e6818d 0020424f     .s.056.v...COB .
c0d09a00:	00000000 36311200 921585ef a49cf4ac     ......16........
c0d09a10:	1e1325c8 fa704136 4f43b332 00204946     .%..6Ap.2.COFI .
c0d09a20:	00000000 b0910c12 f7a6ab15 cd8d73b4     .............s..
c0d09a30:	0141e736 dc9ab238 494f4329 0000204c     6.A.8...)COIL ..
c0d09a40:	08000000 d17e54eb 14ffa3d8 7faaab61     .....T~.....a...
c0d09a50:	d4fe2200 a4006e83 4e494f43 00000020     ."...n..COIN ...
c0d09a60:	c4120000 b24cd6bc d39fd416 27a343c6     ......L......C.'
c0d09a70:	2646f362 431a5ab4 204d534f 00000000     b.F&.Z.COSM ....
c0d09a80:	29651200 14dfea2e f12dcd26 3d3a79c4     ..e)....&.-..y:=
c0d09a90:	53f21975 4f433b91 00205353 00000000     u..S.;COSS .....
c0d09aa0:	60969e12 19ec4544 5e9aedff 0ab5d78d     ...`DE.....^....
c0d09ab0:	a199c829 534f430c 6f692e53 12000020     )....COSS.io ...
c0d09ac0:	2965fbe2 086a56ef de236d0e 3151d30b     ..e).Vj..m#...Q1
c0d09ad0:	67d58710 20564f43 00000000 0e120000     ...gCOV ........
c0d09ae0:	044261bb b6097ce4 aab9fec3 e08eadec     .aB..|..........
c0d09af0:	433ee260 20594150 00000000 e4fa0000     `.>CPAY ........
c0d09b00:	d8cd59ee e8e93b6e aa530bb9 d7276386     .Y..n;....S..c'.
c0d09b10:	504390c0 00002043 00000000 d487b712     ..CPC ..........
c0d09b20:	9789c8ea 578cbb30 8c993cfc 4e24c549     ....0..W.<..I.$N
c0d09b30:	455043c0 00002058 08000000 b3aa6470     .CPEX ......pd..
c0d09b40:	72cf0f9a 6739c321 7a91d019 1555e365     ...r!.9g...ze.U.
c0d09b50:	4c4f5043 00204f4c 88120000 6b460bd5     CPOLLO .......Fk
c0d09b60:	012252e5 e8f9719d 5f7fe1fa 43a1fc45     .R"..q....._E..C
c0d09b70:	00205450 00000000 47f40800 1fd4fb45     PT ........GE...
c0d09b80:	51a11b6a b00d19df cc5f4c56 50431044     j..Q....VL_.D.CP
c0d09b90:	00002059 00000000 5b587f12 4ec63091     Y ........X[.0.N
c0d09ba0:	0b479f9e ad7b8a61 ca793dd0 3752437e     ..G.a.{..=y.~CR7
c0d09bb0:	00000020 12000000 bf8ff3ae 1a2d93bf      .............-.
c0d09bc0:	8b803bef cdd8fbc8 c58b1f8e 20425243     .;..........CRB 
c0d09bd0:	00000000 2c080000 90c118f6 33dbd941     .......,....A..3
c0d09be0:	b822820d 0224a660 43fb301f 20544252     ..".`.$..0.CRBT 
c0d09bf0:	00000000 1ef41200 6a2fbc5f d80d20ac     ........_./j. ..
c0d09c00:	1c129e61 155df0e1 52437700 00002043     a.....]..wCRC ..
c0d09c10:	00000000 1a2a6712 fb67f6d4 af33a318     .....g*...g...3.
c0d09c20:	a07a6613 5b5b1faf 455243dd 00002044     .fz...[[.CRED ..
c0d09c30:	12000000 e203064e 48307aa2 4f3a5e0e     ....N....z0H.^:O
c0d09c40:	9ee248e5 be642ff1 44455243 0000204f     .H.../d.CREDO ..
c0d09c50:	f4120000 ad50dd9c 7d388d40 a6881f61     ......P.@.8}a...
c0d09c60:	3d9c1747 432b49e3 204f4752 00000000     G..=.I+CRGO ....
c0d09c70:	38921200 a581b7bf cfc3ac5e 94dff705     ...8....^.......
c0d09c80:	8c198c03 5243b9d9 0020544d 00000000     ......CRMT .....
c0d09c90:	e0a78008 507af348 c2510350 7740cb04     ....H.zPP.Q...@w
c0d09ca0:	ae3bfa66 5052437f 00002054 12000000     f.;..CRPT ......
c0d09cb0:	8611daf0 267297a4 065d13b9 e272ee13     ......r&..]...r.
c0d09cc0:	4d3fec29 20545243 00000000 46120000     ).?MCRT .......F
c0d09cd0:	4d94adb9 0d455910 113516a1 8f719c06     ...M.YE...5...q.
c0d09ce0:	43319d69 00002053 00000000 d7290600     i.1CS ........).
c0d09cf0:	7fac7752 16b23503 e895085d 65bf5c72     Rw...5..]...r\.e
c0d09d00:	5343738d 00204f4e 00000000 a549bb08     .sCSNO .......I.
c0d09d10:	6ca6e51e e5cba8a3 a49b3729 677ea64b     ...l....)7..K.~g
c0d09d20:	54534371 00000020 12000000 0f754545     qCST .......EEu.
c0d09d30:	e46baf39 86b637f2 a9cc4e9d 855afd28     9.k..7...N..(.Z.
c0d09d40:	20465443 00000000 c8120000 6ad85d7c     CTF ........|].j
c0d09d50:	f27f563d 6f880187 aa5a74b0 43a48d89     =V.....o.tZ....C
c0d09d60:	00204754 00000000 7d9e1200 9b49bd29     TG ........}).I.
c0d09d70:	a5a27d6c f4fceab2 d83b9da3 5443d145     l}........;.E.CT
c0d09d80:	00204347 00000000 fd4cbf12 eede1e7d     GC .......L.}...
c0d09d90:	0860f6a5 411b4127 8ab01ea2 4c5443bd     ..`.'A.A.....CTL
c0d09da0:	00000020 02000000 0956a696 884eb8a7      .........V...N.
c0d09db0:	eb2d7342 3e6cf508 8a6fac21 20525443     Bs-...l>!.o.CTR 
c0d09dc0:	00000000 e3120000 ce7a17fa 2167b8cf     ..........z...g!
c0d09dd0:	429f6fcf d63bbd06 43d5d772 00205454     .o.B..;.r..CTT .
c0d09de0:	00000000 2a661200 7f0badbc ffb75a34     ......f*....4Z..
c0d09df0:	b9fbb1b1 f19478df 5443668e 00002058     .....x...fCTX ..
c0d09e00:	00000000 7511ea12 881de45a 9ac3ee9c     .......uZ.......
c0d09e10:	75ffe663 c0c12ba0 5854430d 00002043     c..u.+...CTXC ..
c0d09e20:	12000000 8ab56cda 61010c0d a6c5290a     .....l.....a.)..
c0d09e30:	133e305c 7c8885e8 00205663 00000000     \0>....|cV .....
c0d09e40:	41120000 540056e5 b0a64e82 6e652e73     ...A.V.T.N..s.en
c0d09e50:	204ed63a 43454ee9 00204356 00000000     :.N .NECVC .....
c0d09e60:	42be0800 f067388c 892aea5d 02a176fc     ...B.8g.].*..v..
c0d09e70:	c7ea44b5 564372f7 00002054 00000000     .D...rCVT ......
c0d09e80:	05342112 1f460b7c 5c378d89 ac52d6ea     .!4.|.F...7\..R.
c0d09e90:	95b562ae 43584341 00000020 12000000     .b..ACXC .......
c0d09ea0:	6896eeb6 be791a77 29ee6779 84413da6     ...hw.y.yg.).=A.
c0d09eb0:	437109f8 204f5843 00000000 3f120000     ..qCCXO .......?
c0d09ec0:	84d7b506 bd97cd06 425c0ff1 321d240b     ..........\B.$.2
c0d09ed0:	43809c75 204d4659 00000000 c2781200     u..CYFM ......x.
c0d09ee0:	5e44d192 bf58956b 36bce842 d0de7192     ..D^k.X.B..6.q..
c0d09ef0:	5943ea62 0020544d 00000000 fc230208     b.CYMT .......#.
c0d09f00:	14425770 fe1358f6 0a876d33 7f147ec4     pWB..X..3m...~..
c0d09f10:	525a43ae 00000020 12000000 454dc9e4     .CZR .........ME
c0d09f20:	01f7aef7 f4665d8a ec80f74a 8e372360     .....]f.J...`#7.
c0d09f30:	61437243 6e6f6272 05060020 bf7c61c3     CrCarbon ....a|.
c0d09f40:	26b90413 c91ea60a d615f160 43eaec7b     ...&....`...{..C
c0d09f50:	69726275 00002078 b0da1200 4cf31bc3     ubrix .........L
c0d09f60:	feb07f89 c92ed190 5caf1c40 4144ec36     ........@..\6.DA
c0d09f70:	00002042 00000000 0811a300 49b5bae5     B .............I
c0d09f80:	34db6045 659254c9 3539f28a 4341447c     E`.4.T.e..95|DAC
c0d09f90:	00002053 12000000 f2262ffb 0528fb66     S ......./&.f.(.
c0d09fa0:	0f2387a3 31a3a02a ba6fd9b4 49444144     ..#.*..1..o.DADI
c0d09fb0:	00000020 89120000 4c6b4ad2 aa6f1bcb      ........JkL..o.
c0d09fc0:	56fe2526 239add2b 44590326 00204941     &%.V+..#&.YDAI .
c0d09fd0:	00000000 d9071200 02a49ee4 8af44b19     .............K..
c0d09fe0:	fbda7682 63ede416 41441733 0020434c     .v.....c3.DALC .
c0d09ff0:	00000000 74709b08 088a700e 8df36f3c     ......pt.p..<o..
c0d0a000:	029722f5 a5fa5d0f 4e4144ee 00000020     ."...]...DAN ...
c0d0a010:	0a000000 44c29bbb 3f1298d7 cc3f78de     .......D...?.x?.
c0d0a020:	bbd3721c 1394188c 204f4144 00000000     .r......DAO ....
c0d0a030:	81100000 e01d15c9 d3fcbac8 3d7ea525     ............%.~=
c0d0a040:	1cdfa5b5 449cf7eb 00205441 00000000     .......DAT .....
c0d0a050:	5f1b1200 ee98ee21 2e298dd4 d83e2d8e     ..._!.....)..->.
c0d0a060:	72a9402b 4144228a 72424154 0020726b     +@.r."DATABrkr .
c0d0a070:	eef00c12 088a7863 9752fe49 707f40f3     ....cx..I.R..@.p
c0d0a080:	c02c121e 54414423 696f4341 1200206e     ..,.#DATACoin ..
c0d0a090:	44b6bbab d6ff687b 7ca71d14 87b5c718     ...D{h.....|....
c0d0a0a0:	abc5d66e 78544144 00000020 d8120000     n...DATx .......
c0d0a0b0:	d3abf02d eb2514f5 8075ef15 2757a5fd     -.....%...u...W'
c0d0a0c0:	44145f87 00205641 00000000 4b0b1200     ._.DAV ........K
c0d0a0d0:	918747dc 65747289 f55ec12d e6ca35c1     .G...rte-.^..5..
c0d0a0e0:	4144601e 00002058 00000000 5f726112     .`DAX .......ar_
c0d0a0f0:	4a00b43d 454701fe 1eab1db2 32cc7716     =..J..GE.....w.2
c0d0a100:	5841448b 00002054 12000000 aebf689b     .DAXT .......h..
c0d0a110:	515adf21 62a23109 f463cfce 64f23813     !.ZQ.1.b..c..8.d
c0d0a120:	54454244 00000020 38120000 0347aa6f     DBET ......8o.G.
c0d0a130:	db7f4aa3 e1c2be19 c927d44f 44168463     .J......O.'.c..D
c0d0a140:	00204143 00000000 a9ff1200 92f4ac3a     CA .........:...
c0d0a150:	211ed597 28451718 df2f0539 434461b9     ...!..E(9./..aDC
c0d0a160:	00002043 00000000 0e9a3912 d7b3be6f     C .......9..o...
c0d0a170:	7435854c aec8f439 5c8a67d9 4c4344bf     L.5t9....g.\.DCL
c0d0a180:	00000020 03000000 0d2bd308 3b2c3ea6      .........+..>,;
c0d0a190:	c91980cf d749d8c5 e691d7a9 204e4344     ......I.....DCN 
c0d0a1a0:	00000000 cc000000 afeef94e a2c16a65     ........N...ej..
c0d0a1b0:	436788ab e0978ee9 4438ed90 00204644     ..gC......8DDF .
c0d0a1c0:	00000000 12151200 8ec1c902 f3565649     ............IVV.
c0d0a1d0:	491f2872 8969b73e 4544d561 00002042     r(.I>.i.a.DEB ..
c0d0a1e0:	00000000 0a1ede12 461b10e6 6ff60c52     ...........FR..o
c0d0a1f0:	59100bdc 103dccc5 4c45446c 00204154     ...Y..=.lDELTA .
c0d0a200:	08000000 d5bf9735 9a9ca933 7b5883a0     ....5...3.....X{
c0d0a210:	e6344407 58a2b01e 544e4544 00000020     .D4....XDENT ...
c0d0a220:	7c080000 6f9671f2 f03b3436 e5250f15     ...|.q.o64;...%.
c0d0a230:	61794f36 440182c5 204f5045 00000000     6Oya...DEPO ....
c0d0a240:	cb890000 a1e8c5ea 4cbb0e3f c6dffa74     ........?..Lt...
c0d0a250:	501ae89b 65440611 4e736f70 00207465     ...P..DeposNet .
c0d0a260:	de94dd12 3506fe9c 5e1a0577 085d46b7     .......5w..^.F].
c0d0a270:	08887d31 766544b6 326e6f63 00000020     1}...Devcon2 ...
c0d0a280:	6748e920 03ba4d79 f187e20e 0d106e40      .HgyM......@n..
c0d0a290:	d34cc803 20574544 00000000 49120000     ..L.DEW .......I
c0d0a2a0:	94f2ae7b 0f5f1ac1 2a3fea5b db7330db     {....._.[.?*.0s.
c0d0a2b0:	44568b44 00205845 00000000 b7e01200     D.VDEX .........
c0d0a2c0:	f24a7c92 51cb6537 050e4a31 5f64a921     .|J.7e.Q1J..!.d_
c0d0a2d0:	47442a0e 00002044 00000000 e5cff609     .*DGD ..........
c0d0a2e0:	aeeb6f3d 401f05ea 14fcf50f acbdcbf0     =o.....@........
c0d0a2f0:	504744a1 00002054 12000000 8dbfed6a     .DGPT ......j...
c0d0a300:	724331ff 1935df20 332aba50 1b8d1662     .1Cr .5.P.*3b...
c0d0a310:	20534744 00000000 1c080000 78145083     DGS .........P.x
c0d0a320:	770932f1 49087004 60bdac6d 44ef15bb     .2.w.p.Im..`...D
c0d0a330:	20585447 00000000 3a4f1200 a3e5c4fe     GTX ......O:....
c0d0a340:	a4a1a6f2 d7f7de11 e00ee5df 4744bf57     ............W.DG
c0d0a350:	00002058 00000000 a1b95509 51832e1c     X .......U.....Q
c0d0a360:	b1c7ffb4 8b146115 7897c9fa 58474455     .....a.....xUDGX
c0d0a370:	00002031 09000000 291d072e 8d7daa66     1 .........)f.}.
c0d0a380:	5800b1ec 7719ba85 658a03d6 45434944     ...X...w...eDICE
c0d0a390:	00000020 c7100000 b610d019 2cbf5b3e      ...........>[.,
c0d0a3a0:	2c875105 d26e31d5 4483cd6a 6e496365     .Q.,.1n.j..DecIn
c0d0a3b0:	20727573 49f11200 2f1a0022 431a54b8     sur ...I"../.T.C
c0d0a3c0:	7a430539 9c4154e9 49443924 00002054     9.Cz.TA.$9DIT ..
c0d0a3d0:	00000000 1cf11308 8ca00599 853e6ea7     .............n>.
c0d0a3e0:	4f3de63b 6c324409 56494472 00002058     ;.=O.D2lrDIVX ..
c0d0a3f0:	12000000 06c7e307 048b5453 7059a7f0     ........ST....Yp
c0d0a400:	4c1bf8c1 6f60fbbb 20544c44 00000000     ...L..`oDLT ....
c0d0a410:	2c120000 043affcb 6e71682c 0ccba2d2     ...,..:.,hqn....
c0d0a420:	1d9f4a54 44e13519 0020544d 00000000     TJ...5.DMT .....
c0d0a430:	b0820800 ee7804e5 2d39deaf 9e25d145     ......x...9-E.%.
c0d0a440:	6f1b07d1 4e4481da 00002041 00000000     ...o..DNA ......
c0d0a450:	acbd0a12 90370de7 48f45a23 604785c8     ......7.#Z.H..G`
c0d0a460:	0456943b 544e44ea 00000020 12000000     ;.V..DNT .......
c0d0a470:	41203ee4 e18637dc d91e9666 39554a48     .> A.7..f...HJU9
c0d0a480:	fb103d03 20584e44 00000000 e5120000     .=..DNX ........
c0d0a490:	aa80dada 5de87764 287f7409 3d99f742     ....dw.].t.(B..=
c0d0a4a0:	441cf70d 204b434f 00000000 6b901200     ...DOCK .......k
c0d0a4b0:	45788b3f ea880184 5a3f3cb5 87a748d3     ?.xE.....<?Z.H..
c0d0a4c0:	4f442f75 00002052 00000000 1132ac0f     u/DOR ........2.
c0d0a4d0:	145402a5 ff6628af c13fc209 797ec98b     ..T..(f...?...~y
c0d0a4e0:	564f44b1 00000020 12000000 7b4c9776     .DOV .......v.L{
c0d0a4f0:	6a8adc79 1fd79f10 e4b9ced7 8253ff0e     y..j..........S.
c0d0a500:	20574f44 00000000 01120000 ae4aecb3     DOW ..........J.
c0d0a510:	5229871b 6549eb9b 87007df2 44ebb088     ..)R..Ie.}.....D
c0d0a520:	00205050 00000000 9c411200 e2b9b44d     PP .......A.M...
c0d0a530:	adb26d5d b8cc9196 fdd9c832 52445ea0     ]m......2....^DR
c0d0a540:	00204e47 00000000 ba724612 741027d5     GN ......Fr..'.t
c0d0a550:	6750cb71 65f487a8 8a5a586d 4f524431     q.Pg...emXZ.1DRO
c0d0a560:	206c6950 12000000 6522753c 6149fc55     Pil ....<u"eU.Ia
c0d0a570:	888bd468 5fb983df 371f7716 504f5244     h......_.w.7DROP
c0d0a580:	2078656c 62000000 eff2781d bf37d92f     lex ...b.x../.7.
c0d0a590:	ab6c69ca 9f779aaf 44edb359 00205052     .il...w.Y..DRP .
c0d0a5a0:	00000000 99270200 446d0cd9 fba59acb     ......'...mD....
c0d0a5b0:	7f1777c3 053ec316 7244826b 6f437069     .w....>.k.DripCo
c0d0a5c0:	00206e69 020ee300 7e9549f0 5807592a     in ......I.~*Y.X
c0d0a5d0:	64ba069e 21c3b26f 505244ba 00002055     ...do..!.DRPU ..
c0d0a5e0:	08000000 69f2f49a 707c6741 6dcffe6c     .......iAg|pl..m
c0d0a5f0:	01ff7933 abd585bb 20545244 00000000     3y......DRT ....
c0d0a600:	62080000 4446c0d4 86354f31 5cc6a48b     ...b..FD1O5....\
c0d0a610:	68777ac2 44a9e71d 20485652 00000000     .zwh...DRVH ....
c0d0a620:	e3031200 6559c2f0 c5bb3df1 8c734682     ......Ye.=...Fs.
c0d0a630:	b2273e18 5344566a 00205043 00000000     .>'.jVDSCP .....
c0d0a640:	96dc5a12 f7c36a1d a42e2d06 d8b8ef5f     .Z...j...-.._...
c0d0a650:	b1447d16 48544490 00000020 12000000     .}D..DTH .......
c0d0a660:	24bf34d2 9d00a010 3bc6c3f9 73090c61     .4.$.......;a..s
c0d0a670:	d7cc188f 20525444 00000000 c2080000     ....DTR ........
c0d0a680:	c3e06404 2b6d4873 6e573533 b118a283     .d..sHm+35Wn....
c0d0a690:	445e8a61 20435254 00000000 f7f91200     a.^DTRC ........
c0d0a6a0:	f1fd9cc2 2a1fcf9f a34ab8a6 bdf1bc67     .......*..J.g...
c0d0a6b0:	54447616 00002054 00000000 0c5f7612     .vDTT .......v_.
c0d0a6c0:	c2ddd116 1a5c2979 88b0247c 3fd3623f     ....y)\.|$..?b.?
c0d0a6d0:	58544475 00000020 12000000 fbedfd82     uDTX ...........
c0d0a6e0:	1a443576 9127a9a5 73fa01d0 2580da88     v5D...'....s...%
c0d0a6f0:	20785444 00000000 ed120000 c378ea7f     DTx ..........x.
c0d0a700:	177bcf93 c2a852b1 ac97cdd0 440b7931     ..{..R......1y.D
c0d0a710:	20494255 00000000 b58d1200 d369a54c     UBI ........L.i.
c0d0a720:	a12b9a01 373cd026 f85e4bc4 5844f61e     ..+.&.<7.K^...DX
c0d0a730:	00002054 00000000 605cce08 47d0783c     T ........\`<x.G
c0d0a740:	2e0343ef 85b7b596 3a754f32 5234454f     .C......2Ou:OE4R
c0d0a750:	0020574f 02000000 ff0d4f99 bf0baedb     OW ......O......
c0d0a760:	d652b609 3f491af1 b9423fd3 4c474145     ..R...I?.?B.EAGL
c0d0a770:	00002045 90120000 2349440b 6bb27b6a     E .......DI#j{.k
c0d0a780:	dd016628 e7bdd214 456caca6 48545241     (f........lEARTH
c0d0a790:	00000020 f3310800 cebed1d9 f73f030c      .....1.......?.
c0d0a7a0:	60daa68f 3e8f04a6 4245c513 00002043     ...`...>..EBC ..
c0d0a7b0:	00000000 97c3af12 0c1fc588 53b5f71f     ...............S
c0d0a7c0:	02e7f317 ff21e599 434265f6 00002048     ......!..eBCH ..
c0d0a7d0:	08000000 c0ac78a5 787578cb 9080781b     .....x...xux.x..
c0d0a7e0:	d194453f 988bfa3c 204e4345 00000000     ?E..<...ECN ....
c0d0a7f0:	17020000 d27534f9 27f578a9 4ac4f7c3     .....4u..x.'...J
c0d0a800:	fbad44bf 455c0da6 20324f43 00000000     .D....\ECO2 ....
c0d0a810:	1d170200 d6420d75 272cb661 6a486b7a     ....u.B.a.,'zkHj
c0d0a820:	8c3482db 4345ca3e 00204d4f 00000000     ..4.>.ECOM .....
c0d0a830:	b1698812 248bbcf9 20724d6a 6de534f8     ..i....$jMr .4.m
c0d0a840:	5582dddf 504345e7 00000020 12000000     ...U.ECP .......
c0d0a850:	eee21dfa 0cc1e497 b21cc994 892b06b5     ..............+.
c0d0a860:	820b14fb 20434445 00000000 08060000     ....EDC ........
c0d0a870:	023b1d71 2f8f75c8 804eabb3 a7188422     q.;..u./..N."...
c0d0a880:	459ce3f8 00204744 00000000 d4ce0000     ...EDG .........
c0d0a890:	739831e9 84ffda4d bd25d592 eb498d25     .1.sM.....%.%.I.
c0d0a8a0:	44458e38 0000204f 00000000 c228c512     8.EDO ........(.
c0d0a8b0:	900aec8f 8b3283c0 7e585fc4 0a7615e2     ......2.._X~..v.
c0d0a8c0:	5244450f 00000020 12000000 cce5222a     .EDR .......*"..
c0d0a8d0:	633d0aa0 9fa38f30 b12e2029 52ef9eb3     ..=c0...) .....R
c0d0a8e0:	20554445 00000000 eb120000 7102207c     EDU ........| .q
c0d0a8f0:	43d1e572 500d03fb e2ec1cf9 655d48d1     r..C...P.....H]e
c0d0a900:	20435442 00000000 3ab50800 d9bdbc96     BTC .......:....
c0d0a910:	f2df78cf 2b6cab0b 8fecbae7 4765f800     .x....l+......eG
c0d0a920:	00205341 00000000 441b8e08 fcadc78e     AS ........D....
c0d0a930:	c25fa37f 8b6785e8 6e1723d3 54474534     .._...g..#.n4EGT
c0d0a940:	00000020 12000000 4ec2ba5d f4a4e298      .......]..N....
c0d0a950:	c80ddc3a fc03f42a 2cce63a0 20544745     :...*....c.,EGT 
c0d0a960:	00000000 f9120000 6771fcf0 2fdd11c3     ..........qg.../
c0d0a970:	20e9211e a9eb874f 45b22f01 00205448     .!. O..../.EHT .
c0d0a980:	00000000 a8a60800 ca0be540 17a00da5     ........@.......
c0d0a990:	860d1ab9 11d4b2b8 4b45ee56 0000204f     ........V.EKO ..
c0d0a9a0:	00000000 65b1ba12 aa5594df 1fed2a0f     .......e..U..*..
c0d0a9b0:	0b526525 b4addd91 544b45c8 00000020     %eR......EKT ...
c0d0a9c0:	08000000 36f19fd4 13134561 fd5315ca     .......6aE....S.
c0d0a9d0:	1dbd5469 b9026e9b 43454c45 00000020     iT...n..ELEC ...
c0d0a9e0:	bf120000 9f857921 e9bed5c6 635891bf     ....!y........Xc
c0d0a9f0:	7816c52d 450e10a4 0020464c 00000000     -..x...ELF .....
c0d0aa00:	c6c81200 804a1aa3 a710376d 297b8bb3     ......J.m7....{)
c0d0aa10:	ccab2f6d 4c45a8db 00205849 00000000     m/....ELIX .....
c0d0aa20:	7a194412 a0d6444c af7c2959 e1f7e46b     .D.zLD..Y)|.k...
c0d0aa30:	ca56bd72 544c45af 4e494f43 08000020     r.V..ELTCOIN ...
c0d0aa40:	dc9255a9 80c0a3ff 450eb4b4 92565f9c     .U.........E._V.
c0d0aa50:	f8b77df6 20594c45 00000000 b6120000     .}..ELY ........
c0d0aa60:	57a2887b e75aa308 d336d7c2 ce68d298     {..W..Z...6...h.
c0d0aa70:	45837f4f 204e4f4d 00000000 da950800     O..EMON ........
c0d0aa80:	4680b9aa b2f46b84 cb233e85 39fa36a2     ...F.k...>#..6.9
c0d0aa90:	4d45314a 20544e4f 00000000 bf019508     J1EMONT ........
c0d0aaa0:	dc9788c4 31f7adee 5d63ef13 4beef72f     .......1..c]/..K
c0d0aab0:	544d4597 00000020 12000000 4eb202b8     .EMT ..........N
c0d0aac0:	b8c23706 778b2e7d bb55c084 1a0121e9     .7..}..w..U..!..
c0d0aad0:	20564d45 00000000 03020000 de50509f     EMV .........PP.
c0d0aae0:	b5f90849 4f0af4dd 29f3a33a 45876308     I......O:..).c.E
c0d0aaf0:	0020434e 00000000 eef01200 59b7276b     NC .........k'.Y
c0d0ab00:	e43c89c9 9ab494f0 5ad18fd2 4e45e423     ..<........Z#.EN
c0d0ab10:	00002047 00000000 cb29f608 91374dd9     G ........)..M7.
c0d0ab20:	520125c9 dffb8dbd 3b2a0e38 4a4e459c     .%.R....8.*;.ENJ
c0d0ab30:	00000020 12000000 f0e5c75b 102e8bab      .......[.......
c0d0ab40:	f2a3d0d2 e6fc3917 f3ae5924 52544e45     .....9..$Y..ENTR
c0d0ab50:	00002050 86120000 579804fa a79a20e0     P .........W. ..
c0d0ab60:	f716e6d9 783b3beb 45b0fdec 0020534f     .....;;x...EOS .
c0d0ab70:	00000000 9e7e1200 8c0b1a43 742c534d     ......~.C...MS,t
c0d0ab80:	c743105b 8da429fa 6f65ba4f 43414473     [.C..)..O.eosDAC
c0d0ab90:	00000020 a7ba3512 27f13820 f9c8f8f9      ....5.. 8.'....
c0d0aba0:	9f0491b4 9177f364 5850454d 00000020     ....d.w.MEPX ...
c0d0abb0:	04000000 4667ee50 0f5cd789 3cf8e888     ....P.gF..\....<
c0d0abc0:	694b8cfe 0d59fde8 20595045 00000000     ..Ki..Y.EPY ....
c0d0abd0:	47080000 d0d462dd 71adde75 9902e0d0     ...G.b..u..q....
c0d0abe0:	d7a256fc 45bbbe47 00204c51 00000000     .V..G..EQL .....
c0d0abf0:	ce741200 1b2877da a3429133 5ffa1768     ..t..w(.3.B.h.._
c0d0ac00:	2b41299e 524585ab 0000204f 00000000     .)A+..ERO ......
c0d0ac10:	b0a59208 d9d50e4d 3d197a4d 3d4d331d     ....M...Mz.=.3M=
c0d0ac20:	4e6f9916 54524513 00000020 12000000     ..oN.ERT .......
c0d0ac30:	95dfa1e8 0479e38b a3462b5e 3ab9981a     ......y.^+F....:
c0d0ac40:	edfdcd2e 205a5345 00000000 1b120000     ....ESZ ........
c0d0ac50:	56f54397 7c755ed6 450b654c 54f3ba55     .C.V.^u|Le.EU..T
c0d0ac60:	45d38bcb 20534254 00000000 74dd0c00     ...ETBS .......t
c0d0ac70:	9f76a3a7 b36125a7 96659ea6 8c74498f     ..v..%a...e..It.
c0d0ac80:	54450c69 00204843 00000000 d0c82812     i.ETCH ......(..
c0d0ac90:	ea33f61f 6afcd89c 57741d45 8d699e88     ..3....jE.tW..i.
c0d0aca0:	475445e6 00000020 00000000 6d74263a     .ETG .......:&tm
c0d0acb0:	b8b179db 3f0e45e4 8532fe4f 7e3807a3     .y...E.?O.2...8~
c0d0acc0:	42485445 00000020 db080000 9b3e42fb     ETHB ........B>.
c0d0acd0:	432916bf 9676e088 4c0e12a5 45c5a0eb     ..)C..v....L...E
c0d0ace0:	20444854 00000000 f25a1200 6a3a19be     THD ......Z...:j
c0d0acf0:	81c8a9bc 57f40170 b37d7744 54455607     ....p..WDw}..VET
c0d0ad00:	20534f48 00000000 3f4a3c08 103a81fd     HOS .....<J?..:.
c0d0ad10:	7bd5eb7f 34bc012f 0fd96442 4b5445de     ...{/..4Bd...ETK
c0d0ad20:	00000020 02000000 9fc62769 04f2dab4      .......i'......
c0d0ad30:	b71cbb3f 61566cb8 29ea6b41 20525445     ?....lVaAk.)ETR 
c0d0ad40:	00000000 db120000 ab11f225 7dc9b105     ........%......}
c0d0ad50:	f4165559 8a529457 45d87a80 20535255     YU..W.R..z.EURS 
c0d0ad60:	00000000 dfab0200 23707814 41c3cf5f     .........xp#_..A
c0d0ad70:	768c8253 fab3709a 55451fe0 00205452     S..v.p....EURT .
c0d0ad80:	00000000 182db606 4540a7de 2c3522e8     ......-...@E."5,
c0d0ad90:	77eeb3e4 ffc59d31 4356452f 00000020     ...w1.../EVC ...
c0d0ada0:	12000000 a4083192 c2e8c439 654f5c31     .....1..9...1\Oe
c0d0adb0:	95cee521 4c9b4eb4 20455645 00000000     !....N.LEVE ....
c0d0adc0:	68120000 6e589e90 73f4c8ea 4c4be815     ...h..Xn...s..KL
c0d0add0:	54dd8897 45bb65ef 00204e56 00000000     ...T.e.EVN .....
c0d0ade0:	80d71200 4cf02bae 7d576ed9 6247013d     .....+.L.nW}=.Gb
c0d0adf0:	71d931f8 5645d029 0000204e 00000000     .1.q).EVN ......
c0d0ae00:	5fdbf312 7a6bc6a2 0b0cebf3 81102578     ..._..kz....x%..
c0d0ae10:	1348be6c 585645b8 00000020 04000000     l.H..EVX .......
c0d0ae20:	b7974944 0e83fce7 fe9a0820 d58c07a3     DI...... .......
c0d0ae30:	a2f2fc18 204f5745 00000000 00120000     ....EWO ........
c0d0ae40:	5098b3c4 5deb4506 371a0aa0 16b1889a     ...P.E.]...7....
c0d0ae50:	4501ba83 00204358 00000000 8ec91200     ...EXC .........
c0d0ae60:	d2c63906 617a03ec 69c34153 0e116b66     .9....zaSA.ifk..
c0d0ae70:	5845e580 0020524d 00000000 c469e408     ..EXMR .......i.
c0d0ae80:	22f83a47 f10cb317 dbbc107b 6e798c6c     G:."....{...l.yn
c0d0ae90:	52584575 0000204e 00000000 353a745c     uEXRN ......\t:5
c0d0aea0:	c5f603e9 c64e5184 06eeac17 f344cf11     .....QN.......D.
c0d0aeb0:	20595845 00000000 5e120000 7dae1660     EXY .......^`..}
c0d0aec0:	47d3497c 8634f8dc e23e9f0b 452b8182     |I.G..4...>...+E
c0d0aed0:	0020545a 00000000 77b60800 ab1e5234     ZT ........w4R..
c0d0aee0:	37779cbe e173db29 b2dfc26c 5245580a     ..w7).s.l....XER
c0d0aef0:	65657075 00000020 a0ca1c02 0d21a7f2     upee .........!.
c0d0af00:	ecfde176 325f0d74 161b2e3e 43414672     v...t._2>...rFAC
c0d0af10:	00002045 12000000 9b560e19 0cf471e0     E ........V..q..
c0d0af20:	82154e70 8154285f ccb674cb 204d4146     pN.._(T..t..FAM 
c0d0af30:	00000000 900c0000 88412f16 d046096c     ........./A.l.F.
c0d0af40:	6f739999 a1c8151c 4621a405 00204e41     ..so......!FAN .
c0d0af50:	00000000 cb7d1200 c856233b 7d57d322     ......}.;#V.".W}
c0d0af60:	0d0d064d 60c8785d 41468c48 0020584e     M...]x.`H.FANX .
c0d0af70:	00000000 20352312 a211e936 2b69fc2c     .....#5 6...,.i+
c0d0af80:	66192e5e de8a6592 5a4446d9 00000020     ^..f.e...FDZ ...
c0d0af90:	12000000 e2cfa8d9 482d231c 62cb6550     .........#-HPe.b
c0d0afa0:	796668a9 f745469d 20504746 00000000     .hfy.FE.FGP ....
c0d0afb0:	52120000 3ac836fb 24183cd3 10c82f91     ...R.6.:.<.$./..
c0d0afc0:	eb5eca71 4690b38a 00204449 00000000     q.^....FID .....
c0d0afd0:	9e001200 b4234986 f1c76392 f8b7190d     .....I#..c......
c0d0afe0:	5a9a7aab 4b4633ad 00002058 00000000     .z.Z.3FKX ......
c0d0aff0:	8a4af012 edfc53c5 a699bab5 58159947     ..J..S......G..X
c0d0b000:	b036c126 494c46be 00205858 12000000     &.6..FLIXX .....
c0d0b010:	3b78cc04 118d0b45 0dd0c7f3 7fdf3fd0     ..x;E........?..
c0d0b020:	f2e91fb5 434d4c46 00000020 04120000     ....FLMC .......
c0d0b030:	b0a69993 7129d548 ae22d1f7 2753a121     ....H.)q..".!.S'
c0d0b040:	465f2822 20544f4c 00000000 1b3a1200     "(_FLOT ......:.
c0d0b050:	b5ad28da a712a8b0 95a110cf 790f920c     .(.............y
c0d0b060:	4c46d3bc 00002050 00000000 beef9a12     ..FLP ..........
c0d0b070:	a93b3c0b cb62b2ea 15e85698 8e64b77a     .<;...b..V..z.d.
c0d0b080:	524c4609 00000020 12000000 e05d4b95     .FLR ........K].
c0d0b090:	97e5559a a2bdac55 4ab71e9e 7501d345     .U..U......JE..u
c0d0b0a0:	5a554c46 00000020 70120000 1ee047b1     FLUZ ......p.G..
c0d0b0b0:	cee78592 43bab968 19a9e37f 466a750e     ....h..C.....ujF
c0d0b0c0:	0020584c 00000000 f44d1200 b269497b     LX .......M.{Ii.
c0d0b0d0:	65961c91 2c59e306 93943841 4e463b95     ...e..Y,A8...;FN
c0d0b0e0:	00002044 00000000 68070712 eb4d341f     D .........h.4M.
c0d0b0f0:	37401824 852802fc b037216f 4b4e462e     $.@7..(.o!7..FNK
c0d0b100:	0020534f 12000000 a1604bbd e3fcb338     OS ......K`.8...
c0d0b110:	1fa04e58 8c90c050 7a67f918 42544e46     XN..P.....gzFNTB
c0d0b120:	00000020 2a080000 0ccf3b09 4b74ef98      ......*.;....tK
c0d0b130:	749df6b6 0556f8f2 46904232 20444f4f     ...t..V.2B.FOOD 
c0d0b140:	00000000 70420800 6d8f23bb cac3b1d8     ......Bp.#.m....
c0d0b150:	a66cf901 c047265b 4f463c6d 00204154     ..l.[&G.m<FOTA .
c0d0b160:	00000000 fbbe0a12 3acb1176 ad3fea01     ........v..:..?.
c0d0b170:	3c3cf385 2c8e4f93 445246f4 00000020     ..<<.O.,.FRD ...
c0d0b180:	12000000 1c7de617 b949e3b4 e1c34bca     ......}...I..K..
c0d0b190:	a3f27d7c 64bba797 43455246 00000020     |}.....dFREC ...
c0d0b1a0:	48120000 96024edf abce08f9 18a52804     ...H.N.......(..
c0d0b1b0:	1fb3192d 46d637c0 00205652 00000000     -....7.FRV .....
c0d0b1c0:	35d00800 9a9e012a 7757d7b9 7723536f     ...5*.....WwoS#w
c0d0b1d0:	6fd3ebaa 534641d5 0000204e 00000000     ...o.AFSN ......
c0d0b1e0:	3ba77812 185dbc6c 786ee53c 5c906e6f     .x.;l.].<.nxon.\
c0d0b1f0:	5463ecad 2054467b 00000000 12000000     ..cT{FT ........
c0d0b200:	cf4df7e6 8308e2a0 168c8d00 29a3d9b6     ..M............)
c0d0b210:	300c9d18 20435446 00000000 94020000     ...0FTC ........
c0d0b220:	da52d83e 38395cdb 8368dcec 14f88d71     >.R..\98..h.q...
c0d0b230:	46c8e42d 00204954 00000000 23201200     -..FTI ....... #
c0d0b240:	38c4f7dc b0c0c8c8 e1ba8df2 f3b42055     ...8........U ..
c0d0b250:	544620ee 00002052 00000000 18ec2a12     . FTR .......*..
c0d0b260:	210f50c5 bee19c35 7717dca5 c0f44d34     .P.!5......w4M..
c0d0b270:	545446dc 00000020 12000000 02f259d5     .FTT ........Y..
c0d0b280:	9548ff96 bdb539da b454dd9a 616a5942     ..H..9....T.BYja
c0d0b290:	20585446 00000000 41120000 32235c87     FTX .......A.\#2
c0d0b2a0:	df7c87b0 649b69aa d4b70214 46322c64     ..|..i.d....d,2F
c0d0b2b0:	20545854 00000000 be650800 9847c744     TXT ......e.D.G.
c0d0b2c0:	6260bf8f 948c6907 2e44f44d 554619fe     ..`b.i..M.D...FU
c0d0b2d0:	00204b43 00000000 ea38ea04 8f6cc8a3     CK .......8...l.
c0d0b2e0:	3315759b 2d562eba edcd9aeb 45554640     .u.3..V-....@FUE
c0d0b2f0:	0000204c 12000000 8b0d9d41 e6f59add     L ......A.......
c0d0b300:	3222ae06 ff5a28ed 1b710e19 204e5546     .."2.(Z...q.FUN 
c0d0b310:	00000000 18080000 5e04aa29 95d5e021     ........)..^!...
c0d0b320:	954a0280 9680b41d 468217e0 00205458     ..J........FXT .
c0d0b330:	00000000 fc881200 6d2cc2fb 5aa2ba3d     ..........,m=..Z
c0d0b340:	78c578f4 bd398397 59467ae7 0000204e     .x.x..9..zFYN ..
c0d0b350:	00000000 21098f12 625505f3 27d44341     .......!..UbAC.'
c0d0b360:	15b140b3 2c881469 50594610 00000020     .@..i..,.FYP ...
c0d0b370:	12000000 dc5174f6 e0f02184 fa52ebaf     .....tQ..!....R.
c0d0b380:	341010a8 d91e08ed 204d4147 00000000     ...4....GAM ....
c0d0b390:	c0080000 f60663ea dce70f36 6bd165ab     .....c..6....e.k
c0d0b3a0:	92afa3f1 47a29ac7 20414e41 00000000     .......GANA ....
c0d0b3b0:	71681200 9cc4f874 d92977eb 61a9c325     ..hqt....w).%..a
c0d0b3c0:	aca47e50 4147287b 00002054 00000000     P~..{(GAT ......
c0d0b3d0:	76887012 48e486f4 33eb89ee e5c8fb2b     .p.v...H...3+...
c0d0b3e0:	58305593 564147b9 00204c45 12000000     .U0X.GAVEL .....
c0d0b3f0:	35f88575 27522dae 4368d222 83baa023     u..5.-R'".hC#...
c0d0b400:	f5321f40 20544247 00000000 12120000     @.2.GBT ........
c0d0b410:	3e46d6fc f74c9766 fc4fc2bb bed6404d     ..F>f.L...O.M@..
c0d0b420:	47838245 00205842 00000000 0fdb0800     E..GBX .........
c0d0b430:	f86f3069 58f249f9 876b3fe8 2d055dee     i0o..I.X.?k..].-
c0d0b440:	4347230b 00002050 00000000 0d4f4f12     .#GCP .......OO.
c0d0b450:	3b90deb4 a2b1f288 e2717984 8f4fd531     ...;.....yq.1.O.
c0d0b460:	454547d3 00000020 08000000 b33b0824     .GEE .......$.;.
c0d0b470:	3c647200 440bb93b 605828b7 87e655a7     .rd<;..D.(X`.U..
c0d0b480:	444c4547 00000020 c7120000 65b7a5bb     GELD ..........e
c0d0b490:	2cfb1e58 db7926dd e79eea5b 471f209b     X..,.&y.[.... .G
c0d0b4a0:	00204d45 00000000 3f541200 4af627f2     EM .......T?.'.J
c0d0b4b0:	32a17ea1 ca8698bf dc55dbb5 4547dfad     .~.2......U...GE
c0d0b4c0:	0000204e 00000000 42858a12 6097a588     N .........B...`
c0d0b4d0:	8725a736 3eca6491 6a0cd391 5445471b     6.%..d.>...j.GET
c0d0b4e0:	00000020 12000000 9862d8fc 54b22856      .........b.V(.T
c0d0b4f0:	917a1f06 03b83580 d345d040 20464947     ..z..5..@.E.GIF 
c0d0b500:	00000000 ae120000 72f0564f 650a4cc3     ........OV.r.L.e
c0d0b510:	4d3eaeb3 31d897b7 47939d43 00204d49     ..>M...1C..GIM .
c0d0b520:	00000000 d0710800 a2d6b81d 8d7feafb     ......q.........
c0d0b530:	c2994543 230c9837 4c474c4e 00002041     CE..7..#NLGLA ..
c0d0b540:	00000000 49bdb308 838f8fe2 241e8d2b     .......I....+..$
c0d0b550:	1e990661 35326c54 544d4702 00000020     a...Tl25.GMT ...
c0d0b560:	12000000 76e71068 93020c88 1bdb473d     ....h..v....=G..
c0d0b570:	0859c09f 966b38e5 204f4e47 00000000     ..Y..8k.GNO ....
c0d0b580:	a7120000 31447644 de42a919 fe908549     ....DvD1..B.I...
c0d0b590:	d754241f 470dacd4 0020544e 00000000     .$T....GNT .....
c0d0b5a0:	c86e1200 dcab4ca2 a1069a33 3e22f872     ..n..L..3...r.">
c0d0b5b0:	5a0557a5 4e47a5da 00002058 00000000     .W.Z..GNX ......
c0d0b5c0:	51752409 6233ebf2 42c722e2 b888c7e9     .$uQ..3b.".B....
c0d0b5d0:	c89b7d95 594e477e 00000020 12000000     .}..~GNY .......
c0d0b5e0:	9331b4ea 072306cf b99da83c 637912b7     ..1...#.<.....yc
c0d0b5f0:	1474fa56 444c4f47 00002058 42120000     V.t.GOLDX .....B
c0d0b600:	b3625f3b d4d6d028 eef47048 fabe16e3     ;_b.(...Hp......
c0d0b610:	47f52d0b 0020544f 00000000 b1121200     .-.GOT .........
c0d0b620:	cc2c3e9d fa04da14 65633ee3 b369e42c     .>,......>ce,.i.
c0d0b630:	5247fdf2 00204449 00000000 2044b40c     ..GRID .......D 
c0d0b640:	6c51b08c fc780115 0426a5f9 aca104bc     ..Ql..x...&.....
c0d0b650:	4d5247ea 00002044 12000000 bd9571c1     .GRMD .......q..
c0d0b660:	ce709de4 f2a9f8fc ff5917ee b1f07bc2     ..p.......Y..{..
c0d0b670:	4f4f5247 00000020 0a120000 00e69c9a     GROO ...........
c0d0b680:	b7f98bd0 4efa496f 7ea6387b 47e6b1be     ....oI.N{8.~...G
c0d0b690:	20574f52 00000000 8b220800 9f3014a5     ROW ......"...0.
c0d0b6a0:	813af0fd d0a605a2 d629e440 53470ce8     ..:.....@.)...GS
c0d0b6b0:	00002043 00000000 4430e512 bd734f1f     C ........0D.Os.
c0d0b6c0:	a52fdcb6 c53f7caf c81e55fd 45534738     ../..|?..U..8GSE
c0d0b6d0:	00000020 04000000 d73508b7 94bb2e82      .........5.....
c0d0b6e0:	4365b526 6c8491e3 2cd37b10 20435447     &.eC...l.{.,GTC 
c0d0b6f0:	00000000 02120000 e5d9ba5a da6f5118     ........Z....Qo.
c0d0b700:	b9cdbdaf fb371b70 47faf07e 20544b54     ....p.7.~..GTKT 
c0d0b710:	00000000 bbc50000 1b7850ae 069366e1     .........Px..f..
c0d0b720:	ef01e0b9 57297af5 54479db0 0000204f     .....z)W..GTO ..
c0d0b730:	00000000 bfcfbd05 ab914d5c 0997bcc0     ........\M......
c0d0b740:	006d28c7 6f0e3c06 45554722 00205353     .(m..<.o"GUESS .
c0d0b750:	02000000 5d344798 c914b6e8 be6b1456     .....G4]....V.k.
c0d0b760:	6d3349a5 b6268d9c 444c5547 00000020     .I3m..&.GULD ...
c0d0b770:	f7080000 8f2998b0 14fc697c 1df70b61     ......).|i..a...
c0d0b780:	07c6025e 474c8992 00205055 00000000     ^.....LGUP .....
c0d0b790:	3c100300 a59d203a 4a7c3e9d 667e3089     ...<: ...>|J.0~f
c0d0b7a0:	1c081e52 5647f0fd 00002054 00000000     R.....GVT ......
c0d0b7b0:	30ca5812 4cf2c065 e8ae967c 5b6b05d6     .X.0e..L|.....k[
c0d0b7c0:	c2f9ec5d 435847f8 00000020 0a000000     ]....GXC .......
c0d0b7d0:	8daff022 721b8578 059e79ee 00774af5     "...x..r.y...Jw.
c0d0b7e0:	8ab18615 43565847 00000020 8c0a0000     ....GXVC .......
c0d0b7f0:	2992e965 2a095f7d 24ef6d75 281a78f4     e..)}_.*um.$.x.(
c0d0b800:	47ff9801 0020455a 00000000 38e61200     ...GZE ........8
c0d0b810:	adb639dc 6b52e8be 0b38225c f4da454b     .9....Rk\"8.KE..
c0d0b820:	5a478e6d 00002052 00000000 b2c14806     m.GZR .......H..
c0d0b830:	5fa8eff3 b92afbba a84bbf51 db8ca060     ..._..*.Q.K.`...
c0d0b840:	4e4148b7 00002044 00000000 287e565a     .HAND ......ZV~(
c0d0b850:	bd2bfadb 0a3cf13e 4711be01 57963445     ..+.>.<....GE4.W
c0d0b860:	50504148 00002059 90020000 5b48d402     HAPPY ........H[
c0d0b870:	e8e39475 06a2f050 51303b71 489ef613     u...P...q;0Q...H
c0d0b880:	00205441 00000000 11c00c00 e50024a7     AT ..........$..
c0d0b890:	ee99cd8e 9ef87c49 bdd47537 4e532f73     ....I|..7u..s/SN
c0d0b8a0:	00002058 00000000 2f49e212 18262a8d     X ........I/.*&.
c0d0b8b0:	a99c70d8 758d1d9b 40d83b71 20424889     .p.....uq;.@.HB 
c0d0b8c0:	00000000 12000000 bb686cdd 012e4632     .........lh.2F..
c0d0b8d0:	a4115070 601aade2 7f210f74 20544248     pP.....`t.!.HBT 
c0d0b8e0:	00000000 e30f0000 e744194e 929bf376     ........N.D.v...
c0d0b8f0:	050a7952 64daeb27 4868e67a 00205a42     Ry..'..dz.hHBZ .
c0d0b900:	00000000 e8ff1200 59c26b19 54dcdee8     .........k.Y...T
c0d0b910:	8657934d ec0947aa 4448643e 00002047     M.W..G..>dHDG ..
c0d0b920:	00000000 bec49512 9cd63485 23068c24     .........4..$..#
c0d0b930:	a2a7c9c4 73c101a0 4c444837 00000020     .......s7HDL ...
c0d0b940:	12000000 239a1c49 3e6285db 8e5a45ed     ....I..#..b>.EZ.
c0d0b950:	a9abd6fd dfc511b9 20524548 00000000     ........HER ....
c0d0b960:	ba120000 0a528421 619ac41c 617ec559     ....!.R....aY.~a
c0d0b970:	084e84e1 48b61556 00205447 00000000     ..N.V..HGT .....
c0d0b980:	b19b0800 b84514db 6da51332 8931d390     ......E.2..m..1.
c0d0b990:	21263f4b 49484e8e 00205442 00000000     K?&!.NHIBT .....
c0d0b9a0:	0f24a912 0b1facbc b0df6a9a e3c8534a     ..$......j..JS..
c0d0b9b0:	141dccb0 47494844 00000020 12000000     ....DHIG .......
c0d0b9c0:	577bf314 66d34242 1fb68d55 9a283533     ..{WBB.fU...35(.
c0d0b9d0:	06c53550 20474b48 00000000 9e030000     P5..HKG ........
c0d0b9e0:	54112b6b 2fc52b2f 7a072930 fde837ce     k+.T/+./0).z.7..
c0d0b9f0:	487f8d83 00204e4b 00000000 ac880800     ...HKN .........
c0d0ba00:	75d1d594 fc470313 d709e195 bf9dc07a     ...u..G.....z...
c0d0ba10:	4b48b75a 00002059 00000000 65eb6612     Z.HKY .......f.e
c0d0ba20:	958eabd7 a60fba67 59307ce3 1534c556     ....g....|0YV.4.
c0d0ba30:	584c4874 00000020 05000000 0cb10baa     tHLX ...........
c0d0ba40:	72a31fec 17bc3aeb 6bfc33c9 9edd63a8     ...r.:...3.k.c..
c0d0ba50:	20434d48 00000000 cb120000 6e030fcc     HMC ...........n
c0d0ba60:	638f78d4 32ee0ffc 746a3d87 4808b987     .x.c...2.=jt...H
c0d0ba70:	0020514d 00000000 5db40800 bccec47b     MQ ........]{...
c0d0ba80:	09ad98ab c8f8bdba 2b29b218 4f482c67     ..........)+g,HO
c0d0ba90:	00204c44 00000000 51075b12 27253b71     DL ......[.Qq;%'
c0d0baa0:	c002f0d7 7ea3e2c4 0a611912 524f486b     .......~..a.kHOR
c0d0bab0:	00204553 12000000 e3e56e6c e28d821d     SE .....ln......
c0d0bac0:	962b2841 8ee9c806 e22685a4 6f6c6f48     A(+.......&.Holo
c0d0bad0:	206e6b54 9a120000 7f6839f8 2a54946c     Tkn .....9h.l.T*
c0d0bae0:	e3e2ecc5 35aeda17 48a19354 6f726479     .......5T..Hydro
c0d0baf0:	00000020 c6381200 cd0483a6 c4beb9ef      .....8.........
c0d0bb00:	baaabf8b 81475b5c 5048b28b 00002042     ....\[G...HPB ..
c0d0bb10:	00000000 204c5512 be86c4b7 779243ee     .....UL .....C.w
c0d0bb20:	430a54b4 4cdc6645 54534802 00000020     .T.CEf.L.HST ...
c0d0bb30:	12000000 3796256f 764cd7dc 7be38177     ....o%.7..Lvw..{
c0d0bb40:	d63c13c6 61a18aa6 00205448 00000000     ..<....aHT .....
c0d0bb50:	c0120000 5d2885eb d77c2183 2b7091c8     ......(].!|...p+
c0d0bb60:	40fcc0cb 489d2d1e 00204e56 00000000     ...@.-.HVN .....
c0d0bb70:	bdeb0800 40c902f3 9cd4bfc6 455f166b     .......@....k._E
c0d0bb80:	4632db7f 5948bc49 204f5244 00000000     ..2FI.HYDRO ....
c0d0bb90:	07ffe912 f0cf9c80 9974ae5d 1d83250e     ........].t..%..
c0d0bba0:	e5cbc50b 70644875 00000020 12000000     ....uHdp .......
c0d0bbb0:	863f5484 fab1c18e 9dd410c5 f669c013     .T?...........i.
c0d0bbc0:	f9d5d24c 32706448 00000020 5a120000     L...Hdp2 ......Z
c0d0bbd0:	b69b9684 f664fb63 f9dc15d0 dcae22f6     ....c.d......"..
c0d0bbe0:	49506779 00204543 00000000 86881200     ygPICE .........
c0d0bbf0:	e069ca66 d6de78f1 26575bd7 879ae9ce     f.i..x...[W&....
c0d0bc00:	434998d6 0000204e 00000000 723ea312     ..ICN ........>r
c0d0bc10:	ebfdf49b 4e538b86 3452201f 6bc4d963     ......SN. R4c..k
c0d0bc20:	4f4349ee 00000020 0a000000 46504b01     .ICO ........KPF
c0d0bc30:	0d349065 c57c3041 90e9ce4d a88ad5c8     e.4.A0|.M.......
c0d0bc40:	534f4349 00000020 b5060000 9426f2a5     ICOS .........&.
c0d0bc50:	b0152c35 4a842303 b2ab45d5 492810b1     5,...#.J.E....(I
c0d0bc60:	00205843 00000000 4c811200 2d78d4af     CX ........L..x-
c0d0bc70:	7081722e 5782a6fd 32033f98 4449581c     .r.p...W.?.2.XID
c0d0bc80:	00204145 00000000 c9365100 1c81808a     EA ......Q6.....
c0d0bc90:	dabd463f 55455c8b 12f8d9cf 484449f0     ?F...\EU.....IDH
c0d0bca0:	00000020 06000000 62fc13cc e3d6ff7e      ..........b~...
c0d0bcb0:	06272d5d 734d3cea ea10c696 4d584449     ]-'..<Ms....IDXM
c0d0bcc0:	00000020 85080000 440b9c9a d96670cb      ..........D.pf.
c0d0bcd0:	b058a956 c9542eb8 694b4be4 20485445     V.X...T..KKiETH 
c0d0bce0:	00000000 54760800 821b5a91 afd0d2d6     ......vT.Z......
c0d0bcf0:	af527cc3 98a86e55 46497e3c 00002054     .|R.Un..<~IFT ..
c0d0bd00:	00000000 f0888a12 50900c4e 3bf3d254     ........N..PT..;
c0d0bd10:	463abb26 031a09d7 2047499a 00000000     &.:F.....IG ....
c0d0bd20:	12000000 16b0a8ed 16b1a8ef 04cf0812     ................
c0d0bd30:	7269d81c 1ef3e0ee 20544849 00000000     ..ir....IHT ....
c0d0bd40:	16120000 df732f66 4ce5793e b438596c     ....f/s.>y.LlY8.
c0d0bd50:	c5923f31 4920c124 00204349 00000000     1?..$. IIC .....
c0d0bd60:	ae881200 155e8496 59ef5875 e790ffe9     ......^.uX.Y....
c0d0bd70:	482ee266 4b499003 00002042 00000000     f..H..IKB ......
c0d0bd80:	1c83e300 272b985a 5684199a b9cf77d5     ....Z.+'...V.w..
c0d0bd90:	63cb2404 434d4940 00000020 06000000     .$.c@IMC .......
c0d0bda0:	2df6e522 7499a10f 19aa9f74 f63e3d4e     "..-...tt...N=>.
c0d0bdb0:	d7089cd8 20544d49 6f6d6d49 13000020     ....IMT Immo ...
c0d0bdc0:	e1349e11 507a0940 56a5077b c31bde4b     ..4.@.zP{..VK...
c0d0bdd0:	49e6d975 4d20544d 20796e6f e3f81200     u..IMT Mony ....
c0d0bde0:	57a8ed86 125a4f48 a9dab5e4 e7064e98     ...WHOZ......N..
c0d0bdf0:	4e490537 00002044 00000000 ffdd2412     7.IND .......$..
c0d0be00:	428a8b6d 3baf35d8 1fe90d44 4a558633     m..B.5.;D...3.UJ
c0d0be10:	474e49a4 00000020 12000000 3b41e548     .ING .......H.A;
c0d0be20:	43d2ad73 4e50474e 49d1222a 78fedb40     s..CNGPN*".I@..x
c0d0be30:	4d524e49 00000020 5b030000 0d704a2e     INRM ......[.Jp.
c0d0be40:	0660c5fb de7e951e ebeef6c8 4920a374     ..`...~.....t. I
c0d0be50:	0020534e 00000000 2fc70a00 5bdde3e8     NS ......../...[
c0d0be60:	319f0fef 9f3959f2 ef721230 4e492d2a     ...1.Y9.0.r.*-IN
c0d0be70:	52415453 00000020 54760b12 3a416c4f     STAR .....vTOlA:
c0d0be80:	9b305f55 d16062f7 c07723e0 544e492a     U_0..b`..#w.*INT
c0d0be90:	00000020 06000000 1736e8ec d28a20db      .........6.. ..
c0d0bea0:	454fad55 251ef8da bb357513 20564e49     U.OE...%.u5.INV 
c0d0beb0:	00000000 a8080000 a54c6c00 83d6246f     .........lL.o$..
c0d0bec0:	06d12767 db209334 4982ef7f 2054584e     g'..4. ....INXT 
c0d0bed0:	00000000 1afa0800 34fa6c85 45a1cf09     .........l.4...E
c0d0bee0:	eb204efa ebf30d27 4f49ab21 00205453     .N .'...!.IOST .
c0d0bef0:	00000000 e0b36f12 7e4017a2 06caf7ff     .....o....@~....
c0d0bf00:	6ec2462d 4da1605d 544f4969 00002058     -F.n]`.MiIOTX ..
c0d0bf10:	12000000 19f8cd64 c85ae7d3 347b21ec     ....d.....Z..!{4
c0d0bf20:	16ced796 802ee47b 204c5049 00000000     ....{...IPL ....
c0d0bf30:	00120000 daa50a1f 5b5e5815 abdb0523     .........X^[#...
c0d0bf40:	5e42ac2b 490710a7 20585350 00000000     +.B^...IPSX ....
c0d0bf50:	f70c1200 9b1cb113 0dc46e98 7f4fbd65     .........n..e.O.
c0d0bf60:	fff650bd 5349642d 20343354 00000000     .P..-dIST34 ....
c0d0bf70:	6d6b5e12 09d9ba9a 1e86dc3f ba0e60a1     .^km....?....`..
c0d0bf80:	d95c351b 43544940 00000020 12000000     .5\.@ITC .......
c0d0bf90:	dc06ef0a e531c5cc 0044f081 ccffe659     ......1...D.Y...
c0d0bfa0:	ee396020 20545449 00000000 a4080000      `9.ITT ........
c0d0bfb0:	2a7a68ea 2dcf297f c6396bc6 c011448e     .hz*.).-.k9..D..
c0d0bfc0:	49490cd0 00205956 00000000 a4fc1200     ..IIVY .........
c0d0bfd0:	5ad46279 abd1dfdf 1523972d cce74cdb     yb.Z....-.#..L..
c0d0bfe0:	584994f0 00002054 00000000 214bc308     ..IXT ........K!
c0d0bff0:	1ce5f8f6 39c265c9 a3cf3c3b 24eb2bb8     .....e.9;<...+.$
c0d0c000:	546f4903 00000020 06000000 5d2e260d     .IoT ........&.]
c0d0c010:	0f6aa0c4 79ce901c 090ca6c7 e484c8df     ..j....y........
c0d0c020:	2054384a 00000000 88080000 c402394e     J8T ........N9..
c0d0c030:	6da8cfd5 a9e7ace4 bc1ea96a 4affc025     ...m....j...%..J
c0d0c040:	00205842 00000000 d8e20000 0edac72d     BX .........-...
c0d0c050:	962e886f f4516484 f9c8bcfa 434a2805     o....dQ......(JC
c0d0c060:	00000020 00000000 c1278712 c412c712      .........'.....
c0d0c070:	ac7133a0 d64da787 f74a10ab 54454a68     .3q...M...J.hJET
c0d0c080:	00000020 12000000 791afda5 aafc4d1c      ..........y.M..
c0d0c090:	4f3d96cc 58aec673 a79e1424 20544e4a     ..=Os..X$...JNT 
c0d0c0a0:	00000000 db120000 c1715c45 e8e42dbc     ........E\q..-..
c0d0c0b0:	1851a40c 32ef4140 4a014005 0020544f     ..Q.@A.2.@.JOT .
c0d0c0c0:	00000000 e1dd1200 f6a6122a dae05671     ........*...qV..
c0d0c0d0:	5ce02b67 0a1b4e37 4f4a573e 00002059     g+.\7N..>WJOY ..
c0d0c0e0:	00000000 50347706 ecd45e33 f75ab43d     .....w4P3^..=.Z.
c0d0c0f0:	c8f2344f 5d644853 74654a39 6e696f43     O4..SHd]9JetCoin
c0d0c100:	12002073 4b431014 bef54603 b50f8d67     s ....CK.F..g...
c0d0c110:	abc7e554 4a8f0f62 204e414b 00000000     T...b..JKAN ....
c0d0c120:	0d120000 8df6d96d 5f1dec24 3e4f17e2     ....m...$.._..O>
c0d0c130:	2bb5dac8 4bf5ba52 00002043 00000000     ...+R..KC ......
c0d0c140:	d3721200 e6c5c12a 085bfc6b f8716280     ..r.*...k.[..bq.
c0d0c150:	5415f9ee 454b6451 00002045 00000000     ...TQdKEE ......
c0d0c160:	88d94c00 72d3baaf 53afba89 e2983ec1     .L.....r...S.>..
c0d0c170:	eaaa46bd 6869428c 79654b75 12000020     .F...BihuKey ...
c0d0c180:	5693c14c 3873d3f2 a82a80b9 b058fce8     L..V..s8..*...X.
c0d0c190:	e7963237 666c6553 2079654b 27120000     72..SelfKey ...'
c0d0c1a0:	14095e69 8a73dc9a 679a8e97 c3e4998f     i^....s....g....
c0d0c1b0:	4bb99e9e 204b4349 00000000 8f810800     ...KICK ........
c0d0c1c0:	59ecc2c6 2c6ebc86 9d9300bf b16a5590     ...Y..n,.....Uj.
c0d0c1d0:	494be52c 0000204e 00000000 51184612     ,.KIN .......F.Q
c0d0c1e0:	04c3e49d fa4f44f3 dd2d817f c61c97c2     .....DO...-.....
c0d0c1f0:	4e494b88 00002044 08000000 5c4d97dd     .KIND ........M\
c0d0c200:	de28292e 981bf7a5 46b6b825 00d26b68     .)(.....%..Fhk..
c0d0c210:	20434e4b 00000000 8e120000 5eab1056     KNC ........V..^
c0d0c220:	2868d239 ea407616 e13f8229 4b4358dd     9.h(.v@.).?..XCK
c0d0c230:	2043444e 00000000 5cff0800 0bf4d225     NDC .......\%...
c0d0c240:	7fa3c447 33e99d98 ef6265e2 4e4bc00a     G......3.eb...KN
c0d0c250:	00002054 00000000 3fc3b510 99885c96     T .........?.\..
c0d0c260:	4cc355d2 fa3e2add 3dbbbc8a 52504bea     .U.L.*>....=.KPR
c0d0c270:	00000020 12000000 77be4e46 73e493c2      .......FN.w...s
c0d0c280:	96fe8cb4 fc88cfdd c0dabff7 204c524b     ............KRL 
c0d0c290:	00000000 df120000 affb3813 8917afe7     .........8......
c0d0c2a0:	b8271615 a51b7886 4b9aef56 00204555     ..'..x..V..KUE .
c0d0c2b0:	00000000 1b241200 4a5772a6 04a6a378     ......$..rWJx...
c0d0c2c0:	44a9d0cd 843aa729 574b24a3 20545441     ...D).:..$KWATT 
c0d0c2d0:	00000000 fd419512 a95f9b8b 37788173     ......A..._.s.x7
c0d0c2e0:	2fbfce83 c293a75f 4e5a4b62 00000020     .../_...bKZN ...
c0d0c2f0:	08000000 f56503e5 98cb79d6 d662dda1     ......e..y....b.
c0d0c300:	598ee5f6 dfcd1b32 0020414c 00000000     ...Y2...LA .....
c0d0c310:	fd120000 3a477b10 bd8f0eb9 44218789     .....{G:......!D
c0d0c320:	c492dca3 4cc9a80f 20414c41 00000000     .......LALA ....
c0d0c330:	852f1200 88a902e5 eef776af dbb7836d     ../......v..m...
c0d0c340:	820a6c8d 414cf93b 00205854 00000000     .l..;.LATX .....
c0d0c350:	145ffe08 e84ff91b ed8dc24b c166b90a     .._...O.K.....f.
c0d0c360:	0649176b 41424c57 00000020 12000000     k.I.WLBA .......
c0d0c370:	1b9619aa 9f8d856b f215a118 8ad9a15a     ....k.......Z...
c0d0c380:	a8db1fbc 2053434c 00000000 4a120000     ....LCS .......J
c0d0c390:	ec1ea937 09f9974c 216de60c dfaab3d3     7...L.....m!....
c0d0c3a0:	4cade51a 00205443 00000000 c7051200     ...LCT .........
c0d0c3b0:	40645d06 c3e4a496 86af24fe 21e06de3     .]d@.....$...m.!
c0d0c3c0:	434c4b07 00002054 00000000 79025112     .KLCT .......Q.y
c0d0c3d0:	c32fa01c 40985359 330efe0b 22c8b6d7     ../.YS.@...3..."
c0d0c3e0:	43444c67 00000020 12000000 d0c5265b     gLDC .......[&..
c0d0c3f0:	ba5b2e77 2a18b3c8 9b3fa1e9 6537d0b2     w.[....*..?...7e
c0d0c400:	5544454c 00000020 60080000 d00744c2     LEDU ......`.D..
c0d0c410:	17c28217 7cfe325d 73ed2189 4cd17123     ....]2.|.!.s#q.L
c0d0c420:	204f4d45 00000000 fb801200 d67e4b78     EMO ........xK~.
c0d0c430:	b1e83067 0a82d9db 1a9329fd 454c03ab     g0.......)....LE
c0d0c440:	0020444e 00000000 a94c0f12 adef6026     ND .......L.&`..
c0d0c450:	0ca7a997 9c96feb0 77395475 56454c2c     ........uT9w,LEV
c0d0c460:	00000020 09000000 1ccd98c7 290edb49      ...........I..)
c0d0c470:	c6e41273 68267582 adb21dce 2052464c     s....u&h....LFR 
c0d0c480:	00000000 c5050000 30acf320 8f7d103a     ........ ..0:.}.
c0d0c490:	26b3084b a466eab6 4ccd61f9 00002047     K..&..f..a.LG ..
c0d0c4a0:	00000000 06591200 bb266f1b 82e59c4a     ......Y..o&.J...
c0d0c4b0:	5cd3198a 804b5afd 474c56f0 00002044     ...\.ZK..VLGD ..
c0d0c4c0:	00000000 b13a1208 b138dd95 d41005b4     ......:...8.....
c0d0c4d0:	59a3a667 05af01b2 4f474c6f 00000020     g..Y....oLGO ...
c0d0c4e0:	08000000 8f6eb82e f6e020c5 f09a5dbb     ......n.. ...]..
c0d0c4f0:	e74f928f 89ab5805 2052474c 00000000     ..O..X..LGR ....
c0d0c500:	e6080000 ac1fbfdf b83650a9 b21f6ee7     .........P6..n..
c0d0c510:	25d03389 4cc06cb7 52454249 00000020     .3.%.l.LIBER ...
c0d0c520:	99eb1200 98160251 99432eb4 26b6cbf9     ....Q.....C....&
c0d0c530:	825fa37a 494c9dd5 00002046 00000000     z._...LIF ......
c0d0c540:	db18ff12 c2b487c4 112d22e3 bfba5259     ........."-.YR..
c0d0c550:	2fa58bda 46494c5f 00002045 12000000     .../_LIFE ......
c0d0c560:	d21ff602 8b6eda66 21412d10 997bcef5     ....f.n..-A!..{.
c0d0c570:	98cf4026 454b494c 00000020 51120000     &@..LIKE ......Q
c0d0c580:	1a771049 6a65caf9 f8df40f8 ec64823e     I.w...ej.@..>.d.
c0d0c590:	43ca86f9 6e696168 206b6e4c e6e21200     ...ChainLnk ....
c0d0c5a0:	6c08bed4 3bb53869 55481422 2874f6ee     ...li8.;".HU..t(
c0d0c5b0:	494c3916 70204b4e 00206674 7ca72412     .9LINK ptf ..$.|
c0d0c5c0:	47c5171f 81145e10 e07b513e aa40006b     ...G.^..>Q{.k.@.
c0d0c5d0:	56494c76 00002045 12000000 a72dbd49     vLIVE ......I.-.
c0d0c5e0:	f17a1f5b b1d6dfe4 deec5f12 58ecdb59     [.z......_..Y..X
c0d0c5f0:	20594b4c 00000000 25120000 5b5f32b6     LKY .......%.2_[
c0d0c600:	3ce0c1b1 3fe5c3fb 1c1f0e47 4ce322a0     ...<...?G....".L
c0d0c610:	00204c4d 00000000 e6631200 200a3334     ML .......c.43. 
c0d0c620:	61bb0d15 bc4856b1 6c5d8573 4e4c07cf     ...a.VH.s.]l..LN
c0d0c630:	00002043 00000000 41eb6b12 95e1c68f     C .......k.A....
c0d0c640:	8bac0482 09f1dcad 4969e9b8 6e694c66     ..........iIfLin
c0d0c650:	696f436b 1200206e e6b04709 883721d8     kCoin ...G...!7.
c0d0c660:	8259c905 e75c3891 b2a691c7 20444e4c     ..Y..8\.....LND 
c0d0c670:	00000000 5e120000 40444633 22531310     .......^3FD@..S"
c0d0c680:	30468a26 8d5fedd2 4c6c4409 0020434f     &.F0.._..DlLOC .
c0d0c690:	00000000 239c1200 7bea7ad6 4209d895     .......#.z.{...B
c0d0c6a0:	cd6b83e3 a708e7f7 4f4cc247 00204943     ..k.....G.LOCI .
c0d0c6b0:	00000000 0045c612 170f7bdd 677e8094     ......E..{....~g
c0d0c6c0:	bb8a2f80 b0fff8f5 434f4c54 00205355     ./......TLOCUS .
c0d0c6d0:	12000000 d07d3c25 cbbaf474 f9875330     ....%<}.t...0S..
c0d0c6e0:	4f5a2222 bd087c73 4b4f4f4c 00000020     ""ZOs|..LOOK ...
c0d0c6f0:	21120000 82b823ae 22a240a3 86201682     ...!.#...@.".. .
c0d0c700:	e2d398bc 4c1830b7 204b4f4f 20646c6f     .....0.LOOK old 
c0d0c710:	e8a41200 6145ecc3 d367ea07 e3f95b07     ......Ea..g..[..
c0d0c720:	82753adf 4f4cb03d 00204d4f 00000000     .:u.=.LOOM .....
c0d0c730:	e768ef12 0cf494c6 1e820282 e35d52df     ..h..........R].
c0d0c740:	63582478 43524c9f 00000020 12000000     x$Xc.LRC .......
c0d0c750:	6f29be5d 4a3cb297 3d18a66a d074e573     ].)o..<Jj..=s.t.
c0d0c760:	19c7a52b 2043554c 00000000 fb120000     +...LUC ........
c0d0c770:	a9cce312 9df5b983 d12f9190 5a748d7f     ........../...tZ
c0d0c780:	4c53298b 204b4355 00000000 9ba80000     .)SLUCK ........
c0d0c790:	34863459 fce4f647 a915b353 da3b873e     Y4.4G...S...>.;.
c0d0c7a0:	554ca369 0000204d 00000000 a705fa12     i.LUM ..........
c0d0c7b0:	ef78fe3f 94731a8f c562e473 6765ae4b     ?.x...s.s.b.K.eg
c0d0c7c0:	4e554cd9 00000020 12000000 ac67ad57     .LUN .......W.g.
c0d0c7d0:	5e01bff9 d6fb2048 1ba2a16e ec5288ed     ...^H ..n.....R.
c0d0c7e0:	204d594c 00000000 3f120000 6866724b     LYM .......?Krfh
c0d0c7f0:	e0f546da d4a55ae7 9fecac78 4d0f2138     .F...Z..x...8!.M
c0d0c800:	4854452d 00000020 095b1200 1d1c37a0     -ETH .....[..7..
c0d0c810:	248e4aa4 def56bd3 841a14b1 414d75d8     .J.$.k.......uMA
c0d0c820:	00002044 00000000 ce5be212 1c80d3c5     D ........[.....
c0d0c830:	0794a7e3 df4af99b 80cd8c1b 4e414d2d     ......J.....-MAN
c0d0c840:	00000020 12000000 b22f5d0f cfd3b79f      ........]/.....
c0d0c850:	204a44ee 68f49802 42c98c90 414e414d     .DJ ...h...BMANA
c0d0c860:	00000020 fd120000 60ab07cc 33e50d66      ..........`f..3
c0d0c870:	e126adb5 5a567b45 4dbd599d 20545241     ..&.E{VZ.Y.MART 
c0d0c880:	00000000 64381200 ddf3f167 482483be     ......8dg.....$H
c0d0c890:	31180465 ec9e471a 424d57fc 00205352     e..1.G...WMBRS .
c0d0c8a0:	00000000 82e69300 9d1e7d10 eeb5b0ef     .........}......
c0d0c8b0:	70711c70 462e4b7a 41434dbc 00002050     p.qpzK.F.MCAP ..
c0d0c8c0:	08000000 52878a13 9a4f3f09 f4edaa79     .......R.?O.y...
c0d0c8d0:	48924b8d 9c3cb9fa 2049434d 00000000     .K.H..<.MCI ....
c0d0c8e0:	b6120000 c86a603b ca2ca510 b64be415     ....;`j...,...K.
c0d0c8f0:	d842fd30 4d3dd8d1 00204f43 00000000     0.B...=MCO .....
c0d0c900:	db510800 675cd35a 7d20871a d511fc88     ..Q.Z.\g.. }....
c0d0c910:	840cac93 444dbd15 00002041 00000000     ......MDA ......
c0d0c920:	60186612 0605c108 d479f927 25bbea64     .f.`....'.y.d..%
c0d0c930:	3d566088 53444dbe 00000020 12000000     .`V=.MDS .......
c0d0c940:	08094e81 fe992ab1 01c15bcf 8b0b5dbb     .N...*...[...]..
c0d0c950:	267ddf5c 2054444d 00000000 fd120000     \.}&MDT ........
c0d0c960:	8f50801e ce643e24 8aa84e23 7c82d25f     ..P.$>d.#N.._..|
c0d0c970:	4db7d471 20584445 00000000 30f00800     q..MEDX .......0
c0d0c980:	07c8a445 b8f3387e b833ede2 df9ee6ae     E...~8....3.....
c0d0c990:	454d9f86 00204853 00000000 acf20112     ..MESH .........
c0d0c9a0:	604891f2 b11c1c33 daecaca9 6ae07574     ..H`3.......tu.j
c0d0c9b0:	53454df8 00002048 12000000 ff438d5b     .MESH ......[.C.
c0d0c9c0:	82294ade 7c38a5b9 4ed521df 8dac64ad     .J)...8|.!.N.d..
c0d0c9d0:	5453454d 00000020 a3120000 564e8cd5     MEST .........NV
c0d0c9e0:	3aaedcfe 25a7437c 1fa7e9ae 4d4ece0e     ...:|C.%......NM
c0d0c9f0:	00205445 00000000 f3fe1200 3c604b88     ET ..........K`<
c0d0ca00:	d48eef33 e0463318 c973a193 454da64d     3....3F...s.M.ME
c0d0ca10:	00204d54 00000000 c6106712 dea23234     TM ......g..42..
c0d0ca20:	c04f9502 07db51f8 036c6a14 47464d12     ..O..Q...jl..MFG
c0d0ca30:	00000020 12000000 38722cdf b3d88a19      ........,r8....
c0d0ca40:	74656689 41bcd8f2 28744b1a 2054464d     .fet...A.Kt(MFT 
c0d0ca50:	00000000 05120000 18ce12d4 bb4040f2     .............@@.
c0d0ca60:	f25ca43f 65509ec6 4de8d886 20555446     ?.\...Pe...MFTU 
c0d0ca70:	00000000 39401200 3cac4450 1905570c     ......@9PD.<.W..
c0d0ca80:	8b93da06 5765bd54 474d12f2 0000204f     ....T.eW..MGO ..
c0d0ca90:	00000000 37123a08 b90f8dd3 5df81345     .....:.7....E..]
c0d0caa0:	ad9c6761 7250387f 43494d42 00000020     ag...8PrBMIC ...
c0d0cab0:	12000000 60d13ce2 fc631f76 8af71c3a     .....<.`v.c.:...
c0d0cac0:	cdb634a0 0c3e7df9 6e69614d 74727473     .4...}>.Mainstrt
c0d0cad0:	ad120020 25c7d48d b9311dde 46d1f8e8      ......%..1....F
c0d0cae0:	c69d9e08 4d932088 61686379 00002074     ..... .Mychat ..
c0d0caf0:	524a0600 3cc18f7d 24ab0352 f44409ba     ..JR}..<R..$..D.
c0d0cb00:	8d6514cb 494db61d 00207854 00000000     ..e...MITx .....
c0d0cb10:	728f9f12 c80493aa 55d593b5 58f62ef1     ...r.......U...X
c0d0cb20:	79a5c39c 524b4da2 00000020 12000000     ...y.MKR .......
c0d0cb30:	2b883979 bcf0fc54 de536bae e8d69ac3     y9.+T....kS.....
c0d0cb40:	42641706 20544b4d 00000000 be080000     ..dBMKT ........
c0d0cb50:	4a51efb9 7e999b37 ccfd9807 74e41e90     ..QJ7..~.......t
c0d0cb60:	4da1d9b6 00204e4c 00000000 951a1200     ...MLN .........
c0d0cb70:	53b071b2 49fa155d a3ab2d93 b512a61b     .q.S]..I.-......
c0d0cb80:	4e4d4629 00002045 00000000 7b87a908     )FMNE .........{
c0d0cb90:	35d0051e db319189 8203e4d1 9fd06651     ...5..1.....Qf..
c0d0cba0:	544e4d92 00000020 12000000 e0e9ce83     .MNT ...........
c0d0cbb0:	497ea786 93bbe02e 7a43b0c2 ccecfdd6     ..~I......Cz....
c0d0cbc0:	50544e4d 00000020 86120000 068bc55e     MNTP .......^...
c0d0cbd0:	b80563bf a23a7986 1da32d0a 4d684e03     .c...y:..-...NhM
c0d0cbe0:	0020434f 00000000 7c951200 2604ab30     OC ........|0..&
c0d0cbf0:	d83cc9e0 602c1e24 c6082d39 4f4d8eac     ..<.$.,`9-....MO
c0d0cc00:	00002044 00000000 62125000 a02b1b28     D .......P.b(.+.
c0d0cc10:	f1fbe243 06980449 0cdbcd89 524f4d78     C...I.......xMOR
c0d0cc20:	00002045 02000000 84613c26 5ce3db80     E ......&<a....\
c0d0cc30:	5e8d0d30 bb9ba1cd edca6a98 20544f4d     0..^.....j..MOT 
c0d0cc40:	00000000 fb120000 7bc7d1d0 a3961750     ...........{P...
c0d0cc50:	91cf865d 78975dd6 4d95e6ee 4445564f     ]....].x...MOVED
c0d0cc60:	00000020 bf440300 9c9f9422 b9614bc8      .....D."....Ka.
c0d0cc70:	889d8a32 805c1b5d 4f4d416b 00204f5a     2...].\.kAMOZO .
c0d0cc80:	00000000 b553f402 b5e0d4b9 25fb2fc6     ......S....../.%
c0d0cc90:	8c37b26b 8a8ebcc2 4b524d89 00000020     k.7......MRK ...
c0d0cca0:	08000000 fe5a1282 ff9d8101 d6d03515     ......Z......5..
c0d0ccb0:	04576d27 c0b69152 204c524d 00000000     'mW.R...MRL ....
c0d0ccc0:	21120000 31fdf0f0 119eee41 3af1d7b3     ...!...1A......:
c0d0ccd0:	51cd2810 4d9c455f 00205052 00000000     .(.Q_E.MRP .....
c0d0cce0:	6cab1200 f1507af8 1f5e7f7d 6f1bf8ea     ...l.zP.}.^....o
c0d0ccf0:	8ebeffe9 524d84bf 00002056 00000000     ......MRV ......
c0d0cd00:	3faa6812 bda92d23 653434c2 ef945754     .h.?#-...44eTW..
c0d0cd10:	0952ea3e 50534dbd 00000020 12000000     >.R..MSP .......
c0d0cd20:	7c335e90 2645866c 2021353d f47ba35a     .^3|l.E&=5! Z.{.
c0d0cd30:	45e734d0 2043544d 2064654d df120000     .4.EMTC Med ....
c0d0cd40:	d9820ddc 0cd48f6f a2b4cfa0 ec5b9588     ....o.........[.
c0d0cd50:	4d8820ec 4d204354 20687365 4daf1200     . .MTC Mesh ...M
c0d0cd60:	28da16ce e0c9f877 3bc94405 6340ac62     ...(w....D.;b.@c
c0d0cd70:	544d161f 00002048 00000000 0833f405     ..MTH ........3.
c0d0cd80:	9d896693 6af2a983 ec593d77 3530cf7e     .f.....jw=Y.~.05
c0d0cd90:	4c544d5e 00000020 08000000 c1ecdb41     ^MTL .......A...
c0d0cda0:	7c51c5cd a6f6766f bead36e8 e34d75e2     ..Q|ov...6...uM.
c0d0cdb0:	204e544d 00000000 7f120000 110108c4     MTN ............
c0d0cdc0:	e30e7665 20bfe21b 3550f4da 4daf9266     ev..... ..P5f..M
c0d0cdd0:	00205254 00000000 491e0800 55c377ff     TR ........I.w.U
c0d0cde0:	668de3a3 0484ce51 c5480eaf 544d5f39     ...fQ.....H.9_MT
c0d0cdf0:	00206352 00000000 4ef40a12 72638427     Rc ........N'.cr
c0d0ce00:	321ddd18 4ed422a3 0c8f3a60 58544d6a     ...2.".N`:..jMTX
c0d0ce10:	00000020 12000000 d3695651 fd87f808      .......QVi.....
c0d0ce20:	c771a483 085d4f76 4dd38648 4558554d     ..q.vO].H..MMUXE
c0d0ce30:	00000020 a8120000 99aeea49 fa6ab84f      .......I...O.j.
c0d0ce40:	9b2e3873 6b2b8cd8 4d71dc18 00204c56     s8....+k..qMVL .
c0d0ce50:	00000000 778a1200 bb3609e4 e9807ec2     .......w..6..~..
c0d0ce60:	3626f5a3 6978968c 564d6dc8 00002050     ..&6..xi.mMVP ..
c0d0ce70:	00000000 c6256412 692d90be 75dbe22a     .....d%...-i*..u
c0d0ce80:	8a263c2b 9d09dbfa 41574d3b 00002054     +<&.....;MWAT ..
c0d0ce90:	12000000 7883e9f7 23010916 4f51f207     .......x...#..QO
c0d0cea0:	d826d563 66f4243d 2044594d 00000000     c.&.=$.fMYD ....
c0d0ceb0:	a6100000 564c2645 3b6ce903 da8c070b     ....E&LV..l;....
c0d0cec0:	793387b6 4d710a4b 20545359 00000000     ..3yK.qMYST ....
c0d0ced0:	808d0800 19788ade 9d329683 d59a76fa     ......x...2..v..
c0d0cee0:	90bf244d 414eaae7 00002043 00000000     M$....NAC ......
c0d0cef0:	2ee0ff12 df9ec6e4 ca0f341b 6bbd4fd6     .........4...O.k
c0d0cf00:	e2b9a737 4e414e65 0000204a 08000000     7...eNANJ ......
c0d0cf10:	71d9655d 43dc5e89 175c468f 699269db     ]e.q.^.C.F\..i.i
c0d0cf20:	8d31528a 2053414e 00000000 58120000     .R1.NAS .......X
c0d0cf30:	5d364780 9f58baf5 aa043692 35673dc2     .G6]..X..6...=g5
c0d0cf40:	4e23c655 20495641 00000000 f8171200     U.#NAVI ........
c0d0cf50:	fc3db6af be0ec9dc 60f0846e 986a30cc     ..=.....n..`.0j.
c0d0cf60:	424e7d25 00204941 00000000 56199f12     %}NBAI ........V
c0d0cf70:	ba8ffa17 5d0c54d9 a0993a11 ae2a17a0     .....T.].:....*.
c0d0cf80:	43424edc 00000020 12000000 cc269880     .NBC .........&.
c0d0cf90:	388cb6ea 96af2677 4cb61327 ca3ccbb5     ...8w&..'..L..<.
c0d0cfa0:	5341434e 00002048 5d120000 ba93f248     NCASH .....]H...
c0d0cfb0:	2d7a24ed 8b058901 38a27aa3 4e2547bd     .$z-.....z.8.G%N
c0d0cfc0:	4e204343 20727565 44931200 d5b183b3     CC Neur ...D....
c0d0cfd0:	46e35c9b ab4d238b 0b19c743 434e35a7     .\.F.#M.C....5NC
c0d0cfe0:	654e2043 00206465 a3469e12 beaa5d8f     C Need ...F..]..
c0d0cff0:	07e18386 4967b093 33d7f7ee 54434ed1     ......gI...3.NCT
c0d0d000:	00000020 12000000 7bdc4da5 c87fce3c      ........M.{<...
c0d0d010:	02fae3b1 80dbd056 7009c1d2 2043444e     ....V......pNDC 
c0d0d020:	00000000 cc120000 0551c080 d74c777b     ..........Q.{wL.
c0d0d030:	48dc6750 4e7c98f8 4e5e7ab9 00204345     Pg.H..|N.z^NEC .
c0d0d040:	00000000 44d81200 95fa3662 fdf9b5b9     .......Db6......
c0d0d050:	f17d8e0f 3c8244a9 454e3d68 00204f45     ..}..D.<h=NEEO .
c0d0d060:	00000000 86b9cf12 43aebc37 ea2333c1     ........7..C.3#.
c0d0d070:	ed1c73a1 6269712b 54454efd 00000020     .s..+qib.NET ...
c0d0d080:	12000000 72e623a8 e9af0620 0fc3919e     .....#.r .......
c0d0d090:	525029f5 328e6bfe 2055454e 00000000     .)PR.k.2NEU ....
c0d0d0a0:	81120000 bcb16449 264ef2ea 1e036d29     ....Id....N&)m..
c0d0d0b0:	a234f1ad 4e0541ca 20425745 00000000     ..4..A.NEWB ....
c0d0d0c0:	21b60000 6c5ae332 e01eee13 d4c54df8     ...!2.Zl.....M..
c0d0d0d0:	818dad0b 454e0652 00204f58 00000000     ....R.NEXO .....
c0d0d0e0:	4bdd7212 a352d86b e42b17aa dba6c5d6     .r.Kk.R...+.....
c0d0d0f0:	f18c58ec 43474e31 00000020 12000000     .X..1NGC .......
c0d0d100:	a91765e2 45997296 481b3f3d 615e00aa     .e...r.E=?.H..^a
c0d0d110:	1072e627 464d494e 00002041 55120000     '.r.NIMFA .....U
c0d0d120:	764ee054 141d3e53 be052fc5 329d6cef     T.NvS>.../...l.2
c0d0d130:	4e301e9e 00204f49 00000000 76170000     ..0NIO ........v
c0d0d140:	986ff2e1 9cdfa5b1 3a9547d3 b43cdd26     ..o......G.:&.<.
c0d0d150:	4d4e7166 00002052 00000000 88a45812     fqNMR .......X..
c0d0d160:	e8d98241 407f5935 82255f5e e76ae490     A...5Y.@^_%...j.
c0d0d170:	414f4ec2 00002048 12000000 45eafaf4     .NOAH .........E
c0d0d180:	4d357555 20bc9926 ca650a9b 8299f699     Uu5M&.. ..e.....
c0d0d190:	53424f4e 00000020 ec120000 7d20f846     NOBS .......F. }
c0d0d1a0:	45126076 e28d404c 22bcbc10 4e1ce743     v`.EL@....."C..N
c0d0d1b0:	0020584f 00000000 e64c1200 77bc62b3     OX .......L..b.w
c0d0d1c0:	dd6649a2 9c8f07a9 b8b381ef 504ea786     .If...........NP
c0d0d1d0:	00205245 00000000 e1b52812 f151ce2c     ER ......(..,.Q.
c0d0d1e0:	b9b09455 da5a5b1d 4a680fa7 58504e02     U....[Z...hJ.NPX
c0d0d1f0:	00000020 02000000 be7e5ca1 f6ca071f      ........\~.....
c0d0d200:	d897f0bf 8afb89a5 b3e59ac4 5358504e     ............NPXS
c0d0d210:	00000020 69120000 3440abbe 133f2538      ......i..@48%?.
c0d0d220:	b92de9b6 49b87f1f 4e638225 00204b54     ..-....I%.cNTK .
c0d0d230:	00000000 4d5d1200 fa06cd57 269ee97f     ......]MW......&
c0d0d240:	b481c4fd 057ff768 544e3c07 0000204b     ....h....<NTK ..
c0d0d250:	00000000 ed998a12 49201b8a e746ee03     .......... I..F.
c0d0d260:	28c1f233 b1206d6f 4f544e77 00000020     3..(om .wNTO ...
c0d0d270:	12000000 9e793322 753d68e2 bcacefdf     ...."3y..h=u....
c0d0d280:	786ca2d2 0d474bd3 4b57544e 00000020     ..lx.KG.NTWK ...
c0d0d290:	24120000 4d7df45e f3ec0505 4d3f46ac     ...$^.}M.....F?M
c0d0d2a0:	de1af481 4ed11f8f 00204755 00000000     .......NUG .....
c0d0d2b0:	13b91200 db5bf318 23942e26 2a7c7cbc     ......[.&..#.||*
c0d0d2c0:	93dd933a 554e2cc9 0020534c 00000000     :....,NULS .....
c0d0d2d0:	1eab5712 37e2fe02 110c5874 9e124097     .W.....7tX...@..
c0d0d2e0:	e98170ac 535573d3 00002044 12000000     .p...sUSD ......
c0d0d2f0:	4bde2776 6a3a2693 dab87075 e8ba64fa     v'.K.&:jup...d..
c0d0d300:	94c3e512 2058584e 00000000 5c080000     ....NXX .......\
c0d0d310:	0ad18361 7a74cd00 655fbb6d 3814d58a     a.....tzm._e...8
c0d0d320:	4e19943e 4f205858 0020444c e4450800     >..NXX OLD ...E.
c0d0d330:	9f9d652d 5dcd6694 605022f6 9b5a1433     -e...f.]."P`3.Z.
c0d0d340:	784ebc89 00002043 00000000 8b885e03     ..NxC .......^..
c0d0d350:	7e28b783 dab74fed 0d0a7d7b 945d734c     ..(~.O..{}..Ls].
c0d0d360:	4b414fb3 00000020 12000000 4b241c70     .OAK .......p.$K
c0d0d370:	3c518a98 de735994 93de05fa 1dfe233b     ..Q<.Ys.....;#..
c0d0d380:	2058414f 00000000 02120000 4e62fe35     OAX ........5.bN
c0d0d390:	ee054a04 163ea4d7 c83b08e3 4f7a28a4     .J....>...;..(zO
c0d0d3a0:	00204343 00000000 92401200 784e8e67     CC .......@.g.Nx
c0d0d3b0:	a1460f23 bc0f4c53 8097a38f 434f2b89     #.F.SL.......+OC
c0d0d3c0:	0000204e 00000000 f252bf12 6ee239ab     N ........R..9.n
c0d0d3d0:	a0d25109 70b7492b 4030be2a 45444f6a     .Q..+I.p*.0@jODE
c0d0d3e0:	00000020 12000000 949a536f b6bca556      .......oS..V...
c0d0d3f0:	411a4a33 88377c20 075282f5 494e484f     3J.A |7...R.OHNI
c0d0d400:	00000020 c6120000 7102a86e 3398fb7b      .......n..q{..3
c0d0d410:	dd640240 eabcc212 4f6d4aa3 4d5f444c     @.d......JmOLD_M
c0d0d420:	0020524b 929d1200 dd6d4323 47c26f46     KR .....#Cm.Fo.G
c0d0d430:	20bddbe9 0f647e20 4c4f58ef 00002045     ...  ~d..XOLE ..
c0d0d440:	00000000 04a66412 7288d893 1626f48c     .....d.....r..&.
c0d0d450:	dfa034e0 fc8ee3ea 544c4ff0 00000020     .4.......OLT ...
c0d0d460:	12000000 cd1461d2 ac89e26e 0c3582cf     .....a..n.....5.
c0d0d470:	fe87848d 070c8adb 20474d4f 00000000     ........OMG ....
c0d0d480:	b5120000 cfd3c6db df790038 5613273b     ........8.y.;'.V
c0d0d490:	f4bcb664 4f69185d 0020584d 00000000     d...].iOMX .....
c0d0d4a0:	3bb20800 bc7335e7 6edb037e 4062fc5d     ...;.5s.~..n].b@
c0d0d4b0:	6d716853 4e4fa828 00204b45 00000000     Shqm(.ONEK .....
c0d0d4c0:	d141d312 e3ee0e68 4c8c5b25 7ecebc75     ..A.h...%[.Lu..~
c0d0d4d0:	4d147fb5 476e6fae 00000020 12000000     ...M.onG .......
c0d0d4e0:	0ebe6368 86cef77c 6047570a 510d02e9     hc..|....WG`...Q
c0d0d4f0:	47dc8b9a 204c4e4f 00000000 69120000     ...GONL .......i
c0d0d500:	0c24bbc4 ee515df0 ba8569ab d02755b3     ..$..]Q..i...U'.
c0d0d510:	4f648c4a 204e4550 00000000 55430800     J.dOPEN ......CU
c0d0d520:	740f16fc 389b8f32 58ecf23d d8dfb39b     ...t2..8=..X....
c0d0d530:	504fa02b 00002054 00000000 04298312     +.OPT ........).
c0d0d540:	b9783986 31120248 49ebe606 f90ddf1b     .9x.H..1...I....
c0d0d550:	54504f28 00002049 12000000 6bcc56ff     (OPTI .......V.k
c0d0d560:	34ed6d1e 67b7a07a 0bab856c fab0083d     .m.4z..gl...=...
c0d0d570:	5342524f 00000020 6f120000 1a46e059     ORBS ......oY.F.
c0d0d580:	9f79e2e5 7f84b31f 163ba605 4ff8dbd0     ..y.......;....O
c0d0d590:	20414352 00000000 fad21200 72ea928f     RCA ...........r
c0d0d5a0:	bd5db3ab 71a5ec6d b22dd273 524f49ba     ..].m..qs.-..IOR
c0d0d5b0:	00002049 00000000 546e5112 c1fdba36     I .......QnT6...
c0d0d5c0:	4d658310 959bbbe7 d5082d38 4d524fde     ..eM....8-...ORM
c0d0d5d0:	00002045 08000000 184b9aeb 54c31658     E ........K.X..T
c0d0d5e0:	09db92db be503bcc b601b960 2053524f     .....;P.`...ORS 
c0d0d5f0:	00000000 2c120000 742d8f4e 69d01361     .......,N.-ta..i
c0d0d600:	359be86c 88bfd8f0 4fcaaee0 00205453     l..5.......OST .
c0d0d610:	00000000 1e881200 981182f4 cbe2012d     ............-...
c0d0d620:	15c99270 40cd47e6 544f5cd8 0000204e     p....G.@.\OTN ..
c0d0d630:	00000000 270b1712 9f08ed5c e9bfaeff     .......'\.......
c0d0d640:	a345f427 6091ed50 4e574fdc 00000020     '.E.P..`.OWN ...
c0d0d650:	08000000 1450a165 02214f96 7e6458ff     ....e.P..O!..Xd~
c0d0d660:	6b6aa116 f6bc149e 4620784f 20616e69     ..jk....Ox Fina 
c0d0d670:	b9030000 7eab08bb 35a1a09f 9ea3d46b     .......~...5k...
c0d0d680:	7e26cac0 50b3b003 00204941 00000000     ..&~...PAI .....
c0d0d690:	dafe1200 682664e5 116a63f8 86f37f98     .....d&h.cj.....
c0d0d6a0:	f915d2bf 4150ee42 0000204c 00000000     ....B.PAL ......
c0d0d6b0:	885fea12 2c984de5 1c440cbb bc794ede     .._..M.,..D..Ny.
c0d0d6c0:	435b5e30 524150bc 204f5445 12000000     0^[C.PARETO ....
c0d0d6d0:	aae4d46d ed409ad2 b909a4d6 865162c1     m.....@......bQ.
c0d0d6e0:	4d5b85c9 4b524150 204e4547 77080000     ..[MPARKGEN ...w
c0d0d6f0:	c0631e76 4866ee5a 9baaaefd 51832494     v.c.Z.fH.....$.Q
c0d0d700:	50cd9baf 20535341 00000000 b3f31200     ...PASS ........
c0d0d710:	b894d0ca e5fc9293 bc40fdfa 2b0fb803     ..........@....+
c0d0d720:	415024c6 00002054 00000000 04446912     .$PAT .......iD.
c0d0d730:	75305e59 7f3942a9 d4ac6a46 7b1aff62     Y^0u.B9.Fj..b..{
c0d0d740:	544150d0 53544e45 12000020 90f313f8     .PATENTS .......
c0d0d750:	a600bc2b 6378e3dc d8793b4d d703984f     +.....xcM;y.O...
c0d0d760:	48544150 00000020 8e120000 f6670d87     PATH .........g.
c0d0d770:	5b5dd960 0d3830e5 38bdc00e 50e18982     `.][.08....8...P
c0d0d780:	00205841 00000000 70b91200 b68d6248     AX ........pHb..
c0d0d790:	c2d461b6 953e83aa 05a9e1db 415080b2     .a....>.......PA
c0d0d7a0:	00002059 00000000 8d645512 333698e1     Y .......Ud...63
c0d0d7b0:	0b134985 f187f51a f646ea6b 4c42506b     .I......k.F.kPBL
c0d0d7c0:	00000020 12000000 187bc0f4 6a32bc65      .........{.e.2j
c0d0d7d0:	9433013c 3875ca92 c08c03fd 20544250     <.3...u8....PBT 
c0d0d7e0:	00000000 fc040000 15757aac 61d7a9e9     .........zu....a
c0d0d7f0:	1f7aa79f 1f1138a7 507e7266 00204843     ..z..8..fr~PCH .
c0d0d800:	00000000 f4e31200 1ed9a5b4 5b43b95c     ............\.C[
c0d0d810:	0a097f94 03379731 43501263 00002048     ....1.7.c.PCH ..
c0d0d820:	00000000 51183612 3ccd456f f9813f91     .....6.QoE.<.?..
c0d0d830:	10f47a98 c42b9377 4c43500d 00000020     .z..w.+..PCL ...
c0d0d840:	08000000 b48b1453 ed071755 8d1e1af5     ....S...U.......
c0d0d850:	8d69937a 25129318 4f4c4350 0020444c     z.i....%PCLOLD .
c0d0d860:	0d080000 de6c3bb0 7c422d0b ea4fa064     .....;l..-B|d.O.
c0d0d870:	385982fd 501f8f36 41544144 00000020     ..Y86..PDATA ...
c0d0d880:	e58a1200 a750686a c3c3eacb 11b32cab     ....jhP......,..
c0d0d890:	670162e7 4550c8ea 00002047 00000000     .b.g..PEG ......
c0d0d8a0:	96845812 0548c09e 111de156 6a138099     .X....H.V......j
c0d0d8b0:	deed174c 544550d1 00000020 12000000     L....PET .......
c0d0d8c0:	98f818ec 3e6a07b4 9d08f118 c36c3733     ......j>....37l.
c0d0d8d0:	1de6bd80 52544550 0000204f 55120000     ....PETRO .....U
c0d0d8e0:	71c1a0c2 358420d9 e34d5960 09cceed6     ...q. .5`YM.....
c0d0d8f0:	5098c0ef 20545845 00000000 a32f0400     ...PEXT ....../.
c0d0d900:	1cfc392a c70c9e39 685893b2 e75d16f5     *9..9.....Xh..].
c0d0d910:	465097ce 00002052 00000000 fac21308     ..PFR ..........
c0d0d920:	374d35b6 e4ecd890 28a3f1f0 ad254a0b     .5M7.......(.J%.
c0d0d930:	49485096 00000020 12000000 f00945e6     .PHI ........E..
c0d0d940:	2dce07bf 19efa729 06bca9a8 b4c17754     ...-).......Tw..
c0d0d950:	4c504950 00000020 0f080000 1e0761f1     PIPL ........a..
c0d0d960:	6d0e7a62 5c1038e1 860f9773 502279ca     bz.m.8.\s....y"P
c0d0d970:	00205449 00000000 ff8e1200 69eb94d4     IT ............i
c0d0d980:	af99c38c cdfc3162 d28fe039 4950150b     ....b1..9.....PI
c0d0d990:	00002058 00000000 d4f20200 016e4ea0     X ...........Nn.
c0d0d9a0:	d28be8ac 752863cd f52e3b54 474b5077     .....c(uT;..wPKG
c0d0d9b0:	00000020 12000000 40fa0426 e557e96b      .......&..@k.W.
c0d0d9c0:	9eb8be42 defc5467 3fe81568 20544b50     B...gT..h..?PKT 
c0d0d9d0:	00000000 59120000 62256a41 73b4768a     .......YAj%b.v.s
c0d0d9e0:	8614c50e e0324c11 50a182b5 4d53414c     .....L2....PLASM
c0d0d9f0:	00002041 77e40600 321b2f29 297a6868     A .....w)/.2hhz)
c0d0da00:	b0166137 c7a927ed 4c507061 00205941     7a...'..apPLAY .
c0d0da10:	00000000 a0ff0a12 5bbe7f6e c964a7c9     ........n..[..d.
c0d0da20:	e866aa79 1f636a25 424c5002 00002054     y.f.%jc..PLBT ..
c0d0da30:	06000000 048581e3 f12bb3c1 c2167b55     ..........+.U{..
c0d0da40:	1fe0b238 179c14d3 20524c50 00000000     8.......PLR ....
c0d0da50:	d8120000 68102c91 fd218b1d 4f244237     .....,.h..!.7B$O
c0d0da60:	ba8d6544 504e2612 0020554c 00000000     De...&NPLU .....
c0d0da70:	6c841200 c471cf66 3b40803f 0639fe51     ...lf.q.?.@;Q.9.
c0d0da80:	639d59b3 4d506f33 00002041 00000000     .Y.c3oPMA ......
c0d0da90:	d0b48112 11da4586 74034a37 8370b19a     .....E..7J.t..p.
c0d0daa0:	97534e6e 4e4d5067 00002054 09000000     nNS.gPMNT ......
c0d0dab0:	be3fed93 c27e2021 c3d3f2e8 8c056ede     ..?.! ~......n..
c0d0dac0:	4dc03bb7 204b4e50 00000000 67120000     .;.MPNK .......g
c0d0dad0:	41d4b758 989b73a9 37372b55 d1d3d803     X..A.s..U+77....
c0d0dae0:	50629e4f 3032414f 00000020 090e1200     O.bPOA20 .......
c0d0daf0:	b8f9b189 c28389a3 265380ba c92ea69c     ..........S&....
c0d0db00:	4f5095b1 00002045 00000000 a1f64308     ..POE .......C..
c0d0db10:	ee2d99be 74218740 2b779084 e03c1415     ..-.@.!t..w+..<.
c0d0db20:	494f50a7 0000204e 00000000 6ce95e70     .POIN ......p^.l
c0d0db30:	4208161c ec1a2cc9 c9ccfffc d9e312c4     ...B.,..........
c0d0db40:	4c4c4f50 00000020 99120000 f63cec92     POLL .........<.
c0d0db50:	97005ba5 b2f2dd8c 2d88c67b 50ecd188     .[......{..-...P
c0d0db60:	20594c4f 00000000 9b771200 863c717b     OLY ......w.{q<.
c0d0db70:	4f77e6e3 ccd94050 d33ad4c2 4f50f875     ..wOP@....:.u.PO
c0d0db80:	00204c4f 00000000 9f60ee08 8c1292e2     OL .......`.....
c0d0db90:	86b703ad 26bcb9db e7dbcc34 534f50fc     .......&4....POS
c0d0dba0:	00000020 12000000 f8325859 9cf56bfc      .......YX2..k..
c0d0dbb0:	fe27c585 1b0a74c3 6912367a 52574f50     ..'..t..z6.iPOWR
c0d0dbc0:	00000020 c4060000 ccac0922 109c0214      .......".......
c0d0dbd0:	8056fb12 60bd5fd9 50a0e236 00205050     ..V.._.`6..PPP .
c0d0dbe0:	00000000 fad41200 37f56014 d28590bb     .........`.7....
c0d0dbf0:	b5cc7b2c f20e45dd 50503a8e 00002054     ,{...E...:PPT ..
c0d0dc00:	00000000 e4a38808 aa645df3 406d1ad4     .........]d...m@
c0d0dc10:	fe9aac30 84cb5643 455250fa 00000020     0...CV...PRE ...
c0d0dc20:	12000000 efdf2877 8646bd5a 9b7feb69     ....w(..Z.F.i...
c0d0dc30:	0af7a748 9dd21e50 20475250 00000000     H...P...PRG ....
c0d0dc40:	3a060000 9f99c4df 834cd077 f3c5ba41     ...:....w.L.A...
c0d0dc50:	df586fa7 507ab3f5 20584952 00000000     .oX...zPRIX ....
c0d0dc60:	44180800 269315b2 24b76826 a2570f8d     ...D...&&h.$..W.
c0d0dc70:	a4abca20 5250b96a 0000204c 00000000      ...j.PRL ......
c0d0dc80:	fe419012 a0de3f5b dcafe4f5 8051e717     ..A.[?........Q.
c0d0dc90:	7a878d73 4f525001 00000020 12000000     s..z.PRO .......
c0d0dca0:	99b56b22 64822ca1 71a7e376 ea974645     "k...,.dv..qEF..
c0d0dcb0:	20e2e952 204f5250 00000000 a3080000     R.. PRO ........
c0d0dcc0:	a00f9e14 07901a06 0707f3fa 90d2dc4c     ............L...
c0d0dcd0:	50fde2f0 204e4f52 00000000 0ce40800     ...PRON ........
c0d0dce0:	05884d37 cd58ddb1 8a99ffce cb20692f     7M....X...../i .
c0d0dcf0:	5250fd52 00205350 00000000 33371612     R.PRPS .......73
c0d0dd00:	bf8dc2bc 8c1ab426 69e383fa 74afb3b5     ....&......i...t
c0d0dd10:	5352501b 00000020 12000000 f3d4040c     .PRS ...........
c0d0dd20:	f78dda31 272e9e5f 143f3f1e 366cc694     1..._..'.??...l6
c0d0dd30:	50535250 00000020 5d090000 b877bc4a     PRSP ......]J.w.
c0d0dd40:	77d15a40 8266acd8 bfec84d5 50ec6cd4     @Z.w..f......l.P
c0d0dd50:	00205453 00000000 49661200 0a3e287a     ST .......fIz(>.
c0d0dd60:	97a37b00 8477834e 3432aec6 5450de47     .{..N.w...24G.PT
c0d0dd70:	00000020 00000000 988e2a12 22f356e2      ........*...V."
c0d0dd80:	cbe5b559 c863dd55 069591e8 43545066     Y...U.c.....fPTC
c0d0dd90:	00000020 12000000 3c584649 1ce0865b      .......IFX<[...
c0d0dda0:	1ac730cd 067d6105 6030e7e3 4e4f5450     .0...a}...0`PTON
c0d0ddb0:	00000020 8a120000 332cbfe4 de67e6a8      .........,3..g.
c0d0ddc0:	3849b534 3ed0ccb0 5006ccb8 20594f54     4.I8...>...PTOY 
c0d0ddd0:	00000000 89460800 eb69e1a4 7890cc39     ......F...i.9..x
c0d0dde0:	210e94c0 a3a81aff 54509c9b 00002054     ...!......PTT ..
c0d0ddf0:	00000000 e1125512 42bea7d6 1223434b     .....U.....BKC#.
c0d0de00:	869e4f6b 57f923d0 57545064 0000204f     kO...#.WdPTWO ..
c0d0de10:	12000000 e84c6bef 7483bcc9 26debc4f     .....kL....tO..&
c0d0de20:	c12eb357 8a459087 20435550 00000000     W.....E.PUC ....
c0d0de30:	c1000000 3ae53048 c1e844a3 12a90346     ....H0.:.D..F...
c0d0de40:	25b9a029 5062b2b0 00205458 00000000     )..%..bPXT .....
c0d0de50:	03770800 dcff5cc3 278dda5c f9f23daa     ..w..\..\..'.=..
c0d0de60:	546469ba 59506e4b 20544e4c 00000000     .idTKnPYLNT ....
c0d0de70:	758e6112 2cb190ac 3bba4960 f8d5f527     .a.u...,`I.;'...
c0d0de80:	37001b65 534151f6 00002048 06000000     e..7.QASH ......
c0d0de90:	e5bb1a67 912465ce e8425398 1beb2854     g....e$..SB.T(..
c0d0dea0:	646cbc07 20554151 00000000 cb080000     ..ldQAU ........
c0d0deb0:	90c1a35e ea2df8d8 afe57cdf f3db5d85     ^.....-..|...]..
c0d0dec0:	5162393e 20544942 00000000 67240600     >9bQBIT ......$g
c0d0ded0:	235a6baa d46f4151 46f8dec3 ee1f842d     .kZ#QAo....F-...
c0d0dee0:	4251ecec 00002058 00000000 c426ea12     ..QBX ........&.
c0d0def0:	a5d416ac 0b8206a1 5fe8aec8 b6b2b7d0     ..........._....
c0d0df00:	434b5164 00000020 12000000 600e224a     dQKC .......J".`
c0d0df10:	ad5eb296 cb5883b8 328a0644 75462548     ..^...X.D..2H%Fu
c0d0df20:	20544e51 00000000 ff120000 45fc5faa     QNT ........._.E
c0d0df30:	f831915d 743a71a2 0396d11f 518b5030     ].1..q:t....0P.Q
c0d0df40:	00204752 00000000 7b691200 098bc2ea     RG .......i{....
c0d0df50:	33c422e1 8539162d 2131a7e8 52517fb9     .".3-.9...1!..QR
c0d0df60:	0000204c 00000000 4dea9908 ac77eeb9     L .........M..w.
c0d0df70:	9b110bd4 334edcd1 b870c0e1 5053510d     ......N3..p..QSP
c0d0df80:	00000020 12000000 051f3c2c 7aba7d18      .......,<...}.z
c0d0df90:	7dd42d5f 1c2857ca 3f184f4d 20515451     _-.}.W(.MO.?QTQ 
c0d0dfa0:	00000000 9a120000 336b2d64 62c6dd68     ........d-k3h..b
c0d0dfb0:	ad4b24ca 71da2cf3 51bc0560 204d5554     .$K..,.q`..QTUM 
c0d0dfc0:	00000000 4d261200 dcdcdec2 617589bb     ......&M......ua
c0d0dfd0:	50ba7ca5 6f41ca85 5551b4b7 0000204e     .|.P..Ao..QUN ..
c0d0dfe0:	00000000 f9831112 d624562a b9ff858e     ........*V$.....
c0d0dff0:	bf160f17 c2b44304 54565142 00000020     .....C..BQVT ...
c0d0e000:	12000000 ef75f748 ce5e4fbe f7f20d6e     ....H.u..O^.n...
c0d0e010:	f52d93b5 90b92368 00002052 00000000     ..-.h#..R ......
c0d0e020:	45000000 9435b5ed d9848c2a 7ed3b5f4     ...E..5.*......~
c0d0e030:	1ef9251b 524c80a4 00204f41 00000000     .%....LRAO .....
c0d0e040:	2cfc1200 00958f4d 0aed142c 0251a67a     ...,M...,...z.Q.
c0d0e050:	95e5c9ca 42525e3b 0020584c 00000000     ....;^RBLX .....
c0d0e060:	b870f912 f7236ee3 52d73ffc 8b6fa8ee     ..p..n#..?.R..o.
c0d0e070:	7533d8e8 4e4352a6 00000020 12000000     ..3u.RCN .......
c0d0e080:	d55cf213 0c65212b c92582aa d9372394     ..\.+!e...%..#7.
c0d0e090:	30b0c914 20544352 00000000 25120000     ...0RCT .......%
c0d0e0a0:	07dfa65a d3b50c54 d0f097d2 b54cd8d4     Z...T.........L.
c0d0e0b0:	52e6c82b 00204e44 00000000 7b761200     +..RDN .......v{
c0d0e0c0:	c35e91a2 795a0144 dfeee338 198527ec     ..^.D.Zy8....'..
c0d0e0d0:	4552055d 00002041 00000000 ec149212     ].REA ..........
c0d0e0e0:	cb71cb02 89a6ada0 60a28d6b ab676a73     ..q.....k..`sjg.
c0d0e0f0:	41455210 0000204c 12000000 a8f7535f     .REAL ......_S..
c0d0e100:	b6145607 0badba99 f499c8c2 bffbd8ba     .V..............
c0d0e110:	4c424552 00000020 76120000 d5cc0d96     REBL ......v....
c0d0e120:	9f79fea1 9fbe297c 62b4ce19 522feb7a     ..y.|).....bz./R
c0d0e130:	00204445 00000000 63b51200 ac3b0a30     ED ........c0.;.
c0d0e140:	b909fc79 ce846f3b a265440d 455227ac     y...;o...De..'RE
c0d0e150:	00204344 00000000 35308912 fbaba700     DC .......05....
c0d0e160:	4f278b17 69249fd8 1e9564c2 4645521f     ..'O..$i.d...REF
c0d0e170:	00000020 08000000 614d9883 b54b9342      .........MaB.K.
c0d0e180:	823a7935 6ea4b0ad 6d6bf6f0 204d4552     5y:....n..kmREM 
c0d0e190:	00000000 40040000 6c87418e 920fdccc     .......@.A.l....
c0d0e1a0:	ef000621 56263750 52382a05 00204e45     !...P7&V.*8REN .
c0d0e1b0:	00000000 85191200 789f5e36 6a9b9a35     ........6^.x5..j
c0d0e1c0:	24e360d7 45a4f412 455262e8 00002050     .`.$...E.bREP ..
c0d0e1d0:	00000000 21828f12 9933bbaf a284858d     .......!..3.....
c0d0e1e0:	ba4957b0 937ac373 5145528a 00000020     .WI.s.z..REQ ...
c0d0e1f0:	12000000 82935af0 9ef2c3a4 27508427     .....Z......'.P'
c0d0e200:	883d2954 9c1035b8 20584552 00000000     T)=..5..REX ....
c0d0e210:	d0120000 19419d92 3874c454 1d871ddc     ......A.T.t8....
c0d0e220:	5c1f08d6 529c145e 00205246 00000000     ...\^..RFR .....
c0d0e230:	384c0400 52aedc3b 81cbe1a6 0dc7760c     ..L8;..R.....v..
c0d0e240:	49a2316f 47529bec 00002053 00000000     o1.I..RGS ......
c0d0e250:	96821608 4ae209bb b95c8088 535633c3     .......J..\..3VS
c0d0e260:	3f0d986b 4f4852c5 00002043 08000000     k..?.RHOC ......
c0d0e270:	13d06994 b7ff5b80 5ebeded3 7e233978     .i...[.....^x9#~
c0d0e280:	83c45e53 474e4952 00000020 dd120000     S^..RING .......
c0d0e290:	b6787200 f5bef667 c2a4d02f 1faa0436     .rx.g.../...6...
c0d0e2a0:	529a0396 20545049 00000000 170b0800     ...RIPT ........
c0d0e2b0:	da9fcc24 1e918601 4959a7f6 f0d3c0e9     $.........YI....
c0d0e2c0:	4952f3f2 00204159 00000000 a46a1008     ..RIYA .......j.
c0d0e2d0:	25b59592 aa59f9fc 7d3fec75 2f35f5cb     ...%..Y.u.?}..5/
c0d0e2e0:	544b521c 00000020 12000000 5b4c7f60     .RKT .......`.L[
c0d0e2f0:	0e2372b6 55087286 01e9f732 75734a54     .r#..r.U2...TJsu
c0d0e300:	20434c52 00000000 cc090000 88825bed     RLC .........[..
c0d0e310:	c3e86b08 7e56238e 40374c68 52484dbe     .k...#V~hL7@.MHR
c0d0e320:	0020544c 00000000 99be0a00 fc0997b0     LT .............
c0d0e330:	bc093b75 92a957f5 595d60f6 4c52b097     u;...W...`]Y..RL
c0d0e340:	00205954 00000000 d2424a08 3df880c5     TY ......JB....=
c0d0e350:	ca4a40ce 26ab8dd1 75a111db 584c520e     .@J....&...u.RLX
c0d0e360:	00000020 12000000 12f4c47d 797a6994      .......}....izy
c0d0e370:	7f02c403 c528c56a ebd74cd1 20434d52     ....j.(..L..RMC 
c0d0e380:	00000000 8d080000 1c948256 0b9056e4     ........V....V..
c0d0e390:	c07ad412 7cb4886a 52e14c76 4853454d     ..z.j..|vL.RMESH
c0d0e3a0:	00000020 96091200 57d0b5bf 6437a2fa      ..........W..7d
c0d0e3b0:	be06250e 469c4f7b 4e520bde 00205244     .%..{O.F..RNDR .
c0d0e3c0:	00000000 3f60ff12 3a6a9443 6a5edf28     ......`?C.j:(.^j
c0d0e3d0:	55251773 23b0c8d8 544e5286 00000020     s.%U...#.RNT ...
c0d0e3e0:	12000000 e70be71f e573e434 7ca51e72     ........4.s.r..|
c0d0e3f0:	e6015b8b 8626a5ca 42544e52 00000020     .[....&.RNTB ...
c0d0e400:	1b120000 6641c5cb 9914baf6 600b8734     ......Af....4..`
c0d0e410:	b6996150 526ddbc9 0020434f 00000000     Pa....mROC .....
c0d0e420:	01a40a00 5b4c1306 1114c4f4 b96d4e55     ......L[....UNm.
c0d0e430:	5ea1959b 4f52d8d9 00204b43 00000000     ...^..ROCK .....
c0d0e440:	546bc112 e090f42f c50dcc1f efe1608a     ..kT/........`..
c0d0e450:	7c353edc 434f52a6 0020324b 00000000     .>5|.ROCK2 .....
c0d0e460:	b0e33d0e fd17d6e3 88801d8d 77a89b63     .=..........c..w
c0d0e470:	42d7b4fe 4b434f52 59415032 c9120020     ...BROCK2PAY ...
c0d0e480:	0c7f4bde 961e993d d4e45871 1eb5a4bf     .K..=...qX......
c0d0e490:	5214b1c0 00204b4f 00000000 93491200     ...ROK .......I.
c0d0e4a0:	44c795cb 1506dc3b 88565f5c 698f9dbe     ...D;...\_V....i
c0d0e4b0:	4f52a599 20444e55 00000000 d8efb412     ..ROUND ........
c0d0e4c0:	9d99195c 04132584 909ea9bd bd0023b9     \....%.......#..
c0d0e4d0:	4c505293 00000020 12000000 101c49ec     .RPL ........I..
c0d0e4e0:	92e9ea88 ef14a2b7 ad66a2b0 2aa72709     ..........f..'.*
c0d0e4f0:	20425452 00000000 3f120000 969af3d8     RTB .......?....
c0d0e500:	49a0fd2e 311c9856 b5fa89ab 52c88bfb     ...IV..1.......R
c0d0e510:	00204854 00000000 b2541200 00602293     TH .......T.."`.
c0d0e520:	4dc0bfcc c5ee02f9 354ccb67 545203a9     ...M....g.L5..RT
c0d0e530:	0000204e 00000000 c178f212 959096ca     N ........x.....
c0d0e540:	d0deddff f80c2920 ac24c4b5 465552e2     .... )....$..RUF
c0d0e550:	00002046 12000000 942de0de d22949be     F ........-..I).
c0d0e560:	4ab6676f 19cf7ada 107f0014 454e5552     og.J.z......RUNE
c0d0e570:	00000020 3d120000 9fbea91b 10eeb866      ......=....f...
c0d0e580:	36bc1119 2e56fbd3 524422ac 00205456     ...6..V.."DRVT .
c0d0e590:	00000000 66e81200 61a9643a 954dff69     .......f:d.ai.M.
c0d0e5a0:	7a9e29b4 906ba7e9 6152315b 676e6974     .).z..k.[1Rating
c0d0e5b0:	00000020 fec81e08 a3b6a951 d127c4a6      .......Q.....'.
c0d0e5c0:	30cc9e7d a4c4fb60 412d535c 5441502d     }..0`...\S-A-PAT
c0d0e5d0:	12000020 231db93e 0d1e497e c48285ee      ...>..#~I......
c0d0e5e0:	b45cd802 546bfb40 54452d53 00002048     ..\.@.kTS-ETH ..
c0d0e5f0:	41120000 2d34d356 875a385c 06f964d2     ...AV.4-\8Z..d..
c0d0e600:	92357353 53810500 20544c41 00000000     Ss5....SALT ....
c0d0e610:	5a7c0800 7e26e90c f8229bd1 f153e6ca     ..|Z..&~.."...S.
c0d0e620:	dae8e398 415398f0 0000204e 00000000     ......SAN ......
c0d0e630:	18fe7812 6e431fe4 a6a38119 c857150d     .x....Cn......W.
c0d0e640:	0437a9a7 41435361 2049444e 02000000     ..7.aSCANDI ....
c0d0e650:	871763d7 7bc8dcb4 d1cf5412 e948cee5     .c.....{.T....H.
c0d0e660:	e8de2368 204c4353 00000000 24080000     h#..SCL .......$
c0d0e670:	e781c8dc 460573dd f2524483 cbd57218     .....s.F.DR..r..
c0d0e680:	5393524b 204c5243 00000000 3fa11200     KR.SCRL .......?
c0d0e690:	1b954307 3a3e6e4f 82f639a0 f57972e1     .C..On>:.9...ry.
c0d0e6a0:	4553c32b 0020434e 00000000 fa456712     +.SENC ......gE.
c0d0e6b0:	371e80b6 034fd26c 9b9c2b57 dcdd4e0d     ...7l.O.W+...N..
c0d0e6c0:	4e4553cf 00204553 08000000 37514ea4     .SENSE ......NQ7
c0d0e6d0:	5b853e29 e2c77b1b 79cdf8c6 37b0fc6f     )>.[.{.....yo..7
c0d0e6e0:	544e4553 00000020 e0080000 3574da6e     SENT .......n.t5
c0d0e6f0:	049b74ba d4ce8073 e9dd2191 53ae3433     .t..s....!..34.S
c0d0e700:	00205445 00000000 f5980000 e3f0b7e9     ET .............
c0d0e710:	44c05639 7dbf813e 1e5b8beb 455345d5     9V.D>..}..[..ESE
c0d0e720:	00205958 00000000 c1cca112 e9f0fa66     XY .........f...
c0d0e730:	32e3b398 30a0a125 11861c1b 4547539d     ...2%..0.....SGE
c0d0e740:	0000204c 12000000 b95a13b2 78765a69     L ........Z.iZvx
c0d0e750:	1a0b59dd f3b06c99 1807cb7b 204e4753     .Y...l..{...SGN 
c0d0e760:	00000000 33090000 baa223c6 158debaf     .......3.#......
c0d0e770:	e43cafdf ecef9540 532cd783 00205047     ..<.@.....,SGP .
c0d0e780:	00000000 5acb1200 25f3be05 84e91376     .......Z...%v...
c0d0e790:	f0bc7dc1 6d2b9539 47533f88 00002052     .}..9.+m.?SGR ..
c0d0e7a0:	00000000 75423708 e14f3276 915c62f3     .....7Buv2O..b\.
c0d0e7b0:	72476702 3771cfd7 6c65537d 59656966     .gGr..q7}SelfieY
c0d0e7c0:	1200206f d4b048d2 f9aa448e 03ea9ac4     o ...H...D......
c0d0e7d0:	137ebe12 6814dca6 74617453 6e477375     ..~....hStatusGn
c0d0e7e0:	e2010020 01ba0b5b 313056dc 92216a2b      ...[....V01+j!.
c0d0e7f0:	6180577e 53553fa1 20504948 00000000     ~W.a.?USHIP ....
c0d0e800:	2eef1200 61eb6699 534e49bb 8ddfd575     .....f.a.INSu...
c0d0e810:	8adbb767 48530d78 00205449 00000000     g...x.SHIT .....
c0d0e820:	32428500 d9c6725b cad20afc 43785a96     ..B2[r.......ZxC
c0d0e830:	15a91354 4c4853a0 00000020 12000000     T....SHL .......
c0d0e840:	096324ef 85a06093 070bf1f1 f62ed76e     .$c..`......n...
c0d0e850:	067a4925 20504853 00000000 8a120000     %Iz.SHP ........
c0d0e860:	85527d18 bcbc16d3 08fcda9a a0701db5     .}R...........p.
c0d0e870:	5300e0d8 20544649 00000000 88680000     ...SIFT ......h.
c0d0e880:	79a96ea1 dca4152c 23c6f6f2 edc855d0     .n.y,......#.U..
c0d0e890:	495392e7 00002047 00000000 28f34a12     ..SIG .......J.(
c0d0e8a0:	702129c5 9f73cb6d 10627825 af699149     .)!pm.s.%xb.I.i.
c0d0e8b0:	424b53e6 00000020 08000000 b374db13     .SKB .........t.
c0d0e8c0:	652f51cf 8316b9c4 394f0b94 8550e055     .Q/e......O9U.P.
c0d0e8d0:	20454b53 00000000 2b080000 99420ddc     SKE .......+..B.
c0d0e8e0:	e2fc1760 0716b214 41da15a5 53c5e0a9     `..........A...S
c0d0e8f0:	204e494b 00000000 9bd90600 8ea47f8a     KIN ............
c0d0e900:	3be8cc25 20228181 f63be0a3 4b535f4e     %..;.." ..;.N_SK
c0d0e910:	0000204d 00000000 e8944912 20a99718     M .......I..... 
c0d0e920:	35a2fec0 eeed8ceb f6ffc6d3 4f4b5397     ...5.........SKO
c0d0e930:	00002031 12000000 8e2f384c c85a6109     1 ......L8/..aZ.
c0d0e940:	58ce086e 27c26c26 13d9d4e7 20524b53     n..X&l.'....SKR 
c0d0e950:	00000000 fd060000 b67a8bfe e3d11bcf     ..........z.....
c0d0e960:	ef3845d1 96626840 535220c4 2050524b     .E8.@hb.. RSKRP 
c0d0e970:	00000000 346e1200 6447d8d8 7b6d0fd4     ......n4..Gd..m{
c0d0e980:	9f56cd39 53bf17d0 4b537d17 31205052     9.V....S.}SKRP 1
c0d0e990:	00000020 484a3212 6eb4cbeb 31399961      ....2JH...na.91
c0d0e9a0:	f6359def 90d27c69 524b531b 2d312050     ..5.i|...SKRP 1-
c0d0e9b0:	12002045 95f25f7a d53982dc 4d4e37c2     E ..z_....9..7NM
c0d0e9c0:	aa024289 b6ca29f0 20544c53 00000000     .B...)..SLT ....
c0d0e9d0:	79030000 f1abc828 f9f94ef7 440a4d6d     ...y(....N..mM.D
c0d0e9e0:	9d20b4e3 53850736 0020594c 00000000     .. .6..SLY .....
c0d0e9f0:	6d6f1200 c4b05deb 83824a99 fe6c1da0     ..om.]...J....l.
c0d0ea00:	3bfc27eb 4d539cbe 20545241 00000000     .'.;..SMART ....
c0d0ea10:	3f013900 8f371c96 2ab8c202 e9311d6e     .9.?..7....*n.1.
c0d0ea20:	fd862781 534d539d 00000020 03000000     .'...SMS .......
c0d0ea30:	c1aacf2d d8eb9e1c 0321c4c6 6a2a9efe     -.........!...*j
c0d0ea40:	27af37d2 72616d53 646f4e74 55120020     .7.'SmartNod ..U
c0d0ea50:	438539f9 4030c91f 357a6877 3d10baa1     .9.C..0@whz5...=
c0d0ea60:	5381e0c1 7472616d 2068734d eb781200     ...SmartMsh ..x.
c0d0ea70:	0741c68d 919f047f d5b65906 c40de880     ..A......Y......
c0d0ea80:	6f5337d2 6c616963 00206b4d 878a1908     .7SocialMk .....
c0d0ea90:	434111b3 29423d91 4b6d0ffb 8aaa44cb     ..AC.=B)..mK.D..
c0d0eaa0:	424e53ff 0000204c 08000000 464113f4     .SNBL ........AF
c0d0eab0:	1d512daf db8cead5 8cc84a1c 0404d657     .-Q......J..W...
c0d0eac0:	20434e53 00000000 f3120000 e9acb233     SNC ........3...
c0d0ead0:	bd2bac92 57bf9887 61a065bc 53baaf84     ..+....W.e.a...S
c0d0eae0:	0020444e 00000000 d6cf0000 3ff18bae     ND ............?
c0d0eaf0:	8614de42 ffea5173 9f3b8a7a 4e53e7bb     B...sQ..z.;...SN
c0d0eb00:	00002047 00000000 e8c2ae08 52230a7e     G ..........~.#R
c0d0eb10:	adc5d966 b2b4dec9 d0549be2 474e5309     f.........T..SNG
c0d0eb20:	0020534c 00000000 ae88f544 47448ceb     LS .....D.....DG
c0d0eb30:	27d13914 c603360b f162926a 50494e53     .9.'.6..j.b.SNIP
c0d0eb40:	00000020 98120000 db606d3f a48cea79      .......?m`.y...
c0d0eb50:	c66899eb a0cff8af 53633c4b 00204d4e     ..h.....K<cSNM .
c0d0eb60:	00000000 c5bd1200 be9dc3ba 031e2b13     .............+..
c0d0eb70:	e38a890e d7170083 4e5369d9 0020564f     .........iSNOV .
c0d0eb80:	00000000 704d7412 a42bbefd 161395cf     .....tMp..+.....
c0d0eb90:	174a6126 5b80df63 544e539e 00000020     &aJ.c..[.SNT ...
c0d0eba0:	12000000 1e025928 10cbf2e7 f3672e16     ....(Y........g.
c0d0ebb0:	27d2f23a ff1ab364 52544e53 00000020     :..'d...SNTR ...
c0d0ebc0:	2d040000 47bd950e e0acd795 f70f3cda     ...-...G.....<..
c0d0ebd0:	97a506b7 53d3b90e 0020434f 00000000     .......SOC .....
c0d0ebe0:	541f1200 37778b63 86fd3f19 19c59ec1     ...Tc.w7.?......
c0d0ebf0:	17c4a707 4f53d855 0000204c 00000000     ....U.SOL ......
c0d0ec00:	ac621c06 5d60b7a2 ac6e60b3 7ac67bda     ..b...`].`n..{.z
c0d0ec10:	b8dd5718 4e4f53ff 00205149 12000000     .W...SONIQ .....
c0d0ec20:	2d62d642 b594e3ec d7fb9949 2381103d     B.b-....I...=..#
c0d0ec30:	186a6f80 4e415053 0000204b 58120000     .oj.SPANK .....X
c0d0ec40:	7df57dbf 3c11a79d d849cb4c 08493d46     .}.}...<L.I.F=I.
c0d0ec50:	53cb35c7 43524150 00000020 ae241200     .5.SPARC .....$.
c0d0ec60:	471abff3 f9001556 ed740d43 7fc49740     ...GV...C.t.@...
c0d0ec70:	5053f251 41545241 00000020 97ea1d04     Q.SPARTA .......
c0d0ec80:	266fe79a f8701807 a78d0824 91eb7989     ..o&..p.$....y..
c0d0ec90:	445053c8 00000020 12000000 89930885     .SPD ...........
c0d0eca0:	c7d94bc1 f0b8c27f 33dcd1c3 ef06bf63     .K.........3c...
c0d0ecb0:	20465053 00000000 38120000 aea0dd33     SPF .......83...
c0d0ecc0:	987b94b6 894d45ce 8cba6c36 532855c5     ..{..EM.6l...U(S
c0d0ecd0:	58544850 00000020 24031200 0c5d19dd     PHTX ......$..].
c0d0ece0:	079f3fd5 8ea4e6be ad0ba2e7 50538f73     .?..........s.SP
c0d0ecf0:	20454349 00000000 a3f72008 dc44f2dd     ICE ..... ....D.
c0d0ed00:	5b979992 9fc3a14d f0755d8d 4e50535a     ...[M....]u.ZSPN
c0d0ed10:	00000020 06000000 82aaaa05 7d40fa9a      .............@}
c0d0ed20:	de5c3183 b15ed4d1 0c912560 20585053     .1\...^.`%..SPX 
c0d0ed30:	00000000 68120000 1c9a7cd5 2c3ef635     .......h.|..5.>,
c0d0ed40:	498eee83 709d4ea6 53258d52 00204e52     ...I.N.pR.%SRN .
c0d0ed50:	00000000 ffbb1200 6e902d86 46998e34     .........-.n4..F
c0d0ed60:	2e13b2bf a37d15cb 5353b4d4 61687320     ......}...SS sha
c0d0ed70:	00206472 50206e12 d83efbcb 649bd3a4     rd ..n P..>....d
c0d0ed80:	e7479fcc 5a3aa011 48535389 00000020     ..G...:Z.SSH ...
c0d0ed90:	12000000 0b524d62 d84a2eab 50fa3539     ....bMR...J.95.P
c0d0eda0:	6130b13f 50e87443 20505353 00000000     ?.0aCt.PSSP ....
c0d0edb0:	9a040000 899a5c00 bda472bd 7a1e7227     .....\...r..'r.z
c0d0edc0:	1dc1a309 53c4032b 20434154 00000000     ....+..STAC ....
c0d0edd0:	0af71200 87d32b64 ff8043f9 c25104b9     ....d+...C....Q.
c0d0ede0:	b84e1dc8 5453bc2c 00205241 00000000     ..N.,.STAR .....
c0d0edf0:	a6bc0912 ee05abeb be45e92a 3951da4e     ........*.E.N.Q9
c0d0ee00:	7bbf943d 42545399 00000020 04000000     =..{.STB .......
c0d0ee10:	55ee9a62 1c5849ed f927ab33 92793f40     b..U.IX.3.'.@?y.
c0d0ee20:	d5ff89a2 20435453 00000000 ae120000     ....STC ........
c0d0ee30:	1c8db373 41278b9a 1630ec27 c427490a     s.....'A'.0..I'.
c0d0ee40:	532418d7 00204b54 00000000 93591200     ..$STK .......Y.
c0d0ee50:	909e7746 995f3ffc 15a75e7b f9209834     Fw...?_.{^..4. .
c0d0ee60:	54537115 0000204e 00000000 f54eb604     .qSTN ........N.
c0d0ee70:	7289881c accf08c9 c1479bf5 b80abcaf     ...r......G.....
c0d0ee80:	4f5453ac 00204a52 08000000 94b8a4d0     .STORJ .........
c0d0ee90:	062fb56c fb3b2761 0c0efdc6 3364fc75     l./.a';.....u.d3
c0d0eea0:	524f5453 0000204d ec120000 f7bb70d5     STORM .......p..
c0d0eeb0:	60b96147 10cc04fa 864e2cfe 5336daff     Ga.`.....,N...6S
c0d0eec0:	00205054 00000000 3a5c0800 d2108522     TP .......\:"...
c0d0eed0:	378ab746 2102c265 2b08f3cb 5453a444     F..7e..!...+D.ST
c0d0eee0:	00002051 00000000 35e2ba12 55723d82     Q .........5.=rU
c0d0eef0:	3586d4d9 5273d4ce d54c2427 52545383     ...5..sR'$L..STR
c0d0ef00:	00000020 12000000 73244946 f98d5e75      .......FI$su^..
c0d0ef10:	4803f860 3217f677 96ce18d7 43525453     `..Hw..2....STRC
c0d0ef20:	00000020 03080000 4a2ea871 12430a9d      .......q..J..C.
c0d0ef30:	c92aeef3 128595c6 53721389 00205554     ..*.......rSTU .
c0d0ef40:	00000000 6b001200 a3ba43ea 65f7a6f7     .......k.C.....e
c0d0ef50:	a1104ff1 3483b0a1 545345ef 00002058     .O.....4.ESTX ..
c0d0ef60:	00000000 0e481212 ec5beb24 69439d1a     ......H.$.[...Ci
c0d0ef70:	0ca8b6ca 370a3cad 4255537a 00000020     .....<.7zSUB ...
c0d0ef80:	02000000 ecc120e1 7feadfbf e30e8f0a     ..... ..........
c0d0ef90:	1e496300 dffe268c 20525553 00000000     .cI..&..SUR ....
c0d0efa0:	bd080000 25834beb 6846b11f 1c9da17f     .....K.%..Fh....
c0d0efb0:	41990f66 53e3ef1e 00204456 00000000     f..A...SVD .....
c0d0efc0:	b20b1200 8a0fe417 df9ab75c b6aae104     ........\.......
c0d0efd0:	0dbd5a0e 57531efc 20435446 00000000     .Z....SWFTC ....
c0d0efe0:	61889e08 03cf1834 6a4da5dc 93adf62c     ...a4.....Mj,...
c0d0eff0:	a1c7784a 4d57537a 00000020 12000000     Jx..zSWM .......
c0d0f000:	56f8e7b9 65d5088e c4295d9f d8737199     ...V...e.])..qs.
c0d0f010:	0726df4c 20545753 00000000 12120000     L.&.SWT ........
c0d0f020:	98fa06b3 d4b8cbf4 f3df7f45 6fa5a0a0     ........E......o
c0d0f030:	53dfcc07 20544458 00000000 822c1200     ...SXDT ......,.
c0d0f040:	345b3dc7 895901aa 48292b46 376a61cd     .=[4..Y.F+)H.aj7
c0d0f050:	58531f64 00205455 00000000 23b11012     d.SXUT ........#
c0d0f060:	03e0ddfd aa993124 062235d0 2758c05d     ....$1...5".].X'
c0d0f070:	4e5953a0 00000020 12000000 47f1eeb1     .SYN ..........G
c0d0f080:	489f8e02 ca5cbc0d 417d27a3 f0851b7d     ...H..\..'}A}...
c0d0f090:	6c656553 00002065 4c120000 538541a7     Seele .....L.A.S
c0d0f0a0:	9578c12d 5b4e1927 d36d869c 53824e3f     -.x.'.N[..m.?N.S
c0d0f0b0:	61536e65 20496f74 59d61200 8ecbfa60     enSatoI ...Y`...
c0d0f0c0:	b2fc2d4a b22c21c2 e2024ae4 6f537ea5     J-...!,..J...~So
c0d0f0d0:	00207261 00000000 cc4c1d06 eab6da31     ar .......L.1...
c0d0f0e0:	d361f420 2c56a029 2541581c 4c415415      .a.).V,.XA%.TAL
c0d0f0f0:	00204f41 12000000 052f7ac2 837a57fa     AO ......z/..Wz.
c0d0f100:	4cdb0fba 073c4438 01653518 20554154     ...L8D<..5e.TAU 
c0d0f110:	00000000 fa120000 83fcd5cc c1c3e4c3     ................
c0d0f120:	5df31eac 6bf0ad15 549c20cf 20324342     ...]...k. .TBC2 
c0d0f130:	00000000 e6af0800 1a341105 e28d4837     ..........4.7H..
c0d0f140:	1935ef5b 312e5652 4254c1fc 00002054     [.5.RV.1..TBT ..
c0d0f150:	00000000 bd923a08 82ef6a39 c0eb98af     .....:..9j......
c0d0f160:	d23090aa 1cb1235a 5842546b 00000020     ..0.Z#..kTBX ...
c0d0f170:	12000000 e0f50efa aee1ca34 bd592d75     ........4...u-Y.
c0d0f180:	e3cdadb8 97abd77e 20414354 00000000     ....~...TCA ....
c0d0f190:	99120000 41f2a072 737e4494 cdb6e8a7     ....r..A.D~s....
c0d0f1a0:	022ea526 54d5fadd 00204843 00000000     &......TCH .....
c0d0f1b0:	1d2a0000 c565beba 2e02b095 348c2075     ..*...e.....u .4
c0d0f1c0:	d5394101 445457d3 00002048 00000000     .A9..WTDH ......
c0d0f1d0:	ab791c12 ca6ac632 19e8e9a1 a5aab852     ..y.2.j.....R...
c0d0f1e0:	543eb481 414554e7 0000204d 04000000     ..>T.TEAM ......
c0d0f1f0:	72a932ec 5d85595c d8a71b84 849cc9d9     .2.r\Y.]........
c0d0f200:	884675ff 204c4554 6964654d 85120020     .uF.TEL Medi ...
c0d0f210:	1c3676e0 08a913c8 9b2f67ff 474115ad     .v6......g/...AG
c0d0f220:	54b20244 00204c45 00000000 16dd0200     D..TEL .........
c0d0f230:	e5660fec 673e454d 533e7156 90985533     ..f.ME>gVq>S3U..
c0d0f240:	4554e440 0000204e 00000000 66f1e512     @.TEN .........f
c0d0f250:	2b87d8c0 61007968 ccb67b31 c98245a0     ...+hy.a1{...E..
c0d0f260:	44465412 00000020 12000000 c376f9a7     .TFD .........v.
c0d0f270:	d4beeb60 55285c46 ae1a4d68 a9ef7152     `...F\(UhM..Rq..
c0d0f280:	204c4654 00000000 f8080000 4a4e6ee0     TFL .........nNJ
c0d0f290:	dc7f2880 cc2db0a5 099daaec 540f8454     .(....-.....T..T
c0d0f2a0:	454d4147 00000020 3dac1200 c2ea87a5     GAME ......=....
c0d0f2b0:	6d89c929 23bc9a91 7ffda45c 4754c172     )..m...#\...r.TG
c0d0f2c0:	00002054 00000000 f5833801 cafc81e1     T .......8......
c0d0f2d0:	a60f41f8 9bb5121e b63f96ad 45485445     .A........?.ETHE
c0d0f2e0:	00204154 12000000 9d20b31c 0ba6b245     TA ....... .E...
c0d0f2f0:	cca1bc7f 677ff8db aaa43742 20524854     .......gB7..THR 
c0d0f300:	00000000 4f040000 323f0527 84afa8ed     .......O'.?2....
c0d0f310:	bc376495 a7ffe500 54873200 20545248     .d7......2.THRT 
c0d0f320:	00000000 7bfe1200 aa0b5a91 5cf8790e     .......{.Z...y.\
c0d0f330:	65265355 c0c1f713 4854d03e 00204755     US&e....>.THUG .
c0d0f340:	00000000 0a437212 00dc2a61 b6e3507c     .....rC.a*..|P..
c0d0f350:	1bbb6d94 0131fdb0 434954d1 00000020     .m....1..TIC ...
c0d0f360:	08000000 692a4b7f cba70506 a67a6fb6     .....K*i.....oz.
c0d0f370:	90bd5e88 9e2e5e6a 4f434954 00000020     .^..j^..TICO ...
c0d0f380:	99080000 ece26799 c8b7748a e019dbe9     .....g...t......
c0d0f390:	b320d939 54d0391d 00204549 00000000     9. ..9.TIE .....
c0d0f3a0:	e2ee1200 deb70ed0 2469ddb8 a35a7f18     ..........i$..Z.
c0d0f3b0:	067d6b49 49542ae6 00002047 00000000     Ik}..*TIG ......
c0d0f3c0:	f1316512 ebdee633 e5dcf2e7 a71a44a0     .e1.3........D..
c0d0f3d0:	4e0b33ef 4d495453 00002045 08000000     .3.NSTIME ......
c0d0f3e0:	1255bc80 857f1c56 8c50a9a3 1b90f77d     ..U.V.....P.}...
c0d0f3f0:	dfa10f37 204f4954 00000000 ea120000     7...TIO ........
c0d0f400:	af6f341f 4e973f02 08afadb5 02dfbc8b     .4o..?.N........
c0d0f410:	54f461d7 00205849 00000000 e1da1200     .a.TIX .........
c0d0f420:	9649f2ba acb6c44b 2f12c398 5f783e0e     ..I.K....../.>x_
c0d0f430:	4b5479d2 00002041 00000000 da750612     .yTKA ........u.
c0d0f440:	a52547a9 3a5ab028 035c6388 fa4b96ea     .G%.(.Z:.c\...K.
c0d0f450:	4c4b547e 0000204e 12000000 d991afaa     ~TKLN ..........
c0d0f460:	00f80db9 c2554fdf 8969fd05 3ae777c9     .....OU...i..w.:
c0d0f470:	204e4b54 00000000 b4080000 5b54505a     TKN ........ZPT[
c0d0f480:	f373abee 97e5318f 21c46837 545e5e80     ..s..1..7h.!.^^T
c0d0f490:	0020524b 00000000 61b31200 c8ab5065     KR ........aeP..
c0d0f4a0:	a5c779af 9eef2d90 a9c93bfa 4c540052     .y...-...;..R.TL
c0d0f4b0:	00002058 00000000 f9093208 14f0eb8b     X .......2......
c0d0f4c0:	e29c769b aef7716d ef35e4a8 544d54ea     .v..mq....5..TMT
c0d0f4d0:	00000020 12000000 430728b0 dbf74bb4      ........(.C.K..
c0d0f4e0:	82e46b4b 757bbab2 6c09dae5 20534e54     Kk....{u...lTNS 
c0d0f4f0:	00000000 08120000 5b23a9f5 753b1708     ..........#[..;u
c0d0f500:	4536f869 55fbc7d2 54d8cce8 0020544e     i.6E...U...TNT .
c0d0f510:	00000000 358b0800 93182130 23175975     .......50!..uY.#
c0d0f520:	624238e7 a30957f4 4f54dcc3 00204f4d     .8Bb.W....TOMO .
c0d0f530:	00000000 65b98e12 bccf9cee 060a6ce7     .......e.....l..
c0d0f540:	c0924426 82c2efaf 4f4f546d 00002052     &D......mTOOR ..
c0d0f550:	12000000 a89c7aaa b594367d 3b215f75     .....z..}6..u_!;
c0d0f560:	4b09045d 6f0a0f8d 43415254 00000020     ]..K...oTRAC ...
c0d0f570:	12120000 d3129575 453b3026 f7c8cef1     ....u...&0;E....
c0d0f580:	f396fdb6 548e7787 204b4152 00000000     .....w.TRAK ....
c0d0f590:	3fcb1200 76f92b90 f81b3926 4b2687ba     ...?.+.v&9....&K
c0d0f5a0:	34c13dbc 5254be69 00002043 00000000     .=.4i.TRC ......
c0d0f5b0:	d76f5612 c31f9b99 bd228098 487a5038     .Vo.......".8PzH
c0d0f5c0:	2cf2bcf0 43525477 0000204e 12000000     ...,wTRCN ......
c0d0f5d0:	54cbce30 a949a461 a5f58100 e0b45df5     0..Ta.I......]..
c0d0f5e0:	ab7b3948 54435254 00000020 33080000     H9{.TRCT ......3
c0d0f5f0:	07ee0df9 68b9e8c6 730fd22d b258c3e6     .......h-..s..X.
c0d0f600:	54030fed 20544452 00000000 94cb0000     ...TRDT ........
c0d0f610:	a1136fbe 4b4a2e18 7bcb4061 285d02f2     .o....JKa@.{..](
c0d0f620:	52541be4 00205453 00000000 b730f206     ..TRST .......0.
c0d0f630:	9053e090 f49582fc 3203f6d3 42ed3bc9     ..S........2.;.B
c0d0f640:	585254e2 00000020 06000000 9b99876b     .TRX .......k...
c0d0f650:	065873e8 1ee4bd5b b7e00f8a 1425cdb1     .sX.[.........%.
c0d0f660:	20575354 00000000 aa120000 788106b6     TSW ...........x
c0d0f670:	8b1e8409 87be6811 67afee79 5464ef44     .....h..y..gD.dT
c0d0f680:	00204154 00000000 89931200 b9524843     TA .........CHR.
c0d0f690:	c8d4ba4b 7b5bedaf 0cffc5db 54547522     K.....[{...."uTT
c0d0f6a0:	00002043 00000000 8ada9c12 fa5add60     C ..........`.Z.
c0d0f6b0:	bd956c15 d9284497 e012081a 55545454     .l...D(.....TTTU
c0d0f6c0:	00000020 12000000 cefbd58d 6c956a2f      .........../j.l
c0d0f6d0:	36ba2230 11907563 3ee751dd 44535554     0".6cu...Q.>TUSD
c0d0f6e0:	00000020 2e120000 268aabf1 bb587c18      ..........&.|X.
c0d0f6f0:	1bb1ae8a 5cd2c62f 5416075c 00204e57     ..../..\\..TWN .
c0d0f700:	00000000 77e71200 cf9b6e5a 9db34e90     .......wZn...N..
c0d0f710:	5e8cb6a2 60934ffb 61548ce0 00205361     ...^.O.`..TaaS .
c0d0f720:	00000000 d9008406 fab05c4a 371a040d     ........J\.....7
c0d0f730:	2895e388 eec9615d 5442555e 00000020     ...(]a..^UBT ...
c0d0f740:	08000000 1a2ae592 109a5d23 0109973d     ......*.#]..=...
c0d0f750:	10e96c06 37fdceaa 53414355 00002048     .l.....7UCASH ..
c0d0f760:	aa080000 185570f3 86e4ee8f 6434e69d     .....pU.......4d
c0d0f770:	3d687e93 55a1b261 00204e43 00000000     .~h=a..UCN .....
c0d0f780:	09ea1200 b01d2b7a fab22706 d20a4617     ....z+...'...F..
c0d0f790:	0116c060 46557769 00002052 00000000     `...iwUFR ......
c0d0f7a0:	27692412 4c44bc91 1eb8d05c a4abbc3c     .$i'..DL\...<...
c0d0f7b0:	1fcd4ab0 474b553b 00000020 12000000     .J..;UKG .......
c0d0f7c0:	69fc5a8e 3a7a22f6 46d35ed7 c63b72c8     .Z.i."z:.^.F.r;.
c0d0f7d0:	2371e92c 414b4d55 00000020 6b040000     ,.q#UMKA ......k
c0d0f7e0:	75ab60a4 34562ccd ff17353b 4807a6eb     .`.u.,V4;5.....H
c0d0f7f0:	55264d65 00002050 00000000 6dc80800     eM&UP .........m
c0d0f800:	62094805 0c213234 e3f27a10 fbdc19f6     .H.b42!..z......
c0d0f810:	505552f6 00002050 00000000 b71dd012     .RUPP ..........
c0d0f820:	5578043e e614b4ef c4982020 42d24cbe     >.xU....  ...L.B
c0d0f830:	4351553b 00000020 12000000 13841693     ;UQC ...........
c0d0f840:	246c759f e93107ec 0ee54ff7 efdd4855     .ul$..1..O..UH..
c0d0f850:	20425255 00000000 a0120000 c69169b8     URB .........i..
c0d0f860:	c1368b21 2e4a9dd1 36ceb09e 5548eb06     !.6...J....6..HU
c0d0f870:	20434453 00000000 60d70600 4db2dfad     SDC .......`...M
c0d0f880:	4bfe019c 5c47a7fe 6836365e 53555840     ...K..G\^66h@XUS
c0d0f890:	00204d44 00000000 7fc1da02 e52e8d95     DM .............
c0d0f8a0:	6220a223 97459906 1e833dc1 445355c7     #. b..E..=...USD
c0d0f8b0:	00002054 06000000 3328a770 507fbfd6     T ......p.(3...P
c0d0f8c0:	ce24828c f31eea59 383aead0 204b5455     ..$.Y.....:8UTK 
c0d0f8d0:	00000000 9e120000 6e631933 c0e32621     ........3.cn!&..
c0d0f8e0:	34319ebc 50e1c5ae 55c7468a 502d4e54     ..14...P.F.UTN-P
c0d0f8f0:	00000020 f8161200 ff7fbe12 62f6ca02      ..............b
c0d0f900:	585d5db8 7265daa5 5455dfd4 00002054     .]]X..er..UTT ..
c0d0f910:	00000000 63433508 00a9d48e b140486e     .....5Cc....nH@.
c0d0f920:	71429405 6015eabc 5555555d 00000020     ..Bq...`]UUU ...
c0d0f930:	12000000 3a5a2089 de692a3b 017fbf6d     ..... Z:;*i.m...
c0d0f940:	10b213ed e7432c8b 63696e55 206e726f     .....,C.Unicorn 
c0d0f950:	57000000 c8cc5ec7 d3367155 91a11926     ...W.^..Uq6.&...
c0d0f960:	85c8cdfb 5611d760 00204744 00000000     ....`..VDG .....
c0d0f970:	bd820000 71db6b52 d24d6d8c 13d01e29     ....Rk.q.mM.)...
c0d0f980:	ae6c18a5 4456ca2d 0020434f 00000000     ..l.-.VDOC .....
c0d0f990:	2b0d3412 8cb25ede b291ed1e 3e7290f7     .4.+.^........r>
c0d0f9a0:	1306163b 454556b7 00000020 12000000     ;....VEE .......
c0d0f9b0:	2e9450d8 2a1f81f8 a6926686 de1b0123     .P.....*.f..#...
c0d0f9c0:	c162a452 204e4556 00000000 eb120000     R.b.VEN ........
c0d0f9d0:	fef94fed b83d4134 559482fc 2815bd6b     .O..4A=....Uk..(
c0d0f9e0:	56cadaa4 53554e45 00000020 348f0300     ...VENUS ......4
c0d0f9f0:	8c38a770 7a4eee05 8c1dd0f3 f50f2b72     p.8...Nz....r+..
c0d0fa00:	45567423 00204952 00000000 4b972c12     #tVERI ......,.K
c0d0fa10:	71a10b2d 1f4c646e a88299c5 f72fdd9d     -..qndL......./.
c0d0fa20:	42495624 00000020 12000000 9c5cffe8     $VIB .........\.
c0d0fa30:	46b3de75 3c49acac 50893c46 badf03be     u..F..I<F<.P....
c0d0fa40:	45424956 00000020 88120000 3df84824     VIBE .......$H.=
c0d0fa50:	47bfb290 79eaf27a a1de7f32 56935d33     ...Gz..y2...3].V
c0d0fa60:	58454249 00000020 3ff01200 faba658d     IBEX ......?.e..
c0d0fa70:	c3118659 09245149 f6e8563c 4956f038     Y...IQ$.<V..8.VI
c0d0fa80:	00205745 00000000 6b94d212 5cf386e7     EW ........k...\
c0d0fa90:	c202c43c 4736329b 9079daab 4b495671     <....26G..y.qVIK
c0d0faa0:	0020594b 08000000 fe14e0f3 70782681     KY ..........&xp
c0d0fab0:	ef324162 8e6b643a 963a8583 204e4956     bA2.:dk...:.VIN 
c0d0fac0:	00000000 23120000 aac75bb7 662d8ef2     .......#.[....-f
c0d0fad0:	24f4c328 8f2f88b3 563c2a07 00205449     (..$../..*<VIT .
c0d0fae0:	00000000 791b1200 7723493e b7d8db58     .......y>I#wX...
c0d0faf0:	ebc9af52 5d9d324b 495616a0 00204554     R...K2.]..VITE .
c0d0fb00:	00000000 75945112 e45316b3 09cd206d     .....Q.u..S.m ..
c0d0fb10:	3bcffdf9 b4acbd12 554956f5 00000020     ...;.....VIU ...
c0d0fb20:	12000000 73c42a92 1f24cca3 9e04a0d3     .....*.s..$.....
c0d0fb30:	453645d1 3cd7582d 20444c56 00000000     .E6E-X.<VLD ....
c0d0fb40:	c3120000 1fb79ebc 9a43ec75 8b8e6c6b     ........u.C.kl..
c0d0fb50:	5bcf6f74 5603f762 0020434f 00000000     to.[b..VOC .....
c0d0fb60:	ee831200 8f830da0 d1c4de92 b9975647     ............GV..
c0d0fb70:	7b53d3f4 4f56e356 20455349 00000000     ..S{V.VOISE ....
c0d0fb80:	f3baed08 020310c5 32a5dddc 372f3269     ...........2i2/7
c0d0fb90:	41f0b130 5352566d 00000020 05000000     0..AmVRS .......
c0d0fba0:	ae8de792 7a061513 d6ef1988 de32a4dc     .......z......2.
c0d0fbb0:	e9e2cd9d 20535256 00000000 5c060000     ....VRS .......\
c0d0fbc0:	e07a3e54 784f10a1 0e346c40 9ffd649c     T>z...Ox@l4..d..
c0d0fbd0:	567051ce 00204c53 00000000 20971200     .QpVSL ........ 
c0d0fbe0:	10a767b4 2a232a38 bd40f532 62d6d7ce     .g..8*#*2.@....b
c0d0fbf0:	5a560ba1 00002054 00000000 c5bb4b12     ..VZT .......K..
c0d0fc00:	1370f27a 2cfff28e d6fadb50 e6e0e984     z.p....,P.......
c0d0fc10:	42415704 00000020 12000000 a14c9a82     .WAB .........L.
c0d0fc20:	f1833330 1f6b2b08 6e1137b9 05563b4b     03...+k..7.nK;V.
c0d0fc30:	54544157 00000020 39120000 669f25bb     WATT ......9.%.f
c0d0fc40:	5a9dc5e1 7583f8be 204d9b97 572280d9     ...Z...u..M .."W
c0d0fc50:	00205841 00000000 95740800 e37d671b     AX .......t..g}.
c0d0fc60:	e86e592d 3333a251 a2e62669 425709cd     -Yn.Q.33i&....WB
c0d0fc70:	00002041 00000000 970a6a07 aa157de4     A .......j...}..
c0d0fc80:	a132d1d1 80a479ac 9007f2e3 54435763     ..2..y......cWCT
c0d0fc90:	00000020 12000000 5ae70f84 f2c0adbf      ..........Z....
c0d0fca0:	823740d5 78b27195 e49c912e 20424557     .@7..q.x....WEB 
c0d0fcb0:	00000000 c0120000 b239aa2a 0a8dfe23     ........*.9.#...
c0d0fcc0:	274f5c0e 3c08d9ea 57c26c75 20485445     .\O'...<ul.WETH 
c0d0fcd0:	00000000 fef41200 81386095 5479e0d0     .........`8...yT
c0d0fce0:	e00576fd e416a9e9 4857442c 00204e45     .v......,DWHEN .
c0d0fcf0:	00000000 c033e912 418497cd 8c275f4d     ......3....AM_'.
c0d0fd00:	f5044911 69394ba8 4f485719 00000020     .I...K9i.WHO ...
c0d0fd10:	12000000 d407cd62 b650ec14 a8ca7e8c     ....b.....P..~..
c0d0fd20:	343da263 2f062d4f 20434957 00000000     c.=4O-./WIC ....
c0d0fd30:	d3000000 b27207c0 817a994d 63ca4922     ......r.M.z."I.c
c0d0fd40:	811e927a 57017735 20444c49 00000000     z...5w.WILD ....
c0d0fd50:	93891200 254db838 335a50ac 40e7dc2a     ....8.M%.PZ3*..@
c0d0fd60:	947d692d 49579474 0000204e 00000000     -i}.t.WIN ......
c0d0fd70:	88706608 3dce12b2 53b5a106 1f1e22a7     .fp....=...S."..
c0d0fd80:	d90090d1 4e4957af 00205347 12000000     .....WINGS .....
c0d0fd90:	2cc3221b 97cb36d9 90568cc2 825a69a0     .".,.6....V..iZ.
c0d0fda0:	e688f6ab 48534957 00000020 f6120000     ....WISH .......
c0d0fdb0:	bccb5ab5 4a52f449 28198da4 c5779a1a     .Z..I.RJ...(..w.
c0d0fdc0:	570fe14d 00204b4c 00000000 bebf1200     M..WLK .........
c0d0fdd0:	72f13253 bc1178d7 4428276c 7b4ae5f3     S2.r.x..l'(D..J{
c0d0fde0:	4d57bb23 0000204b 00000000 663ad712     #.WMK ........:f
c0d0fdf0:	be26fbb8 7ccd0a8b 5032bd52 467dac54     ..&....|R.2PT.}F
c0d0fe00:	4b4e578b 00000020 12000000 e7818772     .WNK .......r...
c0d0fe10:	09dc3557 513adf62 e747efd7 7e10a798     W5..b.:Q..G....~
c0d0fe20:	4b4c4f57 00000020 a6120000 af4f5186     WOLK ........QO.
c0d0fe30:	9228547d d183f466 992c85e4 57c73ee1     }T(.f.....,..>.W
c0d0fe40:	204b524f 00000000 f44c0800 037f3888     ORK ......L..8..
c0d0fe50:	378cf05f 2c561515 902f71ba 5057d415     _..7..V,.q/...WP
c0d0fe60:	00002052 00000000 adad7212 4d7847b4     R .......r...GxM
c0d0fe70:	471fabd7 0f756724 cbe485c4 4352572d     ...G$gu.....-WRC
c0d0fe80:	00000020 06000000 4fd7e871 e323c9f1      .......q..O..#.
c0d0fe90:	0de7d069 668609fb 35ddc429 204b5257     i......f)..5WRK 
c0d0fea0:	00000000 b7120000 db961ccb d3b0226b     ............k"..
c0d0feb0:	016e53d9 bd62d008 57748f48 00204354     .Sn...b.H.tWTC .
c0d0fec0:	00000000 11841200 8f3eb39c c2750d59     ..........>.Y.u.
c0d0fed0:	6b4eead6 49a74107 5457da4e 00002054     ..Nk.A.IN.WTT ..
c0d0fee0:	00000000 0f95d800 3010aade d07f7a4b     ...........0Kz..
c0d0fef0:	6bc62f3a 713c9fc3 5359571a 00000020     :/.k..<q.WYS ...
c0d0ff00:	12000000 c5176005 32aee75a 7cef2ad1     .....`..Z..2.*.|
c0d0ff10:	3af89d67 ff75ca85 20565957 00000000     g..:..u.WYV ....
c0d0ff20:	28120000 1314da6b 7381dfa2 ce30491d     ...(k......s.I0.
c0d0ff30:	352a862f 57fe09a6 20694261 00000000     /.*5...WaBi ....
c0d0ff40:	4a5e1200 651964be ce39a80c 42dbb75b     ..^J.d.e..9.[..B
c0d0ff50:	601a882b 6957bb64 00002043 00000000     +..`d.WiC ......
c0d0ff60:	fc0d9112 3dead618 a624716a 8f45b5f8     .......=jq$...E.
c0d0ff70:	fa601028 5838584c 00000020 12000000     (.`.LX8X .......
c0d0ff80:	f612f84d 1eef4d06 1c9f025e 7c7758a8     M....M..^....Xw|
c0d0ff90:	812d8dc9 52554158 00000020 49080000     ..-.XAUR ......I
c0d0ffa0:	2e75c0ae 2d28d068 77c644b5 7b40baf6     ..u.h.(-.D.w..@{
c0d0ffb0:	58d77ea1 00204c42 00000000 de281200     .~.XBL .......(.
c0d0ffc0:	fe531de0 f6f5edd0 8ebf10e3 131531f9     ..S..........1..
c0d0ffd0:	425840ae 00002050 00000000 9f824d12     .@XBP .......M..
c0d0ffe0:	69a6928c 0d30561c 0d9e0c02 e2cf84b9     ...i.V0.........
c0d0fff0:	434358ba 00000020 12000000 d0b3261e     .XCC ........&..
c0d10000:	53f4577e 7d0fe3ca 5f942fdd 33eff35b     ~W.S...}./._[..3
c0d10010:	524c4358 00000020 41080000 cb6f1bab     XCLR ......A..o.
c0d10020:	ce9dfab2 decb1ad8 31a63ec1 58f22b5f     .........>.1_+.X
c0d10030:	20454344 00000000 17a01200 59ac5fac     DCE ........._.Y
c0d10040:	1050f941 b87025b1 4674c912 45582c9c     A.P..%p...tF.,XE
c0d10050:	00002053 00000000 644c0512 fdba1d74     S ........Ldt...
c0d10060:	508497c1 98029454 3b9cd823 54455813     ...PT...#..;.XET
c0d10070:	00000020 08000000 fb5baf16 75e4e74a      .........[.J..u
c0d10080:	bfc3adb9 e6f1b25c 40790da5 20534658     ....\.....y@XFS 
c0d10090:	00000000 f6080000 f00eaab6 c1c2edf5     ................
c0d100a0:	4725d9c5 f6ea977f 58e70363 00204747     ..%G....c..XGG .
c0d100b0:	00000000 3e530800 2f4b98f0 cc7a22aa     ......S>..K/."z.
c0d100c0:	cc670c62 9ca32ae1 4758cdd8 0000204d     b.g..*....XGM ..
c0d100d0:	00000000 a3f43008 767aabe0 608b3d73     .....0....zvs=.`
c0d100e0:	3cd99db8 9e4c0b3d 5447582f 00000020     ...<=.L./XGT ...
c0d100f0:	12000000 7bec10b1 ab8fcb1d 28bfed8d     .......{.......(
c0d10100:	3ec63bf5 84ddbea5 20444958 00000000     .;.>....XID ....
c0d10110:	44080000 d6a49f44 d107f807 ad694aed     ...DD........Ji.
c0d10120:	72712994 58c89183 2054434d 00000000     .)qr...XMCT ....
c0d10130:	8c0f1200 7896b845 85401e4a 0530b926     ....E..xJ.@.&.0.
c0d10140:	6086ef19 4d589c20 00002058 00000000     ...` .XMX ......
c0d10150:	7286bc08 e60d777e c960108b 94b66b1f     ...r~w....`..k..
c0d10160:	03e1735c 4b4e5888 00000020 12000000     \s...XNK .......
c0d10170:	15e995ab edfd23c1 32b6df5b 55ef355e     .....#..[..2^5.U
c0d10180:	69eaf115 204e4e58 00000000 57120000     ...iXNN .......W
c0d10190:	80316f2e 5d0cba56 6522a447 3d841331     .o1.V..]G."e1..=
c0d101a0:	58910625 0020544e 00000000 3e150000     %..XNT ........>
c0d101b0:	791bccd9 bdd27929 5cf4bbe0 36e4a7c2     ...y)y.....\...6
c0d101c0:	4f58f9a5 00002056 00000000 8a529012     ..XOV ........R.
c0d101d0:	732b3aeb d10f786b bb78c4b6 31641d7e     .:+skx....x.~.d1
c0d101e0:	41505870 00000020 12000000 fda41fbb     pXPA ...........
c0d101f0:	735934eb bc7ef63b 0330896f 826a97fa     .4Ys;.~.o.0...j.
c0d10200:	54415058 00000020 b2120000 79be5447     XPAT .......GT.y
c0d10210:	dc531528 0d16dc1a b7d95cdf 58a46143     (.S......\..Ca.X
c0d10220:	00204c52 00000000 510f0900 2649fb3f     RL ........Q?.I&
c0d10230:	f6d782ff 9006050a 95a2ac47 535813c4     ........G.....XS
c0d10240:	00002043 00000000 6f295512 a60ef469     C .......U)oi...
c0d10250:	85470ed2 6b5ac133 e754b608 4f595858     ..G.3.Zk..T.XXYO
c0d10260:	00000020 12000000 fa052192 513f15d8      ........!....?Q
c0d10270:	29b8cf6b 97c06df5 05d7e1a0 20454559     k..).m......YEE 
c0d10280:	00000000 ca120000 f6f99627 38b2c71d     ........'......8
c0d10290:	9743b0aa 16c6491e 5975f34d 20444545     ..C..I..M.uYEED 
c0d102a0:	00000000 eacb1200 319469ec 4ddb7f85     .........i.1...M
c0d102b0:	bddbad37 2d130ec2 4f590349 20574f59     7......-I.YOYOW 
c0d102c0:	00000000 2ca1d912 6ea803de 46960480     .......,...n...F
c0d102d0:	85de5898 35a5d381 5055593d 00000020     .X.....5=YUP ...
c0d102e0:	12000000 20bb330f 64a782a2 ff3a7b9c     .....3. ...d.{:.
c0d102f0:	4a084f64 33e94893 49505559 00002045     dO.J.H.3YUPIE ..
c0d10300:	67120000 4cf8a081 6d849e7e a5a984cb     ...g...L~..m....
c0d10310:	303349bd 5a04b167 00205041 00000000     .I30g..ZAP .....
c0d10320:	efb91200 5e6a0b77 8359e412 4505d8c5     ....w.j^..Y....E
c0d10330:	8fa38a25 435a783b 0000204e 00000000     %...;xZCN ......
c0d10340:	e308200a 34d77b05 3cd10ae1 ff45ae9e     . ...{.4...<..E.
c0d10350:	17bc2a13 4f435a22 00000020 08000000     .*.."ZCO .......
c0d10360:	2ea4f405 522d1f25 e915edb8 fcacdafe     ....%.-R........
c0d10370:	27ad1fef 204c495a 00000000 4a0c0000     ...'ZIL .......J
c0d10380:	861c46ac e971faab 2c9a0dd0 e4748dde     .F....q....,..t.
c0d10390:	5aeaaee1 20434e49 00000000 d2a91200     ...ZINC ........
c0d103a0:	043a7d92 8b009e30 e2e2f66a 5229ae82     .}:.0...j.....)R
c0d103b0:	495afde7 00002050 00000000 c9d7ed12     ..ZIP ..........
c0d103c0:	97b4d74f 156d911b 54c47b06 d9bae1b9     O.....m..{.T....
c0d103d0:	50495a80 00002054 12000000 d57189fd     .ZIPT ........q.
c0d103e0:	0c74e1e8 40a8d0e2 dea4fc95 160c9d72     ..t....@....r...
c0d103f0:	20414c5a 00000000 55120000 f477fc4f     ZLA .......UO.w.
c0d10400:	b39f1a25 0a59e3c0 8d5f206a 5a7d064e     %.....Y.j _.N.}Z
c0d10410:	00204e4d 00000000 b8b51200 e46f61f5     MN ..........ao.
c0d10420:	a3ec5c2d dd3f7fe8 96f4d8bd 505a60d7     -\....?......`ZP
c0d10430:	00002052 00000000 241de412 321d5789     R .........$.W.2
c0d10440:	6d248921 deeba5af f499461f 58525a98     !.$m.....F...ZRX
c0d10450:	00000020 12000000 51e0417a 4fca5e7a      .......zA.Qz^.O
c0d10460:	ebfbc7db 7bc4d4a4 63dcf69f 2043535a     .......{...cZSC 
c0d10470:	00000000 e3120000 ed39b186 4bca1537     ..........9.7..K
c0d10480:	6752fd18 1ceadc1b 5ab1e4df 00205453     ..Rg.......ZST .
c0d10490:	00000000 f9e80800 a57e97fa 9f1d5985     ..........~..Y..
c0d104a0:	31814639 2555168c 545afb77 00002058     9F.1..U%w.ZTX ..
c0d104b0:	00000000 bee28312 964f118d 84132261     ..........O.a"..
c0d104c0:	240da5b3 53566ab9 43585af5 00000020     ...$.jVS.ZXC ...
c0d104d0:	12000000 0a28c1ab 02a28701 4375c60c     ......(.......uC
c0d104e0:	0140ed7a b66df885 20434153 00000000     z.@...m.SAC ....
c0d104f0:	f3120000 8cca92c0 cad4d3d6 d0c14d00     .............M..
c0d10500:	ca8cfef1 5a9935b5 00205849 00000000     .....5.ZIX .....
c0d10510:	1e991200                                         ..

c0d10512 <TOKENS_ELLAISM>:
c0d10512:	e47f1e99 3d2b5fb0 e788d7b1 5d3f9605     ....._+=......?]
c0d10522:	44007b64 494e494d 0000474e 6f120000              d{.DMINING.....

c0d10531 <TOKENS_ETHEREUM_CLASSIC>:
c0d10531:	5deb6d6f 4a99c4b0 1da08382 27ebfe6c     om.]...J....l..'
c0d10541:	9cbe3bfc 72616d53 00002074 08000000     .;..Smart ......
c0d10551:	40f2b45f bcedea31 a51a612b 4323f228     _..@1...+a..(.#C
c0d10561:	42db52eb 00204345 00000000 ce5a0800     .R.BEC .......Z.
c0d10571:	737cf817 2a79e591 9a068376 3bb82580     ..|s..y*v....%.;
c0d10581:	4c5085bd 00205941 00000000 6fda6a00     ..PLAY ......j.o
c0d10591:	6815c848 3ec40295 1b9fa5c1 4ec0d35d     H..h...>....]..N
c0d105a1:	564e551f 00000020 12000000              .UNV .......

c0d105ad <TOKENS_ETHER1>:
c0d105ad:	7c2045d2 6febf6fb b20d9734 1dab07a8     .E |...o4.......
c0d105bd:	6cde8f17 20585041 00000000 ff080000     ...lAPX ........
c0d105cd:	ad57f03b 15e0b0f3 315346b6 556e23a6     ;.W......FS1.#nU
c0d105dd:	42748268 20524545 00000000 53080000     h.tBEER .......S
c0d105ed:	ce066a3d b1985236 b42ef92e aaa8cb07     =j..6R..........
c0d105fd:	45437382 00205346 00000000 7ead9408     .sCEFS ........~
c0d1060d:	40d4c141 7cf4c422 9f01bab1 c522a0d1     A..@"..|......".
c0d1061d:	544f4436 00000020 08000000 a199484b     6DOT .......KH..
c0d1062d:	7d503e0f eeb007b2 9e022624 678a16fa     .>P}....$&.....g
c0d1063d:	52415751 0000204b 5e080000 79bb1517     QWARK .....^...y
c0d1064d:	72d65b80 b3609772 6f4df3f7 52985048     .[.rr.`...MoHP.R
c0d1065d:	534b4349 00000020 006f0800                       ICKS .....

c0d10667 <TOKENS_ATHEIOS>:
c0d10667:	0190006f                                         o.

c0d10669 <SW_BUSY>:
c0d10669:	00670190                                         ..

c0d1066b <SW_WRONG_LENGTH>:
c0d1066b:	85690067                                         g.

c0d1066d <SW_PROOF_OF_PRESENCE_REQUIRED>:
c0d1066d:	806a8569                                         i.

c0d1066f <SW_BAD_KEY_HANDLE>:
c0d1066f:	3255806a                                         j.

c0d10671 <U2F_VERSION>:
c0d10671:	5f463255 00903256                       U2F_V2..

c0d10679 <INFO>:
c0d10679:	00900901                                ....

c0d1067d <SW_UNKNOWN_CLASS>:
c0d1067d:	006d006e                                         n.

c0d1067f <SW_UNKNOWN_INSTRUCTION>:
c0d1067f:	ffff006d                                         m.

c0d10681 <BROADCAST_CHANNEL>:
c0d10681:	ffffffff                                ....

c0d10685 <FORBIDDEN_CHANNEL>:
c0d10685:	00000000                                ....

c0d10689 <HEXDIGITS>:
c0d10689:	33323130 37363534 62613938 66656463     0123456789abcdef
c0d10699:	09000000                                         ...

c0d1069c <USBD_HID_Desc_fido>:
c0d1069c:	01112109 22220121 00000000              .!..!.""....

c0d106a8 <USBD_HID_Desc>:
c0d106a8:	01112109 22220100 f1d00600                       .!...."".

c0d106b1 <HID_ReportDesc_fido>:
c0d106b1:	09f1d006 0901a101 26001503 087500ff     ...........&..u.
c0d106c1:	08814095 00150409 7500ff26 91409508     .@......&..u..@.
c0d106d1:	a006c008                                         ..

c0d106d3 <HID_ReportDesc>:
c0d106d3:	09ffa006 0901a101 26001503 087500ff     ...........&..u.
c0d106e3:	08814095 00150409 7500ff26 91409508     .@......&..u..@.
c0d106f3:	0000c008 d06a4d00                                .....

c0d106f8 <HID_Desc>:
c0d106f8:	c0d06a4d c0d06a5d c0d06a6d c0d06a7d     Mj..]j..mj..}j..
c0d10708:	c0d06a8d c0d06a9d c0d06aad 00000000     .j...j...j......

c0d10718 <C_webusb_url_descriptor>:
c0d10718:	77010317 6c2e7777 65676465 6c617772     ...www.ledgerwal
c0d10728:	2e74656c 056d6f63                                let.com

c0d1072f <C_usb_bos>:
c0d1072f:	001d0f05 05101801 08b63800 a009a934     .........8..4...
c0d1073f:	a0fd8b47 b6158876 1e010065 d067df01              G...v...e....

c0d1074c <USBD_HID>:
c0d1074c:	c0d067df c0d06811 c0d06747 00000000     .g...h..Gg......
c0d1075c:	00000000 c0d06939 c0d06951 00000000     ....9i..Qi......
	...
c0d10774:	c0d06ba1 c0d06ba1 c0d06ba1 c0d06bb1     .k...k...k...k..

c0d10784 <USBD_U2F>:
c0d10784:	c0d068c1 c0d06811 c0d06747 00000000     .h...h..Gg......
c0d10794:	00000000 c0d068f5 c0d0690d 00000000     .....h...i......
	...
c0d107ac:	c0d06ba1 c0d06ba1 c0d06ba1 c0d06bb1     .k...k...k...k..

c0d107bc <USBD_WEBUSB>:
c0d107bc:	c0d069a9 c0d069d5 c0d069d9 00000000     .i...i...i......
c0d107cc:	00000000 c0d069dd c0d069f5 00000000     .....i...i......
	...
c0d107e4:	c0d06ba1 c0d06ba1 c0d06ba1 c0d06bb1     .k...k...k...k..

c0d107f4 <USBD_DeviceDesc>:
c0d107f4:	02000112 40000000 00012c97 02010200     .......@.,......
c0d10804:	03040103                                         ..

c0d10806 <USBD_LangIDDesc>:
c0d10806:	04090304                                ....

c0d1080a <USBD_MANUFACTURER_STRING>:
c0d1080a:	004c030e 00640065 00650067 030e0072              ..L.e.d.g.e.r.

c0d10818 <USBD_PRODUCT_FS_STRING>:
c0d10818:	004e030e 006e0061 0020006f 030a0053              ..N.a.n.o. .S.

c0d10826 <USB_SERIAL_STRING>:
c0d10826:	0030030a 00300030 02090031                       ..0.0.0.1.

c0d10830 <USBD_CfgDesc>:
c0d10830:	00600209 c0020103 00040932 00030200     ..`.....2.......
c0d10840:	21090200 01000111 07002222 40038205     ...!...."".....@
c0d10850:	05070100 00400302 01040901 01030200     ......@.........
c0d10860:	21090201 01210111 07002222 40038105     ...!..!."".....@
c0d10870:	05070100 00400301 02040901 ffff0200     ......@.........
c0d10880:	050702ff 00400383 03050701 01004003     ......@......@..

c0d10890 <USBD_DeviceQualifierDesc>:
c0d10890:	0200060a 40000000 00000001              .......@....

c0d1089c <_etext>:
	...

c0d108c0 <N_storage_real>:
	...
